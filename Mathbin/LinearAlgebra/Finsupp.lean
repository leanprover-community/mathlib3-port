/-
Copyright (c) 2019 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl

! This file was ported from Lean 3 source module linear_algebra.finsupp
! leanprover-community/mathlib commit 23aa88e32dcc9d2a24cca7bc23268567ed4cd7d6
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finsupp.Defs
import Mathbin.LinearAlgebra.Pi
import Mathbin.LinearAlgebra.Span

/-!
# Properties of the module `α →₀ M`

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Given an `R`-module `M`, the `R`-module structure on `α →₀ M` is defined in
`data.finsupp.basic`.

In this file we define `finsupp.supported s` to be the set `{f : α →₀ M | f.support ⊆ s}`
interpreted as a submodule of `α →₀ M`. We also define `linear_map` versions of various maps:

* `finsupp.lsingle a : M →ₗ[R] ι →₀ M`: `finsupp.single a` as a linear map;

* `finsupp.lapply a : (ι →₀ M) →ₗ[R] M`: the map `λ f, f a` as a linear map;

* `finsupp.lsubtype_domain (s : set α) : (α →₀ M) →ₗ[R] (s →₀ M)`: restriction to a subtype as a
  linear map;

* `finsupp.restrict_dom`: `finsupp.filter` as a linear map to `finsupp.supported s`;

* `finsupp.lsum`: `finsupp.sum` or `finsupp.lift_add_hom` as a `linear_map`;

* `finsupp.total α M R (v : ι → M)`: sends `l : ι → R` to the linear combination of `v i` with
  coefficients `l i`;

* `finsupp.total_on`: a restricted version of `finsupp.total` with domain `finsupp.supported R R s`
  and codomain `submodule.span R (v '' s)`;

* `finsupp.supported_equiv_finsupp`: a linear equivalence between the functions `α →₀ M` supported
  on `s` and the functions `s →₀ M`;

* `finsupp.lmap_domain`: a linear map version of `finsupp.map_domain`;

* `finsupp.dom_lcongr`: a `linear_equiv` version of `finsupp.dom_congr`;

* `finsupp.congr`: if the sets `s` and `t` are equivalent, then `supported M R s` is equivalent to
  `supported M R t`;

* `finsupp.lcongr`: a `linear_equiv`alence between `α →₀ M` and `β →₀ N` constructed using `e : α ≃
  β` and `e' : M ≃ₗ[R] N`.

## Tags

function with finite support, module, linear algebra
-/


noncomputable section

open Set LinearMap Submodule

open Classical BigOperators

namespace Finsupp

variable {α : Type _} {M : Type _} {N : Type _} {P : Type _} {R : Type _} {S : Type _}

variable [Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]

variable [AddCommMonoid N] [Module R N]

variable [AddCommMonoid P] [Module R P]

/- warning: finsupp.lsingle -> Finsupp.lsingle is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], α -> (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], α -> (LinearMap.{u3, u3, u2, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.lsingle Finsupp.lsingleₓ'. -/
/-- Interpret `finsupp.single a` as a linear map. -/
def lsingle (a : α) : M →ₗ[R] α →₀ M :=
  { Finsupp.singleAddHom a with map_smul' := fun a b => (smul_single _ _ _).symm }
#align finsupp.lsingle Finsupp.lsingle

/- warning: finsupp.lhom_ext -> Finsupp.lhom_ext is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] {{φ : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}} {{ψ : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}}, (forall (a : α) (b : M), Eq.{succ u3} N (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) φ (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a b)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) ψ (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a b))) -> (Eq.{max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) φ ψ)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {N : Type.{u1}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u4, u1} R N _inst_1 _inst_5] {{φ : LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}} {{ψ : LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}}, (forall (a : α) (b : M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => N) (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) a b)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (fun (_x : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => N) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u2 u3, u1} R R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) φ (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) a b)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (fun (_x : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => N) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u2 u3, u1} R R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) ψ (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) a b))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u1)} (LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) φ ψ)
Case conversion may be inaccurate. Consider using '#align finsupp.lhom_ext Finsupp.lhom_extₓ'. -/
/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere. -/
theorem lhom_ext ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=
  LinearMap.toAddMonoidHom_injective <| addHom_ext h
#align finsupp.lhom_ext Finsupp.lhom_ext

/- warning: finsupp.lhom_ext' -> Finsupp.lhom_ext' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] {{φ : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}} {{ψ : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}}, (forall (a : α), Eq.{max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (LinearMap.comp.{u4, u4, u4, u2, max u1 u2, u3} R R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.right_ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) φ (Finsupp.lsingle.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4 a)) (LinearMap.comp.{u4, u4, u4, u2, max u1 u2, u3} R R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.right_ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) ψ (Finsupp.lsingle.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4 a))) -> (Eq.{max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) φ ψ)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {N : Type.{u1}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u4, u1} R N _inst_1 _inst_5] {{φ : LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}} {{ψ : LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6}}, (forall (a : α), Eq.{max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (LinearMap.comp.{u4, u4, u4, u3, max u2 u3, u1} R R R M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) φ (Finsupp.lsingle.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 a)) (LinearMap.comp.{u4, u4, u4, u3, max u2 u3, u1} R R R M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) ψ (Finsupp.lsingle.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 a))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u1)} (LinearMap.{u4, u4, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_5 (Finsupp.module.{u2, u3, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) φ ψ)
Case conversion may be inaccurate. Consider using '#align finsupp.lhom_ext' Finsupp.lhom_ext'ₓ'. -/
/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere.

We formulate this fact using equality of linear maps `φ.comp (lsingle a)` and `ψ.comp (lsingle a)`
so that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these
maps. E.g., if `M = R`, then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/
@[ext]
theorem lhom_ext' ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) :
    φ = ψ :=
  lhom_ext fun a => LinearMap.congr_fun (h a)
#align finsupp.lhom_ext' Finsupp.lhom_ext'

/- warning: finsupp.lapply -> Finsupp.lapply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], α -> (LinearMap.{u3, u3, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], α -> (LinearMap.{u3, u3, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4)
Case conversion may be inaccurate. Consider using '#align finsupp.lapply Finsupp.lapplyₓ'. -/
/-- Interpret `λ (f : α →₀ M), f a` as a linear map. -/
def lapply (a : α) : (α →₀ M) →ₗ[R] M :=
  { Finsupp.applyAddHom a with map_smul' := fun a b => rfl }
#align finsupp.lapply Finsupp.lapply

/- warning: finsupp.lcoe_fun -> Finsupp.lcoeFun is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (α -> M) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Pi.Function.module.{u1, u3, u2} α R M _inst_1 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], LinearMap.{u3, u3, max u2 u1, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (α -> M) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Pi.module.{u1, u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.499 : α) => M) R _inst_1 (fun (i : α) => _inst_3) (fun (i : α) => _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.lcoe_fun Finsupp.lcoeFunₓ'. -/
/-- Forget that a function is finitely supported.

This is the linear version of `finsupp.to_fun`. -/
@[simps]
def lcoeFun : (α →₀ M) →ₗ[R] α → M where
  toFun := coeFn
  map_add' x y := by
    ext
    simp
  map_smul' x y := by
    ext
    simp
#align finsupp.lcoe_fun Finsupp.lcoeFun

section LsubtypeDomain

variable (s : Set α)

/- warning: finsupp.lsubtype_domain -> Finsupp.lsubtypeDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M R _inst_1 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearMap.{u3, u3, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u2} (Set.Elem.{u1} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} (Set.Elem.{u1} α s) M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} (Set.Elem.{u1} α s) M R _inst_1 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align finsupp.lsubtype_domain Finsupp.lsubtypeDomainₓ'. -/
/-- Interpret `finsupp.subtype_domain s` as a linear map. -/
def lsubtypeDomain : (α →₀ M) →ₗ[R] s →₀ M
    where
  toFun := subtypeDomain fun x => x ∈ s
  map_add' a b := subtypeDomain_add
  map_smul' c a := ext fun a => rfl
#align finsupp.lsubtype_domain Finsupp.lsubtypeDomain

/- warning: finsupp.lsubtype_domain_apply -> Finsupp.lsubtypeDomain_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M R _inst_1 _inst_3 _inst_4)) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))) (LinearMap.hasCoeToFun.{u3, u3, max u1 u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lsubtypeDomain.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) f) (Finsupp.subtypeDomain.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s) f)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (f : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} (Set.Elem.{u3} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} (Set.Elem.{u3} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} (Set.Elem.{u3} α s) M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} (Set.Elem.{u3} α s) M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} (Set.Elem.{u3} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} (Set.Elem.{u3} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} (Set.Elem.{u3} α s) M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} (Set.Elem.{u3} α s) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lsubtypeDomain.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) f) (Finsupp.subtypeDomain.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (fun (x : α) => Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) x s) f)
Case conversion may be inaccurate. Consider using '#align finsupp.lsubtype_domain_apply Finsupp.lsubtypeDomain_applyₓ'. -/
theorem lsubtypeDomain_apply (f : α →₀ M) :
    (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M) f = subtypeDomain (fun x => x ∈ s) f :=
  rfl
#align finsupp.lsubtype_domain_apply Finsupp.lsubtypeDomain_apply

end LsubtypeDomain

/- warning: finsupp.lsingle_apply -> Finsupp.lsingle_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (a : α) (b : M), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeFn.{max (succ u2) (succ (max u1 u2)), max (succ u2) (succ (max u1 u2))} (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) => M -> (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))) (LinearMap.hasCoeToFun.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a) b) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a b)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (a : α) (b : M), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) b) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lsingle.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a) b) (Finsupp.single.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) a b)
Case conversion may be inaccurate. Consider using '#align finsupp.lsingle_apply Finsupp.lsingle_applyₓ'. -/
@[simp]
theorem lsingle_apply (a : α) (b : M) : (lsingle a : M →ₗ[R] α →₀ M) b = single a b :=
  rfl
#align finsupp.lsingle_apply Finsupp.lsingle_apply

/- warning: finsupp.lapply_apply -> Finsupp.lapply_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (a : α) (f : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{succ u2} M (coeFn.{max (succ (max u1 u2)) (succ u2), max (succ (max u1 u2)) (succ u2)} (LinearMap.{u3, u3, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u2, u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lapply.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a) f) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) f a)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (a : α) (f : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => M) f) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), succ u2} (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u2, u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lapply.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a) f) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f a)
Case conversion may be inaccurate. Consider using '#align finsupp.lapply_apply Finsupp.lapply_applyₓ'. -/
@[simp]
theorem lapply_apply (a : α) (f : α →₀ M) : (lapply a : (α →₀ M) →ₗ[R] M) f = f a :=
  rfl
#align finsupp.lapply_apply Finsupp.lapply_apply

/- warning: finsupp.ker_lsingle -> Finsupp.ker_lsingle is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (a : α), Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (LinearMap.ker.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a)) (Bot.bot.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasBot.{u3, u2} R M _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_1 _inst_3] (a : α), Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_3 _inst_4) (LinearMap.ker.{u2, u2, u3, max u1 u3, max u1 u3} R R M (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) _inst_4 (Finsupp.module.{u1, u3, u2} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, u3, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) _inst_4 (Finsupp.module.{u1, u3, u2} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u3, max u1 u3} R R M (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) _inst_4 (Finsupp.module.{u1, u3, u2} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.lsingle.{u1, u3, u2} α M R _inst_1 _inst_3 _inst_4 a)) (Bot.bot.{u3} (Submodule.{u2, u3} R M _inst_1 _inst_3 _inst_4) (Submodule.instBotSubmodule.{u2, u3} R M _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.ker_lsingle Finsupp.ker_lsingleₓ'. -/
@[simp]
theorem ker_lsingle (a : α) : (lsingle a : M →ₗ[R] α →₀ M).ker = ⊥ :=
  ker_eq_bot_of_injective (single_injective a)
#align finsupp.ker_lsingle Finsupp.ker_lsingle

/- warning: finsupp.lsingle_range_le_ker_lapply -> Finsupp.lsingle_range_le_ker_lapply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (t : Set.{u1} α), (Disjoint.{u1} (Set.{u1} α) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} α) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} α) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} α) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} α) (Set.completeBooleanAlgebra.{u1} α)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} α) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} α) (Set.booleanAlgebra.{u1} α))) s t) -> (LE.le.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))))) (supᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u1 u2, 0} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) => LinearMap.range.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a)))) (infᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasInf.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) α (fun (a : α) => infᵢ.{max u1 u2, 0} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasInf.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a t) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a t) => LinearMap.ker.{u3, u3, max u1 u2, u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lapply.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a)))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (t : Set.{u3} α), (Disjoint.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} α) (Preorder.toLE.{u3} (Set.{u3} α) (PartialOrder.toPreorder.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) s t) -> (LE.le.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a s) (fun (H : Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a s) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.lsingle.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a)))) (infᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) α (fun (a : α) => infᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a t) (fun (H : Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a t) => LinearMap.ker.{u1, u1, max u3 u2, u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lapply.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a)))))
Case conversion may be inaccurate. Consider using '#align finsupp.lsingle_range_le_ker_lapply Finsupp.lsingle_range_le_ker_lapplyₓ'. -/
theorem lsingle_range_le_ker_lapply (s t : Set α) (h : Disjoint s t) :
    (⨆ a ∈ s, (lsingle a : M →ₗ[R] α →₀ M).range) ≤ ⨅ a ∈ t, ker (lapply a : (α →₀ M) →ₗ[R] M) :=
  by
  refine' supᵢ_le fun a₁ => supᵢ_le fun h₁ => range_le_iff_comap.2 _
  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]
  intro b hb a₂ h₂
  have : a₁ ≠ a₂ := fun eq => h.le_bot ⟨h₁, Eq.symm ▸ h₂⟩
  exact single_eq_of_ne this
#align finsupp.lsingle_range_le_ker_lapply Finsupp.lsingle_range_le_ker_lapply

/- warning: finsupp.infi_ker_lapply_le_bot -> Finsupp.infᵢ_ker_lapply_le_bot is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], LE.le.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))))) (infᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasInf.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) α (fun (a : α) => LinearMap.ker.{u3, u3, max u1 u2, u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_3 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lapply.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a))) (Bot.bot.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], LE.le.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))))) (infᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) α (fun (a : α) => LinearMap.ker.{u1, u1, max u3 u2, u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_3 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lapply.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a))) (Bot.bot.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instBotSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.infi_ker_lapply_le_bot Finsupp.infᵢ_ker_lapply_le_botₓ'. -/
theorem infᵢ_ker_lapply_le_bot : (⨅ a, ker (lapply a : (α →₀ M) →ₗ[R] M)) ≤ ⊥ :=
  by
  simp only [SetLike.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]
  exact fun a h => Finsupp.ext h
#align finsupp.infi_ker_lapply_le_bot Finsupp.infᵢ_ker_lapply_le_bot

/- warning: finsupp.supr_lsingle_range -> Finsupp.supᵢ_lsingle_range is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (supᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => LinearMap.range.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a))) (Top.top.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasTop.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.lsingle.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a))) (Top.top.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instTopSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.supr_lsingle_range Finsupp.supᵢ_lsingle_rangeₓ'. -/
theorem supᵢ_lsingle_range : (⨆ a, (lsingle a : M →ₗ[R] α →₀ M).range) = ⊤ :=
  by
  refine' eq_top_iff.2 <| SetLike.le_def.2 fun f _ => _
  rw [← sum_single f]
  exact sum_mem fun a ha => Submodule.mem_supᵢ_of_mem a ⟨_, rfl⟩
#align finsupp.supr_lsingle_range Finsupp.supᵢ_lsingle_range

/- warning: finsupp.disjoint_lsingle_lsingle -> Finsupp.disjoint_lsingle_lsingle is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (t : Set.{u1} α), (Disjoint.{u1} (Set.{u1} α) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} α) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} α) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} α) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} α) (Set.completeBooleanAlgebra.{u1} α)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} α) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} α) (Set.booleanAlgebra.{u1} α))) s t) -> (Disjoint.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (supᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u1 u2, 0} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) => LinearMap.range.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a)))) (supᵢ.{max u1 u2, succ u1} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u1 u2, 0} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a t) (fun (H : Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a t) => LinearMap.range.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a)))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (t : Set.{u3} α), (Disjoint.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} α) (Preorder.toLE.{u3} (Set.{u3} α) (PartialOrder.toPreorder.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) s t) -> (Disjoint.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a s) (fun (H : Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a s) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.lsingle.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a)))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) α (fun (a : α) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a t) (fun (H : Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a t) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R M (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) _inst_4 (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.lsingle.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 a)))))
Case conversion may be inaccurate. Consider using '#align finsupp.disjoint_lsingle_lsingle Finsupp.disjoint_lsingle_lsingleₓ'. -/
theorem disjoint_lsingle_lsingle (s t : Set α) (hs : Disjoint s t) :
    Disjoint (⨆ a ∈ s, (lsingle a : M →ₗ[R] α →₀ M).range)
      (⨆ a ∈ t, (lsingle a : M →ₗ[R] α →₀ M).range) :=
  by
  refine'
    (Disjoint.mono (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right)
        (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right))
      _
  rw [disjoint_iff_inf_le]
  refine' le_trans (le_infᵢ fun i => _) infi_ker_lapply_le_bot
  classical
    by_cases his : i ∈ s
    · by_cases hit : i ∈ t
      · exact (hs.le_bot ⟨his, hit⟩).elim
      exact inf_le_of_right_le (infᵢ_le_of_le i <| infᵢ_le _ hit)
    exact inf_le_of_left_le (infᵢ_le_of_le i <| infᵢ_le _ his)
#align finsupp.disjoint_lsingle_lsingle Finsupp.disjoint_lsingle_lsingle

/- warning: finsupp.span_single_image -> Finsupp.span_single_image is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u2} M) (a : α), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Set.image.{u2, max u1 u2} M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a) s)) (Submodule.map.{u3, u3, u2, max u1 u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomSurjective.ids.{u3} R _inst_1) (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, u2, max u1 u2} R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_4 (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lsingle.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 a) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 s))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] (s : Set.{u3} M) (a : α), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.span.{u1, max u3 u2} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Set.image.{u3, max u3 u2} M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.single.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) a) s)) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_4 (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_3 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_4 (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) _inst_4 (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lsingle.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4 a) (Submodule.span.{u1, u3} R M _inst_1 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align finsupp.span_single_image Finsupp.span_single_imageₓ'. -/
theorem span_single_image (s : Set M) (a : α) :
    Submodule.span R (single a '' s) = (Submodule.span R s).map (lsingle a : M →ₗ[R] α →₀ M) := by
  rw [← span_image] <;> rfl
#align finsupp.span_single_image Finsupp.span_single_image

variable (M R)

/- warning: finsupp.supported -> Finsupp.supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], (Set.{u1} α) -> (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], (Set.{u1} α) -> (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.supported Finsupp.supportedₓ'. -/
/-- `finsupp.supported M R s` is the `R`-submodule of all `p : α →₀ M` such that `p.support ⊆ s`. -/
def supported (s : Set α) : Submodule R (α →₀ M) :=
  by
  refine' ⟨{ p | ↑p.support ⊆ s }, _, _, _⟩
  · intro p q hp hq
    refine' subset.trans (subset.trans (Finset.coe_subset.2 support_add) _) (union_subset hp hq)
    rw [Finset.coe_union]
  · simp only [subset_def, Finset.mem_coe, Set.mem_setOf_eq, mem_support_iff, zero_apply]
    intro h ha
    exact (ha rfl).elim
  · intro a p hp
    refine' subset.trans (Finset.coe_subset.2 support_smul) hp
#align finsupp.supported Finsupp.supported

variable {M}

/- warning: finsupp.mem_supported -> Finsupp.mem_supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Set.{u1} α} (p : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Iff (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (HasSubset.Subset.{u1} (Set.{u1} α) (Set.hasSubset.{u1} α) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) p)) s)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {s : Set.{u3} α} (p : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Iff (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (HasSubset.Subset.{u3} (Set.{u3} α) (Set.instHasSubsetSet.{u3} α) (Finset.toSet.{u3} α (Finsupp.support.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) p)) s)
Case conversion may be inaccurate. Consider using '#align finsupp.mem_supported Finsupp.mem_supportedₓ'. -/
theorem mem_supported {s : Set α} (p : α →₀ M) : p ∈ supported M R s ↔ ↑p.support ⊆ s :=
  Iff.rfl
#align finsupp.mem_supported Finsupp.mem_supported

/- warning: finsupp.mem_supported' -> Finsupp.mem_supported' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Set.{u1} α} (p : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Iff (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (forall (x : α), (Not (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) x s)) -> (Eq.{succ u2} M (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => α -> M) (Finsupp.coeFun.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) p x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {s : Set.{u3} α} (p : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Iff (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (forall (x : α), (Not (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) x s)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) p x) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) _inst_3))))))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_supported' Finsupp.mem_supported'ₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/
theorem mem_supported' {s : Set α} (p : α →₀ M) :
    p ∈ supported M R s ↔ ∀ (x) (_ : x ∉ s), p x = 0 := by
  haveI := Classical.decPred fun x : α => x ∈ s <;>
    simp [mem_supported, Set.subset_def, not_imp_comm]
#align finsupp.mem_supported' Finsupp.mem_supported'

/- warning: finsupp.mem_supported_support -> Finsupp.mem_supported_support is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (p : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) (Finsupp.support.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) p)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (p : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) p (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Finset.toSet.{u3} α (Finsupp.support.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) p)))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_supported_support Finsupp.mem_supported_supportₓ'. -/
theorem mem_supported_support (p : α →₀ M) : p ∈ Finsupp.supported M R (p.support : Set α) := by
  rw [Finsupp.mem_supported]
#align finsupp.mem_supported_support Finsupp.mem_supported_support

/- warning: finsupp.single_mem_supported -> Finsupp.single_mem_supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Set.{u1} α} {a : α} (b : M), (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) -> (Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) a b) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {s : Set.{u3} α} {a : α} (b : M), (Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) a s) -> (Membership.mem.{max u2 u3, max u2 u3} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.single.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) a b) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align finsupp.single_mem_supported Finsupp.single_mem_supportedₓ'. -/
theorem single_mem_supported {s : Set α} {a : α} (b : M) (h : a ∈ s) :
    single a b ∈ supported M R s :=
  Set.Subset.trans support_single_subset (Finset.singleton_subset_set_iff.2 h)
#align finsupp.single_mem_supported Finsupp.single_mem_supported

/- warning: finsupp.supported_eq_span_single -> Finsupp.supported_eq_span_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] (s : Set.{u1} α), Eq.{succ (max u1 u2)} (Submodule.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.supported.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) s) (Submodule.span.{u2, max u1 u2} R (Finsupp.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Set.image.{u1, max u1 u2} α (Finsupp.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (fun (i : α) => Finsupp.single.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) i (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))) s))
but is expected to have type
  forall {α : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (s : Set.{u2} α), Eq.{max (succ u2) (succ u1)} (Submodule.{u1, max u1 u2} R (Finsupp.{u2, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.supported.{u2, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s) (Submodule.span.{u1, max u1 u2} R (Finsupp.{u2, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u2, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u2, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Set.image.{u2, max u1 u2} α (Finsupp.{u2, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (i : α) => Finsupp.single.{u2, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) i (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1)))) s))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_eq_span_single Finsupp.supported_eq_span_singleₓ'. -/
theorem supported_eq_span_single (s : Set α) :
    supported R R s = span R ((fun i => single i 1) '' s) :=
  by
  refine' (span_eq_of_le _ _ (SetLike.le_def.2 fun l hl => _)).symm
  · rintro _ ⟨_, hp, rfl⟩
    exact single_mem_supported R 1 hp
  · rw [← l.sum_single]
    refine' sum_mem fun i il => _
    convert@smul_mem R (α →₀ R) _ _ _ _ (single i 1) (l i) _
    · simp
    apply subset_span
    apply Set.mem_image_of_mem _ (hl il)
#align finsupp.supported_eq_span_single Finsupp.supported_eq_span_single

variable (M R)

/- warning: finsupp.restrict_dom -> Finsupp.restrictDom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))
but is expected to have type
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearMap.{u3, u3, max u2 u1, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align finsupp.restrict_dom Finsupp.restrictDomₓ'. -/
/-- Interpret `finsupp.filter s` as a linear map from `α →₀ M` to `supported M R s`. -/
def restrictDom (s : Set α) : (α →₀ M) →ₗ[R] supported M R s :=
  LinearMap.codRestrict _
    { toFun := filter (· ∈ s)
      map_add' := fun l₁ l₂ => filter_add
      map_smul' := fun a l => filter_smul } fun l =>
    (mem_supported' _ _).2 fun x => filter_apply_neg (· ∈ s) l
#align finsupp.restrict_dom Finsupp.restrictDom

variable {M R}

section

/- warning: finsupp.restrict_dom_apply -> Finsupp.restrictDom_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (l : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) ((fun (a : Type.{max u1 u2}) (b : Sort.{max (succ u1) (succ u2)}) [self : HasLiftT.{succ (max u1 u2), max (succ u1) (succ u2)} a b] => self.0) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (HasLiftT.mk.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (CoeTCₓ.coe.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeBase.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSubtype.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (x : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => Membership.Mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)))))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (fun (_x : LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.hasCoeToFun.{u3, u3, max u1 u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.restrictDom.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) l)) (Finsupp.filter.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : α) => Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) _x s) l)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (l : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Eq.{max (succ u3) (succ u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.val.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Set.{max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Set.instMembershipSet.{max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) x (SetLike.coe.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.restrictDom.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) l)) (Finsupp.filter.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (fun (_x : α) => Membership.mem.{u3, u3} α (Set.{u3} α) (Set.instMembershipSet.{u3} α) _x s) l)
Case conversion may be inaccurate. Consider using '#align finsupp.restrict_dom_apply Finsupp.restrictDom_applyₓ'. -/
@[simp]
theorem restrictDom_apply (s : Set α) (l : α →₀ M) :
    ((restrictDom M R s : (α →₀ M) →ₗ[R] supported M R s) l : α →₀ M) = Finsupp.filter (· ∈ s) l :=
  rfl
#align finsupp.restrict_dom_apply Finsupp.restrictDom_apply

end

/- warning: finsupp.restrict_dom_comp_subtype -> Finsupp.restrictDom_comp_subtype is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), Eq.{succ (max u1 u2)} (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.comp.{u3, u3, u3, max u1 u2, max u1 u2, max u1 u2} R R R (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 _inst_1 _inst_1 (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.restrictDom.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Submodule.subtype.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.id.{u3, max u1 u2} R (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α), Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.comp.{u1, u1, u1, max u3 u2, max u3 u2, max u3 u2} R R R (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.restrictDom.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (Submodule.subtype.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.id.{u1, max u3 u2} R (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align finsupp.restrict_dom_comp_subtype Finsupp.restrictDom_comp_subtypeₓ'. -/
theorem restrictDom_comp_subtype (s : Set α) :
    (restrictDom M R s).comp (Submodule.subtype _) = LinearMap.id :=
  by
  ext (l a)
  by_cases a ∈ s <;> simp [h]
  exact ((mem_supported' R l.1).1 l.2 a h).symm
#align finsupp.restrict_dom_comp_subtype Finsupp.restrictDom_comp_subtype

/- warning: finsupp.range_restrict_dom -> Finsupp.range_restrictDom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.range.{u3, u3, max u1 u2, max u1 u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, max u1 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.restrictDom.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Top.top.{max u1 u2} (Submodule.{u3, max u1 u2} R (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (Submodule.hasTop.{u3, max u1 u2} R (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u3 u2} R (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.range.{u1, u1, max u3 u2, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.restrictDom.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Top.top.{max u3 u2} (Submodule.{u1, max u3 u2} R (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) (Submodule.instTopSubmodule.{u1, max u3 u2} R (Subtype.{succ (max u3 u2)} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u3 u2, max u3 u2} (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommMonoid.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s))))
Case conversion may be inaccurate. Consider using '#align finsupp.range_restrict_dom Finsupp.range_restrictDomₓ'. -/
theorem range_restrictDom (s : Set α) : (restrictDom M R s).range = ⊤ :=
  range_eq_top.2 <|
    Function.RightInverse.surjective <| LinearMap.congr_fun (restrictDom_comp_subtype s)
#align finsupp.range_restrict_dom Finsupp.range_restrictDom

/- warning: finsupp.supported_mono -> Finsupp.supported_mono is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Set.{u1} α} {t : Set.{u1} α}, (HasSubset.Subset.{u1} (Set.{u1} α) (Set.hasSubset.{u1} α) s t) -> (LE.le.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 t))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {s : Set.{u3} α} {t : Set.{u3} α}, (HasSubset.Subset.{u3} (Set.{u3} α) (Set.instHasSubsetSet.{u3} α) s t) -> (LE.le.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))))) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 t))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_mono Finsupp.supported_monoₓ'. -/
theorem supported_mono {s t : Set α} (st : s ⊆ t) : supported M R s ≤ supported M R t := fun l h =>
  Set.Subset.trans h st
#align finsupp.supported_mono Finsupp.supported_mono

/- warning: finsupp.supported_empty -> Finsupp.supported_empty is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} α) (Set.hasEmptyc.{u1} α))) (Bot.bot.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u3} (Set.{u3} α) (Set.instEmptyCollectionSet.{u3} α))) (Bot.bot.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instBotSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_empty Finsupp.supported_emptyₓ'. -/
@[simp]
theorem supported_empty : supported M R (∅ : Set α) = ⊥ :=
  eq_bot_iff.2 fun l h => (Submodule.mem_bot R).2 <| by ext <;> simp_all [mem_supported']
#align finsupp.supported_empty Finsupp.supported_empty

/- warning: finsupp.supported_univ -> Finsupp.supported_univ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Set.univ.{u1} α)) (Top.top.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasTop.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Set.univ.{u3} α)) (Top.top.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instTopSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_univ Finsupp.supported_univₓ'. -/
@[simp]
theorem supported_univ : supported M R (Set.univ : Set α) = ⊤ :=
  eq_top_iff.2 fun l _ => Set.subset_univ _
#align finsupp.supported_univ Finsupp.supported_univ

/- warning: finsupp.supported_Union -> Finsupp.supported_unionᵢ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {δ : Type.{u4}} (s : δ -> (Set.{u1} α)), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Set.unionᵢ.{u1, succ u4} α δ (fun (i : δ) => s i))) (supᵢ.{max u1 u2, succ u4} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))) δ (fun (i : δ) => Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (s i)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {δ : Type.{u4}} (s : δ -> (Set.{u3} α)), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Set.unionᵢ.{u3, succ u4} α δ (fun (i : δ) => s i))) (supᵢ.{max u2 u3, succ u4} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) δ (fun (i : δ) => Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (s i)))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_Union Finsupp.supported_unionᵢₓ'. -/
theorem supported_unionᵢ {δ : Type _} (s : δ → Set α) :
    supported M R (⋃ i, s i) = ⨆ i, supported M R (s i) :=
  by
  refine' le_antisymm _ (supᵢ_le fun i => supported_mono <| Set.subset_unionᵢ _ _)
  haveI := Classical.decPred fun x => x ∈ ⋃ i, s i
  suffices
    ((Submodule.subtype _).comp (restrict_dom M R (⋃ i, s i))).range ≤ ⨆ i, supported M R (s i) by
    rwa [LinearMap.range_comp, range_restrict_dom, map_top, range_subtype] at this
  rw [range_le_iff_comap, eq_top_iff]
  rintro l ⟨⟩
  apply Finsupp.induction l
  · exact zero_mem _
  refine' fun x a l hl a0 => add_mem _
  by_cases ∃ i, x ∈ s i <;> simp [h]
  · cases' h with i hi
    exact le_supᵢ (fun i => supported M R (s i)) i (single_mem_supported R _ hi)
#align finsupp.supported_Union Finsupp.supported_unionᵢ

/- warning: finsupp.supported_union -> Finsupp.supported_union is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (t : Set.{u1} α), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Union.union.{u1} (Set.{u1} α) (Set.hasUnion.{u1} α) s t)) (Sup.sup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SemilatticeSup.toHasSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Lattice.toSemilatticeSup.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)))))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 t))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (t : Set.{u3} α), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Union.union.{u3} (Set.{u3} α) (Set.instUnionSet.{u3} α) s t)) (Sup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (SemilatticeSup.toSup.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Lattice.toSemilatticeSup.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (ConditionallyCompleteLattice.toLattice.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))))) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 t))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_union Finsupp.supported_unionₓ'. -/
theorem supported_union (s t : Set α) : supported M R (s ∪ t) = supported M R s ⊔ supported M R t :=
  by erw [Set.union_eq_unionᵢ, supported_Union, supᵢ_bool_eq] <;> rfl
#align finsupp.supported_union Finsupp.supported_union

/- warning: finsupp.supported_Inter -> Finsupp.supported_interᵢ is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {ι : Type.{u4}} (s : ι -> (Set.{u1} α)), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Set.interᵢ.{u1, succ u4} α ι (fun (i : ι) => s i))) (infᵢ.{max u1 u2, succ u4} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasInf.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) ι (fun (i : ι) => Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (s i)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {ι : Type.{u4}} (s : ι -> (Set.{u3} α)), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Set.interᵢ.{u3, succ u4} α ι (fun (i : ι) => s i))) (infᵢ.{max u2 u3, succ u4} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) ι (fun (i : ι) => Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (s i)))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_Inter Finsupp.supported_interᵢₓ'. -/
theorem supported_interᵢ {ι : Type _} (s : ι → Set α) :
    supported M R (⋂ i, s i) = ⨅ i, supported M R (s i) :=
  Submodule.ext fun x => by simp [mem_supported, subset_Inter_iff]
#align finsupp.supported_Inter Finsupp.supported_interᵢ

/- warning: finsupp.supported_inter -> Finsupp.supported_inter is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α) (t : Set.{u1} α), Eq.{succ (max u1 u2)} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Inter.inter.{u1} (Set.{u1} α) (Set.hasInter.{u1} α) s t)) (Inf.inf.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Submodule.hasInf.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 t))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u3} α) (t : Set.{u3} α), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Inter.inter.{u3} (Set.{u3} α) (Set.instInterSet.{u3} α) s t)) (Inf.inf.{max u2 u3} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.instInfSubmodule.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 t))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_inter Finsupp.supported_interₓ'. -/
theorem supported_inter (s t : Set α) : supported M R (s ∩ t) = supported M R s ⊓ supported M R t :=
  by rw [Set.inter_eq_interᵢ, supported_Inter, infᵢ_bool_eq] <;> rfl
#align finsupp.supported_inter Finsupp.supported_inter

/- warning: finsupp.disjoint_supported_supported -> Finsupp.disjoint_supported_supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Set.{u1} α} {t : Set.{u1} α}, (Disjoint.{u1} (Set.{u1} α) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} α) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} α) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} α) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} α) (Set.completeBooleanAlgebra.{u1} α)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} α) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} α) (Set.booleanAlgebra.{u1} α))) s t) -> (Disjoint.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 t))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {s : Set.{u3} α} {t : Set.{u3} α}, (Disjoint.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} α) (Preorder.toLE.{u3} (Set.{u3} α) (PartialOrder.toPreorder.{u3} (Set.{u3} α) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} α) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} α) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} α) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} α) (Set.instCompleteBooleanAlgebraSet.{u3} α)))))) s t) -> (Disjoint.{max u2 u3} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 t))
Case conversion may be inaccurate. Consider using '#align finsupp.disjoint_supported_supported Finsupp.disjoint_supported_supportedₓ'. -/
theorem disjoint_supported_supported {s t : Set α} (h : Disjoint s t) :
    Disjoint (supported M R s) (supported M R t) :=
  disjoint_iff.2 <| by rw [← supported_inter, disjoint_iff_inter_eq_empty.1 h, supported_empty]
#align finsupp.disjoint_supported_supported Finsupp.disjoint_supported_supported

/- warning: finsupp.disjoint_supported_supported_iff -> Finsupp.disjoint_supported_supported_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_9 : Nontrivial.{u2} M] {s : Set.{u1} α} {t : Set.{u1} α}, Iff (Disjoint.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 t)) (Disjoint.{u1} (Set.{u1} α) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} α) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} α) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} α) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} α) (Set.completeBooleanAlgebra.{u1} α)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} α) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} α) (Set.booleanAlgebra.{u1} α))) s t)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] [_inst_9 : Nontrivial.{u3} M] {s : Set.{u2} α} {t : Set.{u2} α}, Iff (Disjoint.{max u3 u2} (Submodule.{u1, max u3 u2} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, max u2 u3} R (Finsupp.{u2, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α M _inst_3) (Finsupp.module.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4 s) (Finsupp.supported.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4 t)) (Disjoint.{u2} (Set.{u2} α) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} α) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} α) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} α) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} α) (Set.instCompleteBooleanAlgebraSet.{u2} α)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} α) (Preorder.toLE.{u2} (Set.{u2} α) (PartialOrder.toPreorder.{u2} (Set.{u2} α) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} α) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} α) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} α) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} α) (Set.instCompleteBooleanAlgebraSet.{u2} α)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} α) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} α) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} α) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} α) (Set.instCompleteBooleanAlgebraSet.{u2} α)))))) s t)
Case conversion may be inaccurate. Consider using '#align finsupp.disjoint_supported_supported_iff Finsupp.disjoint_supported_supported_iffₓ'. -/
theorem disjoint_supported_supported_iff [Nontrivial M] {s t : Set α} :
    Disjoint (supported M R s) (supported M R t) ↔ Disjoint s t :=
  by
  refine' ⟨fun h => set.disjoint_left.mpr fun x hx1 hx2 => _, disjoint_supported_supported⟩
  rcases exists_ne (0 : M) with ⟨y, hy⟩
  have := h.le_bot ⟨single_mem_supported R y hx1, single_mem_supported R y hx2⟩
  rw [mem_bot, single_eq_zero] at this
  exact hy this
#align finsupp.disjoint_supported_supported_iff Finsupp.disjoint_supported_supported_iff

/- warning: finsupp.supported_equiv_finsupp -> Finsupp.supportedEquivFinsupp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearEquiv.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M _inst_3) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) M R _inst_1 _inst_3 _inst_4)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (s : Set.{u1} α), LinearEquiv.{u3, u3, max u1 u2, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Subtype.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (Finsupp.{u1, u2} (Set.Elem.{u1} α s) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.addCommMonoid.{u1, u2} (Set.Elem.{u1} α s) M _inst_3) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.module.{u1, u2, u3} (Set.Elem.{u1} α s) M R _inst_1 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align finsupp.supported_equiv_finsupp Finsupp.supportedEquivFinsuppₓ'. -/
/-- Interpret `finsupp.restrict_support_equiv` as a linear equivalence between
`supported M R s` and `s →₀ M`. -/
def supportedEquivFinsupp (s : Set α) : supported M R s ≃ₗ[R] s →₀ M :=
  by
  let F : supported M R s ≃ (s →₀ M) := restrict_support_equiv s M
  refine' F.to_linear_equiv _
  have :
    (F : supported M R s → ↥s →₀ M) =
      (lsubtype_domain s : (α →₀ M) →ₗ[R] s →₀ M).comp (Submodule.subtype (supported M R s)) :=
    rfl
  rw [this]
  exact LinearMap.isLinear _
#align finsupp.supported_equiv_finsupp Finsupp.supportedEquivFinsupp

section Lsum

variable (S) [Module S N] [SMulCommClass R S N]

/- warning: finsupp.lsum -> Finsupp.lsum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u4, u3} R N (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} S N (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))], LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toSMul.{u4, u3} R N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u4, u3} R N (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u5, u3} S N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u3} S N (MonoidWithZero.toZero.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))], LinearEquiv.{u5, u5, max (max u1 u2) u3, max u3 u2 u1} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u2 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.module.{u1, max u2 u3, u5} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)
Case conversion may be inaccurate. Consider using '#align finsupp.lsum Finsupp.lsumₓ'. -/
/-- Lift a family of linear maps `M →ₗ[R] N` indexed by `x : α` to a linear map from `α →₀ M` to
`N` using `finsupp.sum`. This is an upgraded version of `finsupp.lift_add_hom`.

See note [bundled maps over different rings] for why separate `R` and `S` semirings are used.
-/
def lsum : (α → M →ₗ[R] N) ≃ₗ[S] (α →₀ M) →ₗ[R] N
    where
  toFun F :=
    { toFun := fun d => d.Sum fun i => F i
      map_add' := (liftAddHom fun x => (F x).toAddMonoidHom).map_add
      map_smul' := fun c f => by simp [sum_smul_index', smul_sum] }
  invFun F x := F.comp (lsingle x)
  left_inv F := by
    ext (x y)
    simp
  right_inv F := by
    ext (x y)
    simp
  map_add' F G := by
    ext (x y)
    simp
  map_smul' F G := by
    ext (x y)
    simp
#align finsupp.lsum Finsupp.lsum

/- warning: finsupp.coe_lsum -> Finsupp.coe_lsum is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u4, u3} R N (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} S N (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)), Eq.{max (max (succ u1) (succ u2)) (succ u3)} ((fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (fun (_x : LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) => (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) -> (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6)) (LinearEquiv.hasCoeToFun.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2)) (Finsupp.lsum.{u1, u2, u3, u4, u5} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f)) (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (fun (_x : LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) => (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) -> (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6)) (LinearEquiv.hasCoeToFun.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2)) (Finsupp.lsum.{u1, u2, u3, u4, u5} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f)) (fun (d : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_5 d (fun (i : α) => coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) => M -> N) (LinearMap.hasCoeToFun.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (f i)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} {R : Type.{u5}} (S : Type.{u1}) [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u1, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u5, u1, u3} R S N (SMulZeroClass.toSMul.{u5, u3} R N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u3} R N (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u3} R N (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u5, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u1, u3} S N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} S N (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} S N (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u1, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)), Eq.{max (max (succ u2) (succ u4)) (succ u3)} (forall (a : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) a) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u2) (succ u4), succ u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) f) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (fun (_x : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toZero.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toZero.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2)))))) (Finsupp.lsum.{u2, u4, u3, u5, u1} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f)) (fun (d : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => Finsupp.sum.{u2, u4, u3} α M ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) d) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) _inst_5 d (fun (i : α) => FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (f i)))
Case conversion may be inaccurate. Consider using '#align finsupp.coe_lsum Finsupp.coe_lsumₓ'. -/
@[simp]
theorem coe_lsum (f : α → M →ₗ[R] N) : (lsum S f : (α →₀ M) → N) = fun d => d.Sum fun i => f i :=
  rfl
#align finsupp.coe_lsum Finsupp.coe_lsum

/- warning: finsupp.lsum_apply -> Finsupp.lsum_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u4, u3} R N (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} S N (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (l : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{succ u3} N (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (fun (_x : LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) => (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) -> (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6)) (LinearEquiv.hasCoeToFun.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2)) (Finsupp.lsum.{u1, u2, u3, u4, u5} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f) l) (Finsupp.sum.{u1, u2, u3} α M N (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_5 l (fun (b : α) => coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) => M -> N) (LinearMap.hasCoeToFun.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (f b)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} {R : Type.{u5}} (S : Type.{u1}) [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u1, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u5, u1, u3} R S N (SMulZeroClass.toSMul.{u5, u3} R N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u3} R N (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u3} R N (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u5, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u1, u3} S N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} S N (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} S N (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u1, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (l : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) l) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u2) (succ u4), succ u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) f) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (fun (_x : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toZero.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toZero.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2)))))) (Finsupp.lsum.{u2, u4, u3, u5, u1} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f) l) (Finsupp.sum.{u2, u4, u3} α M N (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) _inst_5 l (fun (b : α) => FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (f b)))
Case conversion may be inaccurate. Consider using '#align finsupp.lsum_apply Finsupp.lsum_applyₓ'. -/
theorem lsum_apply (f : α → M →ₗ[R] N) (l : α →₀ M) : Finsupp.lsum S f l = l.Sum fun b => f b :=
  rfl
#align finsupp.lsum_apply Finsupp.lsum_apply

/- warning: finsupp.lsum_single -> Finsupp.lsum_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u4, u3} R N (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} S N (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (i : α) (m : M), Eq.{succ u3} N (coeFn.{max (succ (max u1 u2)) (succ u3), max (succ (max u1 u2)) (succ u3)} (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> N) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (coeFn.{max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3)), max (succ (max u1 u2 u3)) (succ (max (max u1 u2) u3))} (LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (fun (_x : LinearEquiv.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) => (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) -> (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6)) (LinearEquiv.hasCoeToFun.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2)) (Finsupp.lsum.{u1, u2, u3, u4, u5} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f) (Finsupp.single.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) i m)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) => M -> N) (LinearMap.hasCoeToFun.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (f i) m)
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u4}} {N : Type.{u3}} {R : Type.{u5}} (S : Type.{u1}) [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u1, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u5, u1, u3} R S N (SMulZeroClass.toSMul.{u5, u3} R N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u3} R N (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u3} R N (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u5, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u1, u3} S N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u3} S N (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u3} S N (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)) (Module.toMulActionWithZero.{u1, u3} S N _inst_2 _inst_5 _inst_9))))] (f : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (i : α) (m : M), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) (Finsupp.single.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) i m)) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u2) (succ u4), succ u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) f) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (fun (_x : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (fun (_x : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) => LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toZero.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toZero.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} S (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u3 u4 u2} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} S S (α -> (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u2, max u4 u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u2 u4, u3} R R (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u2, max u4 u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u2 u4, u3} R R S (Finsupp.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u4} α M _inst_3) _inst_5 (Finsupp.module.{u2, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2)))))) (Finsupp.lsum.{u2, u4, u3, u5, u1} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10) f) (Finsupp.single.{u2, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) i m)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (f i) m)
Case conversion may be inaccurate. Consider using '#align finsupp.lsum_single Finsupp.lsum_singleₓ'. -/
theorem lsum_single (f : α → M →ₗ[R] N) (i : α) (m : M) :
    Finsupp.lsum S f (Finsupp.single i m) = f i m :=
  Finsupp.sum_single_index (f i).map_zero
#align finsupp.lsum_single Finsupp.lsum_single

/- warning: finsupp.lsum_symm_apply -> Finsupp.lsum_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u4} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] [_inst_9 : Module.{u5, u3} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u4, u5, u3} R S N (SMulZeroClass.toHasSmul.{u4, u3} R N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u4, u3} R N (MulZeroClass.toHasZero.{u4} R (MulZeroOneClass.toMulZeroClass.{u4} R (MonoidWithZero.toMulZeroOneClass.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u4, u3} R N (Semiring.toMonoidWithZero.{u4} R _inst_1) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u4, u3} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u3} S N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u3} S N (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u3} S N (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Module.toMulActionWithZero.{u5, u3} S N _inst_2 _inst_5 _inst_9))))] (f : LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (x : α), Eq.{max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (coeFn.{max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3)), max (succ (max (max u1 u2) u3)) (succ (max u1 u2 u3))} (LinearEquiv.{u5, u5, max (max u1 u2) u3, max u1 u2 u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10))) (fun (_x : LinearEquiv.{u5, u5, max (max u1 u2) u3, max u1 u2 u3} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10))) => (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) -> α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearEquiv.hasCoeToFun.{u5, u5, max (max u1 u2) u3, max u1 u2 u3} S S (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 _inst_2 (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2)) (LinearEquiv.symm.{u5, u5, max u1 u2 u3, max (max u1 u2) u3} S S (α -> (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u4, u4, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, max u2 u3} α (fun (ᾰ : α) => LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) (LinearMap.addCommMonoid.{u4, u4, max u1 u2, u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Pi.Function.module.{u1, u5, max u2 u3} α S (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_2 (LinearMap.addCommMonoid.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (LinearMap.module.{u4, u4, u5, u2, u3} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.module.{u4, u4, u5, max u1 u2, u3} R R S (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (Finsupp.lsum.{u1, u2, u3, u4, u5} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10)) f x) (LinearMap.comp.{u4, u4, u4, u2, max u1 u2, u3} R R R M (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomCompTriple.right_ids.{u4, u4} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) f (Finsupp.lsingle.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4 x))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u4}} {N : Type.{u2}} {R : Type.{u5}} (S : Type.{u1}) [_inst_1 : Semiring.{u5} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u5, u2} R N _inst_1 _inst_5] [_inst_9 : Module.{u1, u2} S N _inst_2 _inst_5] [_inst_10 : SMulCommClass.{u5, u1, u2} R S N (SMulZeroClass.toSMul.{u5, u2} R N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u2} R N (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_1)) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u2} R N (Semiring.toMonoidWithZero.{u5} R _inst_1) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (Module.toMulActionWithZero.{u5, u2} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u1, u2} S N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u2} S N (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u2} S N (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)) (Module.toMulActionWithZero.{u1, u2} S N _inst_2 _inst_5 _inst_9))))] (f : LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (x : α), Eq.{max (succ u4) (succ u2)} (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (max (succ u2) (succ u4)) (succ u3), max (max (succ u2) (succ u4)) (succ u3)} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (fun (_x : LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) => α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _x) (SMulHomClass.toFunLike.{max (max u2 u4) u3, u1, max (max u2 u4) u3, max (max u2 u4) u3} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (SMulZeroClass.toSMul.{u1, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toZero.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribSMul.toSMulZeroClass.{u1, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddMonoid.toAddZeroClass.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (DistribMulAction.toDistribSMul.{u1, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Module.toDistribMulAction.{u1, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))))) (SMulZeroClass.toSMul.{u1, max (max u2 u4) u3} S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toZero.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u1, max (max u2 u4) u3} S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddMonoid.toAddZeroClass.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u1, max (max u2 u4) u3} S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (Module.toDistribMulAction.{u1, max (max u2 u4) u3} S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u4) u3, u1, max (max u2 u4) u3, max (max u2 u4) u3} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))))) (Module.toDistribMulAction.{u1, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (Module.toDistribMulAction.{u1, max (max u2 u4) u3} S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u2 u4) u3, max (max u2 u4) u3, max (max u2 u4) u3} S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3, max (max u2 u4) u3} S S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S _inst_2 _inst_2 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10))) _inst_2 _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) _inst_2 _inst_2 (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.addCommMonoid.{u3, max u4 u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2)))))) (LinearEquiv.symm.{u1, u1, max (max u2 u4) u3, max (max u2 u4) u3} S S (α -> (LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6)) (LinearMap.{u5, u5, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6) _inst_2 _inst_2 (Pi.addCommMonoid.{u3, max u4 u2} α (fun (ᾰ : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)))) (LinearMap.addCommMonoid.{u5, u5, max u3 u4, u2} R R (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Pi.module.{u3, max u4 u2, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4473 : α) => LinearMap.{u5, u5, u4, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) S _inst_2 (fun (i : α) => LinearMap.addCommMonoid.{u5, u5, u4, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (fun (i : α) => LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, u4, u2} R R S M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10)) (LinearMap.instModuleLinearMapAddCommMonoid.{u5, u5, u1, max u3 u4, u2} R R S (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) _inst_2 _inst_9 _inst_10) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_2)) (RingHomInvPair.ids.{u1} S _inst_2) (RingHomInvPair.ids.{u1} S _inst_2) (Finsupp.lsum.{u3, u4, u2, u5, u1} α M N R S _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10)) f x) (LinearMap.comp.{u5, u5, u5, u4, max u3 u4, u2} R R R M (Finsupp.{u3, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) N _inst_1 _inst_1 _inst_1 _inst_3 (Finsupp.addCommMonoid.{u3, u4} α M _inst_3) _inst_5 _inst_4 (Finsupp.module.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4) _inst_6 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) f (Finsupp.lsingle.{u3, u4, u5} α M R _inst_1 _inst_3 _inst_4 x))
Case conversion may be inaccurate. Consider using '#align finsupp.lsum_symm_apply Finsupp.lsum_symm_applyₓ'. -/
theorem lsum_symm_apply (f : (α →₀ M) →ₗ[R] N) (x : α) : (lsum S).symm f x = f.comp (lsingle x) :=
  rfl
#align finsupp.lsum_symm_apply Finsupp.lsum_symm_apply

end Lsum

section

variable (M) (R) (X : Type _)

/- warning: finsupp.lift -> Finsupp.lift is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (X : Type.{u3}), AddEquiv.{max u3 u1, max (max u3 u2) u1} (X -> M) (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))
but is expected to have type
  forall (M : Type.{u1}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (X : Type.{u3}), AddEquiv.{max u1 u3, max u1 u2 u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align finsupp.lift Finsupp.liftₓ'. -/
/-- A slight rearrangement from `lsum` gives us
the bijection underlying the free-forgetful adjunction for R-modules.
-/
noncomputable def lift : (X → M) ≃+ ((X →₀ R) →ₗ[R] M) :=
  (AddEquiv.arrowCongr (Equiv.refl X) (ringLmapEquivSelf R ℕ M).toAddEquiv.symm).trans
    (lsum _ : _ ≃ₗ[ℕ] _).toAddEquiv
#align finsupp.lift Finsupp.lift

/- warning: finsupp.lift_symm_apply -> Finsupp.lift_symm_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (X : Type.{u3}) (f : LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (x : X), Eq.{succ u1} M (coeFn.{max (succ (max (max u3 u2) u1)) (succ (max u3 u1)), max (succ (max (max u3 u2) u1)) (succ (max u3 u1))} (AddEquiv.{max (max u3 u2) u1, max u3 u1} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (X -> M) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (fun (_x : AddEquiv.{max (max u3 u2) u1, max u3 u1} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (X -> M) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) => (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) -> X -> M) (AddEquiv.hasCoeToFun.{max (max u3 u2) u1, max u3 u1} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (X -> M) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (AddEquiv.symm.{max u3 u1, max (max u3 u2) u1} (X -> M) (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.lift.{u1, u2, u3} M R _inst_1 _inst_3 _inst_4 X)) f x) (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ (max u3 u2)) (succ u1)} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f (Finsupp.single.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) x (OfNat.ofNat.{u2} R 1 (OfNat.mk.{u2} R 1 (One.one.{u2} R (AddMonoidWithOne.toOne.{u2} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} R (NonAssocSemiring.toAddCommMonoidWithOne.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))))))
but is expected to have type
  forall (M : Type.{u1}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] (X : Type.{u2}) (f : LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (x : X), Eq.{succ u1} M (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (max (succ u1) (succ u3)) (succ u2), max (succ u1) (succ u2)} (AddEquiv.{max (max u1 u3) u2, max u1 u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Pi.instAdd.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => X -> M) _x) (AddHomClass.toFunLike.{max (max u1 u3) u2, max (max u1 u3) u2, max u1 u2} (AddEquiv.{max (max u1 u3) u2, max u1 u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Pi.instAdd.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (AddZeroClass.toAdd.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (AddZeroClass.toAdd.{max u1 u2} (X -> M) (Pi.addZeroClass.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max u1 u2} (AddEquiv.{max (max u1 u3) u2, max u1 u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Pi.instAdd.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Pi.addZeroClass.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u3) u2, max (max u1 u3) u2, max u1 u2} (AddEquiv.{max (max u1 u3) u2, max u1 u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Pi.instAdd.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (AddMonoid.toAddZeroClass.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Pi.addZeroClass.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{max (max u1 u3) u2, max u1 u2} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (X -> M) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Pi.instAdd.{u2, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))))) (AddEquiv.symm.{max u1 u2, max (max u1 u3) u2} (X -> M) (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (Pi.instAdd.{u2, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lift.{u1, u3, u2} M R _inst_1 _inst_3 _inst_4 X)) f x) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (fun (_x : Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u3 u2, u1} R R (Finsupp.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u3} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u3, u3} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f (Finsupp.single.{u2, u3} X R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) x (OfNat.ofNat.{u3} R 1 (One.toOfNat1.{u3} R (Semiring.toOne.{u3} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_symm_apply Finsupp.lift_symm_applyₓ'. -/
@[simp]
theorem lift_symm_apply (f) (x) : ((lift M R X).symm f) x = f (single x 1) :=
  rfl
#align finsupp.lift_symm_apply Finsupp.lift_symm_apply

/- warning: finsupp.lift_apply -> Finsupp.lift_apply is a dubious translation:
lean 3 declaration is
  forall (M : Type.{u1}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (X : Type.{u3}) (f : X -> M) (g : Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), Eq.{succ u1} M (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ (max u3 u2)) (succ u1)} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (coeFn.{max (succ (max u3 u1)) (succ (max (max u3 u2) u1)), max (succ (max u3 u1)) (succ (max (max u3 u2) u1))} (AddEquiv.{max u3 u1, max (max u3 u2) u1} (X -> M) (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (fun (_x : AddEquiv.{max u3 u1, max (max u3 u2) u1} (X -> M) (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) => (X -> M) -> (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4)) (AddEquiv.hasCoeToFun.{max u3 u1, max (max u3 u2) u1} (X -> M) (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (ᾰ : X) => M) (fun (i : X) => AddZeroClass.toHasAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.hasAdd.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} X R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.lift.{u1, u2, u3} M R _inst_1 _inst_3 _inst_4 X) f) g) (Finsupp.sum.{u3, u2, u1} X R M (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 g (fun (x : X) (r : R) => SMul.smul.{u2, u1} R M (SMulZeroClass.toHasSmul.{u2, u1} R M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u2, u1} R M (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_4)))) r (f x)))
but is expected to have type
  forall (M : Type.{u1}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (X : Type.{u3}) (f : X -> M) (g : Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) g) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u1} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : X -> M) => LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) f) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u1) (succ u3), max (max (succ u1) (succ u2)) (succ u3)} (AddEquiv.{max u1 u3, max u1 u2 u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (X -> M) (fun (_x : X -> M) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : X -> M) => LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) _x) (AddHomClass.toFunLike.{max (max u1 u2) u3, max u1 u3, max (max u1 u2) u3} (AddEquiv.{max u1 u3, max u1 u2 u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (AddZeroClass.toAdd.{max u1 u3} (X -> M) (Pi.addZeroClass.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (AddZeroClass.toAdd.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (AddMonoidHomClass.toAddHomClass.{max (max u1 u2) u3, max u1 u3, max (max u1 u2) u3} (AddEquiv.{max u1 u3, max u1 u2 u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.addZeroClass.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (AddEquivClass.instAddMonoidHomClass.{max (max u1 u2) u3, max u1 u3, max (max u1 u2) u3} (AddEquiv.{max u1 u3, max u1 u2 u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.addZeroClass.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (AddCommMonoid.toAddMonoid.{max (max u1 u2) u3} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.addCommMonoid.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (AddEquiv.instAddEquivClassAddEquiv.{max u1 u3, max (max u1 u2) u3} (X -> M) (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Pi.instAdd.{u3, u1} X (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.4991 : X) => M) (fun (i : X) => AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (LinearMap.instAddLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} X R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} X R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} X R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Finsupp.lift.{u1, u2, u3} M R _inst_1 _inst_3 _inst_4 X) f) g) (Finsupp.sum.{u3, u2, u1} X R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) _inst_3 g (fun (x : X) (r : R) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_4))))) r (f x)))
Case conversion may be inaccurate. Consider using '#align finsupp.lift_apply Finsupp.lift_applyₓ'. -/
@[simp]
theorem lift_apply (f) (g) : ((lift M R X) f) g = g.Sum fun x r => r • f x :=
  rfl
#align finsupp.lift_apply Finsupp.lift_apply

end

section LmapDomain

variable {α' : Type _} {α'' : Type _} (M R)

/- warning: finsupp.lmap_domain -> Finsupp.lmapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}}, (α -> α') -> (LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}}, (α -> α') -> (LinearMap.{u3, u3, max u2 u1, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain Finsupp.lmapDomainₓ'. -/
/-- Interpret `finsupp.map_domain` as a linear map. -/
def lmapDomain (f : α → α') : (α →₀ M) →ₗ[R] α' →₀ M
    where
  toFun := mapDomain f
  map_add' a b := mapDomain_add
  map_smul' := mapDomain_smul
#align finsupp.lmap_domain Finsupp.lmapDomain

/- warning: finsupp.lmap_domain_apply -> Finsupp.lmapDomain_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (f : α -> α') (l : Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))), Eq.{max (succ u4) (succ u2)} (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (coeFn.{max (succ (max u1 u2)) (succ (max u4 u2)), max (succ (max u1 u2)) (succ (max u4 u2))} (LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) => (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) -> (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))) (LinearMap.hasCoeToFun.{u3, u3, max u1 u2, max u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lmapDomain.{u1, u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 α' f) l) (Finsupp.mapDomain.{u1, u4, u2} α α' M _inst_3 f l)
but is expected to have type
  forall {α : Type.{u4}} (M : Type.{u3}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] {α' : Type.{u2}} (f : α -> α') (l : Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) l) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u4) (succ u3), max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u3 u4, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.addCommMonoid.{u4, u3} α M _inst_3) (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (fun (_x : Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) => Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u3, max u3 u2} R R (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u3} α M _inst_3) (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lmapDomain.{u4, u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 α' f) l) (Finsupp.mapDomain.{u4, u2, u3} α α' M _inst_3 f l)
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_apply Finsupp.lmapDomain_applyₓ'. -/
@[simp]
theorem lmapDomain_apply (f : α → α') (l : α →₀ M) :
    (lmapDomain M R f : (α →₀ M) →ₗ[R] α' →₀ M) l = mapDomain f l :=
  rfl
#align finsupp.lmap_domain_apply Finsupp.lmapDomain_apply

/- warning: finsupp.lmap_domain_id -> Finsupp.lmapDomain_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.lmapDomain.{u1, u2, u3, u1} α M R _inst_1 _inst_3 _inst_4 α (id.{succ u1} α)) (LinearMap.id.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u3}} (M : Type.{u2}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.lmapDomain.{u3, u2, u1, u3} α M R _inst_1 _inst_3 _inst_4 α (id.{succ u3} α)) (LinearMap.id.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_id Finsupp.lmapDomain_idₓ'. -/
@[simp]
theorem lmapDomain_id : (lmapDomain M R id : (α →₀ M) →ₗ[R] α →₀ M) = LinearMap.id :=
  LinearMap.ext fun l => mapDomain_id
#align finsupp.lmap_domain_id Finsupp.lmapDomain_id

/- warning: finsupp.lmap_domain_comp -> Finsupp.lmapDomain_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} {α'' : Type.{u5}} (f : α -> α') (g : α' -> α''), Eq.{max (succ (max u1 u2)) (succ (max u5 u2))} (LinearMap.{u3, u3, max u1 u2, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u5, u2} α'' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u5, u2} α'' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} α'' M R _inst_1 _inst_3 _inst_4)) (Finsupp.lmapDomain.{u1, u2, u3, u5} α M R _inst_1 _inst_3 _inst_4 α'' (Function.comp.{succ u1, succ u4, succ u5} α α' α'' g f)) (LinearMap.comp.{u3, u3, u3, max u1 u2, max u4 u2, max u5 u2} R R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u5, u2} α'' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.addCommMonoid.{u5, u2} α'' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} α'' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lmapDomain.{u4, u2, u3, u5} α' M R _inst_1 _inst_3 _inst_4 α'' g) (Finsupp.lmapDomain.{u1, u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 α' f))
but is expected to have type
  forall {α : Type.{u5}} (M : Type.{u4}) (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u2, u4} R M _inst_1 _inst_3] {α' : Type.{u1}} {α'' : Type.{u3}} (f : α -> α') (g : α' -> α''), Eq.{max (max (succ u5) (succ u4)) (succ u3)} (LinearMap.{u2, u2, max u4 u5, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u5, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.{u3, u4} α'' M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.addCommMonoid.{u5, u4} α M _inst_3) (Finsupp.addCommMonoid.{u3, u4} α'' M _inst_3) (Finsupp.module.{u5, u4, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u4, u2} α'' M R _inst_1 _inst_3 _inst_4)) (Finsupp.lmapDomain.{u5, u4, u2, u3} α M R _inst_1 _inst_3 _inst_4 α'' (Function.comp.{succ u5, succ u1, succ u3} α α' α'' g f)) (LinearMap.comp.{u2, u2, u2, max u4 u5, max u4 u1, max u4 u3} R R R (Finsupp.{u5, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.{u1, u4} α' M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.{u3, u4} α'' M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u4} α M _inst_3) (Finsupp.addCommMonoid.{u1, u4} α' M _inst_3) (Finsupp.addCommMonoid.{u3, u4} α'' M _inst_3) (Finsupp.module.{u5, u4, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u4, u2} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u4, u2} α'' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.lmapDomain.{u1, u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 α'' g) (Finsupp.lmapDomain.{u5, u4, u2, u1} α M R _inst_1 _inst_3 _inst_4 α' f))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_comp Finsupp.lmapDomain_compₓ'. -/
theorem lmapDomain_comp (f : α → α') (g : α' → α'') :
    lmapDomain M R (g ∘ f) = (lmapDomain M R g).comp (lmapDomain M R f) :=
  LinearMap.ext fun l => mapDomain_comp
#align finsupp.lmap_domain_comp Finsupp.lmapDomain_comp

/- warning: finsupp.supported_comap_lmap_domain -> Finsupp.supported_comap_lmapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (f : α -> α') (s : Set.{u4} α'), LE.le.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Set.preimage.{u1, u4} α α' f s)) (Submodule.comap.{u3, u3, max u1 u2, max u4 u2, max (max u1 u2) u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, max u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lmapDomain.{u1, u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 α' f) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 s))
but is expected to have type
  forall {α : Type.{u3}} (M : Type.{u2}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (f : α -> α') (s : Set.{u4} α'), LE.le.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)))))) (Finsupp.supported.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (Set.preimage.{u3, u4} α α' f s)) (Submodule.comap.{u1, u1, max u3 u2, max u2 u4, max (max u2 u4) u3} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u1} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, max u2 u4} R R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lmapDomain.{u3, u2, u1, u4} α M R _inst_1 _inst_3 _inst_4 α' f) (Finsupp.supported.{u4, u2, u1} α' M R _inst_1 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align finsupp.supported_comap_lmap_domain Finsupp.supported_comap_lmapDomainₓ'. -/
theorem supported_comap_lmapDomain (f : α → α') (s : Set α') :
    supported M R (f ⁻¹' s) ≤ (supported M R s).comap (lmapDomain M R f) :=
  fun l (hl : ↑l.support ⊆ f ⁻¹' s) =>
  show ↑(mapDomain f l).support ⊆ s
    by
    rw [← Set.image_subset_iff, ← Finset.coe_image] at hl
    exact Set.Subset.trans map_domain_support hl
#align finsupp.supported_comap_lmap_domain Finsupp.supported_comap_lmapDomain

/- warning: finsupp.lmap_domain_supported -> Finsupp.lmapDomain_supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} [_inst_9 : Nonempty.{succ u1} α] (f : α -> α') (s : Set.{u1} α), Eq.{succ (max u4 u2)} (Submodule.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (Submodule.map.{u3, u3, max u1 u2, max u4 u2, max (max u1 u2) u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomSurjective.ids.{u3} R _inst_1) (LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, max u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lmapDomain.{u1, u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 α' f) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 (Set.image.{u1, u4} α α' f s))
but is expected to have type
  forall {α : Type.{u4}} (M : Type.{u3}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] {α' : Type.{u2}} [_inst_9 : Nonempty.{succ u4} α] (f : α -> α') (s : Set.{u4} α), Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u3 u2} R (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4)) (Submodule.map.{u1, u1, max u4 u3, max u3 u2, max (max u3 u2) u4} R R (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u3} α M _inst_3) (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u4, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.addCommMonoid.{u4, u3} α M _inst_3) (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u4 u3, max u3 u2} R R (Finsupp.{u4, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u2, u3} α' M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u3} α M _inst_3) (Finsupp.addCommMonoid.{u2, u3} α' M _inst_3) (Finsupp.module.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lmapDomain.{u4, u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 α' f) (Finsupp.supported.{u4, u3, u1} α M R _inst_1 _inst_3 _inst_4 s)) (Finsupp.supported.{u2, u3, u1} α' M R _inst_1 _inst_3 _inst_4 (Set.image.{u4, u2} α α' f s))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_supported Finsupp.lmapDomain_supportedₓ'. -/
theorem lmapDomain_supported [Nonempty α] (f : α → α') (s : Set α) :
    (supported M R s).map (lmapDomain M R f) = supported M R (f '' s) :=
  by
  inhabit α
  refine'
    le_antisymm
      (map_le_iff_le_comap.2 <|
        le_trans (supported_mono <| Set.subset_preimage_image _ _)
          (supported_comap_lmap_domain _ _ _ _))
      _
  intro l hl
  refine' ⟨(lmap_domain M R (Function.invFunOn f s) : (α' →₀ M) →ₗ[R] α →₀ M) l, fun x hx => _, _⟩
  · rcases Finset.mem_image.1 (map_domain_support hx) with ⟨c, hc, rfl⟩
    exact Function.invFunOn_mem (by simpa using hl hc)
  · rw [← LinearMap.comp_apply, ← lmap_domain_comp]
    refine' (map_domain_congr fun c hc => _).trans map_domain_id
    exact Function.invFunOn_eq (by simpa using hl hc)
#align finsupp.lmap_domain_supported Finsupp.lmapDomain_supported

/- warning: finsupp.lmap_domain_disjoint_ker -> Finsupp.lmapDomain_disjoint_ker is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (f : α -> α') {s : Set.{u1} α}, (forall (a : α), (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) a s) -> (forall (b : α), (Membership.Mem.{u1, u1} α (Set.{u1} α) (Set.hasMem.{u1} α) b s) -> (Eq.{succ u4} α' (f a) (f b)) -> (Eq.{succ u1} α a b))) -> (Disjoint.{max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.partialOrder.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Submodule.orderBot.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s) (LinearMap.ker.{u3, u3, max u1 u2, max u4 u2, max (max u1 u2) u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.semilinearMapClass.{u3, u3, max u1 u2, max u4 u2} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.lmapDomain.{u1, u2, u3, u4} α M R _inst_1 _inst_3 _inst_4 α' f)))
but is expected to have type
  forall {α : Type.{u4}} (M : Type.{u2}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α' : Type.{u3}} (f : α -> α') {s : Set.{u4} α}, (forall (a : α), (Membership.mem.{u4, u4} α (Set.{u4} α) (Set.instMembershipSet.{u4} α) a s) -> (forall (b : α), (Membership.mem.{u4, u4} α (Set.{u4} α) (Set.instMembershipSet.{u4} α) b s) -> (Eq.{succ u3} α' (f a) (f b)) -> (Eq.{succ u4} α a b))) -> (Disjoint.{max u2 u4} (Submodule.{u1, max u2 u4} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (OmegaCompletePartialOrder.toPartialOrder.{max u4 u2} (Submodule.{u1, max u2 u4} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (CompleteLattice.instOmegaCompletePartialOrder.{max u4 u2} (Submodule.{u1, max u2 u4} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Submodule.completeLattice.{u1, max u4 u2} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, max u4 u2} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.supported.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4 s) (LinearMap.ker.{u1, u1, max u4 u2, max u2 u3, max (max u2 u3) u4} R R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α' M R _inst_1 _inst_3 _inst_4)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u4 u2, max u2 u3} R R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α' M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.lmapDomain.{u4, u2, u1, u3} α M R _inst_1 _inst_3 _inst_4 α' f)))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_disjoint_ker Finsupp.lmapDomain_disjoint_kerₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a b «expr ∈ » s) -/
theorem lmapDomain_disjoint_ker (f : α → α') {s : Set α}
    (H : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), f a = f b → a = b) :
    Disjoint (supported M R s) (lmapDomain M R f).ker :=
  by
  rw [disjoint_iff_inf_le]
  rintro l ⟨h₁, h₂⟩
  rw [SetLike.mem_coe, mem_ker, lmap_domain_apply, map_domain] at h₂
  simp; ext x
  haveI := Classical.decPred fun x => x ∈ s
  by_cases xs : x ∈ s
  · have : Finsupp.sum l (fun a => Finsupp.single (f a)) (f x) = 0 :=
      by
      rw [h₂]
      rfl
    rw [Finsupp.sum_apply, Finsupp.sum, Finset.sum_eq_single x] at this
    · simpa [Finsupp.single_apply]
    · intro y hy xy
      simp [mt (H _ (h₁ hy) _ xs) xy]
    · simp (config := { contextual := true })
  · by_contra h
    exact xs (h₁ <| Finsupp.mem_support_iff.2 h)
#align finsupp.lmap_domain_disjoint_ker Finsupp.lmapDomain_disjoint_ker

end LmapDomain

section LcomapDomain

variable {β : Type _} {R M}

/- warning: finsupp.lcomap_domain -> Finsupp.lcomapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {β : Type.{u4}} (f : α -> β), (Function.Injective.{succ u1, succ u4} α β f) -> (LinearMap.{u3, u3, max u4 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u4, u2} β M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u4, u2} β M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u4, u2, u3} β M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {β : Type.{u4}} (f : α -> β), (Function.Injective.{succ u1, succ u4} α β f) -> (LinearMap.{u3, u3, max u2 u4, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u4, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} β M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u4, u2, u3} β M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.lcomap_domain Finsupp.lcomapDomainₓ'. -/
/-- Given `f : α → β` and a proof `hf` that `f` is injective, `lcomap_domain f hf` is the linear map
sending  `l : β →₀ M` to the finitely supported function from `α` to `M` given by composing
`l` with `f`.

This is the linear version of `finsupp.comap_domain`. -/
def lcomapDomain (f : α → β) (hf : Function.Injective f) : (β →₀ M) →ₗ[R] α →₀ M
    where
  toFun l := Finsupp.comapDomain f l (hf.InjOn _)
  map_add' x y := by
    ext
    simp
  map_smul' c x := by
    ext
    simp
#align finsupp.lcomap_domain Finsupp.lcomapDomain

end LcomapDomain

section Total

variable (α) {α' : Type _} (M) {M' : Type _} (R) [AddCommMonoid M'] [Module R M'] (v : α → M)
  {v' : α' → M'}

/- warning: finsupp.total -> Finsupp.total is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4)
but is expected to have type
  forall (α : Type.{u1}) (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], (α -> M) -> (LinearMap.{u3, u3, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4)
Case conversion may be inaccurate. Consider using '#align finsupp.total Finsupp.totalₓ'. -/
/-- Interprets (l : α →₀ R) as linear combination of the elements in the family (v : α → M) and
    evaluates this linear combination. -/
protected def total : (α →₀ R) →ₗ[R] M :=
  Finsupp.lsum ℕ fun i => LinearMap.id.smul_right (v i)
#align finsupp.total Finsupp.total

variable {α M v}

/- warning: finsupp.total_apply -> Finsupp.total_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} (l : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) l) (Finsupp.sum.{u1, u3, u2} α R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 l (fun (i : α) (a : R) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) a (v i)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {v : α -> M} (l : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 v) l) (Finsupp.sum.{u3, u2, u1} α R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) _inst_3 l (fun (i : α) (a : R) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_4))))) a (v i)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_apply Finsupp.total_applyₓ'. -/
theorem total_apply (l : α →₀ R) : Finsupp.total α M R v l = l.Sum fun i a => a • v i :=
  rfl
#align finsupp.total_apply Finsupp.total_apply

/- warning: finsupp.total_apply_of_mem_supported -> Finsupp.total_apply_of_mem_supported is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} {l : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))} {s : Finset.{u1} α}, (Membership.Mem.{max u1 u3, max u1 u3} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SetLike.hasMem.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) l (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} α) (Set.{u1} α) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (CoeTCₓ.coe.{succ u1, succ u1} (Finset.{u1} α) (Set.{u1} α) (Finset.Set.hasCoeT.{u1} α))) s))) -> (Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) l) (Finset.sum.{u2, u1} M α _inst_3 s (fun (i : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (_x : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => α -> R) (Finsupp.coeFun.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) l i) (v i))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {v : α -> M} {l : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))} {s : Finset.{u3} α}, (Membership.mem.{max u3 u2, max u2 u3} (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SetLike.instMembership.{max u3 u2, max u3 u2} (Submodule.{u2, max u2 u3} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (Submodule.setLike.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))) l (Finsupp.supported.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) (Finset.toSet.{u3} α s))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 v) l) (Finset.sum.{u1, u3} M α _inst_3 s (fun (i : α) => HSMul.hSMul.{u2, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M M (instHSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M (SMulZeroClass.toSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) i) M _inst_1 _inst_3 _inst_4))))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) _x) (Finsupp.funLike.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) l i) (v i))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_apply_of_mem_supported Finsupp.total_apply_of_mem_supportedₓ'. -/
theorem total_apply_of_mem_supported {l : α →₀ R} {s : Finset α}
    (hs : l ∈ supported R R (↑s : Set α)) : Finsupp.total α M R v l = s.Sum fun i => l i • v i :=
  Finset.sum_subset hs fun x _ hxg =>
    show l x • v x = 0 by rw [not_mem_support_iff.1 hxg, zero_smul]
#align finsupp.total_apply_of_mem_supported Finsupp.total_apply_of_mem_supported

/- warning: finsupp.total_single -> Finsupp.total_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} (c : R) (a : α), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.single.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) a c)) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) c (v a))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u3}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u1, u3} R M _inst_1 _inst_3] {v : α -> M} (c : R) (a : α), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) (Finsupp.single.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) a c)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u1), succ u3} (LinearMap.{u1, u1, max u1 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u1, u3} R R (Finsupp.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u3, u1} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.single.{u2, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) a c)) (HSMul.hSMul.{u1, u3, u3} R M M (instHSMul.{u1, u3} R M (SMulZeroClass.toSMul.{u1, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} R M _inst_1 _inst_3 _inst_4))))) c (v a))
Case conversion may be inaccurate. Consider using '#align finsupp.total_single Finsupp.total_singleₓ'. -/
@[simp]
theorem total_single (c : R) (a : α) : Finsupp.total α M R v (single a c) = c • v a := by
  simp [total_apply, sum_single_index]
#align finsupp.total_single Finsupp.total_single

/- warning: finsupp.total_zero_apply -> Finsupp.total_zero_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (x : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (OfNat.ofNat.{max u1 u2} (α -> M) 0 (OfNat.mk.{max u1 u2} (α -> M) 0 (Zero.zero.{max u1 u2} (α -> M) (Pi.instZero.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))) x) (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) x) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 (OfNat.ofNat.{max u3 u1} (α -> M) 0 (Zero.toOfNat0.{max u3 u1} (α -> M) (Pi.instZero.{u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.6553 : α) => M) (fun (i : α) => AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))) x) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) x) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) x) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) x) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) x) _inst_3))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_zero_apply Finsupp.total_zero_applyₓ'. -/
theorem total_zero_apply (x : α →₀ R) : (Finsupp.total α M R 0) x = 0 := by
  simp [Finsupp.total_apply]
#align finsupp.total_zero_apply Finsupp.total_zero_apply

variable (α M)

/- warning: finsupp.total_zero -> Finsupp.total_zero is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (OfNat.ofNat.{max u1 u2} (α -> M) 0 (OfNat.mk.{max u1 u2} (α -> M) 0 (Zero.zero.{max u1 u2} (α -> M) (Pi.instZero.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))) (OfNat.ofNat.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) 0 (OfNat.mk.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) 0 (Zero.zero.{max (max u1 u3) u2} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.hasZero.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))
but is expected to have type
  forall (α : Type.{u3}) (M : Type.{u2}) (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (max (succ u3) (succ u2)) (succ u1)} (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.total.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 (OfNat.ofNat.{max u3 u2} (α -> M) 0 (Zero.toOfNat0.{max u3 u2} (α -> M) (Pi.instZero.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.6553 : α) => M) (fun (i : α) => AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))) (OfNat.ofNat.{max (max u3 u2) u1} (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_zero Finsupp.total_zeroₓ'. -/
@[simp]
theorem total_zero : Finsupp.total α M R 0 = 0 :=
  LinearMap.ext (total_zero_apply R)
#align finsupp.total_zero Finsupp.total_zero

variable {α M}

/- warning: finsupp.apply_total -> Finsupp.apply_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {M' : Type.{u4}} [_inst_9 : AddCommMonoid.{u4} M'] [_inst_10 : Module.{u3, u4} R M' _inst_1 _inst_9] (f : LinearMap.{u3, u3, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) (v : α -> M) (l : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))), Eq.{succ u4} M' (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u3, u3, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) (fun (_x : LinearMap.{u3, u3, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) => M -> M') (LinearMap.hasCoeToFun.{u3, u3, u2, u4} R R M M' _inst_1 _inst_1 _inst_3 _inst_9 _inst_4 _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) l)) (coeFn.{max (succ (max u1 u3)) (succ u4), max (succ (max u1 u3)) (succ u4)} (LinearMap.{u3, u3, max u1 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u3, u3, max u1 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_10) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u4} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u4, u3} α M' R _inst_1 _inst_9 _inst_10 (Function.comp.{succ u1, succ u2, succ u4} α M M' (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u3, u3, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) (fun (_x : LinearMap.{u3, u3, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) => M -> M') (LinearMap.hasCoeToFun.{u3, u3, u2, u4} R R M M' _inst_1 _inst_1 _inst_3 _inst_9 _inst_4 _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) v)) l)
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} (R : Type.{u4}) {_inst_1 : Type.{u2}} [_inst_3 : Semiring.{u4} R] [_inst_4 : AddCommMonoid.{u2} _inst_1] [M' : AddCommMonoid.{u3} M] [_inst_9 : Module.{u4, u2} R _inst_1 _inst_3 _inst_4] [_inst_10 : Module.{u4, u3} R M _inst_3 M'] (f : LinearMap.{u4, u4, u3, u2} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) M _inst_1 M' _inst_4 _inst_10 _inst_9) (v : α -> M) (l : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => _inst_1) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (succ u1) (succ u4), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) M (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) M' (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_10) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) (fun (a : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => M) a) (LinearMap.instFunLikeLinearMap.{u4, u4, max u1 u4, u3} R R (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) M _inst_3 _inst_3 (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) M' (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_10 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Finsupp.total.{u1, u3, u4} α M R _inst_3 M' _inst_10 v) l)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) M _inst_1 M' _inst_4 _inst_10 _inst_9) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} R R M _inst_1 _inst_3 _inst_3 M' _inst_4 _inst_10 _inst_9 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) f (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (succ u1) (succ u4), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) M (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) M' (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_10) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) (fun (_x : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => M) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u1 u4, u3} R R (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) M _inst_3 _inst_3 (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) M' (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_10 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Finsupp.total.{u1, u3, u4} α M R _inst_3 M' _inst_10 v) l)) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u2), max (succ u1) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u1, u2} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) _inst_4 (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_9) (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) (fun (_x : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) => _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u1 u4, u2} R R (Finsupp.{u1, u4} α R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_3))) _inst_1 _inst_3 _inst_3 (Finsupp.addCommMonoid.{u1, u4} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)))) _inst_4 (Finsupp.module.{u1, u4, u4} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Semiring.toModule.{u4} R _inst_3)) _inst_9 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) (Finsupp.total.{u1, u2, u4} α _inst_1 R _inst_3 _inst_4 _inst_9 (Function.comp.{succ u1, succ u3, succ u2} α M _inst_1 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} R R _inst_3 _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3)) M _inst_1 M' _inst_4 _inst_10 _inst_9) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => _inst_1) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} R R M _inst_1 _inst_3 _inst_3 M' _inst_4 _inst_10 _inst_9 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_3))) f) v)) l)
Case conversion may be inaccurate. Consider using '#align finsupp.apply_total Finsupp.apply_totalₓ'. -/
theorem apply_total (f : M →ₗ[R] M') (v) (l : α →₀ R) :
    f (Finsupp.total α M R v l) = Finsupp.total α M' R (f ∘ v) l := by
  apply Finsupp.induction_linear l <;> simp (config := { contextual := true })
#align finsupp.apply_total Finsupp.apply_total

/- warning: finsupp.total_unique -> Finsupp.total_unique is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_11 : Unique.{succ u1} α] (l : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (v : α -> M), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) l) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (_x : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => α -> R) (Finsupp.coeFun.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) l (Inhabited.default.{succ u1} α (Unique.inhabited.{succ u1} α _inst_11))) (v (Inhabited.default.{succ u1} α (Unique.inhabited.{succ u1} α _inst_11))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] [_inst_11 : Unique.{succ u3} α] (l : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (v : α -> M), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 v) l) (HSMul.hSMul.{u2, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M M (instHSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M (SMulZeroClass.toSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) M _inst_1 _inst_3 _inst_4))))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => R) _x) (Finsupp.funLike.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) l (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))) (v (Inhabited.default.{succ u3} α (Unique.instInhabited.{succ u3} α _inst_11))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_unique Finsupp.total_uniqueₓ'. -/
theorem total_unique [Unique α] (l : α →₀ R) (v) :
    Finsupp.total α M R v l = l default • v default := by rw [← total_single, ← unique_single l]
#align finsupp.total_unique Finsupp.total_unique

/- warning: finsupp.total_surjective -> Finsupp.total_surjective is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M}, (Function.Surjective.{succ u1, succ u2} α M v) -> (Function.Surjective.{max (succ u1) (succ u3), succ u2} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {v : α -> M}, (Function.Surjective.{succ u3, succ u2} α M v) -> (Function.Surjective.{max (succ u3) (succ u1), succ u2} (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), succ u2} (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 v)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_surjective Finsupp.total_surjectiveₓ'. -/
theorem total_surjective (h : Function.Surjective v) :
    Function.Surjective (Finsupp.total α M R v) :=
  by
  intro x
  obtain ⟨y, hy⟩ := h x
  exact ⟨Finsupp.single y 1, by simp [hy]⟩
#align finsupp.total_surjective Finsupp.total_surjective

/- warning: finsupp.total_range -> Finsupp.total_range is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M}, (Function.Surjective.{succ u1, succ u2} α M v) -> (Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (LinearMap.range.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v)) (Top.top.{u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.hasTop.{u3, u2} R M _inst_1 _inst_3 _inst_4)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {v : α -> M}, (Function.Surjective.{succ u3, succ u2} α M v) -> (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (LinearMap.range.{u1, u1, max u3 u1, u2, max (max u3 u2) u1} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.total.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 v)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_range Finsupp.total_rangeₓ'. -/
theorem total_range (h : Function.Surjective v) : (Finsupp.total α M R v).range = ⊤ :=
  range_eq_top.2 <| total_surjective R h
#align finsupp.total_range Finsupp.total_range

/- warning: finsupp.total_id_surjective -> Finsupp.total_id_surjective is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) [_inst_11 : AddCommMonoid.{u2} M] [_inst_12 : Module.{u1, u2} R M _inst_1 _inst_11], Function.Surjective.{max (succ u2) (succ u1), succ u2} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (coeFn.{max (succ (max u2 u1)) (succ u2), max (succ (max u2 u1)) (succ u2)} (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_11 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_12) (fun (_x : LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_11 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_12) => (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_11 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_11 _inst_12 (id.{succ u2} M)))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] (M : Type.{u2}) [_inst_11 : AddCommMonoid.{u2} M] [_inst_12 : Module.{u1, u2} R M _inst_1 _inst_11], Function.Surjective.{max (succ u1) (succ u2), succ u2} (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_11 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_12) (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, u2} R R (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} M R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_11 (Finsupp.module.{u2, u1, u1} M R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} M M R _inst_1 _inst_11 _inst_12 (id.{succ u2} M)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_id_surjective Finsupp.total_id_surjectiveₓ'. -/
/-- Any module is a quotient of a free module. This is stated as surjectivity of
`finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. -/
theorem total_id_surjective (M) [AddCommMonoid M] [Module R M] :
    Function.Surjective (Finsupp.total M M R id) :=
  total_surjective R Function.surjective_id
#align finsupp.total_id_surjective Finsupp.total_id_surjective

/- warning: finsupp.range_total -> Finsupp.range_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M}, Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (LinearMap.range.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.range.{u2, succ u1} M α v))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_1 _inst_3] {v : α -> M}, Eq.{succ u3} (Submodule.{u2, u3} R M _inst_1 _inst_3 _inst_4) (LinearMap.range.{u2, u2, max u1 u2, u3, max (max u1 u3) u2} R R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, max u2 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, max u1 u2, u3} R R (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (RingHomSurjective.ids.{u2} R _inst_1) (Finsupp.total.{u1, u3, u2} α M R _inst_1 _inst_3 _inst_4 v)) (Submodule.span.{u2, u3} R M _inst_1 _inst_3 _inst_4 (Set.range.{u3, succ u1} M α v))
Case conversion may be inaccurate. Consider using '#align finsupp.range_total Finsupp.range_totalₓ'. -/
theorem range_total : (Finsupp.total α M R v).range = span R (range v) :=
  by
  ext x
  constructor
  · intro hx
    rw [LinearMap.mem_range] at hx
    rcases hx with ⟨l, hl⟩
    rw [← hl]
    rw [Finsupp.total_apply]
    exact sum_mem fun i hi => Submodule.smul_mem _ _ (subset_span (mem_range_self i))
  · apply span_le.2
    intro x hx
    rcases hx with ⟨i, hi⟩
    rw [SetLike.mem_coe, LinearMap.mem_range]
    use Finsupp.single i 1
    simp [hi]
#align finsupp.range_total Finsupp.range_total

/- warning: finsupp.lmap_domain_total -> Finsupp.lmapDomain_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} {M' : Type.{u5}} [_inst_9 : AddCommMonoid.{u5} M'] [_inst_10 : Module.{u3, u5} R M' _inst_1 _inst_9] {v : α -> M} {v' : α' -> M'} (f : α -> α') (g : LinearMap.{u3, u3, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10), (forall (i : α), Eq.{succ u5} M' (coeFn.{max (succ u2) (succ u5), max (succ u2) (succ u5)} (LinearMap.{u3, u3, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) (fun (_x : LinearMap.{u3, u3, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M' _inst_3 _inst_9 _inst_4 _inst_10) => M -> M') (LinearMap.hasCoeToFun.{u3, u3, u2, u5} R R M M' _inst_1 _inst_1 _inst_3 _inst_9 _inst_4 _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) g (v i)) (v' (f i))) -> (Eq.{max (succ (max u1 u3)) (succ u5)} (LinearMap.{u3, u3, max u1 u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) M' (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_10) (LinearMap.comp.{u3, u3, u3, max u1 u3, max u4 u3, u5} R R R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M' _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.addCommMonoid.{u4, u3} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.module.{u4, u3, u3} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u4, u5, u3} α' M' R _inst_1 _inst_9 _inst_10 v') (Finsupp.lmapDomain.{u1, u3, u3, u4} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) α' f)) (LinearMap.comp.{u3, u3, u3, max u1 u3, u2, u5} R R R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) M M' _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 _inst_9 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) g (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u4}} (R : Type.{u5}) {_inst_1 : Type.{u1}} {_inst_3 : Type.{u3}} [_inst_4 : Semiring.{u5} R] [α' : AddCommMonoid.{u3} _inst_3] [M' : AddCommMonoid.{u4} M] [_inst_9 : Module.{u5, u3} R _inst_3 _inst_4 α'] [_inst_10 : Module.{u5, u4} R M _inst_4 M'] {v : α -> M} {v' : _inst_1 -> _inst_3} (f : α -> _inst_1) (g : LinearMap.{u5, u5, u4, u3} R R _inst_4 _inst_4 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) M _inst_3 M' α' _inst_10 _inst_9), (forall (i : α), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => _inst_3) (v i)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} R R _inst_4 _inst_4 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) M _inst_3 M' α' _inst_10 _inst_9) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => _inst_3) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} R R M _inst_3 _inst_4 _inst_4 M' α' _inst_10 _inst_9 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) g (v i)) (v' (f i))) -> (Eq.{max (max (succ u2) (succ u5)) (succ u3)} (LinearMap.{u5, u5, max u5 u2, u3} R R _inst_4 _inst_4 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (Finsupp.{u2, u5} α R (AddMonoid.toZero.{u5} R (AddCommMonoid.toAddMonoid.{u5} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))))) _inst_3 (Finsupp.addCommMonoid.{u2, u5} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))) α' (Finsupp.module.{u2, u5, u5} α R R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Semiring.toModule.{u5} R _inst_4)) _inst_9) (LinearMap.comp.{u5, u5, u5, max u5 u2, max u5 u1, u3} R R R (Finsupp.{u2, u5} α R (AddMonoid.toZero.{u5} R (AddCommMonoid.toAddMonoid.{u5} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))))) (Finsupp.{u1, u5} _inst_1 R (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_4))) _inst_3 _inst_4 _inst_4 _inst_4 (Finsupp.addCommMonoid.{u2, u5} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))) (Finsupp.addCommMonoid.{u1, u5} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))) α' (Finsupp.module.{u2, u5, u5} α R R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Semiring.toModule.{u5} R _inst_4)) (Finsupp.module.{u1, u5, u5} _inst_1 R R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Semiring.toModule.{u5} R _inst_4)) _inst_9 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHomCompTriple.ids.{u5, u5} R R _inst_4 _inst_4 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Finsupp.total.{u1, u3, u5} _inst_1 _inst_3 R _inst_4 α' _inst_9 v') (Finsupp.lmapDomain.{u2, u5, u5, u1} α R R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Semiring.toModule.{u5} R _inst_4) _inst_1 f)) (LinearMap.comp.{u5, u5, u5, max u2 u5, u4, u3} R R R (Finsupp.{u2, u5} α R (MonoidWithZero.toZero.{u5} R (Semiring.toMonoidWithZero.{u5} R _inst_4))) M _inst_3 _inst_4 _inst_4 _inst_4 (Finsupp.addCommMonoid.{u2, u5} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)))) M' α' (Finsupp.module.{u2, u5, u5} α R R _inst_4 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u5} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) (Semiring.toModule.{u5} R _inst_4)) _inst_10 _inst_9 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4)) (RingHomCompTriple.ids.{u5, u5} R R _inst_4 _inst_4 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_4))) g (Finsupp.total.{u2, u4, u5} α M R _inst_4 M' _inst_10 v)))
Case conversion may be inaccurate. Consider using '#align finsupp.lmap_domain_total Finsupp.lmapDomain_totalₓ'. -/
theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by
  ext l <;> simp [total_apply, Finsupp.sum_mapDomain_index, add_smul, h]
#align finsupp.lmap_domain_total Finsupp.lmapDomain_total

/- warning: finsupp.total_comp_lmap_domain -> Finsupp.total_comp_lmapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {α' : Type.{u3}} {M' : Type.{u4}} [_inst_9 : AddCommMonoid.{u4} M'] [_inst_10 : Module.{u2, u4} R M' _inst_1 _inst_9] {v' : α' -> M'} (f : α -> α'), Eq.{max (succ (max u1 u2)) (succ u4)} (LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (LinearMap.comp.{u2, u2, u2, max u1 u2, max u3 u2, u4} R R R (Finsupp.{u1, u2} α R (AddZeroClass.toHasZero.{u2} R (AddMonoid.toAddZeroClass.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.right_ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u4, u2} α' M' R _inst_1 _inst_9 _inst_10 v') (Finsupp.lmapDomain.{u1, u2, u2, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1) α' f)) (Finsupp.total.{u1, u4, u2} α M' R _inst_1 _inst_9 _inst_10 (Function.comp.{succ u1, succ u3, succ u4} α α' M' v' f))
but is expected to have type
  forall {α : Type.{u4}} (R : Type.{u3}) {_inst_1 : Type.{u1}} {α' : Type.{u2}} [M' : Semiring.{u3} R] [_inst_9 : AddCommMonoid.{u2} α'] [_inst_10 : Module.{u3, u2} R α' M' _inst_9] {v' : _inst_1 -> α'} (f : α -> _inst_1), Eq.{max (max (succ u4) (succ u3)) (succ u2)} (LinearMap.{u3, u3, max u3 u4, u2} R R M' M' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (Finsupp.{u4, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))))) α' (Finsupp.addCommMonoid.{u4, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u4, u3, u3} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10) (LinearMap.comp.{u3, u3, u3, max u3 u4, max u3 u1, u2} R R R (Finsupp.{u4, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))))) (Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) α' M' M' M' (Finsupp.addCommMonoid.{u4, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) (Finsupp.addCommMonoid.{u1, u3} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u4, u3, u3} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) (Finsupp.module.{u1, u3, u3} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (RingHomCompTriple.ids.{u3, u3} R R M' M' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Finsupp.total.{u1, u2, u3} _inst_1 α' R M' _inst_9 _inst_10 v') (Finsupp.lmapDomain.{u4, u3, u3, u1} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M') _inst_1 f)) (Finsupp.total.{u4, u2, u3} α α' R M' _inst_9 _inst_10 (Function.comp.{succ u4, succ u1, succ u2} α _inst_1 α' v' f))
Case conversion may be inaccurate. Consider using '#align finsupp.total_comp_lmap_domain Finsupp.total_comp_lmapDomainₓ'. -/
theorem total_comp_lmapDomain (f : α → α') :
    (Finsupp.total α' M' R v').comp (Finsupp.lmapDomain R R f) = Finsupp.total α M' R (v' ∘ f) :=
  by
  ext
  simp
#align finsupp.total_comp_lmap_domain Finsupp.total_comp_lmapDomain

/- warning: finsupp.total_emb_domain -> Finsupp.total_embDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {α' : Type.{u3}} {M' : Type.{u4}} [_inst_9 : AddCommMonoid.{u4} M'] [_inst_10 : Module.{u2, u4} R M' _inst_1 _inst_9] {v' : α' -> M'} (f : Function.Embedding.{succ u1, succ u3} α α') (l : Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), Eq.{succ u4} M' (coeFn.{max (succ (max u3 u2)) (succ u4), max (succ (max u3 u2)) (succ u4)} (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u4} R R (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u4, u2} α' M' R _inst_1 _inst_9 _inst_10 v') (Finsupp.embDomain.{u1, u3, u2} α α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) f l)) (coeFn.{max (succ (max u1 u2)) (succ u4), max (succ (max u1 u2)) (succ u4)} (LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u4} R R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u4, u2} α M' R _inst_1 _inst_9 _inst_10 (Function.comp.{succ u1, succ u3, succ u4} α α' M' v' (coeFn.{max 1 (succ u1) (succ u3), max (succ u1) (succ u3)} (Function.Embedding.{succ u1, succ u3} α α') (fun (_x : Function.Embedding.{succ u1, succ u3} α α') => α -> α') (Function.Embedding.hasCoeToFun.{succ u1, succ u3} α α') f))) l)
but is expected to have type
  forall {α : Type.{u4}} (R : Type.{u2}) {_inst_1 : Type.{u3}} {α' : Type.{u1}} [M' : Semiring.{u2} R] [_inst_9 : AddCommMonoid.{u1} α'] [_inst_10 : Module.{u2, u1} R α' M' _inst_9] {v' : _inst_1 -> α'} (f : Function.Embedding.{succ u4, succ u3} α _inst_1) (l : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') (Finsupp.embDomain.{u4, u3, u2} α _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M')) f l)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R M' M' (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')) (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' (Finsupp.addCommMonoid.{u3, u2} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u3, u2, u2} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10) (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) (fun (_x : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' M' M' (Finsupp.addCommMonoid.{u3, u2} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u3, u2, u2} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Finsupp.total.{u3, u1, u2} _inst_1 α' R M' _inst_9 _inst_10 v') (Finsupp.embDomain.{u4, u3, u2} α _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M')) f l)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u1), max (succ u4) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u4, u1} R R M' M' (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u4, u2, u2} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) (fun (_x : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u1} R R (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' M' M' (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u4, u2, u2} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Finsupp.total.{u4, u1, u2} α α' R M' _inst_9 _inst_10 (Function.comp.{succ u4, succ u3, succ u1} α _inst_1 α' v' (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Function.Embedding.{succ u4, succ u3} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : α) => _inst_1) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u3), succ u4, succ u3} (Function.Embedding.{succ u4, succ u3} α _inst_1) α _inst_1 (Function.instEmbeddingLikeEmbedding.{succ u4, succ u3} α _inst_1)) f))) l)
Case conversion may be inaccurate. Consider using '#align finsupp.total_emb_domain Finsupp.total_embDomainₓ'. -/
@[simp]
theorem total_embDomain (f : α ↪ α') (l : α →₀ R) :
    (Finsupp.total α' M' R v') (embDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l := by
  simp [total_apply, Finsupp.sum, support_emb_domain, emb_domain_apply]
#align finsupp.total_emb_domain Finsupp.total_embDomain

/- warning: finsupp.total_map_domain -> Finsupp.total_mapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {α' : Type.{u3}} {M' : Type.{u4}} [_inst_9 : AddCommMonoid.{u4} M'] [_inst_10 : Module.{u2, u4} R M' _inst_1 _inst_9] {v' : α' -> M'} (f : α -> α') (l : Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), Eq.{succ u4} M' (coeFn.{max (succ (max u3 u2)) (succ u4), max (succ (max u3 u2)) (succ u4)} (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u4} R R (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u4, u2} α' M' R _inst_1 _inst_9 _inst_10 v') (Finsupp.mapDomain.{u1, u3, u2} α α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f l)) (coeFn.{max (succ (max u1 u2)) (succ u4), max (succ (max u1 u2)) (succ u4)} (LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u4} R R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u4, u2} α M' R _inst_1 _inst_9 _inst_10 (Function.comp.{succ u1, succ u3, succ u4} α α' M' v' f)) l)
but is expected to have type
  forall {α : Type.{u4}} (R : Type.{u3}) {_inst_1 : Type.{u1}} {α' : Type.{u2}} [M' : Semiring.{u3} R] [_inst_9 : AddCommMonoid.{u2} α'] [_inst_10 : Module.{u3, u2} R α' M' _inst_9] {v' : _inst_1 -> α'} (f : α -> _inst_1) (l : Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) => α') (Finsupp.mapDomain.{u4, u1, u3} α _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) f l)) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u1), succ u2} (LinearMap.{u3, u3, max u3 u1, u2} R R M' M' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) α' (Finsupp.addCommMonoid.{u1, u3} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u1, u3, u3} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10) (Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) (fun (_x : Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u3 u1, u2} R R (Finsupp.{u1, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) α' M' M' (Finsupp.addCommMonoid.{u1, u3} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u1, u3, u3} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Finsupp.total.{u1, u2, u3} _inst_1 α' R M' _inst_9 _inst_10 v') (Finsupp.mapDomain.{u4, u1, u3} α _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) f l)) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} R R M' M' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')) (Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) α' (Finsupp.addCommMonoid.{u4, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u4, u3, u3} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10) (Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) (fun (_x : Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} R R (Finsupp.{u4, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R M'))) α' M' M' (Finsupp.addCommMonoid.{u4, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M')))) _inst_9 (Finsupp.module.{u4, u3, u3} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Semiring.toModule.{u3} R M')) _inst_10 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R M'))) (Finsupp.total.{u4, u2, u3} α α' R M' _inst_9 _inst_10 (Function.comp.{succ u4, succ u1, succ u2} α _inst_1 α' v' f)) l)
Case conversion may be inaccurate. Consider using '#align finsupp.total_map_domain Finsupp.total_mapDomainₓ'. -/
@[simp]
theorem total_mapDomain (f : α → α') (l : α →₀ R) :
    (Finsupp.total α' M' R v') (mapDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l :=
  LinearMap.congr_fun (total_comp_lmapDomain _ _) l
#align finsupp.total_map_domain Finsupp.total_mapDomain

/- warning: finsupp.total_equiv_map_domain -> Finsupp.total_equivMapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {α' : Type.{u3}} {M' : Type.{u4}} [_inst_9 : AddCommMonoid.{u4} M'] [_inst_10 : Module.{u2, u4} R M' _inst_1 _inst_9] {v' : α' -> M'} (f : Equiv.{succ u1, succ u3} α α') (l : Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), Eq.{succ u4} M' (coeFn.{max (succ (max u3 u2)) (succ u4), max (succ (max u3 u2)) (succ u4)} (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u4} R R (Finsupp.{u3, u2} α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u3, u2, u2} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u4, u2} α' M' R _inst_1 _inst_9 _inst_10 v') (Finsupp.equivMapDomain.{u1, u3, u2} α α' R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) f l)) (coeFn.{max (succ (max u1 u2)) (succ u4), max (succ (max u1 u2)) (succ u4)} (LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) (fun (_x : LinearMap.{u2, u2, max u1 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10) => (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M') (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u4} R R (Finsupp.{u1, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M' _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_9 (Finsupp.module.{u1, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u4, u2} α M' R _inst_1 _inst_9 _inst_10 (Function.comp.{succ u1, succ u3, succ u4} α α' M' v' (coeFn.{max 1 (max (succ u1) (succ u3)) (succ u3) (succ u1), max (succ u1) (succ u3)} (Equiv.{succ u1, succ u3} α α') (fun (_x : Equiv.{succ u1, succ u3} α α') => α -> α') (Equiv.hasCoeToFun.{succ u1, succ u3} α α') f))) l)
but is expected to have type
  forall {α : Type.{u4}} (R : Type.{u2}) {_inst_1 : Type.{u3}} {α' : Type.{u1}} [M' : Semiring.{u2} R] [_inst_9 : AddCommMonoid.{u1} α'] [_inst_10 : Module.{u2, u1} R α' M' _inst_9] {v' : _inst_1 -> α'} (f : Equiv.{succ u4, succ u3} α _inst_1) (l : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') (Finsupp.equivMapDomain.{u4, u3, u2} α _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M')) f l)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u3), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R M' M' (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')) (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' (Finsupp.addCommMonoid.{u3, u2} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u3, u2, u2} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10) (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) (fun (_x : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' M' M' (Finsupp.addCommMonoid.{u3, u2} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u3, u2, u2} _inst_1 R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Finsupp.total.{u3, u1, u2} _inst_1 α' R M' _inst_9 _inst_10 v') (Finsupp.equivMapDomain.{u4, u3, u2} α _inst_1 R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M')) f l)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u1), max (succ u4) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u4, u1} R R M' M' (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u4, u2, u2} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) (fun (_x : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) => α') _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u1} R R (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R M'))) α' M' M' (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M')))) _inst_9 (Finsupp.module.{u4, u2, u2} α R R M' (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Semiring.toModule.{u2} R M')) _inst_10 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R M'))) (Finsupp.total.{u4, u1, u2} α α' R M' _inst_9 _inst_10 (Function.comp.{succ u4, succ u3, succ u1} α _inst_1 α' v' (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} α _inst_1) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α) => _inst_1) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} α _inst_1) f))) l)
Case conversion may be inaccurate. Consider using '#align finsupp.total_equiv_map_domain Finsupp.total_equivMapDomainₓ'. -/
@[simp]
theorem total_equivMapDomain (f : α ≃ α') (l : α →₀ R) :
    (Finsupp.total α' M' R v') (equivMapDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l := by
  rw [equiv_map_domain_eq_map_domain, total_map_domain]
#align finsupp.total_equiv_map_domain Finsupp.total_equivMapDomain

/- warning: finsupp.span_eq_range_total -> Finsupp.span_eq_range_total is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (s : Set.{u1} M), Eq.{succ u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (Submodule.span.{u2, u1} R M _inst_1 _inst_3 _inst_4 s) (LinearMap.range.{u2, u2, max u1 u2, u1, max u1 u2} R R (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, max u1 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.semilinearMapClass.{u2, u2, max u1 u2, u1} R R (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (RingHomSurjective.ids.{u2} R _inst_1) (Finsupp.total.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M R _inst_1 _inst_3 _inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u1} M (Set.{u1} M) (Set.hasMem.{u1} M) x s))))))))
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u2} M), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 s) (LinearMap.range.{u1, u1, max u2 u1, u2, max u2 u1} R R (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.total.{u2, u2, u1} (Set.Elem.{u2} M s) M R _inst_1 _inst_3 _inst_4 (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s))))
Case conversion may be inaccurate. Consider using '#align finsupp.span_eq_range_total Finsupp.span_eq_range_totalₓ'. -/
/-- A version of `finsupp.range_total` which is useful for going in the other direction -/
theorem span_eq_range_total (s : Set M) : span R s = (Finsupp.total s M R coe).range := by
  rw [range_total, Subtype.range_coe_subtype, Set.setOf_mem_eq]
#align finsupp.span_eq_range_total Finsupp.span_eq_range_total

/- warning: finsupp.mem_span_iff_total -> Finsupp.mem_span_iff_total is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (s : Set.{u1} M) (x : M), Iff (Membership.Mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u2, u1} R M _inst_1 _inst_3 _inst_4 s)) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (fun (l : Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) => Eq.{succ u1} M (coeFn.{max (succ (max u1 u2)) (succ u1), max (succ (max u1 u2)) (succ u1)} (LinearMap.{u2, u2, max u1 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u1 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, u1} R R (Finsupp.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u2, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u1, u1, u2} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M R _inst_1 _inst_3 _inst_4 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (HasLiftT.mk.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (CoeTCₓ.coe.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (coeBase.{succ u1, succ u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} M) Type.{u1} (Set.hasCoeToSort.{u1} M) s) M (coeSubtype.{succ u1} M (fun (x : M) => Membership.Mem.{u1, u1} M (Set.{u1} M) (Set.hasMem.{u1} M) x s))))))) l) x))
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (s : Set.{u2} M) (x : M), Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 s)) (Exists.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (l : Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u2} (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} (Set.Elem.{u2} M s) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M s) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M s) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} (Set.Elem.{u2} M s) M R _inst_1 _inst_3 _inst_4 (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x s))) l) x))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_span_iff_total Finsupp.mem_span_iff_totalₓ'. -/
theorem mem_span_iff_total (s : Set M) (x : M) :
    x ∈ span R s ↔ ∃ l : s →₀ R, Finsupp.total s M R coe l = x :=
  (SetLike.ext_iff.1 <| span_eq_range_total _ _) x
#align finsupp.mem_span_iff_total Finsupp.mem_span_iff_total

variable {R}

/- warning: finsupp.mem_span_range_iff_exists_finsupp -> Finsupp.mem_span_range_iff_exists_finsupp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.range.{u2, succ u1} M α v))) (Exists.{max (succ u1) (succ u3)} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (c : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => Eq.{succ u2} M (Finsupp.sum.{u1, u3, u2} α R M (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 c (fun (i : α) (a : R) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) a (v i))) x))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_1 _inst_3] {v : α -> M} {x : M}, Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u2, u3} R M _inst_1 _inst_3 _inst_4 (Set.range.{u3, succ u1} M α v))) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (c : Finsupp.{u1, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => Eq.{succ u3} M (Finsupp.sum.{u1, u2, u3} α R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) _inst_3 c (fun (i : α) (a : R) => HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_1 _inst_3 _inst_4))))) a (v i))) x))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_span_range_iff_exists_finsupp Finsupp.mem_span_range_iff_exists_finsuppₓ'. -/
theorem mem_span_range_iff_exists_finsupp {v : α → M} {x : M} :
    x ∈ span R (range v) ↔ ∃ c : α →₀ R, (c.Sum fun i a => a • v i) = x := by
  simp only [← Finsupp.range_total, LinearMap.mem_range, Finsupp.total_apply]
#align finsupp.mem_span_range_iff_exists_finsupp Finsupp.mem_span_range_iff_exists_finsupp

variable (R)

/- warning: finsupp.span_image_eq_map_total -> Finsupp.span_image_eq_map_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} (s : Set.{u1} α), Eq.{succ u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)) (Submodule.map.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomSurjective.ids.{u3} R _inst_1) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {v : α -> M} (s : Set.{u3} α), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)) (Submodule.map.{u1, u1, max u1 u3, u2, max (max u3 u2) u1} R R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))
Case conversion may be inaccurate. Consider using '#align finsupp.span_image_eq_map_total Finsupp.span_image_eq_map_totalₓ'. -/
theorem span_image_eq_map_total (s : Set α) :
    span R (v '' s) = Submodule.map (Finsupp.total α M R v) (supported R R s) :=
  by
  apply span_eq_of_le
  · intro x hx
    rw [Set.mem_image] at hx
    apply Exists.elim hx
    intro i hi
    exact ⟨_, Finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]⟩
  · refine' map_le_iff_le_comap.2 fun z hz => _
    have : ∀ i, z i • v i ∈ span R (v '' s) := by
      intro c
      haveI := Classical.decPred fun x => x ∈ s
      by_cases c ∈ s
      · exact smul_mem _ _ (subset_span (Set.mem_image_of_mem _ h))
      · simp [(Finsupp.mem_supported' R _).1 hz _ h]
    refine' sum_mem _
    simp [this]
#align finsupp.span_image_eq_map_total Finsupp.span_image_eq_map_total

/- warning: finsupp.mem_span_image_iff_total -> Finsupp.mem_span_image_iff_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} {s : Set.{u1} α} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Exists.{succ (max u1 u3)} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (l : Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => Exists.{0} (Membership.Mem.{max u1 u3, max u1 u3} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SetLike.hasMem.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) l (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (fun (H : Membership.Mem.{max u1 u3, max u1 u3} (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SetLike.hasMem.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) l (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) => Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) l) x)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {v : α -> M} {s : Set.{u3} α} {x : M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Exists.{succ (max u3 u1)} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (l : Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => And (Membership.mem.{max u3 u1, max u1 u3} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.setLike.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) l (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) l) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), succ u2} (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (a : Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) a) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 v) l) x)))
Case conversion may be inaccurate. Consider using '#align finsupp.mem_span_image_iff_total Finsupp.mem_span_image_iff_totalₓ'. -/
theorem mem_span_image_iff_total {s : Set α} {x : M} :
    x ∈ span R (v '' s) ↔ ∃ l ∈ supported R R s, Finsupp.total α M R v l = x :=
  by
  rw [span_image_eq_map_total]
  simp
#align finsupp.mem_span_image_iff_total Finsupp.mem_span_image_iff_total

/- warning: finsupp.total_option -> Finsupp.total_option is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (v : (Option.{u1} α) -> M) (f : Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} (Option.{u1} α) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} (Option.{u1} α) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} (Option.{u1} α) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} (Option.{u1} α) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} (Option.{u1} α) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} (Option.{u1} α) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} (Option.{u1} α) M R _inst_1 _inst_3 _inst_4 v) f) (HAdd.hAdd.{u2, u2, u2} M M M (instHAdd.{u2} M (AddZeroClass.toHasAdd.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (_x : Finsupp.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => (Option.{u1} α) -> R) (Finsupp.coeFun.{u1, u3} (Option.{u1} α) R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) f (Option.none.{u1} α)) (v (Option.none.{u1} α))) (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 (Function.comp.{succ u1, succ u1, succ u2} α (Option.{u1} α) M v (Option.some.{u1} α))) (Finsupp.some.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) f)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (v : (Option.{u3} α) -> M) (f : Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) f) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} (Option.{u3} α) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} (Option.{u3} α) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} (Option.{u3} α) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} (Option.{u3} α) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} (Option.{u3} α) M R _inst_1 _inst_3 _inst_4 v) f) (HAdd.hAdd.{u1, u1, u1} M ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) (Finsupp.some.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) f)) M (instHAdd.{u1} M (AddZeroClass.toAdd.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (HSMul.hSMul.{u2, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M M (instHSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M (SMulZeroClass.toSMul.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) (Option.none.{u3} α)) M _inst_1 _inst_3 _inst_4))))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Option.{u3} α) (fun (_x : Option.{u3} α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Option.{u3} α) => R) _x) (Finsupp.funLike.{u3, u2} (Option.{u3} α) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) f (Option.none.{u3} α)) (v (Option.none.{u3} α))) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 (Function.comp.{succ u3, succ u3, succ u1} α (Option.{u3} α) M v (Option.some.{u3} α))) (Finsupp.some.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) f)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_option Finsupp.total_optionₓ'. -/
theorem total_option (v : Option α → M) (f : Option α →₀ R) :
    Finsupp.total (Option α) M R v f =
      f none • v none + Finsupp.total α M R (v ∘ Option.some) f.some :=
  by rw [total_apply, sum_option_index_smul, total_apply]
#align finsupp.total_option Finsupp.total_option

/- warning: finsupp.total_total -> Finsupp.total_total is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}} (A : α -> M) (B : β -> (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (f : Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))), Eq.{succ u1} M (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ (max u3 u2)) (succ u1)} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 A) (coeFn.{max (succ (max u4 u2)) (succ (max u3 u2)), max (succ (max u4 u2)) (succ (max u3 u2))} (LinearMap.{u2, u2, max u4 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (fun (_x : LinearMap.{u2, u2, max u4 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) => (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (LinearMap.hasCoeToFun.{u2, u2, max u4 u2, max u3 u2} R R (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u4, max u3 u2, u2} β (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) R _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) B) f)) (coeFn.{max (succ (max u4 u2)) (succ u1), max (succ (max u4 u2)) (succ u1)} (LinearMap.{u2, u2, max u4 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u4 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u4 u2, u1} R R (Finsupp.{u4, u2} β R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4 (fun (b : β) => coeFn.{max (succ (max u3 u2)) (succ u1), max (succ (max u3 u2)) (succ u1)} (LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u2, u2, max u3 u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) => (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 A) (B b))) f)
but is expected to have type
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u4}} {β : Type.{u3}} (A : α -> M) (B : β -> (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))) (f : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u4)} (LinearMap.{u2, u2, max u2 u3, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (a : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) a) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, max u2 u4} R R (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, max u2 u4, u2} β (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) R _inst_1 (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) B) f)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u4), max (succ u2) (succ u4), succ u1} (LinearMap.{u2, u2, max u2 u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u4, u1} R R (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u4, u1, u2} α M R _inst_1 _inst_3 _inst_4 A) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u2) (succ u3), max (succ u2) (succ u4)} (LinearMap.{u2, u2, max u2 u3, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, max u2 u4} R R (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, max u2 u4, u2} β (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) R _inst_1 (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) B) f)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (Finsupp.{u3, u2} β R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} β R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} β R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} β M R _inst_1 _inst_3 _inst_4 (fun (b : β) => FunLike.coe.{max (max (succ u1) (succ u2)) (succ u4), max (succ u2) (succ u4), succ u1} (LinearMap.{u2, u2, max u2 u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u4, u1} R R (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u4, u1, u2} α M R _inst_1 _inst_3 _inst_4 A) (B b))) f)
Case conversion may be inaccurate. Consider using '#align finsupp.total_total Finsupp.total_totalₓ'. -/
theorem total_total {α β : Type _} (A : α → M) (B : β → α →₀ R) (f : β →₀ R) :
    Finsupp.total α M R A (Finsupp.total β (α →₀ R) R B f) =
      Finsupp.total β M R (fun b => Finsupp.total α M R A (B b)) f :=
  by
  simp only [total_apply]
  apply induction_linear f
  · simp only [sum_zero_index]
  · intro f₁ f₂ h₁ h₂
    simp [sum_add_index, h₁, h₂, add_smul]
  · simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
#align finsupp.total_total Finsupp.total_total

/- warning: finsupp.total_fin_zero -> Finsupp.total_fin_zero is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] (f : (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> M), Eq.{max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{0, u2} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{0, u2} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{0, u2, u2} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.total.{0, u1, u2} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) M R _inst_1 _inst_3 _inst_4 f) (OfNat.ofNat.{max u2 u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{0, u2, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) 0 (OfNat.mk.{max u2 u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{0, u2, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) 0 (Zero.zero.{max u2 u1} (LinearMap.{u2, u2, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M (Finsupp.addCommMonoid.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{0, u2, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (LinearMap.hasZero.{u2, u2, u2, u1} R R (Finsupp.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (MulZeroClass.toHasZero.{u2} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{0, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{0, u2, u2} (Fin (Zero.zero.{0} Nat Nat.hasZero)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))))
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] (f : (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> M), Eq.{max (succ u2) (succ u1)} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{0, u1, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (Finsupp.total.{0, u2, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) M R _inst_1 _inst_3 _inst_4 f) (OfNat.ofNat.{max u2 u1} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{0, u1, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) 0 (Zero.toOfNat0.{max u2 u1} (LinearMap.{u1, u1, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{0, u1, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4) (LinearMap.instZeroLinearMap.{u1, u1, u1, u2} R R (Finsupp.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{0, u1, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_fin_zero Finsupp.total_fin_zeroₓ'. -/
@[simp]
theorem total_fin_zero (f : Fin 0 → M) : Finsupp.total (Fin 0) M R f = 0 :=
  by
  ext i
  apply finZeroElim i
#align finsupp.total_fin_zero Finsupp.total_fin_zero

variable (α) (M) (v)

/- warning: finsupp.total_on -> Finsupp.totalOn is a dubious translation:
lean 3 declaration is
  forall (α : Type.{u1}) (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (v : α -> M) (s : Set.{u1} α), LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (coeSort.{succ (max u1 u3), succ (succ (max u1 u3))} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) Type.{max u1 u3} (SetLike.hasCoeToSort.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.addCommMonoid.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))
but is expected to have type
  forall (α : Type.{u1}) (M : Type.{u2}) (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] (v : α -> M) (s : Set.{u1} α), LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Subtype.{succ (max u1 u3)} (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (fun (x : Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) => Membership.mem.{max u1 u3, max u1 u3} (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (Submodule.{u3, max u3 u1} R (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SetLike.instMembership.{max u1 u3, max u1 u3} (Submodule.{u3, max u3 u1} R (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) x (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))) (Submodule.addCommMonoid.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_on Finsupp.totalOnₓ'. -/
/-- `finsupp.total_on M v s` interprets `p : α →₀ R` as a linear combination of a
subset of the vectors in `v`, mapping it to the span of those vectors.

The subset is indicated by a set `s : set α` of indices.
-/
protected def totalOn (s : Set α) : supported R R s →ₗ[R] span R (v '' s) :=
  LinearMap.codRestrict _ ((Finsupp.total _ _ _ v).comp (Submodule.subtype (supported R R s)))
    fun ⟨l, hl⟩ => (mem_span_image_iff_total _).2 ⟨l, hl, rfl⟩
#align finsupp.total_on Finsupp.totalOn

variable {α} {M} {v}

/- warning: finsupp.total_on_range -> Finsupp.totalOn_range is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {v : α -> M} (s : Set.{u1} α), Eq.{succ u2} (Submodule.{u3, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))) (LinearMap.range.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (coeSort.{succ (max u1 u3), succ (succ (max u1 u3))} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) Type.{max u1 u3} (SetLike.hasCoeToSort.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (coeSort.{succ (max u1 u3), succ (succ (max u1 u3))} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) Type.{max u1 u3} (SetLike.hasCoeToSort.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.addCommMonoid.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (coeSort.{succ (max u1 u3), succ (succ (max u1 u3))} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) Type.{max u1 u3} (SetLike.hasCoeToSort.{max u1 u3, max u1 u3} (Submodule.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) (Submodule.setLike.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, max u1 u3} R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.supported.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) s)) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) (Finsupp.totalOn.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v s)) (Top.top.{u2} (Submodule.{u3, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))) (Submodule.hasTop.{u3, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u3, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) _inst_1 (Submodule.addCommMonoid.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s))) (Submodule.module.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u3, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u1, u2} α M v s)))))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {v : α -> M} (s : Set.{u3} α), Eq.{succ u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) (LinearMap.range.{u1, u1, max u3 u1, u2, max (max u3 u2) u1} R R (Subtype.{succ (max u3 u1)} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u3 u1, max u3 u1} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.setLike.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Subtype.{succ (max u3 u1)} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u3 u1, max u3 u1} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.setLike.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) (Submodule.addCommMonoid.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u1, u2} R R (Subtype.{succ (max u3 u1)} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (fun (x : Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) => Membership.mem.{max u3 u1, max u3 u1} (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u1, max u1 u3} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (Submodule.setLike.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) x (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s))) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) _inst_1 _inst_1 (Submodule.addCommMonoid.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (AddMonoid.toZero.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.supported.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1) s)) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (Finsupp.totalOn.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4 v s)) (Top.top.{u2} (Submodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) (Submodule.instTopSubmodule.{u1, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_3 _inst_4)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s))) (Submodule.module.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Submodule.span.{u1, u2} R M _inst_1 _inst_3 _inst_4 (Set.image.{u3, u2} α M v s)))))
Case conversion may be inaccurate. Consider using '#align finsupp.total_on_range Finsupp.totalOn_rangeₓ'. -/
theorem totalOn_range (s : Set α) : (Finsupp.totalOn α M R v s).range = ⊤ :=
  by
  rw [Finsupp.totalOn, LinearMap.range_eq_map, LinearMap.map_codRestrict, ←
    LinearMap.range_le_iff_comap, range_subtype, map_top, LinearMap.range_comp, range_subtype]
  exact (span_image_eq_map_total _ _).le
#align finsupp.total_on_range Finsupp.totalOn_range

/- warning: finsupp.total_comp -> Finsupp.total_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} {v : α -> M} (f : α' -> α), Eq.{max (succ (max u4 u3)) (succ u2)} (LinearMap.{u3, u3, max u4 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u4, u3} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u3, u3} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (Finsupp.total.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 (Function.comp.{succ u4, succ u1, succ u2} α' α M v f)) (LinearMap.comp.{u3, u3, u3, max u4 u3, max u1 u3, u2} R R R (Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u3} α' R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u4, u3, u3} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.lmapDomain.{u4, u3, u3, u1} α' R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1) α f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} (R : Type.{u3}) {_inst_1 : Type.{u2}} [_inst_3 : Semiring.{u3} R] [_inst_4 : AddCommMonoid.{u4} M] [α' : Module.{u3, u4} R M _inst_3 _inst_4] {v : α -> M} (f : _inst_1 -> α), Eq.{max (max (succ u4) (succ u3)) (succ u2)} (LinearMap.{u3, u3, max u3 u2, u4} R R _inst_3 _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)) (Finsupp.{u2, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) M (Finsupp.addCommMonoid.{u2, u3} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))) _inst_4 (Finsupp.module.{u2, u3, u3} _inst_1 R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3)) α') (Finsupp.total.{u2, u4, u3} _inst_1 M R _inst_3 _inst_4 α' (Function.comp.{succ u2, succ u1, succ u4} _inst_1 α M v f)) (LinearMap.comp.{u3, u3, u3, max u3 u2, max u1 u3, u4} R R R (Finsupp.{u2, u3} _inst_1 R (AddMonoid.toZero.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))))) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) M _inst_3 _inst_3 _inst_3 (Finsupp.addCommMonoid.{u2, u3} _inst_1 R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))) _inst_4 (Finsupp.module.{u2, u3, u3} _inst_1 R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3)) (Finsupp.module.{u1, u3, u3} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3)) α' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)) (RingHomCompTriple.ids.{u3, u3} R R _inst_3 _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Finsupp.total.{u1, u4, u3} α M R _inst_3 _inst_4 α' v) (Finsupp.lmapDomain.{u2, u3, u3, u1} _inst_1 R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3) α f))
Case conversion may be inaccurate. Consider using '#align finsupp.total_comp Finsupp.total_compₓ'. -/
theorem total_comp (f : α' → α) :
    Finsupp.total α' M R (v ∘ f) = (Finsupp.total α M R v).comp (lmapDomain R R f) :=
  by
  ext
  simp [total_apply]
#align finsupp.total_comp Finsupp.total_comp

/- warning: finsupp.total_comap_domain -> Finsupp.total_comapDomain is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} {v : α -> M} (f : α -> α') (l : Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (hf : Set.InjOn.{u1, u4} α α' f (Set.preimage.{u1, u4} α α' f ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} α') (Set.{u4} α') (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} α') (Set.{u4} α') (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} α') (Set.{u4} α') (Finset.Set.hasCoeT.{u4} α'))) (Finsupp.support.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) l)))), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 v) (Finsupp.comapDomain.{u1, u4, u3} α α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) f l hf)) (Finset.sum.{u2, u1} M α _inst_3 (Finset.preimage.{u1, u4} α α' (Finsupp.support.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) l) f hf) (fun (i : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (fun (_x : Finsupp.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) => α' -> R) (Finsupp.coeFun.{u4, u3} α' R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) l (f i)) (v i)))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u1}} (R : Type.{u3}) {_inst_1 : Type.{u4}} [_inst_3 : Semiring.{u3} R] [_inst_4 : AddCommMonoid.{u1} M] [α' : Module.{u3, u1} R M _inst_3 _inst_4] {v : α -> M} (f : α -> _inst_1) (l : Finsupp.{u4, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) (hf : Set.InjOn.{u2, u4} α _inst_1 f (Set.preimage.{u2, u4} α _inst_1 f (Finset.toSet.{u4} _inst_1 (Finsupp.support.{u4, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3)) l)))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) => M) (Finsupp.comapDomain.{u2, u4, u3} α _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3)) f l hf)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u2, u1} R R _inst_3 _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)) (Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) M (Finsupp.addCommMonoid.{u2, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))) _inst_4 (Finsupp.module.{u2, u3, u3} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3)) α') (Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) (fun (_x : Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) => M) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u1} R R (Finsupp.{u2, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) M _inst_3 _inst_3 (Finsupp.addCommMonoid.{u2, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3)))) _inst_4 (Finsupp.module.{u2, u3, u3} α R R _inst_3 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Semiring.toModule.{u3} R _inst_3)) α' (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_3))) (Finsupp.total.{u2, u1, u3} α M R _inst_3 _inst_4 α' v) (Finsupp.comapDomain.{u2, u4, u3} α _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3)) f l hf)) (Finset.sum.{u1, u2} M α _inst_4 (Finset.preimage.{u2, u4} α _inst_1 (Finsupp.support.{u4, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3)) l) f hf) (fun (i : α) => HSMul.hSMul.{u3, u1, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M M (instHSMul.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M (SMulZeroClass.toSMul.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)) (SMulWithZero.toSMulZeroClass.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M (MonoidWithZero.toZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) _inst_3)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)) (MulActionWithZero.toSMulWithZero.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M (Semiring.toMonoidWithZero.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) _inst_3) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_4)) (Module.toMulActionWithZero.{u3, u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) (f i)) M _inst_3 _inst_4 α'))))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Finsupp.{u4, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) _inst_1 (fun (_x : _inst_1) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : _inst_1) => R) _x) (Finsupp.funLike.{u4, u3} _inst_1 R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_3))) l (f i)) (v i)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_comap_domain Finsupp.total_comapDomainₓ'. -/
theorem total_comapDomain (f : α → α') (l : α' →₀ R) (hf : Set.InjOn f (f ⁻¹' ↑l.support)) :
    Finsupp.total α M R v (Finsupp.comapDomain f l hf) =
      (l.support.Preimage f hf).Sum fun i => l (f i) • v i :=
  by rw [Finsupp.total_apply] <;> rfl
#align finsupp.total_comap_domain Finsupp.total_comapDomain

/- warning: finsupp.total_on_finset -> Finsupp.total_onFinset is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {s : Finset.{u1} α} {f : α -> R} (g : α -> M) (hf : forall (a : α), (Ne.{succ u3} R (f a) (OfNat.ofNat.{u3} R 0 (OfNat.mk.{u3} R 0 (Zero.zero.{u3} R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))))) -> (Membership.Mem.{u1, u1} α (Finset.{u1} α) (Finset.hasMem.{u1} α) a s)), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Finsupp.total.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 g) (Finsupp.onFinset.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) s f hf)) (Finset.sum.{u2, u1} M α _inst_3 s (fun (x : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (f x) (g x)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {s : Finset.{u3} α} {f : α -> R} (g : α -> M) (hf : forall (a : α), (Ne.{succ u2} R (f a) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))))) -> (Membership.mem.{u3, u3} α (Finset.{u3} α) (Finset.instMembershipFinset.{u3} α) a s)), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) (Finsupp.onFinset.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) s f hf)) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Finsupp.total.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4 g) (Finsupp.onFinset.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) s f hf)) (Finset.sum.{u1, u3} M α _inst_3 s (fun (x : α) => HSMul.hSMul.{u2, u1, u1} R M M (instHSMul.{u2, u1} R M (SMulZeroClass.toSMul.{u2, u1} R M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u1} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u1} R M (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)) (Module.toMulActionWithZero.{u2, u1} R M _inst_1 _inst_3 _inst_4))))) (f x) (g x)))
Case conversion may be inaccurate. Consider using '#align finsupp.total_on_finset Finsupp.total_onFinsetₓ'. -/
theorem total_onFinset {s : Finset α} {f : α → R} (g : α → M) (hf : ∀ a, f a ≠ 0 → a ∈ s) :
    Finsupp.total α M R g (Finsupp.onFinset s f hf) = Finset.sum s fun x : α => f x • g x :=
  by
  simp only [Finsupp.total_apply, Finsupp.sum, Finsupp.onFinset_apply, Finsupp.support_onFinset]
  rw [Finset.sum_filter_of_ne]
  intro x hx h
  contrapose! h
  simp [h]
#align finsupp.total_on_finset Finsupp.total_onFinset

end Total

/- warning: finsupp.dom_lcongr -> Finsupp.domLCongr is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}}, (Equiv.{succ u3, succ u4} α₁ α₂) -> (LinearEquiv.{u2, u2, max u3 u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}}, (Equiv.{succ u3, succ u4} α₁ α₂) -> (LinearEquiv.{u2, u2, max u1 u3, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.{u4, u1} α₂ M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr Finsupp.domLCongrₓ'. -/
/-- An equivalence of domains induces a linear equivalence of finitely supported functions.

This is `finsupp.dom_congr` as a `linear_equiv`.
See also `linear_map.fun_congr_left` for the case of arbitrary functions. -/
protected def domLCongr {α₁ α₂ : Type _} (e : α₁ ≃ α₂) : (α₁ →₀ M) ≃ₗ[R] α₂ →₀ M :=
  (Finsupp.domCongr e : (α₁ →₀ M) ≃+ (α₂ →₀ M)).toLinearEquiv <| by
    simpa only [equiv_map_domain_eq_map_domain, dom_congr_apply] using (lmap_domain M R e).map_smul
#align finsupp.dom_lcongr Finsupp.domLCongr

/- warning: finsupp.dom_lcongr_apply -> Finsupp.domLCongr_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}} (e : Equiv.{succ u3, succ u4} α₁ α₂) (v : Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))), Eq.{max (succ u4) (succ u1)} (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max u3 u1)) (succ (max u4 u1)), max (succ (max u3 u1)) (succ (max u4 u1))} (LinearEquiv.{u2, u2, max u3 u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearEquiv.{u2, u2, max u3 u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4)) => (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearEquiv.hasCoeToFun.{u2, u2, max u3 u1, max u4 u1} R R (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (Finsupp.domLCongr.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α₁ α₂ e) v) (coeFn.{max (succ (max u3 u1)) (succ (max u4 u1)), max (succ (max u3 u1)) (succ (max u4 u1))} (AddEquiv.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.add.{u3, u1} α₁ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.add.{u4, u1} α₂ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : AddEquiv.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.add.{u3, u1} α₁ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.add.{u4, u1} α₂ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (AddEquiv.hasCoeToFun.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.add.{u3, u1} α₁ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.add.{u4, u1} α₂ M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.domCongr.{u3, u4, u1} α₁ α₂ M _inst_3 e) v)
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α₁ : Type.{u4}} {α₂ : Type.{u3}} (e : Equiv.{succ u4, succ u3} α₁ α₂) (v : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) v) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u4) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (SMulHomClass.toFunLike.{max (max u4 u3) u2, u1, max u4 u2, max u3 u2} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulZeroClass.toSMul.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3)) (Module.toDistribMulAction.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3)) (Module.toDistribMulAction.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u4 u3) u2, u1, max u4 u2, max u3 u2} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3)) (Module.toDistribMulAction.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) (SemilinearMapClass.distribMulActionHomClass.{u1, max u4 u2, max u3 u2, max (max u4 u3) u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u4 u2, max u3 u2, max (max u4 u3) u2} R R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u4 u2, max u3 u2} R R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (Finsupp.domLCongr.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α₁ α₂ e) v) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u4) (succ u2), max (succ u3) (succ u2)} (AddEquiv.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u4, u2} α₁ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u3, u2} α₂ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.403 : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (AddHomClass.toFunLike.{max (max u4 u3) u2, max u4 u2, max u3 u2} (AddEquiv.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u4, u2} α₁ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u3, u2} α₂ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddZeroClass.toAdd.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u4, u2} α₁ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddZeroClass.toAdd.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u3, u2} α₂ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoidHomClass.toAddHomClass.{max (max u4 u3) u2, max u4 u2, max u3 u2} (AddEquiv.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u4, u2} α₁ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u3, u2} α₂ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u4, u2} α₁ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u3, u2} α₂ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddEquivClass.instAddMonoidHomClass.{max (max u4 u3) u2, max u4 u2, max u3 u2} (AddEquiv.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u4, u2} α₁ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u3, u2} α₂ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u4, u2} α₁ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addMonoid.{u3, u2} α₂ M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddEquiv.instAddEquivClassAddEquiv.{max u4 u2, max u3 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u4, u2} α₁ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.add.{u3, u2} α₂ M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))))))) (Finsupp.domCongr.{u4, u3, u2} α₁ α₂ M _inst_3 e) v)
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr_apply Finsupp.domLCongr_applyₓ'. -/
@[simp]
theorem domLCongr_apply {α₁ : Type _} {α₂ : Type _} (e : α₁ ≃ α₂) (v : α₁ →₀ M) :
    (Finsupp.domLCongr e : _ ≃ₗ[R] _) v = Finsupp.domCongr e v :=
  rfl
#align finsupp.dom_lcongr_apply Finsupp.domLCongr_apply

/- warning: finsupp.dom_lcongr_refl -> Finsupp.domLCongr_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (LinearEquiv.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.domLCongr.{u2, u3, u1, u1} M R _inst_1 _inst_3 _inst_4 α α (Equiv.refl.{succ u1} α)) (LinearEquiv.refl.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.domLCongr.{u2, u1, u3, u3} M R _inst_1 _inst_3 _inst_4 α α (Equiv.refl.{succ u3} α)) (LinearEquiv.refl.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr_refl Finsupp.domLCongr_reflₓ'. -/
@[simp]
theorem domLCongr_refl : Finsupp.domLCongr (Equiv.refl α) = LinearEquiv.refl R (α →₀ M) :=
  LinearEquiv.ext fun _ => equivMapDomain_refl _
#align finsupp.dom_lcongr_refl Finsupp.domLCongr_refl

/- warning: finsupp.dom_lcongr_trans -> Finsupp.domLCongr_trans is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}} {α₃ : Type.{u5}} (f : Equiv.{succ u3, succ u4} α₁ α₂) (f₂ : Equiv.{succ u4, succ u5} α₂ α₃), Eq.{max (succ (max u3 u1)) (succ (max u5 u1))} (LinearEquiv.{u2, u2, max u3 u1, max u5 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u1} α₃ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u5, u1} α₃ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u1, u2} α₃ M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.trans.{u2, u2, u2, max u3 u1, max u4 u1, max u5 u1} R R R (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u1} α₃ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.addCommMonoid.{u5, u1} α₃ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u1, u2} α₃ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.right_ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (RingHomCompTriple.right_ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.domLCongr.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α₁ α₂ f) (Finsupp.domLCongr.{u1, u2, u4, u5} M R _inst_1 _inst_3 _inst_4 α₂ α₃ f₂)) (Finsupp.domLCongr.{u1, u2, u3, u5} M R _inst_1 _inst_3 _inst_4 α₁ α₃ (Equiv.trans.{succ u3, succ u4, succ u5} α₁ α₂ α₃ f f₂))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α₁ : Type.{u5}} {α₂ : Type.{u4}} {α₃ : Type.{u3}} (f : Equiv.{succ u5, succ u4} α₁ α₂) (f₂ : Equiv.{succ u4, succ u3} α₂ α₃), Eq.{max (max (succ u2) (succ u5)) (succ u3)} (LinearEquiv.{u1, u1, max u5 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u5, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₃ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₃ M _inst_3) (Finsupp.module.{u5, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₃ M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.trans.{u1, u1, u1, max u5 u2, max u4 u2, max u3 u2} R R R (Finsupp.{u5, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₃ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α₂ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₃ M _inst_3) (Finsupp.module.{u5, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₃ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.domLCongr.{u2, u1, u5, u4} M R _inst_1 _inst_3 _inst_4 α₁ α₂ f) (Finsupp.domLCongr.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α₂ α₃ f₂)) (Finsupp.domLCongr.{u2, u1, u5, u3} M R _inst_1 _inst_3 _inst_4 α₁ α₃ (Equiv.trans.{succ u5, succ u4, succ u3} α₁ α₂ α₃ f f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr_trans Finsupp.domLCongr_transₓ'. -/
theorem domLCongr_trans {α₁ α₂ α₃ : Type _} (f : α₁ ≃ α₂) (f₂ : α₂ ≃ α₃) :
    (Finsupp.domLCongr f).trans (Finsupp.domLCongr f₂) =
      (Finsupp.domLCongr (f.trans f₂) : (_ →₀ M) ≃ₗ[R] _) :=
  LinearEquiv.ext fun _ => (equivMapDomain_trans _ _ _).symm
#align finsupp.dom_lcongr_trans Finsupp.domLCongr_trans

/- warning: finsupp.dom_lcongr_symm -> Finsupp.domLCongr_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}} (f : Equiv.{succ u3, succ u4} α₁ α₂), Eq.{max (succ (max u4 u1)) (succ (max u3 u1))} (LinearEquiv.{u2, u2, max u4 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u2, u2, max u3 u1, max u4 u1} R R (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.domLCongr.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α₁ α₂ f)) (Finsupp.domLCongr.{u1, u2, u4, u3} M R _inst_1 _inst_3 _inst_4 α₂ α₁ (Equiv.symm.{succ u3, succ u4} α₁ α₂ f))
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α₁ : Type.{u4}} {α₂ : Type.{u3}} (f : Equiv.{succ u4, succ u3} α₁ α₂), Eq.{max (max (succ u2) (succ u4)) (succ u3)} (LinearEquiv.{u1, u1, max u3 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u1, u1, max u4 u2, max u3 u2} R R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.domLCongr.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α₁ α₂ f)) (Finsupp.domLCongr.{u2, u1, u3, u4} M R _inst_1 _inst_3 _inst_4 α₂ α₁ (Equiv.symm.{succ u4, succ u3} α₁ α₂ f))
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr_symm Finsupp.domLCongr_symmₓ'. -/
@[simp]
theorem domLCongr_symm {α₁ α₂ : Type _} (f : α₁ ≃ α₂) :
    ((Finsupp.domLCongr f).symm : (_ →₀ M) ≃ₗ[R] _) = Finsupp.domLCongr f.symm :=
  LinearEquiv.ext fun x => rfl
#align finsupp.dom_lcongr_symm Finsupp.domLCongr_symm

/- warning: finsupp.dom_lcongr_single -> Finsupp.domLCongr_single is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {R : Type.{u2}} [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α₁ : Type.{u3}} {α₂ : Type.{u4}} (e : Equiv.{succ u3, succ u4} α₁ α₂) (i : α₁) (m : M), Eq.{max (succ u4) (succ u1)} (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max u3 u1)) (succ (max u4 u1)), max (succ (max u3 u1)) (succ (max u4 u1))} (LinearEquiv.{u2, u2, max u3 u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearEquiv.{u2, u2, max u3 u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4)) => (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearEquiv.hasCoeToFun.{u2, u2, max u3 u1, max u4 u1} R R (Finsupp.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α₁ M _inst_3) (Finsupp.addCommMonoid.{u4, u1} α₂ M _inst_3) (Finsupp.module.{u3, u1, u2} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (Finsupp.domLCongr.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α₁ α₂ e) (Finsupp.single.{u3, u1} α₁ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) i m)) (Finsupp.single.{u4, u1} α₂ M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} α₁ α₂) (fun (_x : Equiv.{succ u3, succ u4} α₁ α₂) => α₁ -> α₂) (Equiv.hasCoeToFun.{succ u3, succ u4} α₁ α₂) e i) m)
but is expected to have type
  forall {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α₁ : Type.{u4}} {α₂ : Type.{u3}} (e : Equiv.{succ u4, succ u3} α₁ α₂) (i : α₁) (m : M), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.single.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) i m)) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u4) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (SMulHomClass.toFunLike.{max (max u4 u3) u2, u1, max u4 u2, max u3 u2} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulZeroClass.toSMul.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3)) (Module.toDistribMulAction.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3)) (Module.toDistribMulAction.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u4 u3) u2, u1, max u4 u2, max u3 u2} (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u2} (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3)) (Module.toDistribMulAction.{u1, max u4 u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u1, max u3 u2} R (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) (SemilinearMapClass.distribMulActionHomClass.{u1, max u4 u2, max u3 u2, max (max u4 u3) u2} R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u4 u2, max u3 u2, max (max u4 u3) u2} R R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max u2 u4, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u4 u2, max u3 u2} R R (Finsupp.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α₂ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u2} α₁ M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α₂ M _inst_3) (Finsupp.module.{u4, u2, u1} α₁ M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α₂ M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (Finsupp.domLCongr.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α₁ α₂ e) (Finsupp.single.{u4, u2} α₁ M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) i m)) (Finsupp.single.{u3, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α₁) => α₂) i) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} α₁ α₂) α₁ (fun (_x : α₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α₁) => α₂) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} α₁ α₂) e i) m)
Case conversion may be inaccurate. Consider using '#align finsupp.dom_lcongr_single Finsupp.domLCongr_singleₓ'. -/
@[simp]
theorem domLCongr_single {α₁ : Type _} {α₂ : Type _} (e : α₁ ≃ α₂) (i : α₁) (m : M) :
    (Finsupp.domLCongr e : _ ≃ₗ[R] _) (Finsupp.single i m) = Finsupp.single (e i) m := by
  simp [Finsupp.domLCongr, Finsupp.domCongr, equiv_map_domain_single]
#align finsupp.dom_lcongr_single Finsupp.domLCongr_single

/- warning: finsupp.congr -> Finsupp.congr is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (s : Set.{u1} α) (t : Set.{u4} α'), (Equiv.{succ u1, succ u4} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} α) Type.{u1} (Set.hasCoeToSort.{u1} α) s) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} α') Type.{u4} (Set.hasCoeToSort.{u4} α') t)) -> (LinearEquiv.{u3, u3, max u1 u2, max u4 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submodule.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (coeSort.{succ (max u4 u2), succ (succ (max u4 u2))} (Submodule.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) Type.{max u4 u2} (SetLike.hasCoeToSort.{max u4 u2, max u4 u2} (Submodule.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Submodule.setLike.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4))) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t)) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.addCommMonoid.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u4 u2} R (Finsupp.{u4, u2} α' M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t)))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] {α' : Type.{u4}} (s : Set.{u1} α) (t : Set.{u4} α'), (Equiv.{succ u1, succ u4} (Set.Elem.{u1} α s) (Set.Elem.{u4} α' t)) -> (LinearEquiv.{u3, u3, max u1 u2, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Subtype.{succ (max u1 u2)} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u1 u2, max u1 u2} (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s))) (Subtype.{succ (max u2 u4)} (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (x : Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Membership.mem.{max u2 u4, max u2 u4} (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.{u3, max u2 u4} R (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (SetLike.instMembership.{max u2 u4, max u2 u4} (Submodule.{u3, max u2 u4} R (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Submodule.setLike.{u3, max u2 u4} R (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4))) x (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t))) (Submodule.addCommMonoid.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.addCommMonoid.{u3, max u2 u4} R (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t)) (Submodule.module.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4 s)) (Submodule.module.{u3, max u2 u4} R (Finsupp.{u4, u2} α' M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α' M _inst_3) (Finsupp.module.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4) (Finsupp.supported.{u4, u2, u3} α' M R _inst_1 _inst_3 _inst_4 t)))
Case conversion may be inaccurate. Consider using '#align finsupp.congr Finsupp.congrₓ'. -/
/-- An equivalence of sets induces a linear equivalence of `finsupp`s supported on those sets. -/
noncomputable def congr {α' : Type _} (s : Set α) (t : Set α') (e : s ≃ t) :
    supported M R s ≃ₗ[R] supported M R t :=
  by
  haveI := Classical.decPred fun x => x ∈ s
  haveI := Classical.decPred fun x => x ∈ t
  refine' Finsupp.supportedEquivFinsupp s ≪≫ₗ (_ ≪≫ₗ (Finsupp.supportedEquivFinsupp t).symm)
  exact Finsupp.domLCongr e
#align finsupp.congr Finsupp.congr

/- warning: finsupp.map_range.linear_map -> Finsupp.mapRange.linearMap is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5], (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearMap.{u4, u4, max u1 u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5], (LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearMap.{u4, u4, max u2 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_map Finsupp.mapRange.linearMapₓ'. -/
/-- `finsupp.map_range` as a `linear_map`. -/
@[simps]
def mapRange.linearMap (f : M →ₗ[R] N) : (α →₀ M) →ₗ[R] α →₀ N :=
  {
    mapRange.addMonoidHom
      f.toAddMonoidHom with
    toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)
    map_smul' := fun c v => mapRange_smul c v (f.map_smul c) }
#align finsupp.map_range.linear_map Finsupp.mapRange.linearMap

/- warning: finsupp.map_range.linear_map_id -> Finsupp.mapRange.linearMap_id is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.mapRange.linearMap.{u1, u2, u2, u3} α M M R _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 (LinearMap.id.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (LinearMap.id.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.mapRange.linearMap.{u3, u2, u2, u1} α M M R _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (LinearMap.id.{u1, max u3 u2} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_map_id Finsupp.mapRange.linearMap_idₓ'. -/
@[simp]
theorem mapRange.linearMap_id :
    mapRange.linearMap LinearMap.id = (LinearMap.id : (α →₀ M) →ₗ[R] _) :=
  LinearMap.ext mapRange_id
#align finsupp.map_range.linear_map_id Finsupp.mapRange.linearMap_id

/- warning: finsupp.map_range.linear_map_comp -> Finsupp.mapRange.linearMap_comp is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} {R : Type.{u5}} [_inst_1 : Semiring.{u5} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u5, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_7 : AddCommMonoid.{u4} P] [_inst_8 : Module.{u5, u4} R P _inst_1 _inst_7] (f : LinearMap.{u5, u5, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) N P _inst_5 _inst_7 _inst_6 _inst_8) (f₂ : LinearMap.{u5, u5, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u1 u2)) (succ (max u1 u4))} (LinearMap.{u5, u5, max u1 u2, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_7)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u4} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u4, u5} α P R _inst_1 _inst_7 _inst_8)) (Finsupp.mapRange.linearMap.{u1, u2, u4, u5} α M P R _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (LinearMap.comp.{u5, u5, u5, u2, u3, u4} R R R M N P _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_7 _inst_4 _inst_6 _inst_8 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) f f₂)) (LinearMap.comp.{u5, u5, u5, max u1 u2, max u1 u3, max u1 u4} R R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_7)))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.addCommMonoid.{u1, u4} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u5} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u4, u5} α P R _inst_1 _inst_7 _inst_8) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Finsupp.mapRange.linearMap.{u1, u3, u4, u5} α N P R _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 f) (Finsupp.mapRange.linearMap.{u1, u2, u3, u5} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u4}} {P : Type.{u3}} {R : Type.{u5}} [_inst_1 : Semiring.{u5} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u5, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u4} N] [_inst_6 : Module.{u5, u4} R N _inst_1 _inst_5] [_inst_7 : AddCommMonoid.{u3} P] [_inst_8 : Module.{u5, u3} R P _inst_1 _inst_7] (f : LinearMap.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) N P _inst_5 _inst_7 _inst_6 _inst_8) (f₂ : LinearMap.{u5, u5, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (succ u1) (succ u2)) (succ u3)} (LinearMap.{u5, u5, max u2 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u3} α P (AddMonoid.toZero.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_7))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u5} α P R _inst_1 _inst_7 _inst_8)) (Finsupp.mapRange.linearMap.{u1, u2, u3, u5} α M P R _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (LinearMap.comp.{u5, u5, u5, u2, u4, u3} R R R M N P _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_7 _inst_4 _inst_6 _inst_8 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) f f₂)) (LinearMap.comp.{u5, u5, u5, max u2 u1, max u4 u1, max u3 u1} R R R (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u4} α N (AddMonoid.toZero.{u4} N (AddCommMonoid.toAddMonoid.{u4} N _inst_5))) (Finsupp.{u1, u3} α P (AddMonoid.toZero.{u3} P (AddCommMonoid.toAddMonoid.{u3} P _inst_7))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u4} α N _inst_5) (Finsupp.addCommMonoid.{u1, u3} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u4, u5} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u3, u5} α P R _inst_1 _inst_7 _inst_8) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (Finsupp.mapRange.linearMap.{u1, u4, u3, u5} α N P R _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 f) (Finsupp.mapRange.linearMap.{u1, u2, u4, u5} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_map_comp Finsupp.mapRange.linearMap_compₓ'. -/
theorem mapRange.linearMap_comp (f : N →ₗ[R] P) (f₂ : M →ₗ[R] N) :
    (mapRange.linearMap (f.comp f₂) : (α →₀ _) →ₗ[R] _) =
      (mapRange.linearMap f).comp (mapRange.linearMap f₂) :=
  LinearMap.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.linear_map_comp Finsupp.mapRange.linearMap_comp

/- warning: finsupp.map_range.linear_map_to_add_monoid_hom -> Finsupp.mapRange.linearMap_toAddMonoidHom is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] (f : LinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (AddMonoidHom.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3))) (AddMonoid.toAddZeroClass.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddCommMonoid.toAddMonoid.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5)))) (LinearMap.toAddMonoidHom.{u4, u4, max u1 u2, max u1 u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.mapRange.linearMap.{u1, u2, u3, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.addMonoidHom.{u1, u2, u3} α M N _inst_3 _inst_5 (LinearMap.toAddMonoidHom.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u4, u2} R N _inst_1 _inst_5] (f : LinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (AddMonoidHom.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5)))) (LinearMap.toAddMonoidHom.{u4, u4, max u3 u1, max u2 u1} R R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.mapRange.linearMap.{u1, u3, u2, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.addMonoidHom.{u1, u3, u2} α M N _inst_3 _inst_5 (LinearMap.toAddMonoidHom.{u4, u4, u3, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_map_to_add_monoid_hom Finsupp.mapRange.linearMap_toAddMonoidHomₓ'. -/
@[simp]
theorem mapRange.linearMap_toAddMonoidHom (f : M →ₗ[R] N) :
    (mapRange.linearMap f).toAddMonoidHom =
      (mapRange.addMonoidHom f.toAddMonoidHom : (α →₀ M) →+ _) :=
  AddMonoidHom.ext fun _ => rfl
#align finsupp.map_range.linear_map_to_add_monoid_hom Finsupp.mapRange.linearMap_toAddMonoidHom

/- warning: finsupp.map_range.linear_equiv -> Finsupp.mapRange.linearEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5], (LinearEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearEquiv.{u4, u4, max u1 u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5], (LinearEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearEquiv.{u4, u4, max u2 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv Finsupp.mapRange.linearEquivₓ'. -/
/-- `finsupp.map_range` as a `linear_equiv`. -/
@[simps apply]
def mapRange.linearEquiv (e : M ≃ₗ[R] N) : (α →₀ M) ≃ₗ[R] α →₀ N :=
  { mapRange.linearMap e.toLinearMap,
    mapRange.addEquiv e.toAddEquiv with
    toFun := mapRange e e.map_zero
    invFun := mapRange e.symm e.symm.map_zero }
#align finsupp.map_range.linear_equiv Finsupp.mapRange.linearEquiv

/- warning: finsupp.map_range.linear_equiv_refl -> Finsupp.mapRange.linearEquiv_refl is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3], Eq.{succ (max u1 u2)} (LinearEquiv.{u3, u3, max u1 u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.mapRange.linearEquiv.{u1, u2, u2, u3} α M M R _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 (LinearEquiv.refl.{u3, u2} R M _inst_1 _inst_3 _inst_4)) (LinearEquiv.refl.{u3, max u1 u2} R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u2, u3} α M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u2}} {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3], Eq.{max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4)) (Finsupp.mapRange.linearEquiv.{u3, u2, u2, u1} α M M R _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 (LinearEquiv.refl.{u1, u2} R M _inst_1 _inst_3 _inst_4)) (LinearEquiv.refl.{u1, max u2 u3} R (Finsupp.{u3, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u2} α M _inst_3) (Finsupp.module.{u3, u2, u1} α M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv_refl Finsupp.mapRange.linearEquiv_reflₓ'. -/
@[simp]
theorem mapRange.linearEquiv_refl :
    mapRange.linearEquiv (LinearEquiv.refl R M) = LinearEquiv.refl R (α →₀ M) :=
  LinearEquiv.ext mapRange_id
#align finsupp.map_range.linear_equiv_refl Finsupp.mapRange.linearEquiv_refl

/- warning: finsupp.map_range.linear_equiv_trans -> Finsupp.mapRange.linearEquiv_trans is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {P : Type.{u4}} {R : Type.{u5}} [_inst_1 : Semiring.{u5} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u5, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_7 : AddCommMonoid.{u4} P] [_inst_8 : Module.{u5, u4} R P _inst_1 _inst_7] (f : LinearEquiv.{u5, u5, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (f₂ : LinearEquiv.{u5, u5, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) N P _inst_5 _inst_7 _inst_6 _inst_8), Eq.{max (succ (max u1 u2)) (succ (max u1 u4))} (LinearEquiv.{u5, u5, max u1 u2, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_7)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u4} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u4, u5} α P R _inst_1 _inst_7 _inst_8)) (Finsupp.mapRange.linearEquiv.{u1, u2, u4, u5} α M P R _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (LinearEquiv.trans.{u5, u5, u5, u2, u3, u4} R R R M N P _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_7 _inst_4 _inst_6 _inst_8 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) f f₂)) (LinearEquiv.trans.{u5, u5, u5, max u1 u2, max u1 u3, max u1 u4} R R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.{u1, u4} α P (AddZeroClass.toHasZero.{u4} P (AddMonoid.toAddZeroClass.{u4} P (AddCommMonoid.toAddMonoid.{u4} P _inst_7)))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.addCommMonoid.{u1, u4} α P _inst_7) (Finsupp.module.{u1, u2, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u5} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u4, u5} α P R _inst_1 _inst_7 _inst_8) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomCompTriple.right_ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (Finsupp.mapRange.linearEquiv.{u1, u2, u3, u5} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f) (Finsupp.mapRange.linearEquiv.{u1, u3, u4, u5} α N P R _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 f₂))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u4}} {N : Type.{u3}} {P : Type.{u2}} {R : Type.{u5}} [_inst_1 : Semiring.{u5} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u5, u4} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u5, u3} R N _inst_1 _inst_5] [_inst_7 : AddCommMonoid.{u2} P] [_inst_8 : Module.{u5, u2} R P _inst_1 _inst_7] (f : LinearEquiv.{u5, u5, u4, u3} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (f₂ : LinearEquiv.{u5, u5, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) N P _inst_5 _inst_7 _inst_6 _inst_8), Eq.{max (max (succ u1) (succ u4)) (succ u2)} (LinearEquiv.{u5, u5, max u4 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.{u1, u2} α P (AddMonoid.toZero.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_7))) (Finsupp.addCommMonoid.{u1, u4} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α P _inst_7) (Finsupp.module.{u1, u4, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u5} α P R _inst_1 _inst_7 _inst_8)) (Finsupp.mapRange.linearEquiv.{u1, u4, u2, u5} α M P R _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (LinearEquiv.trans.{u5, u5, u5, u4, u3, u2} R R R M N P _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_7 _inst_4 _inst_6 _inst_8 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) f f₂)) (LinearEquiv.trans.{u5, u5, u5, max u4 u1, max u3 u1, max u2 u1} R R R (Finsupp.{u1, u4} α M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3))) (Finsupp.{u1, u3} α N (AddMonoid.toZero.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5))) (Finsupp.{u1, u2} α P (AddMonoid.toZero.{u2} P (AddCommMonoid.toAddMonoid.{u2} P _inst_7))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u4} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.addCommMonoid.{u1, u2} α P _inst_7) (Finsupp.module.{u1, u4, u5} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u5} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u2, u5} α P R _inst_1 _inst_7 _inst_8) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1)) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomCompTriple.ids.{u5, u5} R R _inst_1 _inst_1 (RingHom.id.{u5} R (Semiring.toNonAssocSemiring.{u5} R _inst_1))) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (RingHomInvPair.ids.{u5} R _inst_1) (Finsupp.mapRange.linearEquiv.{u1, u4, u3, u5} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f) (Finsupp.mapRange.linearEquiv.{u1, u3, u2, u5} α N P R _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 f₂))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv_trans Finsupp.mapRange.linearEquiv_transₓ'. -/
theorem mapRange.linearEquiv_trans (f : M ≃ₗ[R] N) (f₂ : N ≃ₗ[R] P) :
    (mapRange.linearEquiv (f.trans f₂) : (α →₀ _) ≃ₗ[R] _) =
      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f₂) :=
  LinearEquiv.ext <| mapRange_comp _ _ _ _ _
#align finsupp.map_range.linear_equiv_trans Finsupp.mapRange.linearEquiv_trans

/- warning: finsupp.map_range.linear_equiv_symm -> Finsupp.mapRange.linearEquiv_symm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u1 u3)) (succ (max u1 u2))} (LinearEquiv.{u4, u4, max u1 u3, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u4, u4, max u1 u2, max u1 u3} R R (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.mapRange.linearEquiv.{u1, u2, u3, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.linearEquiv.{u1, u3, u2, u4} α N M R _inst_1 _inst_5 _inst_6 _inst_3 _inst_4 (LinearEquiv.symm.{u4, u4, u2, u3} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u4, u2} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (LinearEquiv.{u4, u4, max u2 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u4, u4, max u3 u1, max u2 u1} R R (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.mapRange.linearEquiv.{u1, u3, u2, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.linearEquiv.{u1, u2, u3, u4} α N M R _inst_1 _inst_5 _inst_6 _inst_3 _inst_4 (LinearEquiv.symm.{u4, u4, u3, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv_symm Finsupp.mapRange.linearEquiv_symmₓ'. -/
@[simp]
theorem mapRange.linearEquiv_symm (f : M ≃ₗ[R] N) :
    ((mapRange.linearEquiv f).symm : (α →₀ _) ≃ₗ[R] _) = mapRange.linearEquiv f.symm :=
  LinearEquiv.ext fun x => rfl
#align finsupp.map_range.linear_equiv_symm Finsupp.mapRange.linearEquiv_symm

/- warning: finsupp.map_range.linear_equiv_to_add_equiv -> Finsupp.mapRange.linearEquiv_toAddEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u1 u2)) (succ (max u1 u3))} (AddEquiv.{max u1 u2, max u1 u3} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddZeroClass.toHasAdd.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toAddZeroClass.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max u1 u2} (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3)))) (AddZeroClass.toHasAdd.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddMonoid.toAddZeroClass.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (AddCommMonoid.toAddMonoid.{max u1 u3} (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5))))) (LinearEquiv.toAddEquiv.{u4, u4, max u1 u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.mapRange.linearEquiv.{u1, u2, u3, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.addEquiv.{u1, u2, u3} α M N _inst_3 _inst_5 (LinearEquiv.toAddEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6 f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u4, u2} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (AddEquiv.{max u3 u1, max u2 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddZeroClass.toAdd.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddMonoid.toAddZeroClass.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3)))) (AddZeroClass.toAdd.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5))))) (LinearEquiv.toAddEquiv.{u4, u4, max u3 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.mapRange.linearEquiv.{u1, u3, u2, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.addEquiv.{u1, u3, u2} α M N _inst_3 _inst_5 (LinearEquiv.toAddEquiv.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6 f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv_to_add_equiv Finsupp.mapRange.linearEquiv_toAddEquivₓ'. -/
@[simp]
theorem mapRange.linearEquiv_toAddEquiv (f : M ≃ₗ[R] N) :
    (mapRange.linearEquiv f).toAddEquiv = (mapRange.addEquiv f.toAddEquiv : (α →₀ M) ≃+ _) :=
  AddEquiv.ext fun _ => rfl
#align finsupp.map_range.linear_equiv_to_add_equiv Finsupp.mapRange.linearEquiv_toAddEquiv

/- warning: finsupp.map_range.linear_equiv_to_linear_map -> Finsupp.mapRange.linearEquiv_toLinearMap is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u4, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u3} N] [_inst_6 : Module.{u4, u3} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u1 u2)) (succ (max u1 u3))} (LinearMap.{u4, u4, max u1 u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6)) (LinearEquiv.toLinearMap.{u4, u4, max u1 u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u2} α M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{u1, u3} α N (AddZeroClass.toHasZero.{u3} N (AddMonoid.toAddZeroClass.{u3} N (AddCommMonoid.toAddMonoid.{u3} N _inst_5)))) (Finsupp.addCommMonoid.{u1, u2} α M _inst_3) (Finsupp.addCommMonoid.{u1, u3} α N _inst_5) (Finsupp.module.{u1, u2, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u3, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.mapRange.linearEquiv.{u1, u2, u3, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.linearMap.{u1, u2, u3, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 (LinearEquiv.toLinearMap.{u4, u4, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6 f))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} {N : Type.{u2}} {R : Type.{u4}} [_inst_1 : Semiring.{u4} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u4, u3} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u4, u2} R N _inst_1 _inst_5] (f : LinearEquiv.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (succ u1) (succ u3)) (succ u2)} (LinearMap.{u4, u4, max u3 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6)) (LinearEquiv.toLinearMap.{u4, u4, max u3 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) (Finsupp.{u1, u3} α M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3))) (Finsupp.{u1, u2} α N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u1, u3} α M _inst_3) (Finsupp.addCommMonoid.{u1, u2} α N _inst_5) (Finsupp.module.{u1, u3, u4} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u1, u2, u4} α N R _inst_1 _inst_5 _inst_6) (Finsupp.mapRange.linearEquiv.{u1, u3, u2, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 f)) (Finsupp.mapRange.linearMap.{u1, u3, u2, u4} α M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 (LinearEquiv.toLinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (RingHomInvPair.ids.{u4} R _inst_1) (RingHomInvPair.ids.{u4} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6 f))
Case conversion may be inaccurate. Consider using '#align finsupp.map_range.linear_equiv_to_linear_map Finsupp.mapRange.linearEquiv_toLinearMapₓ'. -/
@[simp]
theorem mapRange.linearEquiv_toLinearMap (f : M ≃ₗ[R] N) :
    (mapRange.linearEquiv f).toLinearMap = (mapRange.linearMap f.toLinearMap : (α →₀ M) →ₗ[R] _) :=
  LinearMap.ext fun _ => rfl
#align finsupp.map_range.linear_equiv_to_linear_map Finsupp.mapRange.linearEquiv_toLinearMap

/- warning: finsupp.lcongr -> Finsupp.lcongr is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}}, (Equiv.{succ u4, succ u5} ι κ) -> (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearEquiv.{u3, u3, max u4 u1, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6))
but is expected to have type
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}}, (Equiv.{succ u4, succ u5} ι κ) -> (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) -> (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.{u5, u2} κ N (AddMonoid.toZero.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6))
Case conversion may be inaccurate. Consider using '#align finsupp.lcongr Finsupp.lcongrₓ'. -/
/-- An equivalence of domain and a linear equivalence of codomain induce a linear equivalence of the
corresponding finitely supported functions. -/
def lcongr {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) : (ι →₀ M) ≃ₗ[R] κ →₀ N :=
  (Finsupp.domLCongr e₁).trans (mapRange.linearEquiv e₂)
#align finsupp.lcongr Finsupp.lcongr

/- warning: finsupp.lcongr_single -> Finsupp.lcongr_single is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}} (e₁ : Equiv.{succ u4, succ u5} ι κ) (e₂ : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (i : ι) (m : M), Eq.{max (succ u5) (succ u2)} (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (coeFn.{max (succ (max u4 u1)) (succ (max u5 u2)), max (succ (max u4 u1)) (succ (max u5 u2))} (LinearEquiv.{u3, u3, max u4 u1, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6)) (fun (_x : LinearEquiv.{u3, u3, max u4 u1, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6)) => (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (LinearEquiv.hasCoeToFun.{u3, u3, max u4 u1, max u5 u2} R R (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) (Finsupp.lcongr.{u1, u2, u3, u4, u5} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂) (Finsupp.single.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) i m)) (Finsupp.single.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) (coeFn.{max 1 (max (succ u4) (succ u5)) (succ u5) (succ u4), max (succ u4) (succ u5)} (Equiv.{succ u4, succ u5} ι κ) (fun (_x : Equiv.{succ u4, succ u5} ι κ) => ι -> κ) (Equiv.hasCoeToFun.{succ u4, succ u5} ι κ) e₁ i) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) => M -> N) (LinearEquiv.hasCoeToFun.{u3, u3, u1, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) e₂ m))
but is expected to have type
  forall {M : Type.{u2}} {N : Type.{u1}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u3, u1} R N _inst_1 _inst_5] {ι : Type.{u5}} {κ : Type.{u4}} (e₁ : Equiv.{succ u5, succ u4} ι κ) (e₂ : LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (i : ι) (m : M), Eq.{max (succ u1) (succ u4)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.single.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) i m)) (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u4)) (succ u5), max (succ u2) (succ u5), max (succ u1) (succ u4)} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _x) (SMulHomClass.toFunLike.{max (max (max u2 u1) u4) u5, u3, max u2 u5, max u1 u4} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (SMulZeroClass.toSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribSMul.toSMulZeroClass.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribMulAction.toDistribSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toZero.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribSMul.toSMulZeroClass.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toAddZeroClass.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribMulAction.toDistribSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u1) u4) u5, u3, max u2 u5, max u1 u4} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) (SemilinearMapClass.distribMulActionHomClass.{u3, max u2 u5, max u1 u4, max (max (max u2 u1) u4) u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, max u2 u5, max u1 u4, max (max (max u2 u1) u4) u5} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (Finsupp.lcongr.{u2, u1, u3, u5, u4} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂) (Finsupp.single.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) i m)) (Finsupp.single.{u4, u1} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => κ) i) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => N) m) (AddMonoid.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => N) m) (AddCommMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => N) m) _inst_5)) (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Equiv.{succ u5, succ u4} ι κ) ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : ι) => κ) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} ι κ) e₁ i) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => N) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) R M N (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u3, u1} R N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R N (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) R M N (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} R M N (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} R R M N (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) e₂ m))
Case conversion may be inaccurate. Consider using '#align finsupp.lcongr_single Finsupp.lcongr_singleₓ'. -/
@[simp]
theorem lcongr_single {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (i : ι) (m : M) :
    lcongr e₁ e₂ (Finsupp.single i m) = Finsupp.single (e₁ i) (e₂ m) := by simp [lcongr]
#align finsupp.lcongr_single Finsupp.lcongr_single

/- warning: finsupp.lcongr_apply_apply -> Finsupp.lcongr_apply_apply is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}} (e₁ : Equiv.{succ u4, succ u5} ι κ) (e₂ : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (f : Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (k : κ), Eq.{succ u2} N (coeFn.{max (succ u5) (succ u2), max (succ u5) (succ u2)} (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (fun (_x : Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) => κ -> N) (Finsupp.coeFun.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (coeFn.{max (succ (max u4 u1)) (succ (max u5 u2)), max (succ (max u4 u1)) (succ (max u5 u2))} (LinearEquiv.{u3, u3, max u4 u1, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6)) (fun (_x : LinearEquiv.{u3, u3, max u4 u1, max u5 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6)) => (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))))) (LinearEquiv.hasCoeToFun.{u3, u3, max u4 u1, max u5 u2} R R (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) (Finsupp.lcongr.{u1, u2, u3, u4, u5} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂) f) k) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (fun (_x : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) => M -> N) (LinearEquiv.hasCoeToFun.{u3, u3, u1, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) e₂ (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => ι -> M) (Finsupp.coeFun.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) f (coeFn.{max 1 (max (succ u5) (succ u4)) (succ u4) (succ u5), max (succ u5) (succ u4)} (Equiv.{succ u5, succ u4} κ ι) (fun (_x : Equiv.{succ u5, succ u4} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u5, succ u4} κ ι) (Equiv.symm.{succ u4, succ u5} ι κ e₁) k)))
but is expected to have type
  forall {M : Type.{u2}} {N : Type.{u1}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u3, u1} R N _inst_1 _inst_5] {ι : Type.{u5}} {κ : Type.{u4}} (e₁ : Equiv.{succ u5, succ u4} ι κ) (e₂ : LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (f : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (k : κ), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : κ) => N) k) (FunLike.coe.{max (succ u4) (succ u1), succ u4, succ u1} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) κ (fun (_x : κ) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : κ) => N) _x) (Finsupp.funLike.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u5)) (succ u4), max (succ u2) (succ u5), max (succ u1) (succ u4)} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _x) (SMulHomClass.toFunLike.{max (max (max u2 u1) u5) u4, u3, max u2 u5, max u1 u4} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (SMulZeroClass.toSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribSMul.toSMulZeroClass.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribMulAction.toDistribSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toZero.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribSMul.toSMulZeroClass.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toAddZeroClass.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribMulAction.toDistribSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u1) u5) u4, u3, max u2 u5, max u1 u4} (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) (SemilinearMapClass.distribMulActionHomClass.{u3, max u2 u5, max u1 u4, max (max (max u2 u1) u5) u4} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, max u2 u5, max u1 u4, max (max (max u2 u1) u5) u4} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (LinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, max u2 u5, max u1 u4} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (Finsupp.lcongr.{u2, u1, u3, u5, u4} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂) f) k) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => N) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) R M N (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u3, u1} R N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R N (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) R M N (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} R M N (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} R R M N (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) e₂ (FunLike.coe.{max (succ u5) (succ u2), succ u5, succ u2} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => M) _x) (Finsupp.funLike.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f (FunLike.coe.{max (succ u5) (succ u4), succ u4, succ u5} (Equiv.{succ u4, succ u5} κ ι) κ (fun (_x : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u5} κ ι) (Equiv.symm.{succ u5, succ u4} ι κ e₁) k)))
Case conversion may be inaccurate. Consider using '#align finsupp.lcongr_apply_apply Finsupp.lcongr_apply_applyₓ'. -/
@[simp]
theorem lcongr_apply_apply {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (f : ι →₀ M) (k : κ) :
    lcongr e₁ e₂ f k = e₂ (f (e₁.symm k)) :=
  rfl
#align finsupp.lcongr_apply_apply Finsupp.lcongr_apply_apply

/- warning: finsupp.lcongr_symm_single -> Finsupp.lcongr_symm_single is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}} (e₁ : Equiv.{succ u4, succ u5} ι κ) (e₂ : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (k : κ) (n : N), Eq.{max (succ u4) (succ u1)} (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max u5 u2)) (succ (max u4 u1)), max (succ (max u5 u2)) (succ (max u4 u1))} (LinearEquiv.{u3, u3, max u5 u2, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearEquiv.{u3, u3, max u5 u2, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4)) => (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) -> (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearEquiv.hasCoeToFun.{u3, u3, max u5 u2, max u4 u1} R R (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) (LinearEquiv.symm.{u3, u3, max u4 u1, max u5 u2} R R (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.lcongr.{u1, u2, u3, u4, u5} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂)) (Finsupp.single.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5))) k n)) (Finsupp.single.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (coeFn.{max 1 (max (succ u5) (succ u4)) (succ u4) (succ u5), max (succ u5) (succ u4)} (Equiv.{succ u5, succ u4} κ ι) (fun (_x : Equiv.{succ u5, succ u4} κ ι) => κ -> ι) (Equiv.hasCoeToFun.{succ u5, succ u4} κ ι) (Equiv.symm.{succ u4, succ u5} ι κ e₁) k) (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) (fun (_x : LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) => N -> M) (LinearEquiv.hasCoeToFun.{u3, u3, u2, u1} R R N M _inst_1 _inst_1 _inst_5 _inst_3 _inst_6 _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)) (LinearEquiv.symm.{u3, u3, u1, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) e₂) n))
but is expected to have type
  forall {M : Type.{u2}} {N : Type.{u1}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u3, u1} R N _inst_1 _inst_5] {ι : Type.{u5}} {κ : Type.{u4}} (e₁ : Equiv.{succ u5, succ u4} ι κ) (e₂ : LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6) (k : κ) (n : N), Eq.{max (succ u2) (succ u5)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) => Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.single.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) k n)) (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u4)) (succ u5), max (succ u1) (succ u4), max (succ u2) (succ u5)} (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (fun (_x : Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) => Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (SMulHomClass.toFunLike.{max (max (max u2 u1) u4) u5, u3, max u1 u4, max u2 u5} (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulZeroClass.toSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toZero.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribSMul.toSMulZeroClass.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddMonoid.toAddZeroClass.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5))) (DistribMulAction.toDistribSMul.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6))))) (SMulZeroClass.toSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribSMul.toSMulZeroClass.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3))) (DistribMulAction.toDistribSMul.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u1) u4) u5, u3, max u1 u4, max u2 u5} (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u4} (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5)) (AddCommMonoid.toAddMonoid.{max u2 u5} (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3)) (Module.toDistribMulAction.{u3, max u1 u4} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6)) (Module.toDistribMulAction.{u3, max u2 u5} R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) (SemilinearMapClass.distribMulActionHomClass.{u3, max u1 u4, max u2 u5, max (max (max u2 u1) u4) u5} R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, max u1 u4, max u2 u5, max (max (max u2 u1) u4) u5} R R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (LinearEquiv.symm.{u3, u3, max u2 u5, max u1 u4} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.lcongr.{u2, u1, u3, u5, u4} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂)) (Finsupp.single.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) k n)) (Finsupp.single.{u5, u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) k) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N) => M) n) (AddMonoid.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N) => M) n) (AddCommMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N) => M) n) _inst_3)) (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (Equiv.{succ u4, succ u5} κ ι) κ (fun (_x : κ) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : κ) => ι) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u5} κ ι) (Equiv.symm.{succ u5, succ u4} ι κ e₁) k) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) N (fun (_x : N) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : N) => M) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u1, u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) R N M (SMulZeroClass.toSMul.{u3, u1} R N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribSMul.toSMulZeroClass.{u3, u1} R N (AddMonoid.toAddZeroClass.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5)) (DistribMulAction.toDistribSMul.{u3, u1} R N (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6)))) (SMulZeroClass.toSMul.{u3, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribSMul.toSMulZeroClass.{u3, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)) (DistribMulAction.toDistribSMul.{u3, u2} R M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u1, u2} (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) R N M (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u1} N _inst_5) (AddCommMonoid.toAddMonoid.{u2} M _inst_3) (Module.toDistribMulAction.{u3, u1} R N _inst_1 _inst_5 _inst_6) (Module.toDistribMulAction.{u3, u2} R M _inst_1 _inst_3 _inst_4) (SemilinearMapClass.distribMulActionHomClass.{u3, u1, u2, max u2 u1} R N M (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) _inst_1 _inst_5 _inst_3 _inst_6 _inst_4 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u1, u2, max u2 u1} R R N M (LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) N M _inst_5 _inst_3 _inst_6 _inst_4) _inst_1 _inst_1 _inst_5 _inst_3 _inst_6 _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u1, u2} R R N M _inst_1 _inst_1 _inst_5 _inst_3 _inst_6 _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (LinearEquiv.symm.{u3, u3, u2, u1} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) e₂) n))
Case conversion may be inaccurate. Consider using '#align finsupp.lcongr_symm_single Finsupp.lcongr_symm_singleₓ'. -/
theorem lcongr_symm_single {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (k : κ) (n : N) :
    (lcongr e₁ e₂).symm (Finsupp.single k n) = Finsupp.single (e₁.symm k) (e₂.symm n) :=
  by
  apply_fun lcongr e₁ e₂ using (lcongr e₁ e₂).Injective
  simp
#align finsupp.lcongr_symm_single Finsupp.lcongr_symm_single

/- warning: finsupp.lcongr_symm -> Finsupp.lcongr_symm is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} {N : Type.{u2}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u3, u1} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u2} N] [_inst_6 : Module.{u3, u2} R N _inst_1 _inst_5] {ι : Type.{u4}} {κ : Type.{u5}} (e₁ : Equiv.{succ u4, succ u5} ι κ) (e₂ : LinearEquiv.{u3, u3, u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (succ (max u5 u2)) (succ (max u4 u1))} (LinearEquiv.{u3, u3, max u5 u2, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u3, u3, max u4 u1, max u5 u2} R R (Finsupp.{u4, u1} ι M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u5, u2} κ N (AddZeroClass.toHasZero.{u2} N (AddMonoid.toAddZeroClass.{u2} N (AddCommMonoid.toAddMonoid.{u2} N _inst_5)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι M _inst_3) (Finsupp.addCommMonoid.{u5, u2} κ N _inst_5) (Finsupp.module.{u4, u1, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u5, u2, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.lcongr.{u1, u2, u3, u4, u5} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂)) (Finsupp.lcongr.{u2, u1, u3, u5, u4} N M R _inst_1 _inst_5 _inst_6 _inst_3 _inst_4 κ ι (Equiv.symm.{succ u4, succ u5} ι κ e₁) (LinearEquiv.symm.{u3, u3, u1, u2} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) e₂))
but is expected to have type
  forall {M : Type.{u2}} {N : Type.{u1}} {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_1 _inst_3] [_inst_5 : AddCommMonoid.{u1} N] [_inst_6 : Module.{u3, u1} R N _inst_1 _inst_5] {ι : Type.{u5}} {κ : Type.{u4}} (e₁ : Equiv.{succ u5, succ u4} ι κ) (e₂ : LinearEquiv.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) M N _inst_3 _inst_5 _inst_4 _inst_6), Eq.{max (max (max (succ u2) (succ u1)) (succ u4)) (succ u5)} (LinearEquiv.{u3, u3, max u1 u4, max u2 u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4)) (LinearEquiv.symm.{u3, u3, max u2 u5, max u1 u4} R R (Finsupp.{u5, u2} ι M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u4, u1} κ N (AddMonoid.toZero.{u1} N (AddCommMonoid.toAddMonoid.{u1} N _inst_5))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{u5, u2} ι M _inst_3) (Finsupp.addCommMonoid.{u4, u1} κ N _inst_5) (Finsupp.module.{u5, u2, u3} ι M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u3} κ N R _inst_1 _inst_5 _inst_6) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Finsupp.lcongr.{u2, u1, u3, u5, u4} M N R _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 ι κ e₁ e₂)) (Finsupp.lcongr.{u1, u2, u3, u4, u5} N M R _inst_1 _inst_5 _inst_6 _inst_3 _inst_4 κ ι (Equiv.symm.{succ u5, succ u4} ι κ e₁) (LinearEquiv.symm.{u3, u3, u2, u1} R R M N _inst_1 _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) e₂))
Case conversion may be inaccurate. Consider using '#align finsupp.lcongr_symm Finsupp.lcongr_symmₓ'. -/
@[simp]
theorem lcongr_symm {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) :
    (lcongr e₁ e₂).symm = lcongr e₁.symm e₂.symm :=
  by
  ext
  rfl
#align finsupp.lcongr_symm Finsupp.lcongr_symm

section Sum

variable (R)

/- warning: finsupp.sum_finsupp_lequiv_prod_finsupp -> Finsupp.sumFinsuppLEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}}, LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))
but is expected to have type
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}}, LinearEquiv.{u2, u2, max u1 u4 u3, max (max u1 u4) u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u4 u3, u1} (Sum.{u3, u4} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Prod.{max u1 u3, max u1 u4} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.{u4, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u1 u3, max u1 u4} (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.{u4, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u1 u3, max u1 u4} R (Finsupp.{u3, u1} α M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) (Finsupp.{u4, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_lequiv_prod_finsupp Finsupp.sumFinsuppLEquivProdFinsuppₓ'. -/
/-- The linear equivalence between `(α ⊕ β) →₀ M` and `(α →₀ M) × (β →₀ M)`.

This is the `linear_equiv` version of `finsupp.sum_finsupp_equiv_prod_finsupp`. -/
@[simps apply symm_apply]
def sumFinsuppLEquivProdFinsupp {α β : Type _} : (Sum α β →₀ M) ≃ₗ[R] (α →₀ M) × (β →₀ M) :=
  { sumFinsuppAddEquivProdFinsupp with
    map_smul' := by
      intros
      ext <;>
        simp only [[anonymous], Prod.smul_fst, Prod.smul_snd, smul_apply,
          snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp,
          RingHom.id_apply] }
#align finsupp.sum_finsupp_lequiv_prod_finsupp Finsupp.sumFinsuppLEquivProdFinsupp

/- warning: finsupp.fst_sum_finsupp_lequiv_prod_finsupp -> Finsupp.fst_sumFinsuppLEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}} (f : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (x : α), Eq.{succ u1} M (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => α -> M) (Finsupp.coeFun.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.fst.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max (max u3 u4) u1)) (succ (max (max u3 u1) u4 u1)), max (succ (max (max u3 u4) u1)) (succ (max (max u3 u1) u4 u1))} (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))) (fun (_x : LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))) => (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))) (LinearEquiv.hasCoeToFun.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (Finsupp.sumFinsuppLEquivProdFinsupp.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α β) f)) x) (coeFn.{max (succ (max u3 u4)) (succ u1), max (succ (max u3 u4)) (succ u1)} (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => (Sum.{u3, u4} α β) -> M) (Finsupp.coeFun.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) f (Sum.inl.{u3, u4} α β x))
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α : Type.{u4}} {β : Type.{u3}} (f : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) x) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.fst.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toZero.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (Finsupp.sumFinsuppLEquivProdFinsupp.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α β) f)) x) (FunLike.coe.{max (succ (max u4 u3)) (succ u2), succ (max u4 u3), succ u2} (Finsupp.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Sum.{u4, u3} α β) (fun (_x : Sum.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f (Sum.inl.{u4, u3} α β x))
Case conversion may be inaccurate. Consider using '#align finsupp.fst_sum_finsupp_lequiv_prod_finsupp Finsupp.fst_sumFinsuppLEquivProdFinsuppₓ'. -/
theorem fst_sumFinsuppLEquivProdFinsupp {α β : Type _} (f : Sum α β →₀ M) (x : α) :
    (sumFinsuppLEquivProdFinsupp R f).1 x = f (Sum.inl x) :=
  rfl
#align finsupp.fst_sum_finsupp_lequiv_prod_finsupp Finsupp.fst_sumFinsuppLEquivProdFinsupp

/- warning: finsupp.snd_sum_finsupp_lequiv_prod_finsupp -> Finsupp.snd_sumFinsuppLEquivProdFinsupp is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}} (f : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (y : β), Eq.{succ u1} M (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => β -> M) (Finsupp.coeFun.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.snd.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max (max u3 u4) u1)) (succ (max (max u3 u1) u4 u1)), max (succ (max (max u3 u4) u1)) (succ (max (max u3 u1) u4 u1))} (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))) (fun (_x : LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4))) => (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) -> (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))))) (LinearEquiv.hasCoeToFun.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (Finsupp.sumFinsuppLEquivProdFinsupp.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α β) f)) y) (coeFn.{max (succ (max u3 u4)) (succ u1), max (succ (max u3 u4)) (succ u1)} (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => (Sum.{u3, u4} α β) -> M) (Finsupp.coeFun.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) f (Sum.inr.{u3, u4} α β y))
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α : Type.{u4}} {β : Type.{u3}} (f : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (y : β), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) y) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.snd.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (fun (_x : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) => Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toZero.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (LinearEquiv.{u1, u1, max u2 u3 u4, max (max u2 u3) u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (Finsupp.sumFinsuppLEquivProdFinsupp.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α β) f)) y) (FunLike.coe.{max (succ (max u4 u3)) (succ u2), succ (max u4 u3), succ u2} (Finsupp.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Sum.{u4, u3} α β) (fun (_x : Sum.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) f (Sum.inr.{u4, u3} α β y))
Case conversion may be inaccurate. Consider using '#align finsupp.snd_sum_finsupp_lequiv_prod_finsupp Finsupp.snd_sumFinsuppLEquivProdFinsuppₓ'. -/
theorem snd_sumFinsuppLEquivProdFinsupp {α β : Type _} (f : Sum α β →₀ M) (y : β) :
    (sumFinsuppLEquivProdFinsupp R f).2 y = f (Sum.inr y) :=
  rfl
#align finsupp.snd_sum_finsupp_lequiv_prod_finsupp Finsupp.snd_sumFinsuppLEquivProdFinsupp

/- warning: finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inl -> Finsupp.sumFinsuppLEquivProdFinsupp_symm_inl is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}} (fg : Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (x : α), Eq.{succ u1} M (coeFn.{max (succ (max u3 u4)) (succ u1), max (succ (max u3 u4)) (succ u1)} (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => (Sum.{u3, u4} α β) -> M) (Finsupp.coeFun.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max (max u3 u1) u4 u1)) (succ (max (max u3 u4) u1)), max (succ (max (max u3 u1) u4 u1)) (succ (max (max u3 u4) u1))} (LinearEquiv.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearEquiv.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4)) => (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) -> (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearEquiv.hasCoeToFun.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (LinearEquiv.symm.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.sumFinsuppLEquivProdFinsupp.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α β)) fg) (Sum.inl.{u3, u4} α β x)) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => α -> M) (Finsupp.coeFun.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.fst.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) fg) x)
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α : Type.{u4}} {β : Type.{u3}} (fg : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (x : α), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) (Sum.inl.{u4, u3} α β x)) (FunLike.coe.{max (succ (max u4 u3)) (succ u2), succ (max u4 u3), succ u2} (Finsupp.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Sum.{u4, u3} α β) (fun (_x : Sum.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toZero.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.sumFinsuppLEquivProdFinsupp.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α β)) fg) (Sum.inl.{u4, u3} α β x)) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => M) _x) (Finsupp.funLike.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.fst.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) fg) x)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inl Finsupp.sumFinsuppLEquivProdFinsupp_symm_inlₓ'. -/
theorem sumFinsuppLEquivProdFinsupp_symm_inl {α β : Type _} (fg : (α →₀ M) × (β →₀ M)) (x : α) :
    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inl x) = fg.1 x :=
  rfl
#align finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inl Finsupp.sumFinsuppLEquivProdFinsupp_symm_inl

/- warning: finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inr -> Finsupp.sumFinsuppLEquivProdFinsupp_symm_inr is a dubious translation:
lean 3 declaration is
  forall {M : Type.{u1}} (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u1} M] [_inst_4 : Module.{u2, u1} R M _inst_1 _inst_3] {α : Type.{u3}} {β : Type.{u4}} (fg : Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (y : β), Eq.{succ u1} M (coeFn.{max (succ (max u3 u4)) (succ u1), max (succ (max u3 u4)) (succ u1)} (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => (Sum.{u3, u4} α β) -> M) (Finsupp.coeFun.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (coeFn.{max (succ (max (max u3 u1) u4 u1)) (succ (max (max u3 u4) u1)), max (succ (max (max u3 u1) u4 u1)) (succ (max (max u3 u4) u1))} (LinearEquiv.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4)) (fun (_x : LinearEquiv.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4)) => (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) -> (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (LinearEquiv.hasCoeToFun.{u2, u2, max (max u3 u1) u4 u1, max (max u3 u4) u1} R R (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 _inst_1 (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)) (LinearEquiv.symm.{u2, u2, max (max u3 u4) u1, max (max u3 u1) u4 u1} R R (Finsupp.{max u3 u4, u1} (Sum.{u3, u4} α β) M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3))))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u3 u4, u1} (Sum.{u3, u4} α β) M _inst_3) (Prod.addCommMonoid.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3)) (Finsupp.module.{max u3 u4, u1, u2} (Sum.{u3, u4} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u2, max u3 u1, max u4 u1} R (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α M _inst_3) (Finsupp.addCommMonoid.{u4, u1} β M _inst_3) (Finsupp.module.{u3, u1, u2} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u4, u1, u2} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.sumFinsuppLEquivProdFinsupp.{u1, u2, u3, u4} M R _inst_1 _inst_3 _inst_4 α β)) fg) (Sum.inr.{u3, u4} α β y)) (coeFn.{max (succ u4) (succ u1), max (succ u4) (succ u1)} (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (fun (_x : Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) => β -> M) (Finsupp.coeFun.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Prod.snd.{max u3 u1, max u4 u1} (Finsupp.{u3, u1} α M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) (Finsupp.{u4, u1} β M (AddZeroClass.toHasZero.{u1} M (AddMonoid.toAddZeroClass.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_3)))) fg) y)
but is expected to have type
  forall {M : Type.{u2}} (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_3] {α : Type.{u4}} {β : Type.{u3}} (fg : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (y : β), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) (Sum.inr.{u4, u3} α β y)) (FunLike.coe.{max (succ (max u4 u3)) (succ u2), succ (max u4 u3), succ u2} (Finsupp.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Sum.{u4, u3} α β) (fun (_x : Sum.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sum.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (fun (_x : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) => Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toZero.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)))))) (SMulZeroClass.toSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toZero.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribSMul.toSMulZeroClass.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3))) (DistribMulAction.toDistribSMul.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u1, max (max u3 u4) u2, max (max u3 u4) u2} (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u2} (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3)) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4))) (Module.toDistribMulAction.{u1, max (max u3 u4) u2} R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) (SemilinearMapClass.distribMulActionHomClass.{u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2, max (max u3 u4) u2} R R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (LinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4)) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, max (max u3 u4) u2, max (max u3 u4) u2} R R (Finsupp.{max u3 u4, u2} (Sum.{u4, u3} α β) M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sum.{u4, u3} α β) M _inst_3) (Prod.instAddCommMonoidSum.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3)) (Finsupp.module.{max u4 u3, u2, u1} (Sum.{u4, u3} α β) M R _inst_1 _inst_3 _inst_4) (Prod.module.{u1, max u2 u4, max u2 u3} R (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) _inst_1 (Finsupp.addCommMonoid.{u4, u2} α M _inst_3) (Finsupp.addCommMonoid.{u3, u2} β M _inst_3) (Finsupp.module.{u4, u2, u1} α M R _inst_1 _inst_3 _inst_4) (Finsupp.module.{u3, u2, u1} β M R _inst_1 _inst_3 _inst_4)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.sumFinsuppLEquivProdFinsupp.{u2, u1, u4, u3} M R _inst_1 _inst_3 _inst_4 α β)) fg) (Sum.inr.{u4, u3} α β y)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Prod.snd.{max u2 u4, max u2 u3} (Finsupp.{u4, u2} α M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Finsupp.{u3, u2} β M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) fg) y)
Case conversion may be inaccurate. Consider using '#align finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inr Finsupp.sumFinsuppLEquivProdFinsupp_symm_inrₓ'. -/
theorem sumFinsuppLEquivProdFinsupp_symm_inr {α β : Type _} (fg : (α →₀ M) × (β →₀ M)) (y : β) :
    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inr y) = fg.2 y :=
  rfl
#align finsupp.sum_finsupp_lequiv_prod_finsupp_symm_inr Finsupp.sumFinsuppLEquivProdFinsupp_symm_inr

end Sum

section Sigma

variable {η : Type _} [Fintype η] {ιs : η → Type _} [Zero α]

variable (R)

/- warning: finsupp.sigma_finsupp_lequiv_pi_finsupp -> Finsupp.sigmaFinsuppLEquivPiFinsupp is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {η : Type.{u2}} [_inst_9 : Fintype.{u2} η] {M : Type.{u3}} {ιs : η -> Type.{u4}} [_inst_11 : AddCommMonoid.{u3} M] [_inst_12 : Module.{u1, u3} R M _inst_1 _inst_11], LinearEquiv.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12))
but is expected to have type
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {η : Type.{u2}} [_inst_9 : Fintype.{u2} η] {M : Type.{u3}} {ιs : η -> Type.{u4}} [_inst_11 : AddCommMonoid.{u3} M] [_inst_12 : Module.{u1, u3} R M _inst_1 _inst_11], LinearEquiv.{u1, u1, max u3 u4 u2, max (max u2 u3) u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u4 u2, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u3 u4} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u3 u4, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_finsupp_lequiv_pi_finsupp Finsupp.sigmaFinsuppLEquivPiFinsuppₓ'. -/
/-- On a `fintype η`, `finsupp.split` is a linear equivalence between
`(Σ (j : η), ιs j) →₀ M` and `Π j, (ιs j →₀ M)`.

This is the `linear_equiv` version of `finsupp.sigma_finsupp_add_equiv_pi_finsupp`. -/
noncomputable def sigmaFinsuppLEquivPiFinsupp {M : Type _} {ιs : η → Type _} [AddCommMonoid M]
    [Module R M] : ((Σj, ιs j) →₀ M) ≃ₗ[R] ∀ j, ιs j →₀ M :=
  { sigmaFinsuppAddEquivPiFinsupp with
    map_smul' := fun c f => by
      ext
      simp }
#align finsupp.sigma_finsupp_lequiv_pi_finsupp Finsupp.sigmaFinsuppLEquivPiFinsupp

/- warning: finsupp.sigma_finsupp_lequiv_pi_finsupp_apply -> Finsupp.sigmaFinsuppLEquivPiFinsupp_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {η : Type.{u2}} [_inst_9 : Fintype.{u2} η] {M : Type.{u3}} {ιs : η -> Type.{u4}} [_inst_11 : AddCommMonoid.{u3} M] [_inst_12 : Module.{u1, u3} R M _inst_1 _inst_11] (f : Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (j : η) (i : ιs j), Eq.{succ u3} M (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (_x : Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) => (ιs j) -> M) (Finsupp.coeFun.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (coeFn.{max (succ (max (max u2 u4) u3)) (succ (max u2 u4 u3)), max (succ (max (max u2 u4) u3)) (succ (max u2 u4 u3))} (LinearEquiv.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12))) (fun (_x : LinearEquiv.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12))) => (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) -> (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))))) (LinearEquiv.hasCoeToFun.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (Finsupp.sigmaFinsuppLEquivPiFinsupp.{u1, u2, u3, u4} R _inst_1 η _inst_9 M (fun (j : η) => ιs j) _inst_11 _inst_12) f j) i) (coeFn.{max (succ (max u2 u4)) (succ u3), max (succ (max u2 u4)) (succ u3)} (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (_x : Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) => (Sigma.{u2, u4} η (fun (j : η) => ιs j)) -> M) (Finsupp.coeFun.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) f (Sigma.mk.{u2, u4} η (fun (j : η) => ιs j) j i))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {η : Type.{u1}} [_inst_9 : Fintype.{u1} η] {M : Type.{u4}} {ιs : η -> Type.{u3}} [_inst_11 : AddCommMonoid.{u4} M] [_inst_12 : Module.{u2, u4} R M _inst_1 _inst_11] (f : Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (j : η) (i : ιs j), Eq.{succ u4} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs j) => M) i) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (ιs j) (fun (_x : ιs j) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs j) => M) _x) (Finsupp.funLike.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (max (succ u3) (succ u4)) (succ u1), max (max (succ u3) (succ u4)) (succ u1)} (LinearEquiv.{u2, u2, max u4 u3 u1, max (max u1 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (i : η) => ιs i)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (_x : Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (i : η) => ιs i)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) => forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u1, u2, max (max u3 u4) u1, max (max u3 u4) u1} (LinearEquiv.{u2, u2, max u4 u3 u1, max (max u1 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (SMulZeroClass.toSMul.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toZero.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11))) (DistribSMul.toSMulZeroClass.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11))) (DistribMulAction.toDistribSMul.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11)) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12))))) (SMulZeroClass.toSMul.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toZero.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)))) (DistribSMul.toSMulZeroClass.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)))) (DistribMulAction.toDistribSMul.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11))) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u1, u2, max (max u3 u4) u1, max (max u3 u4) u1} (LinearEquiv.{u2, u2, max u4 u3 u1, max (max u1 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11))) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) (SemilinearMapClass.distribMulActionHomClass.{u2, max (max u3 u4) u1, max (max u3 u4) u1, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (LinearEquiv.{u2, u2, max u4 u3 u1, max (max u1 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1, max (max u3 u4) u1} R R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (LinearEquiv.{u2, u2, max u4 u3 u1, max (max u1 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (Finsupp.sigmaFinsuppLEquivPiFinsupp.{u2, u1, u4, u3} R _inst_1 η _inst_9 M (fun (j : η) => ιs j) _inst_11 _inst_12) f j) i) (FunLike.coe.{max (succ (max u1 u3)) (succ u4), succ (max u1 u3), succ u4} (Finsupp.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Sigma.{u1, u3} η (fun (j : η) => ιs j)) (fun (_x : Sigma.{u1, u3} η (fun (j : η) => ιs j)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u3} η (fun (j : η) => ιs j)) => M) _x) (Finsupp.funLike.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) f (Sigma.mk.{u1, u3} η (fun (j : η) => ιs j) j i))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_finsupp_lequiv_pi_finsupp_apply Finsupp.sigmaFinsuppLEquivPiFinsupp_applyₓ'. -/
@[simp]
theorem sigmaFinsuppLEquivPiFinsupp_apply {M : Type _} {ιs : η → Type _} [AddCommMonoid M]
    [Module R M] (f : (Σj, ιs j) →₀ M) (j i) : sigmaFinsuppLEquivPiFinsupp R f j i = f ⟨j, i⟩ :=
  rfl
#align finsupp.sigma_finsupp_lequiv_pi_finsupp_apply Finsupp.sigmaFinsuppLEquivPiFinsupp_apply

/- warning: finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply -> Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) [_inst_1 : Semiring.{u1} R] {η : Type.{u2}} [_inst_9 : Fintype.{u2} η] {M : Type.{u3}} {ιs : η -> Type.{u4}} [_inst_11 : AddCommMonoid.{u3} M] [_inst_12 : Module.{u1, u3} R M _inst_1 _inst_11] (f : forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (ji : Sigma.{u2, u4} η (fun (j : η) => ιs j)), Eq.{succ u3} M (coeFn.{max (succ (max u2 u4)) (succ u3), max (succ (max u2 u4)) (succ u3)} (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (_x : Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) => (Sigma.{u2, u4} η (fun (j : η) => ιs j)) -> M) (Finsupp.coeFun.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (coeFn.{max (succ (max u2 u4 u3)) (succ (max (max u2 u4) u3)), max (succ (max u2 u4 u3)) (succ (max (max u2 u4) u3))} (LinearEquiv.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) (fun (_x : LinearEquiv.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) => (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) -> (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11))))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u4 u3, max (max u2 u4) u3} R R (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, max (max u2 u4) u3, max u2 u4 u3} R R (Finsupp.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (forall (j : η), Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u2 u4, u3} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u2, max u4 u3} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11)) (Finsupp.module.{max u2 u4, u3, u1} (Sigma.{u2, u4} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u2, max u4 u3, u1} η (fun (j : η) => Finsupp.{u4, u3} (ιs j) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u4, u3} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u4, u3, u1} (ιs i) M R _inst_1 _inst_11 _inst_12)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Finsupp.sigmaFinsuppLEquivPiFinsupp.{u1, u2, u3, u4} R _inst_1 η _inst_9 M (fun (j : η) => ιs j) _inst_11 _inst_12)) f) ji) (coeFn.{max (succ u4) (succ u3), max (succ u4) (succ u3)} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u2, u4} η (fun (j : η) => ιs j) ji)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (fun (_x : Finsupp.{u4, u3} (ιs (Sigma.fst.{u2, u4} η (fun (j : η) => ιs j) ji)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) => (ιs (Sigma.fst.{u2, u4} η (fun (j : η) => ιs j) ji)) -> M) (Finsupp.coeFun.{u4, u3} (ιs (Sigma.fst.{u2, u4} η (fun (j : η) => ιs j) ji)) M (AddZeroClass.toHasZero.{u3} M (AddMonoid.toAddZeroClass.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_11)))) (f (Sigma.fst.{u2, u4} η (fun (j : η) => ιs j) ji)) (Sigma.snd.{u2, u4} η (fun (j : η) => ιs j) ji))
but is expected to have type
  forall (R : Type.{u2}) [_inst_1 : Semiring.{u2} R] {η : Type.{u1}} [_inst_9 : Fintype.{u1} η] {M : Type.{u4}} {ιs : η -> Type.{u3}} [_inst_11 : AddCommMonoid.{u4} M] [_inst_12 : Module.{u2, u4} R M _inst_1 _inst_11] (f : forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (ji : Sigma.{u1, u3} η (fun (j : η) => ιs j)), Eq.{succ u4} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u3} η (fun (j : η) => ιs j)) => M) ji) (FunLike.coe.{max (succ (max u1 u3)) (succ u4), succ (max u1 u3), succ u4} (Finsupp.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Sigma.{u1, u3} η (fun (j : η) => ιs j)) (fun (_x : Sigma.{u1, u3} η (fun (j : η) => ιs j)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u3} η (fun (j : η) => ιs j)) => M) _x) (Finsupp.funLike.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (max (succ u3) (succ u4)) (succ u1), max (max (succ u3) (succ u4)) (succ u1)} (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (_x : forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) => Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u1, u2, max (max u3 u4) u1, max (max u3 u4) u1} (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (SMulZeroClass.toSMul.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toZero.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)))) (DistribSMul.toSMulZeroClass.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)))) (DistribMulAction.toDistribSMul.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11))) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)))))) (SMulZeroClass.toSMul.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toZero.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11))) (DistribSMul.toSMulZeroClass.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddMonoid.toAddZeroClass.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11))) (DistribMulAction.toDistribSMul.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11)) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u1, u2, max (max u3 u4) u1, max (max u3 u4) u1} (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11))) (AddCommMonoid.toAddMonoid.{max (max u3 u4) u1} (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11)) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12))) (Module.toDistribMulAction.{u2, max (max u3 u4) u1} R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) (SemilinearMapClass.distribMulActionHomClass.{u2, max (max u3 u4) u1, max (max u3 u4) u1, max (max u3 u4) u1} R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1, max (max u3 u4) u1} R R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (LinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12)) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (LinearEquiv.symm.{u2, u2, max (max u3 u4) u1, max (max u3 u4) u1} R R (Finsupp.{max u3 u1, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (forall (j : η), Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) _inst_1 _inst_1 (Finsupp.addCommMonoid.{max u1 u3, u4} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M _inst_11) (Pi.addCommMonoid.{u1, max u4 u3} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11)) (Finsupp.module.{max u1 u3, u4, u2} (Sigma.{u1, u3} η (fun (j : η) => ιs j)) M R _inst_1 _inst_11 _inst_12) (Pi.module.{u1, max u4 u3, u2} η (fun (j : η) => Finsupp.{u3, u4} (ιs j) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) R _inst_1 (fun (i : η) => Finsupp.addCommMonoid.{u3, u4} (ιs i) M _inst_11) (fun (i : η) => Finsupp.module.{u3, u4, u2} (ιs i) M R _inst_1 _inst_11 _inst_12)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (Finsupp.sigmaFinsuppLEquivPiFinsupp.{u2, u1, u4, u3} R _inst_1 η _inst_9 M (fun (j : η) => ιs j) _inst_11 _inst_12)) f) ji) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (Finsupp.{u3, u4} (ιs (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (ιs (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) (fun (_x : ιs (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) => M) _x) (Finsupp.funLike.{u3, u4} (ιs (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_11))) (f (Sigma.fst.{u1, u3} η (fun (j : η) => ιs j) ji)) (Sigma.snd.{u1, u3} η (fun (j : η) => ιs j) ji))
Case conversion may be inaccurate. Consider using '#align finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_applyₓ'. -/
@[simp]
theorem sigmaFinsuppLEquivPiFinsupp_symm_apply {M : Type _} {ιs : η → Type _} [AddCommMonoid M]
    [Module R M] (f : ∀ j, ιs j →₀ M) (ji) :
    (Finsupp.sigmaFinsuppLEquivPiFinsupp R).symm f ji = f ji.1 ji.2 :=
  rfl
#align finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply

end Sigma

section Prod

/- warning: finsupp.finsupp_prod_lequiv -> Finsupp.finsuppProdLEquiv is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} (R : Type.{u3}) {M : Type.{u4}} [_inst_9 : Semiring.{u3} R] [_inst_10 : AddCommMonoid.{u4} M] [_inst_11 : Module.{u3, u4} R M _inst_9 _inst_10], LinearEquiv.{u3, u3, max (max u1 u2) u4, max u1 u2 u4} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11))
but is expected to have type
  forall {α : Type.{u1}} {β : Type.{u2}} (R : Type.{u3}) {M : Type.{u4}} [_inst_9 : Semiring.{u3} R] [_inst_10 : AddCommMonoid.{u4} M] [_inst_11 : Module.{u3, u4} R M _inst_9 _inst_10], LinearEquiv.{u3, u3, max u4 u2 u1, max (max u4 u2) u1} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{max u2 u1, u4} (Prod.{u1, u2} α β) M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))) (Finsupp.{u1, max u4 u2} α (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))) (Finsupp.zero.{u2, u4} β M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11))
Case conversion may be inaccurate. Consider using '#align finsupp.finsupp_prod_lequiv Finsupp.finsuppProdLEquivₓ'. -/
/-- The linear equivalence between `α × β →₀ M` and `α →₀ β →₀ M`.

This is the `linear_equiv` version of `finsupp.finsupp_prod_equiv`. -/
noncomputable def finsuppProdLEquiv {α β : Type _} (R : Type _) {M : Type _} [Semiring R]
    [AddCommMonoid M] [Module R M] : (α × β →₀ M) ≃ₗ[R] α →₀ β →₀ M :=
  {
    finsuppProdEquiv with
    map_add' := fun f g => by
      ext
      simp [finsupp_prod_equiv, curry_apply]
    map_smul' := fun c f => by
      ext
      simp [finsupp_prod_equiv, curry_apply] }
#align finsupp.finsupp_prod_lequiv Finsupp.finsuppProdLEquiv

/- warning: finsupp.finsupp_prod_lequiv_apply -> Finsupp.finsuppProdLEquiv_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} [_inst_9 : Semiring.{u3} R] [_inst_10 : AddCommMonoid.{u4} M] [_inst_11 : Module.{u3, u4} R M _inst_9 _inst_10] (f : Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (x : α) (y : β), Eq.{succ u4} M (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (fun (_x : Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) => β -> M) (Finsupp.coeFun.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (coeFn.{max (succ u1) (succ (max u2 u4)), max (succ u1) (succ (max u2 u4))} (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (fun (_x : Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) => α -> (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.coeFun.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (coeFn.{max (succ (max (max u1 u2) u4)) (succ (max u1 u2 u4)), max (succ (max (max u1 u2) u4)) (succ (max u1 u2 u4))} (LinearEquiv.{u3, u3, max (max u1 u2) u4, max u1 u2 u4} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11))) (fun (_x : LinearEquiv.{u3, u3, max (max u1 u2) u4, max u1 u2 u4} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11))) => (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) -> (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))))) (LinearEquiv.hasCoeToFun.{u3, u3, max (max u1 u2) u4, max u1 u2 u4} R R (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9)) (Finsupp.finsuppProdLEquiv.{u1, u2, u3, u4} α β R M _inst_9 _inst_10 _inst_11) f) x) y) (coeFn.{max (succ (max u1 u2)) (succ u4), max (succ (max u1 u2)) (succ u4)} (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (fun (_x : Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) => (Prod.{u1, u2} α β) -> M) (Finsupp.coeFun.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) f (Prod.mk.{u1, u2} α β x y))
but is expected to have type
  forall {α : Type.{u4}} {β : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_9 : Semiring.{u2} R] [_inst_10 : AddCommMonoid.{u1} M] [_inst_11 : Module.{u2, u1} R M _inst_9 _inst_10] (f : Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (x : α) (y : β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) y) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (FunLike.coe.{max (succ u4) (succ (max u3 u1)), succ u4, succ (max u3 u1)} (Finsupp.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _x) (Finsupp.funLike.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (max (succ u1) (succ u3)) (succ u4), max (max (succ u1) (succ u3)) (succ u4)} (LinearEquiv.{u2, u2, max u1 u3 u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (fun (_x : Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) => Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _x) (SMulHomClass.toFunLike.{max (max u1 u3) u4, u2, max (max u1 u3) u4, max (max u1 u3) u4} (LinearEquiv.{u2, u2, max u1 u3 u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (SMulZeroClass.toSMul.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddMonoid.toZero.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10))) (DistribSMul.toSMulZeroClass.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10))) (DistribMulAction.toDistribSMul.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10)) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11))))) (SMulZeroClass.toSMul.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddMonoid.toZero.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)))) (DistribSMul.toSMulZeroClass.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)))) (DistribMulAction.toDistribSMul.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10))) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u1 u3) u4, u2, max (max u1 u3) u4, max (max u1 u3) u4} (LinearEquiv.{u2, u2, max u1 u3 u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10))) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) (SemilinearMapClass.distribMulActionHomClass.{u2, max (max u1 u3) u4, max (max u1 u3) u4, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (LinearEquiv.{u2, u2, max u1 u3 u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4, max (max u1 u3) u4} R R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (LinearEquiv.{u2, u2, max u1 u3 u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9)))))) (Finsupp.finsuppProdLEquiv.{u4, u3, u2, u1} α β R M _inst_9 _inst_10 _inst_11) f) x) y) (FunLike.coe.{max (succ (max u4 u3)) (succ u1), succ (max u4 u3), succ u1} (Finsupp.{max u4 u3, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Prod.{u4, u3} α β) (fun (_x : Prod.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Prod.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) f (Prod.mk.{u4, u3} α β x y))
Case conversion may be inaccurate. Consider using '#align finsupp.finsupp_prod_lequiv_apply Finsupp.finsuppProdLEquiv_applyₓ'. -/
@[simp]
theorem finsuppProdLEquiv_apply {α β R M : Type _} [Semiring R] [AddCommMonoid M] [Module R M]
    (f : α × β →₀ M) (x y) : finsuppProdLEquiv R f x y = f (x, y) := by
  rw [finsupp_prod_lequiv, LinearEquiv.coe_mk, finsupp_prod_equiv, Finsupp.curry_apply]
#align finsupp.finsupp_prod_lequiv_apply Finsupp.finsuppProdLEquiv_apply

/- warning: finsupp.finsupp_prod_lequiv_symm_apply -> Finsupp.finsuppProdLEquiv_symm_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {R : Type.{u3}} {M : Type.{u4}} [_inst_9 : Semiring.{u3} R] [_inst_10 : AddCommMonoid.{u4} M] [_inst_11 : Module.{u3, u4} R M _inst_9 _inst_10] (f : Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (xy : Prod.{u1, u2} α β), Eq.{succ u4} M (coeFn.{max (succ (max u1 u2)) (succ u4), max (succ (max u1 u2)) (succ u4)} (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (fun (_x : Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) => (Prod.{u1, u2} α β) -> M) (Finsupp.coeFun.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (coeFn.{max (succ (max u1 u2 u4)) (succ (max (max u1 u2) u4)), max (succ (max u1 u2 u4)) (succ (max (max u1 u2) u4))} (LinearEquiv.{u3, u3, max u1 u2 u4, max (max u1 u2) u4} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11)) (fun (_x : LinearEquiv.{u3, u3, max u1 u2 u4, max (max u1 u2) u4} R R _inst_9 _inst_9 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11)) => (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) -> (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (LinearEquiv.hasCoeToFun.{u3, u3, max u1 u2 u4, max (max u1 u2) u4} R R (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9)) (LinearEquiv.symm.{u3, u3, max (max u1 u2) u4, max u1 u2 u4} R R (Finsupp.{max u1 u2, u4} (Prod.{u1, u2} α β) M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{max u1 u2, u4} (Prod.{u1, u2} α β) M _inst_10) (Finsupp.addCommMonoid.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.addCommMonoid.{u2, u4} β M _inst_10)) (Finsupp.module.{max u1 u2, u4, u3} (Prod.{u1, u2} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u1, max u2 u4, u3} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) R _inst_9 (Finsupp.addCommMonoid.{u2, u4} β M _inst_10) (Finsupp.module.{u2, u4, u3} β M R _inst_9 _inst_10 _inst_11)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_9)) (RingHomInvPair.ids.{u3} R _inst_9) (RingHomInvPair.ids.{u3} R _inst_9) (Finsupp.finsuppProdLEquiv.{u1, u2, u3, u4} α β R M _inst_9 _inst_10 _inst_11)) f) xy) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (fun (_x : Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) => β -> M) (Finsupp.coeFun.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (coeFn.{max (succ u1) (succ (max u2 u4)), max (succ u1) (succ (max u2 u4))} (Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (fun (_x : Finsupp.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) => α -> (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) (Finsupp.coeFun.{u1, max u2 u4} α (Finsupp.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10)))) (Finsupp.zero.{u2, u4} β M (AddZeroClass.toHasZero.{u4} M (AddMonoid.toAddZeroClass.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_10))))) f (Prod.fst.{u1, u2} α β xy)) (Prod.snd.{u1, u2} α β xy))
but is expected to have type
  forall {α : Type.{u4}} {β : Type.{u3}} {R : Type.{u2}} {M : Type.{u1}} [_inst_9 : Semiring.{u2} R] [_inst_10 : AddCommMonoid.{u1} M] [_inst_11 : Module.{u2, u1} R M _inst_9 _inst_10] (f : Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (xy : Prod.{u4, u3} α β), Eq.{succ u1} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Prod.{u4, u3} α β) => M) xy) (FunLike.coe.{max (succ (max u4 u3)) (succ u1), succ (max u4 u3), succ u1} (Finsupp.{max u4 u3, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Prod.{u4, u3} α β) (fun (_x : Prod.{u4, u3} α β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Prod.{u4, u3} α β) => M) _x) (Finsupp.funLike.{max u4 u3, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (max (succ u1) (succ u3)) (succ u4), max (max (succ u1) (succ u3)) (succ u4)} (LinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (fun (_x : Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) => Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _x) (SMulHomClass.toFunLike.{max (max u1 u3) u4, u2, max (max u1 u3) u4, max (max u1 u3) u4} (LinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (SMulZeroClass.toSMul.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddMonoid.toZero.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)))) (DistribSMul.toSMulZeroClass.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)))) (DistribMulAction.toDistribSMul.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10))) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)))))) (SMulZeroClass.toSMul.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddMonoid.toZero.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10))) (DistribSMul.toSMulZeroClass.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddMonoid.toAddZeroClass.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10))) (DistribMulAction.toDistribSMul.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10)) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u1 u3) u4, u2, max (max u1 u3) u4, max (max u1 u3) u4} (LinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_9)) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10))) (AddCommMonoid.toAddMonoid.{max (max u1 u3) u4} (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10)) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11))) (Module.toDistribMulAction.{u2, max (max u1 u3) u4} R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) (SemilinearMapClass.distribMulActionHomClass.{u2, max (max u1 u3) u4, max (max u1 u3) u4, max (max u1 u3) u4} R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (LinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4, max (max u1 u3) u4} R R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (LinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R _inst_9 _inst_9 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11)) _inst_9 _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9)))))) (LinearEquiv.symm.{u2, u2, max (max u1 u3) u4, max (max u1 u3) u4} R R (Finsupp.{max u3 u4, u1} (Prod.{u4, u3} α β) M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.{u4, max u1 u3} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) _inst_9 _inst_9 (Finsupp.addCommMonoid.{max u4 u3, u1} (Prod.{u4, u3} α β) M _inst_10) (Finsupp.addCommMonoid.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.addCommMonoid.{u3, u1} β M _inst_10)) (Finsupp.module.{max u4 u3, u1, u2} (Prod.{u4, u3} α β) M R _inst_9 _inst_10 _inst_11) (Finsupp.module.{u4, max u3 u1, u2} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) R _inst_9 (Finsupp.addCommMonoid.{u3, u1} β M _inst_10) (Finsupp.module.{u3, u1, u2} β M R _inst_9 _inst_10 _inst_11)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_9)) (RingHomInvPair.ids.{u2} R _inst_9) (RingHomInvPair.ids.{u2} R _inst_9) (Finsupp.finsuppProdLEquiv.{u4, u3, u2, u1} α β R M _inst_9 _inst_10 _inst_11)) f) xy) (FunLike.coe.{max (succ u3) (succ u1), succ u3, succ u1} (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) β (fun (_x : β) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : β) => M) _x) (Finsupp.funLike.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (FunLike.coe.{max (succ u4) (succ (max u3 u1)), succ u4, succ (max u3 u1)} (Finsupp.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) α (fun (_x : α) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : α) => Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) _x) (Finsupp.funLike.{u4, max u3 u1} α (Finsupp.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10))) (Finsupp.zero.{u3, u1} β M (AddMonoid.toZero.{u1} M (AddCommMonoid.toAddMonoid.{u1} M _inst_10)))) f (Prod.fst.{u4, u3} α β xy)) (Prod.snd.{u4, u3} α β xy))
Case conversion may be inaccurate. Consider using '#align finsupp.finsupp_prod_lequiv_symm_apply Finsupp.finsuppProdLEquiv_symm_applyₓ'. -/
@[simp]
theorem finsuppProdLEquiv_symm_apply {α β R M : Type _} [Semiring R] [AddCommMonoid M] [Module R M]
    (f : α →₀ β →₀ M) (xy) : (finsuppProdLEquiv R).symm f xy = f xy.1 xy.2 := by
  conv_rhs =>
    rw [← (finsupp_prod_lequiv R).apply_symm_apply f, finsupp_prod_lequiv_apply, Prod.mk.eta]
#align finsupp.finsupp_prod_lequiv_symm_apply Finsupp.finsuppProdLEquiv_symm_apply

end Prod

end Finsupp

section Fintype

variable {α M : Type _} (R : Type _) [Fintype α] [Semiring R] [AddCommMonoid M] [Module R M]

variable (S : Type _) [Semiring S] [Module S M] [SMulCommClass R S M]

variable (v : α → M)

#print Fintype.total /-
/-- `fintype.total R S v f` is the linear combination of vectors in `v` with weights in `f`.
This variant of `finsupp.total` is defined on fintype indexed vectors.

This map is linear in `v` if `R` is commutative, and always linear in `f`.
See note [bundled maps over different rings] for why separate `R` and `S` semirings are used.
-/
protected def Fintype.total : (α → M) →ₗ[S] (α → R) →ₗ[R] M
    where
  toFun v :=
    { toFun := fun f => ∑ i, f i • v i
      map_add' := fun f g => by
        simp_rw [← Finset.sum_add_distrib, ← add_smul]
        rfl
      map_smul' := fun r f => by
        simp_rw [Finset.smul_sum, smul_smul]
        rfl }
  map_add' u v := by
    ext
    simp [Finset.sum_add_distrib, Pi.add_apply, smul_add]
  map_smul' r v := by
    ext
    simp [Finset.smul_sum, smul_comm _ r]
#align fintype.total Fintype.total
-/

variable {S}

/- warning: fintype.total_apply -> Fintype.total_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] {S : Type.{u4}} [_inst_5 : Semiring.{u4} S] [_inst_6 : Module.{u4, u2} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u4, u2} R S M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u4, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u4, u2} S M (MulZeroClass.toHasZero.{u4} S (MulZeroOneClass.toMulZeroClass.{u4} S (MonoidWithZero.toMulZeroOneClass.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u2} S M (Semiring.toMonoidWithZero.{u4} S _inst_5) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u4, u2} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (f : α -> R), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) => (α -> R) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (coeFn.{max (succ (max u1 u2)) (succ (max (max u1 u3) u2)), max (succ (max u1 u2)) (succ (max (max u1 u3) u2))} (LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) => (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4)) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, max (max u1 u3) u2} S S (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5))) (Fintype.total.{u1, u2, u3, u4} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) f) (Finset.sum.{u2, u1} M α _inst_3 (Finset.univ.{u1} α _inst_1) (fun (i : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (f i) (v i)))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u4}} (R : Type.{u2}) [_inst_1 : Fintype.{u3} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u2, u4} R M _inst_2 _inst_3] {S : Type.{u1}} [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u1, u4} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u2, u1, u4} R S M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u4} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u2, u4} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u4} S M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u4} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u4} S M (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u1, u4} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (f : α -> R), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) f) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u2), succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) v) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), max (max (succ u2) (succ u4)) (succ u3)} (LinearMap.{u1, u1, max u3 u4, max u4 u3 u2} S S _inst_5 _inst_5 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5)) (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u3, u4} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7)) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u3, max (max u2 u4) u3} S S (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u3, u4} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5))) (Fintype.total.{u3, u4, u2, u1} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) f) (Finset.sum.{u4, u3} M α _inst_3 (Finset.univ.{u3} α _inst_1) (fun (i : α) => HSMul.hSMul.{u2, u4, u4} R M M (instHSMul.{u2, u4} R M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u4} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u2, u4} R M _inst_2 _inst_3 _inst_4))))) (f i) (v i)))
Case conversion may be inaccurate. Consider using '#align fintype.total_apply Fintype.total_applyₓ'. -/
theorem Fintype.total_apply (f) : Fintype.total R S v f = ∑ i, f i • v i :=
  rfl
#align fintype.total_apply Fintype.total_apply

/- warning: fintype.total_apply_single -> Fintype.total_apply_single is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] {S : Type.{u4}} [_inst_5 : Semiring.{u4} S] [_inst_6 : Module.{u4, u2} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u4, u2} R S M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u4, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u4, u2} S M (MulZeroClass.toHasZero.{u4} S (MulZeroOneClass.toMulZeroClass.{u4} S (MonoidWithZero.toMulZeroOneClass.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u2} S M (Semiring.toMonoidWithZero.{u4} S _inst_5) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u4, u2} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (i : α) (r : R), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) => (α -> R) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (coeFn.{max (succ (max u1 u2)) (succ (max (max u1 u3) u2)), max (succ (max u1 u2)) (succ (max (max u1 u3) u2))} (LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) => (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4)) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, max (max u1 u3) u2} S S (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5))) (Fintype.total.{u1, u2, u3, u4} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) (Pi.single.{u1, u3} α (fun (ᾰ : α) => R) (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u1} α a b)) (fun (i : α) => MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) i r)) (SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) r (v i))
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u4}} (R : Type.{u2}) [_inst_1 : Fintype.{u3} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u2, u4} R M _inst_2 _inst_3] {S : Type.{u1}} [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u1, u4} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u2, u1, u4} R S M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u4} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u2, u4} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u4} S M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u4} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u4} S M (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u1, u4} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (i : α) (r : R), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) (Pi.single.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u3} α a b)) (fun (i : α) => MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) i r)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u2), succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) v) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), max (max (succ u2) (succ u4)) (succ u3)} (LinearMap.{u1, u1, max u3 u4, max u4 u3 u2} S S _inst_5 _inst_5 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5)) (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u3, u4} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7)) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u3, max (max u2 u4) u3} S S (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u3, u4} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5))) (Fintype.total.{u3, u4, u2, u1} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) (Pi.single.{u3, u2} α (fun (ᾰ : α) => R) (fun (a : α) (b : α) => Classical.propDecidable (Eq.{succ u3} α a b)) (fun (i : α) => MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) i r)) (HSMul.hSMul.{u2, u4, u4} R M M (instHSMul.{u2, u4} R M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u4} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u2, u4} R M _inst_2 _inst_3 _inst_4))))) r (v i))
Case conversion may be inaccurate. Consider using '#align fintype.total_apply_single Fintype.total_apply_singleₓ'. -/
@[simp]
theorem Fintype.total_apply_single (i : α) (r : R) :
    Fintype.total R S v (Pi.single i r) = r • v i :=
  by
  simp_rw [Fintype.total_apply, Pi.single_apply, ite_smul, zero_smul]
  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ _)]
#align fintype.total_apply_single Fintype.total_apply_single

variable (S)

/- warning: finsupp.total_eq_fintype_total_apply -> Finsupp.total_eq_fintype_total_apply is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] (S : Type.{u4}) [_inst_5 : Semiring.{u4} S] [_inst_6 : Module.{u4, u2} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u4, u2} R S M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u4, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u4, u2} S M (MulZeroClass.toHasZero.{u4} S (MulZeroOneClass.toMulZeroClass.{u4} S (MonoidWithZero.toMulZeroOneClass.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u2} S M (Semiring.toMonoidWithZero.{u4} S _inst_5) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u4, u2} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (x : α -> R), Eq.{succ u2} M (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) => (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))) M _inst_2 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Finsupp.total.{u1, u2, u3} α M R _inst_2 _inst_3 _inst_4 v) (coeFn.{succ (max u1 u3), succ (max u1 u3)} (LinearEquiv.{u3, u3, max u1 u3, max u1 u3} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2) (α -> R) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2))) (fun (_x : LinearEquiv.{u3, u3, max u1 u3, max u1 u3} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2) (α -> R) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2))) => (α -> R) -> (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))))))) (LinearEquiv.hasCoeToFun.{u3, u3, max u1 u3, max u1 u3} R R (α -> R) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2)) (LinearEquiv.symm.{u3, u3, max u1 u3, max u1 u3} R R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) (α -> R) _inst_2 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2) (Finsupp.linearEquivFunOnFinite.{u3, u3, u1} R R α (Finite.of_fintype.{u1} α _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) _inst_2 (Semiring.toModule.{u3} R _inst_2))) x)) (coeFn.{max (succ (max u1 u3)) (succ u2), max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (fun (_x : LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) => (α -> R) -> M) (LinearMap.hasCoeToFun.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (coeFn.{max (succ (max u1 u2)) (succ (max (max u1 u3) u2)), max (succ (max u1 u2)) (succ (max (max u1 u3) u2))} (LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) => (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4)) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, max (max u1 u3) u2} S S (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5))) (Fintype.total.{u1, u2, u3, u4} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) x)
but is expected to have type
  forall {α : Type.{u3}} {M : Type.{u4}} (R : Type.{u2}) [_inst_1 : Fintype.{u3} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u2, u4} R M _inst_2 _inst_3] (S : Type.{u1}) [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u1, u4} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u2, u1, u4} R S M (SMulZeroClass.toSMul.{u2, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u4} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u4} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u2, u4} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u4} S M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u4} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u4} S M (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u1, u4} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M) (x : α -> R), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) => M) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) (α -> R) (fun (a : α -> R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> R) => Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) a) (SMulHomClass.toFunLike.{max u3 u2, u2, max u3 u2, max u3 u2} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (SMulZeroClass.toSMul.{u2, max u3 u2} R (α -> R) (AddMonoid.toZero.{max u3 u2} (α -> R) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u2} R (α -> R) (AddMonoid.toAddZeroClass.{max u3 u2} (α -> R) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u2, max u3 u2} R (α -> R) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)))))) (SMulZeroClass.toSMul.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddMonoid.toZero.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u2, u2, max u3 u2, max u3 u2} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2))) (Module.toDistribMulAction.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) (SemilinearMapClass.distribMulActionHomClass.{u2, max u3 u2, max u3 u2, max u3 u2} R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max u3 u2, max u3 u2, max u3 u2} R R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2)))))) (LinearEquiv.symm.{u2, u2, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (α -> R) _inst_2 _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (Finsupp.linearEquivFunOnFinite.{u2, u2, u3} R R α (Finite.of_fintype.{u3} α _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) _inst_2 (Semiring.toModule.{u2} R _inst_2))) x)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) M (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) _inst_4) (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) (fun (_x : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} R R (Finsupp.{u3, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) M _inst_2 _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Finsupp.total.{u3, u4, u2} α M R _inst_2 _inst_3 _inst_4 v) (FunLike.coe.{max (succ u3) (succ u2), max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : α -> R) => Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _x) (SMulHomClass.toFunLike.{max u3 u2, u2, max u3 u2, max u3 u2} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (SMulZeroClass.toSMul.{u2, max u3 u2} R (α -> R) (AddMonoid.toZero.{max u3 u2} (α -> R) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u2} R (α -> R) (AddMonoid.toAddZeroClass.{max u3 u2} (α -> R) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u2, max u3 u2} R (α -> R) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)))))) (SMulZeroClass.toSMul.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddMonoid.toZero.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddMonoid.toAddZeroClass.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (DistribMulAction.toDistribSMul.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u2, u2, max u3 u2, max u3 u2} (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddCommMonoid.toAddMonoid.{max u3 u2} (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (AddCommMonoid.toAddMonoid.{max u3 u2} (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))))) (Module.toDistribMulAction.{u2, max u3 u2} R (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2))) (Module.toDistribMulAction.{u2, max u3 u2} R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) (SemilinearMapClass.distribMulActionHomClass.{u2, max u3 u2, max u3 u2, max u3 u2} R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max u3 u2, max u3 u2, max u3 u2} R R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (LinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2))) _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max u3 u2, max u3 u2} R R (α -> R) (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2)))))) (LinearEquiv.symm.{u2, u2, max u3 u2, max u3 u2} R R (Finsupp.{u3, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (α -> R) _inst_2 _inst_2 (Finsupp.addCommMonoid.{u3, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u3, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (Finsupp.linearEquivFunOnFinite.{u2, u2, u3} R R α (Finite.of_fintype.{u3} α _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) _inst_2 (Semiring.toModule.{u2} R _inst_2))) x)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u3) (succ u2), succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) v) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), max (max (succ u2) (succ u4)) (succ u3)} (LinearMap.{u1, u1, max u3 u4, max u4 u3 u2} S S _inst_5 _inst_5 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5)) (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u3, u4} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7)) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u3, max (max u2 u4) u3} S S (α -> M) (LinearMap.{u2, u2, max u3 u2, u4} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u3, u4} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u3 u2, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u3, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u3 u2, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5))) (Fintype.total.{u3, u4, u2, u1} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v) x)
Case conversion may be inaccurate. Consider using '#align finsupp.total_eq_fintype_total_apply Finsupp.total_eq_fintype_total_applyₓ'. -/
theorem Finsupp.total_eq_fintype_total_apply (x : α → R) :
    Finsupp.total α M R v ((Finsupp.linearEquivFunOnFinite R R α).symm x) = Fintype.total R S v x :=
  by
  apply Finset.sum_subset
  · exact Finset.subset_univ _
  · intro x _ hx
    rw [finsupp.not_mem_support_iff.mp hx]
    exact zero_smul _ _
#align finsupp.total_eq_fintype_total_apply Finsupp.total_eq_fintype_total_apply

/- warning: finsupp.total_eq_fintype_total -> Finsupp.total_eq_fintype_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] (S : Type.{u4}) [_inst_5 : Semiring.{u4} S] [_inst_6 : Module.{u4, u2} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u4, u2} R S M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u4, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u4, u2} S M (MulZeroClass.toHasZero.{u4} S (MulZeroOneClass.toMulZeroClass.{u4} S (MonoidWithZero.toMulZeroOneClass.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u2} S M (Semiring.toMonoidWithZero.{u4} S _inst_5) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u4, u2} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M), Eq.{max (succ (max u1 u3)) (succ u2)} (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (LinearMap.comp.{u3, u3, u3, max u1 u3, max u1 u3, u2} R R R (α -> R) (Finsupp.{u1, u3} α R (MulZeroClass.toHasZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))) M _inst_2 _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomCompTriple.right_ids.{u3, u3} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Finsupp.total.{u1, u2, u3} α M R _inst_2 _inst_3 _inst_4 v) (LinearEquiv.toLinearMap.{u3, u3, max u1 u3, max u1 u3} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2) (α -> R) (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (LinearEquiv.symm.{u3, u3, max u1 u3, max u1 u3} R R (Finsupp.{u1, u3} α R (AddZeroClass.toHasZero.{u3} R (AddMonoid.toAddZeroClass.{u3} R (AddCommMonoid.toAddMonoid.{u3} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))))))) (α -> R) _inst_2 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) (Finsupp.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (RingHomInvPair.ids.{u3} R _inst_2) (RingHomInvPair.ids.{u3} R _inst_2) (Finsupp.linearEquivFunOnFinite.{u3, u3, u1} R R α (Finite.of_fintype.{u1} α _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) _inst_2 (Semiring.toModule.{u3} R _inst_2))))) (coeFn.{max (succ (max u1 u2)) (succ (max (max u1 u3) u2)), max (succ (max u1 u2)) (succ (max (max u1 u3) u2))} (LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) => (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4)) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, max (max u1 u3) u2} S S (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5))) (Fintype.total.{u1, u2, u3, u4} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v)
but is expected to have type
  forall {α : Type.{u4}} {M : Type.{u3}} (R : Type.{u2}) [_inst_1 : Fintype.{u4} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] (S : Type.{u1}) [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u1, u3} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u2, u1, u3} R S M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u3} S M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u3} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u3} S M (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u1, u3} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M), Eq.{max (max (succ u4) (succ u3)) (succ u2)} (LinearMap.{u2, u2, max u4 u2, u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) (LinearMap.comp.{u2, u2, u2, max u4 u2, max u4 u2, u3} R R R (α -> R) (Finsupp.{u4, u2} α R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2))) M _inst_2 _inst_2 _inst_2 (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u4, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomCompTriple.ids.{u2, u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Finsupp.total.{u4, u3, u2} α M R _inst_2 _inst_3 _inst_4 v) (LinearEquiv.toLinearMap.{u2, u2, max u4 u2, max u4 u2} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (α -> R) (Finsupp.{u4, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (Finsupp.module.{u4, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (LinearEquiv.symm.{u2, u2, max u4 u2, max u4 u2} R R (Finsupp.{u4, u2} α R (AddMonoid.toZero.{u2} R (AddCommMonoid.toAddMonoid.{u2} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))))) (α -> R) _inst_2 _inst_2 (Finsupp.addCommMonoid.{u4, u2} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) (Finsupp.module.{u4, u2, u2} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Semiring.toModule.{u2} R _inst_2)) (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Basic._hyg.429 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (RingHomInvPair.ids.{u2} R _inst_2) (RingHomInvPair.ids.{u2} R _inst_2) (Finsupp.linearEquivFunOnFinite.{u2, u2, u4} R R α (Finite.of_fintype.{u4} α _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) _inst_2 (Semiring.toModule.{u2} R _inst_2))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), max (max (succ u2) (succ u3)) (succ u4)} (LinearMap.{u1, u1, max u4 u3, max u3 u4 u2} S S _inst_5 _inst_5 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5)) (α -> M) (LinearMap.{u2, u2, max u4 u2, u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u4, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u4, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u4 u2, u3} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u4, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u4, u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u4 u2, u3} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u4, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7)) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u2, u2, max u4 u2, u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u4, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u3 u4, max (max u2 u3) u4} S S (α -> M) (LinearMap.{u2, u2, max u4 u2, u3} R R _inst_2 _inst_2 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u4, u3} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u2, u2, max u4 u2, u3} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (Pi.module.{u4, u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, max u4 u2, u3} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u4, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)))) _inst_3 (Pi.module.{u4, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2))) (fun (i : α) => Semiring.toModule.{u2} R _inst_2)) _inst_4 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5))) (Fintype.total.{u4, u3, u2, u1} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v)
Case conversion may be inaccurate. Consider using '#align finsupp.total_eq_fintype_total Finsupp.total_eq_fintype_totalₓ'. -/
theorem Finsupp.total_eq_fintype_total :
    (Finsupp.total α M R v).comp (Finsupp.linearEquivFunOnFinite R R α).symm.toLinearMap =
      Fintype.total R S v :=
  LinearMap.ext <| Finsupp.total_eq_fintype_total_apply R S v
#align finsupp.total_eq_fintype_total Finsupp.total_eq_fintype_total

variable {S}

/- warning: fintype.range_total -> Fintype.range_total is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] {S : Type.{u4}} [_inst_5 : Semiring.{u4} S] [_inst_6 : Module.{u4, u2} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u4, u2} R S M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toHasSmul.{u4, u2} S M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u4, u2} S M (MulZeroClass.toHasZero.{u4} S (MulZeroOneClass.toMulZeroClass.{u4} S (MonoidWithZero.toMulZeroOneClass.{u4} S (Semiring.toMonoidWithZero.{u4} S _inst_5)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u4, u2} S M (Semiring.toMonoidWithZero.{u4} S _inst_5) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u4, u2} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M), Eq.{succ u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (LinearMap.range.{u3, u3, max u1 u3, u2, max (max u1 u3) u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (LinearMap.semilinearMapClass.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (RingHomSurjective.ids.{u3} R _inst_2) (coeFn.{max (succ (max u1 u2)) (succ (max (max u1 u3) u2)), max (succ (max u1 u2)) (succ (max (max u1 u3) u2))} (LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (fun (_x : LinearMap.{u4, u4, max u1 u2, max (max u1 u3) u2} S S _inst_5 _inst_5 (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) => (α -> M) -> (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4)) (LinearMap.hasCoeToFun.{u4, u4, max u1 u2, max (max u1 u3) u2} S S (α -> M) (LinearMap.{u3, u3, max u1 u3, u2} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u1, u2} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u1 u3, u2} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.Function.module.{u1, u4, u2} α S M _inst_5 _inst_3 _inst_6) (LinearMap.module.{u3, u3, u4, max u1 u3, u2} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u1, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.Function.module.{u1, u3, u3} α R R _inst_2 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u4} S (Semiring.toNonAssocSemiring.{u4} S _inst_5))) (Fintype.total.{u1, u2, u3, u4} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v)) (Submodule.span.{u3, u2} R M _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} M α v))
but is expected to have type
  forall {α : Type.{u2}} {M : Type.{u4}} (R : Type.{u3}) [_inst_1 : Fintype.{u2} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : Module.{u3, u4} R M _inst_2 _inst_3] {S : Type.{u1}} [_inst_5 : Semiring.{u1} S] [_inst_6 : Module.{u1, u4} S M _inst_5 _inst_3] [_inst_7 : SMulCommClass.{u3, u1, u4} R S M (SMulZeroClass.toSMul.{u3, u4} R M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u3, u4} R M (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u3, u4} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u3, u4} R M _inst_2 _inst_3 _inst_4)))) (SMulZeroClass.toSMul.{u1, u4} S M (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u1, u4} S M (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_5)) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u1, u4} S M (Semiring.toMonoidWithZero.{u1} S _inst_5) (AddMonoid.toZero.{u4} M (AddCommMonoid.toAddMonoid.{u4} M _inst_3)) (Module.toMulActionWithZero.{u1, u4} S M _inst_5 _inst_3 _inst_6))))] (v : α -> M), Eq.{succ u4} (Submodule.{u3, u4} R M _inst_2 _inst_3 _inst_4) (LinearMap.range.{u3, u3, max u2 u3, u4, max (max u2 u4) u3} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u3, u3, max u2 u3, u4} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4) v) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u2 u3, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (RingHomSurjective.ids.{u3} R _inst_2) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), max (max (succ u3) (succ u4)) (succ u2)} (LinearMap.{u1, u1, max u2 u4, max u4 u2 u3} S S _inst_5 _inst_5 (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5)) (α -> M) (LinearMap.{u3, u3, max u2 u3, u4} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4) (Pi.addCommMonoid.{u2, u4} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u2 u3, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.module.{u2, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u3, u3, u1, max u2 u3, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7)) (α -> M) (fun (_x : α -> M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> M) => LinearMap.{u3, u3, max u2 u3, u4} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u2, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u2, max (max u3 u4) u2} S S (α -> M) (LinearMap.{u3, u3, max u2 u3, u4} R R _inst_2 _inst_2 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) (α -> R) M (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4) _inst_5 _inst_5 (Pi.addCommMonoid.{u2, u4} α (fun (ᾰ : α) => M) (fun (i : α) => _inst_3)) (LinearMap.addCommMonoid.{u3, u3, max u2 u3, u4} R R (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (Pi.module.{u2, u4, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14128 : α) => M) S _inst_5 (fun (i : α) => _inst_3) (fun (i : α) => _inst_6)) (LinearMap.instModuleLinearMapAddCommMonoid.{u3, u3, u1, max u2 u3, u4} R R S (α -> R) M _inst_2 _inst_2 (Pi.addCommMonoid.{u2, u3} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)))) _inst_3 (Pi.module.{u2, u3, u3} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.14140 : α) => R) R _inst_2 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2))) (fun (i : α) => Semiring.toModule.{u3} R _inst_2)) _inst_4 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_2)) _inst_5 _inst_6 _inst_7) (RingHom.id.{u1} S (Semiring.toNonAssocSemiring.{u1} S _inst_5))) (Fintype.total.{u2, u4, u3, u1} α M R _inst_1 _inst_2 _inst_3 _inst_4 S _inst_5 _inst_6 _inst_7) v)) (Submodule.span.{u3, u4} R M _inst_2 _inst_3 _inst_4 (Set.range.{u4, succ u2} M α v))
Case conversion may be inaccurate. Consider using '#align fintype.range_total Fintype.range_totalₓ'. -/
@[simp]
theorem Fintype.range_total : (Fintype.total R S v).range = Submodule.span R (Set.range v) := by
  rw [← Finsupp.total_eq_fintype_total, LinearMap.range_comp, LinearEquiv.toLinearMap_eq_coe,
    LinearEquiv.range, Submodule.map_top, Finsupp.range_total]
#align fintype.range_total Fintype.range_total

section SpanRange

variable {v} {x : M}

/- warning: mem_span_range_iff_exists_fun -> mem_span_range_iff_exists_fun is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] {v : α -> M} {x : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u2, u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_2 _inst_3 _inst_4)) x (Submodule.span.{u3, u2} R M _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} M α v))) (Exists.{max (succ u1) (succ u3)} (α -> R) (fun (c : α -> R) => Eq.{succ u2} M (Finset.sum.{u2, u1} M α _inst_3 (Finset.univ.{u1} α _inst_1) (fun (i : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (c i) (v i))) x))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} (R : Type.{u2}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] {v : α -> M} {x : M}, Iff (Membership.mem.{u3, u3} M (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u2, u3} R M _inst_2 _inst_3 _inst_4)) x (Submodule.span.{u2, u3} R M _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u1} M α v))) (Exists.{max (succ u1) (succ u2)} (α -> R) (fun (c : α -> R) => Eq.{succ u3} M (Finset.sum.{u3, u1} M α _inst_3 (Finset.univ.{u1} α _inst_1) (fun (i : α) => HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4))))) (c i) (v i))) x))
Case conversion may be inaccurate. Consider using '#align mem_span_range_iff_exists_fun mem_span_range_iff_exists_funₓ'. -/
/-- An element `x` lies in the span of `v` iff it can be written as sum `∑ cᵢ • vᵢ = x`.
-/
theorem mem_span_range_iff_exists_fun : x ∈ span R (range v) ↔ ∃ c : α → R, (∑ i, c i • v i) = x :=
  by
  simp only [Finsupp.mem_span_range_iff_exists_finsupp,
    finsupp.equiv_fun_on_finite.surjective.exists, Finsupp.equivFunOnFinite_apply]
  exact exists_congr fun c => Eq.congr_left <| Finsupp.sum_fintype _ _ fun i => zero_smul _ _
#align mem_span_range_iff_exists_fun mem_span_range_iff_exists_fun

/- warning: top_le_span_range_iff_forall_exists_fun -> top_le_span_range_iff_forall_exists_fun is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {M : Type.{u2}} (R : Type.{u3}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u3, u2} R M _inst_2 _inst_3] {v : α -> M}, Iff (LE.le.{u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u2, u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) M (Submodule.setLike.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (Top.top.{u2} (Submodule.{u3, u2} R M _inst_2 _inst_3 _inst_4) (Submodule.hasTop.{u3, u2} R M _inst_2 _inst_3 _inst_4)) (Submodule.span.{u3, u2} R M _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} M α v))) (forall (x : M), Exists.{max (succ u1) (succ u3)} (α -> R) (fun (c : α -> R) => Eq.{succ u2} M (Finset.sum.{u2, u1} M α _inst_3 (Finset.univ.{u1} α _inst_1) (fun (i : α) => SMul.smul.{u3, u2} R M (SMulZeroClass.toHasSmul.{u3, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (SMulWithZero.toSmulZeroClass.{u3, u2} R M (MulZeroClass.toHasZero.{u3} R (MulZeroOneClass.toMulZeroClass.{u3} R (MonoidWithZero.toMulZeroOneClass.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_2)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (MulActionWithZero.toSMulWithZero.{u3, u2} R M (Semiring.toMonoidWithZero.{u3} R _inst_2) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3))) (Module.toMulActionWithZero.{u3, u2} R M _inst_2 _inst_3 _inst_4)))) (c i) (v i))) x))
but is expected to have type
  forall {α : Type.{u1}} {M : Type.{u3}} (R : Type.{u2}) [_inst_1 : Fintype.{u1} α] [_inst_2 : Semiring.{u2} R] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : Module.{u2, u3} R M _inst_2 _inst_3] {v : α -> M}, Iff (LE.le.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.completeLattice.{u2, u3} R M _inst_2 _inst_3 _inst_4))))) (Top.top.{u3} (Submodule.{u2, u3} R M _inst_2 _inst_3 _inst_4) (Submodule.instTopSubmodule.{u2, u3} R M _inst_2 _inst_3 _inst_4)) (Submodule.span.{u2, u3} R M _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u1} M α v))) (forall (x : M), Exists.{max (succ u1) (succ u2)} (α -> R) (fun (c : α -> R) => Eq.{succ u3} M (Finset.sum.{u3, u1} M α _inst_3 (Finset.univ.{u1} α _inst_1) (fun (i : α) => HSMul.hSMul.{u2, u3, u3} R M M (instHSMul.{u2, u3} R M (SMulZeroClass.toSMul.{u2, u3} R M (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (SMulWithZero.toSMulZeroClass.{u2, u3} R M (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_2)) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (MulActionWithZero.toSMulWithZero.{u2, u3} R M (Semiring.toMonoidWithZero.{u2} R _inst_2) (AddMonoid.toZero.{u3} M (AddCommMonoid.toAddMonoid.{u3} M _inst_3)) (Module.toMulActionWithZero.{u2, u3} R M _inst_2 _inst_3 _inst_4))))) (c i) (v i))) x))
Case conversion may be inaccurate. Consider using '#align top_le_span_range_iff_forall_exists_fun top_le_span_range_iff_forall_exists_funₓ'. -/
/-- A family `v : α → V` is generating `V` iff every element `(x : V)`
can be written as sum `∑ cᵢ • vᵢ = x`.
-/
theorem top_le_span_range_iff_forall_exists_fun :
    ⊤ ≤ span R (range v) ↔ ∀ x, ∃ c : α → R, (∑ i, c i • v i) = x :=
  by
  simp_rw [← mem_span_range_iff_exists_fun]
  exact ⟨fun h x => h trivial, fun h x _ => h x⟩
#align top_le_span_range_iff_forall_exists_fun top_le_span_range_iff_forall_exists_fun

end SpanRange

end Fintype

variable {R : Type _} {M : Type _} {N : Type _}

variable [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]

section

variable (R)

/- warning: span.repr -> Span.repr is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (w : Set.{u2} M), (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)) -> (Finsupp.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] (w : Set.{u2} M), (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w))) -> (Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align span.repr Span.reprₓ'. -/
/-- Pick some representation of `x : span R w` as a linear combination in `w`,
using the axiom of choice.
-/
irreducible_def Span.repr (w : Set M) (x : span R w) : w →₀ R :=
  ((Finsupp.mem_span_iff_total _ _ _).mp x.2).some
#align span.repr Span.repr

/- warning: span.finsupp_total_repr -> Span.finsupp_total_repr is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {w : Set.{u2} M} (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)), Eq.{succ u2} M (coeFn.{max (succ (max u2 u1)) (succ u2), max (succ (max u2 u1)) (succ u2)} (LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u2 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (Finsupp.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u1, u2} R R (Finsupp.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) M R _inst_1 _inst_2 _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} M) Type.{u2} (Set.hasCoeToSort.{u2} M) w) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Set.{u2} M) (Set.hasMem.{u2} M) x w))))))) (Span.repr.{u1, u2} R M _inst_1 _inst_2 _inst_3 w x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)) M (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)) M (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)) M (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)) M (coeSubtype.{succ u2} M (fun (x : M) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w)))))) x)
but is expected to have type
  forall (R : Type.{u1}) {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {w : Set.{u2} M} (x : Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) x (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) (Span.repr.{u1, u2} R M _inst_1 _inst_2 _inst_3 w x)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (LinearMap.{u1, u1, max u1 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M w) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M w) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (_x : Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u1 u2, u2} R R (Finsupp.{u2, u1} (Set.Elem.{u2} M w) R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u2, u1} (Set.Elem.{u2} M w) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u2, u1, u1} (Set.Elem.{u2} M w) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u2, u2, u1} (Set.Elem.{u2} M w) M R _inst_1 _inst_2 _inst_3 (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x w))) (Span.repr.{u1, u2} R M _inst_1 _inst_2 _inst_3 w x)) (Subtype.val.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Set.{u2} M) (Set.instMembershipSet.{u2} M) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 w))) x)
Case conversion may be inaccurate. Consider using '#align span.finsupp_total_repr Span.finsupp_total_reprₓ'. -/
@[simp]
theorem Span.finsupp_total_repr {w : Set M} (x : span R w) :
    Finsupp.total w M R coe (Span.repr R w x) = x :=
  by
  rw [Span.repr]
  exact ((Finsupp.mem_span_iff_total _ _ _).mp x.2).choose_spec
#align span.finsupp_total_repr Span.finsupp_total_repr

end

/- warning: submodule.finsupp_sum_mem -> Submodule.finsupp_sum_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Type.{u3}} {β : Type.{u4}} [_inst_6 : Zero.{u4} β] (S : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (f : Finsupp.{u3, u4} ι β _inst_6) (g : ι -> β -> M), (forall (c : ι), (Ne.{succ u4} β (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (Finsupp.{u3, u4} ι β _inst_6) (fun (_x : Finsupp.{u3, u4} ι β _inst_6) => ι -> β) (Finsupp.coeFun.{u3, u4} ι β _inst_6) f c) (OfNat.ofNat.{u4} β 0 (OfNat.mk.{u4} β 0 (Zero.zero.{u4} β _inst_6)))) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (g c (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (Finsupp.{u3, u4} ι β _inst_6) (fun (_x : Finsupp.{u3, u4} ι β _inst_6) => ι -> β) (Finsupp.coeFun.{u3, u4} ι β _inst_6) f c)) S)) -> (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) (Finsupp.sum.{u3, u4, u2} ι β M _inst_6 _inst_2 f g) S)
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Type.{u4}} {β : Type.{u3}} [_inst_6 : Zero.{u3} β] (S : Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (f : Finsupp.{u4, u3} ι β _inst_6) (g : ι -> β -> M), (forall (c : ι), (Ne.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => β) c) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Finsupp.{u4, u3} ι β _inst_6) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => β) _x) (Finsupp.funLike.{u4, u3} ι β _inst_6) f c) (OfNat.ofNat.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => β) c) 0 (Zero.toOfNat0.{u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => β) c) _inst_6))) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (g c (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Finsupp.{u4, u3} ι β _inst_6) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => β) _x) (Finsupp.funLike.{u4, u3} ι β _inst_6) f c)) S)) -> (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) (Finsupp.sum.{u4, u3, u1} ι β M _inst_6 _inst_2 f g) S)
Case conversion may be inaccurate. Consider using '#align submodule.finsupp_sum_mem Submodule.finsupp_sum_memₓ'. -/
protected theorem Submodule.finsupp_sum_mem {ι β : Type _} [Zero β] (S : Submodule R M) (f : ι →₀ β)
    (g : ι → β → M) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : f.Sum g ∈ S :=
  AddSubmonoidClass.finsupp_sum_mem S f g h
#align submodule.finsupp_sum_mem Submodule.finsupp_sum_mem

/- warning: linear_map.map_finsupp_total -> LinearMap.map_finsupp_total is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u3} N] [_inst_5 : Module.{u1, u3} R N _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) {ι : Type.{u4}} {g : ι -> M} (l : Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))), Eq.{succ u3} N (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) => M -> N) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M N _inst_1 _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} R R (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u4, u2, u1} ι M R _inst_1 _inst_2 _inst_3 g) l)) (coeFn.{max (succ (max u4 u1)) (succ u3), max (succ (max u4 u1)) (succ u3)} (LinearMap.{u1, u1, max u4 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) N (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_4 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) (fun (_x : LinearMap.{u1, u1, max u4 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) N (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_4 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5) => (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> N) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u3} R R (Finsupp.{u4, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u4, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_4 (Finsupp.module.{u4, u1, u1} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Finsupp.total.{u4, u3, u1} ι N R _inst_1 _inst_4 _inst_5 (Function.comp.{succ u4, succ u2, succ u3} ι M N (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) => M -> N) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M N _inst_1 _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) g)) l)
but is expected to have type
  forall {R : Type.{u4}} {M : Type.{u3}} {N : Type.{u2}} [_inst_1 : Semiring.{u4} R] [_inst_2 : AddCommMonoid.{u3} M] [_inst_3 : Module.{u4, u3} R M _inst_1 _inst_2] [_inst_4 : AddCommMonoid.{u2} N] [_inst_5 : Module.{u4, u2} R N _inst_1 _inst_4] (f : LinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) {ι : Type.{u1}} {g : ι -> M} (l : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u1), max (succ u4) (succ u1), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_3) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) (fun (a : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => M) a) (LinearMap.instFunLikeLinearMap.{u4, u4, max u4 u1, u3} R R (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Finsupp.total.{u1, u3, u4} ι M R _inst_1 _inst_2 _inst_3 g) l)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} R R M N _inst_1 _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) f (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u1), max (succ u4) (succ u1), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_3) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) (fun (_x : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u4 u1, u3} R R (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_3 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Finsupp.total.{u1, u3, u4} ι M R _inst_1 _inst_2 _inst_3 g) l)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u1), max (succ u4) (succ u1), succ u2} (LinearMap.{u4, u4, max u4 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) N (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_4 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_5) (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) (fun (_x : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) => N) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u4 u1, u2} R R (Finsupp.{u1, u4} ι R (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R _inst_1))) N _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u4} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)))) _inst_4 (Finsupp.module.{u1, u4, u4} ι R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Semiring.toModule.{u4} R _inst_1)) _inst_5 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) (Finsupp.total.{u1, u2, u4} ι N R _inst_1 _inst_4 _inst_5 (Function.comp.{succ u1, succ u3, succ u2} ι M N (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1)) M N _inst_2 _inst_4 _inst_3 _inst_5) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => N) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} R R M N _inst_1 _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R _inst_1))) f) g)) l)
Case conversion may be inaccurate. Consider using '#align linear_map.map_finsupp_total LinearMap.map_finsupp_totalₓ'. -/
theorem LinearMap.map_finsupp_total (f : M →ₗ[R] N) {ι : Type _} {g : ι → M} (l : ι →₀ R) :
    f (Finsupp.total ι M R g l) = Finsupp.total ι N R (f ∘ g) l := by
  simp only [Finsupp.total_apply, Finsupp.total_apply, Finsupp.sum, f.map_sum, f.map_smul]
#align linear_map.map_finsupp_total LinearMap.map_finsupp_total

/- warning: submodule.exists_finset_of_mem_supr -> Submodule.exists_finset_of_mem_supᵢ is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Type.{u3}} (p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)) {m : M}, (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> (Exists.{succ u3} (Finset.{u3} ι) (fun (s : Finset.{u3} ι) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) => p i)))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Type.{u3}} (p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)) {m : M}, (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) -> (Exists.{succ u3} (Finset.{u3} ι) (fun (s : Finset.{u3} ι) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u1, 0} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) (fun (H : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) => p i)))))
Case conversion may be inaccurate. Consider using '#align submodule.exists_finset_of_mem_supr Submodule.exists_finset_of_mem_supᵢₓ'. -/
theorem Submodule.exists_finset_of_mem_supᵢ {ι : Sort _} (p : ι → Submodule R M) {m : M}
    (hm : m ∈ ⨆ i, p i) : ∃ s : Finset ι, m ∈ ⨆ i ∈ s, p i :=
  by
  have :=
    CompleteLattice.IsCompactElement.exists_finset_of_le_supᵢ (Submodule R M)
      (Submodule.singleton_span_isCompactElement m) p
  simp only [Submodule.span_singleton_le_iff_mem] at this
  exact this hm
#align submodule.exists_finset_of_mem_supr Submodule.exists_finset_of_mem_supᵢ

/- warning: submodule.mem_supr_iff_exists_finset -> Submodule.mem_supᵢ_iff_exists_finset is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3)} {m : M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (Exists.{succ u3} (Finset.{u3} ι) (fun (s : Finset.{u3} ι) => Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u2, succ u3} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u2, 0} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_3))) (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) (fun (H : Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) i s) => p i)))))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {ι : Type.{u3}} {p : ι -> (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3)} {m : M}, Iff (Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => p i))) (Exists.{succ u3} (Finset.{u3} ι) (fun (s : Finset.{u3} ι) => Membership.mem.{u1, u1} M (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u2, u1} R M _inst_1 _inst_2 _inst_3)) m (supᵢ.{u1, succ u3} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) ι (fun (i : ι) => supᵢ.{u1, 0} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (ConditionallyCompleteLattice.toSupSet.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u2, u1} R M _inst_1 _inst_2 _inst_3) (Submodule.completeLattice.{u2, u1} R M _inst_1 _inst_2 _inst_3))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) (fun (H : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) => p i)))))
Case conversion may be inaccurate. Consider using '#align submodule.mem_supr_iff_exists_finset Submodule.mem_supᵢ_iff_exists_finsetₓ'. -/
/-- `submodule.exists_finset_of_mem_supr` as an `iff` -/
theorem Submodule.mem_supᵢ_iff_exists_finset {ι : Sort _} {p : ι → Submodule R M} {m : M} :
    (m ∈ ⨆ i, p i) ↔ ∃ s : Finset ι, m ∈ ⨆ i ∈ s, p i :=
  ⟨Submodule.exists_finset_of_mem_supᵢ p, fun ⟨_, hs⟩ =>
    supᵢ_mono (fun i => (supᵢ_const_le : _ ≤ p i)) hs⟩
#align submodule.mem_supr_iff_exists_finset Submodule.mem_supᵢ_iff_exists_finset

#print mem_span_finset /-
theorem mem_span_finset {s : Finset M} {x : M} :
    x ∈ span R (↑s : Set M) ↔ ∃ f : M → R, (∑ i in s, f i • i) = x :=
  ⟨fun hx =>
    let ⟨v, hvs, hvx⟩ :=
      (Finsupp.mem_span_image_iff_total _).1
        (show x ∈ span R (id '' (↑s : Set M)) by rwa [Set.image_id])
    ⟨v, hvx ▸ (Finsupp.total_apply_of_mem_supported _ hvs).symm⟩,
    fun ⟨f, hf⟩ => hf ▸ sum_mem fun i hi => smul_mem _ _ <| subset_span hi⟩
#align mem_span_finset mem_span_finset
-/

/- warning: mem_span_set -> mem_span_set is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {m : M} {s : Set.{u2} M}, Iff (Membership.Mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Exists.{max (succ u2) (succ u1)} (Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (fun (c : Finsupp.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) => And (HasSubset.Subset.{u2} (Set.{u2} M) (Set.hasSubset.{u2} M) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} M) (Set.{u2} M) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} M) (Set.{u2} M) (Finset.Set.hasCoeT.{u2} M))) (Finsupp.support.{u2, u1} M R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) c)) s) (Eq.{succ u2} M (Finsupp.sum.{u2, u1, u2} M R M (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 c (fun (mi : M) (r : R) => SMul.smul.{u1, u2} R M (SMulZeroClass.toHasSmul.{u1, u2} R M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (SMulWithZero.toSmulZeroClass.{u1, u2} R M (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2))) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3)))) r mi)) m)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {m : M} {s : Set.{u2} M}, Iff (Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_3) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_3)) m (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_3 s)) (Exists.{max (succ u1) (succ u2)} (Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (fun (c : Finsupp.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) => And (HasSubset.Subset.{u2} (Set.{u2} M) (Set.instHasSubsetSet.{u2} M) (Finset.toSet.{u2} M (Finsupp.support.{u2, u1} M R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) c)) s) (Eq.{succ u2} M (Finsupp.sum.{u2, u1, u2} M R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) _inst_2 c (fun (mi : M) (r : R) => HSMul.hSMul.{u1, u2, u2} R M M (instHSMul.{u1, u2} R M (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (SMulWithZero.toSMulZeroClass.{u1, u2} R M (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (MulActionWithZero.toSMulWithZero.{u1, u2} R M (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (Module.toMulActionWithZero.{u1, u2} R M _inst_1 _inst_2 _inst_3))))) r mi)) m)))
Case conversion may be inaccurate. Consider using '#align mem_span_set mem_span_setₓ'. -/
/-- An element `m ∈ M` is contained in the `R`-submodule spanned by a set `s ⊆ M`, if and only if
`m` can be written as a finite `R`-linear combination of elements of `s`.
The implementation uses `finsupp.sum`. -/
theorem mem_span_set {m : M} {s : Set M} :
    m ∈ Submodule.span R s ↔
      ∃ c : M →₀ R, (c.support : Set M) ⊆ s ∧ (c.Sum fun mi r => r • mi) = m :=
  by
  conv_lhs => rw [← Set.image_id s]
  simp_rw [← exists_prop]
  exact Finsupp.mem_span_image_iff_total R
#align mem_span_set mem_span_set

/- warning: module.subsingleton_equiv -> Module.subsingletonEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (ι : Type.{u3}) [_inst_6 : Semiring.{u1} R] [_inst_7 : Subsingleton.{succ u1} R] [_inst_8 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_6 _inst_8], LinearEquiv.{u1, u1, u2, max u3 u1} R R _inst_6 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R _inst_6) (RingHomInvPair.ids.{u1} R _inst_6) M (Finsupp.{u3, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6))))) _inst_8 (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)))) _inst_9 (Finsupp.module.{u3, u1, u1} ι R R _inst_6 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6))) (Semiring.toModule.{u1} R _inst_6))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (ι : Type.{u3}) [_inst_6 : Semiring.{u1} R] [_inst_7 : Subsingleton.{succ u1} R] [_inst_8 : AddCommMonoid.{u2} M] [_inst_9 : Module.{u1, u2} R M _inst_6 _inst_8], LinearEquiv.{u1, u1, u2, max u1 u3} R R _inst_6 _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R _inst_6) (RingHomInvPair.ids.{u1} R _inst_6) M (Finsupp.{u3, u1} ι R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_6))) _inst_8 (Finsupp.addCommMonoid.{u3, u1} ι R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6)))) _inst_9 (Finsupp.module.{u3, u1, u1} ι R R _inst_6 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_6))) (Semiring.toModule.{u1} R _inst_6))
Case conversion may be inaccurate. Consider using '#align module.subsingleton_equiv Module.subsingletonEquivₓ'. -/
/-- If `subsingleton R`, then `M ≃ₗ[R] ι →₀ R` for any type `ι`. -/
@[simps]
def Module.subsingletonEquiv (R M ι : Type _) [Semiring R] [Subsingleton R] [AddCommMonoid M]
    [Module R M] : M ≃ₗ[R] ι →₀ R where
  toFun m := 0
  invFun f := 0
  left_inv m := by
    letI := Module.subsingleton R M
    simp only [eq_iff_true_of_subsingleton]
  right_inv f := by simp only [eq_iff_true_of_subsingleton]
  map_add' m n := (add_zero 0).symm
  map_smul' r m := (smul_zero r).symm
#align module.subsingleton_equiv Module.subsingletonEquiv

namespace LinearMap

variable {R M} {α : Type _}

open Finsupp Function

/- warning: linear_map.splitting_of_finsupp_surjective -> LinearMap.splittingOfFinsuppSurjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))), (Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)) -> (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} (f : LinearMap.{u1, u1, u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))), (Function.Surjective.{succ u2, max (succ u1) (succ u3)} M (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u2, max (succ u1) (succ u3)} (LinearMap.{u1, u1, u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u1 u3} R R M (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)) -> (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3)
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_finsupp_surjective LinearMap.splittingOfFinsuppSurjectiveₓ'. -/
-- See also `linear_map.splitting_of_fun_on_fintype_surjective`
/-- A surjective linear map to finitely supported functions has a splitting. -/
def splittingOfFinsuppSurjective (f : M →ₗ[R] α →₀ R) (s : Surjective f) : (α →₀ R) →ₗ[R] M :=
  Finsupp.lift _ _ _ fun x : α => (s (Finsupp.single x 1)).some
#align linear_map.splitting_of_finsupp_surjective LinearMap.splittingOfFinsuppSurjective

/- warning: linear_map.splitting_of_finsupp_surjective_splits -> LinearMap.splittingOfFinsuppSurjective_splits is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Eq.{succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (LinearMap.comp.{u1, u1, u1, max u3 u1, u2, max u3 u1} R R R (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.splittingOfFinsuppSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α f s)) (LinearMap.id.{u1, max u3 u1} R (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {α : Type.{u1}} (f : LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u2, max (succ u3) (succ u1)} (LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u3 u1} R R M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f)), Eq.{max (succ u3) (succ u1)} (LinearMap.{u3, u3, max u3 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (LinearMap.comp.{u3, u3, u3, max u3 u1, u2, max u3 u1} R R R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f (LinearMap.splittingOfFinsuppSurjective.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 α f s)) (LinearMap.id.{u3, max u3 u1} R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_finsupp_surjective_splits LinearMap.splittingOfFinsuppSurjective_splitsₓ'. -/
theorem splittingOfFinsuppSurjective_splits (f : M →ₗ[R] α →₀ R) (s : Surjective f) :
    f.comp (splittingOfFinsuppSurjective f s) = LinearMap.id :=
  by
  ext (x y)
  dsimp [splitting_of_finsupp_surjective]
  congr
  rw [sum_single_index, one_smul]
  · exact (s (Finsupp.single x 1)).choose_spec
  · rw [zero_smul]
#align linear_map.splitting_of_finsupp_surjective_splits LinearMap.splittingOfFinsuppSurjective_splits

/- warning: linear_map.left_inverse_splitting_of_finsupp_surjective -> LinearMap.leftInverse_splittingOfFinsuppSurjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Function.LeftInverse.{max (succ u3) (succ u1), succ u2} (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.splittingOfFinsuppSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α f s))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {α : Type.{u1}} (f : LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u2, max (succ u3) (succ u1)} (LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u3 u1} R R M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f)), Function.LeftInverse.{max (succ u3) (succ u1), succ u2} (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u2, max (succ u3) (succ u1)} (LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u3 u1} R R M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), succ u2} (LinearMap.{u3, u3, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_3) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (fun (_x : Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u3 u1, u2} R R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.splittingOfFinsuppSurjective.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 α f s))
Case conversion may be inaccurate. Consider using '#align linear_map.left_inverse_splitting_of_finsupp_surjective LinearMap.leftInverse_splittingOfFinsuppSurjectiveₓ'. -/
theorem leftInverse_splittingOfFinsuppSurjective (f : M →ₗ[R] α →₀ R) (s : Surjective f) :
    LeftInverse f (splittingOfFinsuppSurjective f s) := fun g =>
  LinearMap.congr_fun (splittingOfFinsuppSurjective_splits f s) g
#align linear_map.left_inverse_splitting_of_finsupp_surjective LinearMap.leftInverse_splittingOfFinsuppSurjective

/- warning: linear_map.splitting_of_finsupp_surjective_injective -> LinearMap.splittingOfFinsuppSurjective_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Function.Injective.{max (succ u3) (succ u1), succ u2} (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, u2} R R (Finsupp.{u3, u1} α R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u3, u1} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Finsupp.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.splittingOfFinsuppSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α f s))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u3, u2} R M _inst_1 _inst_2] {α : Type.{u1}} (f : LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u2, max (succ u3) (succ u1)} (LinearMap.{u3, u3, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u3 u1} R R M (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 _inst_2 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_3 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f)), Function.Injective.{max (succ u3) (succ u1), succ u2} (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u3) (succ u1), succ u2} (LinearMap.{u3, u3, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_3) (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (fun (_x : Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) => M) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u3 u1, u2} R R (Finsupp.{u1, u3} α R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) M _inst_1 _inst_1 (Finsupp.addCommMonoid.{u1, u3} α R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) _inst_2 (Finsupp.module.{u1, u3, u3} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.splittingOfFinsuppSurjective.{u3, u2, u1} R M _inst_1 _inst_2 _inst_3 α f s))
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_finsupp_surjective_injective LinearMap.splittingOfFinsuppSurjective_injectiveₓ'. -/
theorem splittingOfFinsuppSurjective_injective (f : M →ₗ[R] α →₀ R) (s : Surjective f) :
    Injective (splittingOfFinsuppSurjective f s) :=
  (leftInverse_splittingOfFinsuppSurjective f s).Injective
#align linear_map.splitting_of_finsupp_surjective_injective LinearMap.splittingOfFinsuppSurjective_injective

/- warning: linear_map.splitting_of_fun_on_fintype_surjective -> LinearMap.splittingOfFunOnFintypeSurjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))), (Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (α -> R) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> α -> R) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)) -> (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u1, u1, u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.module.{u3, u1, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16729 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : α) => Semiring.toModule.{u1} R _inst_1))), (Function.Surjective.{succ u2, max (succ u1) (succ u3)} M (α -> R) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u2, max (succ u1) (succ u3)} (LinearMap.{u1, u1, u2, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16729 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.module.{u3, u1, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16729 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : α) => Semiring.toModule.{u1} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => α -> R) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u1 u3} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.module.{u3, u1, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16729 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : α) => Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)) -> (LinearMap.{u1, u1, max u1 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.module.{u3, u1, u1} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : α) => Semiring.toModule.{u1} R _inst_1)) _inst_3)
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_fun_on_fintype_surjective LinearMap.splittingOfFunOnFintypeSurjectiveₓ'. -/
-- See also `linear_map.splitting_of_finsupp_surjective`
/-- A surjective linear map to functions on a finite type has a splitting. -/
def splittingOfFunOnFintypeSurjective [Fintype α] (f : M →ₗ[R] α → R) (s : Surjective f) :
    (α → R) →ₗ[R] M :=
  (Finsupp.lift _ _ _ fun x : α => (s (Finsupp.single x 1)).some).comp
    (linearEquivFunOnFinite R R α).symm.toLinearMap
#align linear_map.splitting_of_fun_on_fintype_surjective LinearMap.splittingOfFunOnFintypeSurjective

/- warning: linear_map.splitting_of_fun_on_fintype_surjective_splits -> LinearMap.splittingOfFunOnFintypeSurjective_splits is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (α -> R) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> α -> R) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Eq.{succ (max u3 u1)} (LinearMap.{u1, u1, max u3 u1, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) (α -> R) (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (LinearMap.comp.{u1, u1, u1, max u3 u1, u2, max u3 u1} R R R (α -> R) M (α -> R) _inst_1 _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.splittingOfFunOnFintypeSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s)) (LinearMap.id.{u1, max u3 u1} R (α -> R) _inst_1 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) (s : Function.Surjective.{succ u1, max (succ u2) (succ u3)} M (α -> R) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u1, max (succ u2) (succ u3)} (LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => α -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u2 u3} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f)), Eq.{max (succ u2) (succ u3)} (LinearMap.{u2, u2, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (α -> R) (α -> R) (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) (LinearMap.comp.{u2, u2, u2, max u2 u3, u1, max u2 u3} R R R (α -> R) M (α -> R) _inst_1 _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16812 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f (LinearMap.splittingOfFunOnFintypeSurjective.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s)) (LinearMap.id.{u2, max u2 u3} R (α -> R) _inst_1 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)))
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_fun_on_fintype_surjective_splits LinearMap.splittingOfFunOnFintypeSurjective_splitsₓ'. -/
theorem splittingOfFunOnFintypeSurjective_splits [Fintype α] (f : M →ₗ[R] α → R)
    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id :=
  by
  ext (x y)
  dsimp [splitting_of_fun_on_fintype_surjective]
  rw [linear_equiv_fun_on_finite_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]
#align linear_map.splitting_of_fun_on_fintype_surjective_splits LinearMap.splittingOfFunOnFintypeSurjective_splits

/- warning: linear_map.left_inverse_splitting_of_fun_on_fintype_surjective -> LinearMap.leftInverse_splittingOfFunOnFintypeSurjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (α -> R) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> α -> R) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Function.LeftInverse.{max (succ u3) (succ u1), succ u2} (α -> R) M (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> α -> R) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (α -> R) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, u2} R R (α -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.splittingOfFunOnFintypeSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) (s : Function.Surjective.{succ u1, max (succ u2) (succ u3)} M (α -> R) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u1, max (succ u2) (succ u3)} (LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => α -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u2 u3} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f)), Function.LeftInverse.{max (succ u2) (succ u3), succ u1} (α -> R) M (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u1, max (succ u2) (succ u3)} (LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => α -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u2 u3} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16944 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) _inst_3) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (α -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.splittingOfFunOnFintypeSurjective.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s))
Case conversion may be inaccurate. Consider using '#align linear_map.left_inverse_splitting_of_fun_on_fintype_surjective LinearMap.leftInverse_splittingOfFunOnFintypeSurjectiveₓ'. -/
theorem leftInverse_splittingOfFunOnFintypeSurjective [Fintype α] (f : M →ₗ[R] α → R)
    (s : Surjective f) : LeftInverse f (splittingOfFunOnFintypeSurjective f s) := fun g =>
  LinearMap.congr_fun (splittingOfFunOnFintypeSurjective_splits f s) g
#align linear_map.left_inverse_splitting_of_fun_on_fintype_surjective LinearMap.leftInverse_splittingOfFunOnFintypeSurjective

/- warning: linear_map.splitting_of_fun_on_fintype_surjective_injective -> LinearMap.splittingOfFunOnFintypeSurjective_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : Module.{u1, u2} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (s : Function.Surjective.{succ u2, max (succ u3) (succ u1)} M (α -> R) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearMap.{u1, u1, u2, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => M -> α -> R) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u1} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_3 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f)), Function.Injective.{max (succ u3) (succ u1), succ u2} (α -> R) M (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) (fun (_x : LinearMap.{u1, u1, max u3 u1, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3) => (α -> R) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, u2} R R (α -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u1} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) _inst_2 (Pi.Function.module.{u3, u1, u1} α R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.splittingOfFunOnFintypeSurjective.{u1, u2, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : AddCommMonoid.{u1} M] [_inst_3 : Module.{u2, u1} R M _inst_1 _inst_2] {α : Type.{u3}} [_inst_6 : Fintype.{u3} α] (f : LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.17003 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) (s : Function.Surjective.{succ u1, max (succ u2) (succ u3)} M (α -> R) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u1, max (succ u2) (succ u3)} (LinearMap.{u2, u2, u1, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M (α -> R) _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.17003 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.17003 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1))) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : M) => α -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u2 u3} R R M (α -> R) _inst_1 _inst_1 _inst_2 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_3 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.17003 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) f)), Function.Injective.{max (succ u2) (succ u3), succ u1} (α -> R) M (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (α -> R) M (Pi.addCommMonoid.{u3, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) _inst_3) (α -> R) (fun (_x : α -> R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : α -> R) => M) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u2 u3, u1} R R (α -> R) M _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} α (fun (ᾰ : α) => R) (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) _inst_2 (Pi.module.{u3, u2, u2} α (fun (a._@.Mathlib.LinearAlgebra.Finsupp._hyg.16744 : α) => R) R _inst_1 (fun (i : α) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : α) => Semiring.toModule.{u2} R _inst_1)) _inst_3 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.splittingOfFunOnFintypeSurjective.{u2, u1, u3} R M _inst_1 _inst_2 _inst_3 α _inst_6 f s))
Case conversion may be inaccurate. Consider using '#align linear_map.splitting_of_fun_on_fintype_surjective_injective LinearMap.splittingOfFunOnFintypeSurjective_injectiveₓ'. -/
theorem splittingOfFunOnFintypeSurjective_injective [Fintype α] (f : M →ₗ[R] α → R)
    (s : Surjective f) : Injective (splittingOfFunOnFintypeSurjective f s) :=
  (leftInverse_splittingOfFunOnFintypeSurjective f s).Injective
#align linear_map.splitting_of_fun_on_fintype_surjective_injective LinearMap.splittingOfFunOnFintypeSurjective_injective

end LinearMap

