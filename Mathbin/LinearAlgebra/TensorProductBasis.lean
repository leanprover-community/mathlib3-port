/-
Copyright (c) 2021 Jakob von Raumer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob von Raumer

! This file was ported from Lean 3 source module linear_algebra.tensor_product_basis
! leanprover-community/mathlib commit f784cc6142443d9ee623a20788c282112c322081
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.DirectSum.Finsupp
import Mathbin.LinearAlgebra.FinsuppVectorSpace

/-!
# Bases and dimensionality of tensor products of modules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

These can not go into `linear_algebra.tensor_product` since they depend on
`linear_algebra.finsupp_vector_space` which in turn imports `linear_algebra.tensor_product`.

-/


noncomputable section

open Set LinearMap Submodule

section CommRing

variable {R : Type _} {M : Type _} {N : Type _} {ι : Type _} {κ : Type _}

variable [CommRing R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]

/- warning: basis.tensor_product -> Basis.tensorProduct is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {ι : Type.{u4}} {κ : Type.{u5}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : AddCommGroup.{u3} N] [_inst_5 : Module.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4)], (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) -> (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) -> (Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {ι : Type.{u4}} {κ : Type.{u5}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : AddCommGroup.{u3} N] [_inst_5 : Module.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4)], (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) -> (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) -> (Basis.{max u5 u4, u1, max u3 u2} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.instModuleTensorProductToSemiringAddCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align basis.tensor_product Basis.tensorProductₓ'. -/
/-- If b : ι → M and c : κ → N are bases then so is λ i, b i.1 ⊗ₜ c i.2 : ι × κ → M ⊗ N. -/
def Basis.tensorProduct (b : Basis ι R M) (c : Basis κ R N) :
    Basis (ι × κ) R (TensorProduct R M N) :=
  Finsupp.basisSingleOne.map
    ((TensorProduct.congr b.repr c.repr).trans <|
        (finsuppTensorFinsupp R _ _ _ _).trans <|
          Finsupp.lcongr (Equiv.refl _) (TensorProduct.lid R R)).symm
#align basis.tensor_product Basis.tensorProduct

/- warning: basis.tensor_product_apply -> Basis.tensorProduct_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {ι : Type.{u4}} {κ : Type.{u5}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : AddCommGroup.{u3} N] [_inst_5 : Module.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4)] (b : Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (c : Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) (i : ι) (j : κ), Eq.{succ (max u2 u3)} (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (coeFn.{max (succ (max u4 u5)) (succ u1) (succ (max u2 u3)), max (succ (max u4 u5)) (succ (max u2 u3))} (Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (fun (_x : Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) => (Prod.{u4, u5} ι κ) -> (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (FunLike.hasCoeToFun.{max (succ (max u4 u5)) (succ u1) (succ (max u2 u3)), succ (max u4 u5), succ (max u2 u3)} (Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (Prod.{u4, u5} ι κ) (fun (_x : Prod.{u4, u5} ι κ) => TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Basis.funLike.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5))) (Basis.tensorProduct.{u1, u2, u3, u4, u5} R M N ι κ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 b c) (Prod.mk.{u4, u5} ι κ i j)) (TensorProduct.tmul.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5 (coeFn.{max (succ u4) (succ u1) (succ u2), max (succ u4) (succ u2)} (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (fun (_x : Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) => ι -> M) (FunLike.hasCoeToFun.{max (succ u4) (succ u1) (succ u2), succ u4, succ u2} (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι (fun (_x : ι) => M) (Basis.funLike.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) b i) (coeFn.{max (succ u5) (succ u1) (succ u3), max (succ u5) (succ u3)} (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) (fun (_x : Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) => κ -> N) (FunLike.hasCoeToFun.{max (succ u5) (succ u1) (succ u3), succ u5, succ u3} (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) κ (fun (_x : κ) => N) (Basis.funLike.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5)) c j))
but is expected to have type
  forall {R : Type.{u4}} {M : Type.{u3}} {N : Type.{u1}} {ι : Type.{u5}} {κ : Type.{u2}} [_inst_1 : CommRing.{u4} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u4, u3} R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_4 : AddCommGroup.{u1} N] [_inst_5 : Module.{u4, u1} R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4)] (b : Basis.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (c : Basis.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) (i : ι) (j : κ), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Prod.{u5, u2} ι κ) => TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (Prod.mk.{u5, u2} ι κ i j)) (FunLike.coe.{max (max (max (max (succ u4) (succ u3)) (succ u1)) (succ u5)) (succ u2), max (succ u5) (succ u2), max (succ u3) (succ u1)} (Basis.{max u2 u5, u4, max u1 u3} (Prod.{u5, u2} ι κ) R (TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (TensorProduct.addCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (TensorProduct.instModuleTensorProductToSemiringAddCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5)) (Prod.{u5, u2} ι κ) (fun (_x : Prod.{u5, u2} ι κ) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Prod.{u5, u2} ι κ) => TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) _x) (Basis.funLike.{max u5 u2, u4, max u3 u1} (Prod.{u5, u2} ι κ) R (TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (TensorProduct.addCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (TensorProduct.instModuleTensorProductToSemiringAddCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5)) (Basis.tensorProduct.{u4, u3, u1, u5, u2} R M N ι κ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 b c) (Prod.mk.{u5, u2} ι κ i j)) (TensorProduct.tmul.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) i) ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) j) (AddCommGroup.toAddCommMonoid.{u3} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) i) _inst_2) (AddCommGroup.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) j) _inst_4) _inst_3 _inst_5 (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u5), succ u5, succ u3} (Basis.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) _x) (Basis.funLike.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) b i) (FunLike.coe.{max (max (succ u4) (succ u1)) (succ u2), succ u2, succ u1} (Basis.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) κ (fun (_x : κ) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) _x) (Basis.funLike.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) c j))
Case conversion may be inaccurate. Consider using '#align basis.tensor_product_apply Basis.tensorProduct_applyₓ'. -/
@[simp]
theorem Basis.tensorProduct_apply (b : Basis ι R M) (c : Basis κ R N) (i : ι) (j : κ) :
    Basis.tensorProduct b c (i, j) = b i ⊗ₜ c j := by simp [Basis.tensorProduct]
#align basis.tensor_product_apply Basis.tensorProduct_apply

/- warning: basis.tensor_product_apply' -> Basis.tensorProduct_apply' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {N : Type.{u3}} {ι : Type.{u4}} {κ : Type.{u5}} [_inst_1 : CommRing.{u1} R] [_inst_2 : AddCommGroup.{u2} M] [_inst_3 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2)] [_inst_4 : AddCommGroup.{u3} N] [_inst_5 : Module.{u1, u3} R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4)] (b : Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (c : Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) (i : Prod.{u4, u5} ι κ), Eq.{succ (max u2 u3)} (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (coeFn.{max (succ (max u4 u5)) (succ u1) (succ (max u2 u3)), max (succ (max u4 u5)) (succ (max u2 u3))} (Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (fun (_x : Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) => (Prod.{u4, u5} ι κ) -> (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (FunLike.hasCoeToFun.{max (succ (max u4 u5)) (succ u1) (succ (max u2 u3)), succ (max u4 u5), succ (max u2 u3)} (Basis.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5)) (Prod.{u4, u5} ι κ) (fun (_x : Prod.{u4, u5} ι κ) => TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Basis.funLike.{max u4 u5, u1, max u2 u3} (Prod.{u4, u5} ι κ) R (TensorProduct.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (TensorProduct.addCommMonoid.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5) (TensorProduct.module.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5))) (Basis.tensorProduct.{u1, u2, u3, u4, u5} R M N ι κ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 b c) i) (TensorProduct.tmul.{u1, u2, u3} R (CommRing.toCommSemiring.{u1} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_3 _inst_5 (coeFn.{max (succ u4) (succ u1) (succ u2), max (succ u4) (succ u2)} (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) (fun (_x : Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) => ι -> M) (FunLike.hasCoeToFun.{max (succ u4) (succ u1) (succ u2), succ u4, succ u2} (Basis.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3) ι (fun (_x : ι) => M) (Basis.funLike.{u4, u1, u2} ι R M (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} M _inst_2) _inst_3)) b (Prod.fst.{u4, u5} ι κ i)) (coeFn.{max (succ u5) (succ u1) (succ u3), max (succ u5) (succ u3)} (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) (fun (_x : Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) => κ -> N) (FunLike.hasCoeToFun.{max (succ u5) (succ u1) (succ u3), succ u5, succ u3} (Basis.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5) κ (fun (_x : κ) => N) (Basis.funLike.{u5, u1, u3} κ R N (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} N _inst_4) _inst_5)) c (Prod.snd.{u4, u5} ι κ i)))
but is expected to have type
  forall {R : Type.{u4}} {M : Type.{u3}} {N : Type.{u1}} {ι : Type.{u5}} {κ : Type.{u2}} [_inst_1 : CommRing.{u4} R] [_inst_2 : AddCommGroup.{u3} M] [_inst_3 : Module.{u4, u3} R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2)] [_inst_4 : AddCommGroup.{u1} N] [_inst_5 : Module.{u4, u1} R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4)] (b : Basis.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) (c : Basis.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) (i : Prod.{u5, u2} ι κ), Eq.{max (succ u3) (succ u1)} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Prod.{u5, u2} ι κ) => TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) i) (FunLike.coe.{max (max (max (max (succ u4) (succ u3)) (succ u1)) (succ u5)) (succ u2), max (succ u5) (succ u2), max (succ u3) (succ u1)} (Basis.{max u2 u5, u4, max u1 u3} (Prod.{u5, u2} ι κ) R (TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (TensorProduct.addCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (TensorProduct.instModuleTensorProductToSemiringAddCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5)) (Prod.{u5, u2} ι κ) (fun (_x : Prod.{u5, u2} ι κ) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Prod.{u5, u2} ι κ) => TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) _x) (Basis.funLike.{max u5 u2, u4, max u3 u1} (Prod.{u5, u2} ι κ) R (TensorProduct.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (TensorProduct.addCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5) (TensorProduct.instModuleTensorProductToSemiringAddCommMonoid.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) M N (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_3 _inst_5)) (Basis.tensorProduct.{u4, u3, u1, u5, u2} R M N ι κ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 b c) i) (TensorProduct.tmul.{u4, u3, u1} R (CommRing.toCommSemiring.{u4} R _inst_1) ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) (Prod.fst.{u5, u2} ι κ i)) ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) (Prod.snd.{u5, u2} ι κ i)) (AddCommGroup.toAddCommMonoid.{u3} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) (Prod.fst.{u5, u2} ι κ i)) _inst_2) (AddCommGroup.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) (Prod.snd.{u5, u2} ι κ i)) _inst_4) _inst_3 _inst_5 (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u5), succ u5, succ u3} (Basis.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => M) _x) (Basis.funLike.{u5, u4, u3} ι R M (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} M _inst_2) _inst_3) b (Prod.fst.{u5, u2} ι κ i)) (FunLike.coe.{max (max (succ u4) (succ u1)) (succ u2), succ u2, succ u1} (Basis.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) κ (fun (_x : κ) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : κ) => N) _x) (Basis.funLike.{u2, u4, u1} κ R N (Ring.toSemiring.{u4} R (CommRing.toRing.{u4} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} N _inst_4) _inst_5) c (Prod.snd.{u5, u2} ι κ i)))
Case conversion may be inaccurate. Consider using '#align basis.tensor_product_apply' Basis.tensorProduct_apply'ₓ'. -/
theorem Basis.tensorProduct_apply' (b : Basis ι R M) (c : Basis κ R N) (i : ι × κ) :
    Basis.tensorProduct b c i = b i.1 ⊗ₜ c i.2 := by simp [Basis.tensorProduct]
#align basis.tensor_product_apply' Basis.tensorProduct_apply'

@[simp]
theorem Basis.tensorProduct_repr_tmul_apply (b : Basis ι R M) (c : Basis κ R N) (m : M) (n : N)
    (i : ι) (j : κ) : (Basis.tensorProduct b c).repr (m ⊗ₜ n) (i, j) = b.repr m i * c.repr n j := by
  simp [Basis.tensorProduct]
#align basis.tensor_product_repr_tmul_apply Basis.tensorProduct_repr_tmul_apply

end CommRing

