/-
Copyright (c) 2019 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, Anne Baanen

! This file was ported from Lean 3 source module linear_algebra.finrank
! leanprover-community/mathlib commit 9a48a083b390d9b84a71efbdc4e8dfa26a687104
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Dimension

/-!
# Finite dimension of vector spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Definition of the rank of a module, or dimension of a vector space, as a natural number.

## Main definitions

Defined is `finite_dimensional.finrank`, the dimension of a finite dimensional space, returning a
`nat`, as opposed to `module.rank`, which returns a `cardinal`. When the space has infinite
dimension, its `finrank` is by convention set to `0`.

The definition of `finrank` does not assume a `finite_dimensional` instance, but lemmas might.
Import `linear_algebra.finite_dimensional` to get access to these additional lemmas.

Formulas for the dimension are given for linear equivs, in `linear_equiv.finrank_eq`

## Implementation notes

Most results are deduced from the corresponding results for the general dimension (as a cardinal),
in `dimension.lean`. Not all results have been ported yet.

You should not assume that there has been any effort to state lemmas as generally as possible.
-/


universe u v v' w

open Classical Cardinal

open Cardinal Submodule Module Function

variable {K : Type u} {V : Type v}

namespace FiniteDimensional

open IsNoetherian

section Ring

variable [Ring K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂]

#print FiniteDimensional.finrank /-
/-- The rank of a module as a natural number.

Defined by convention to be `0` if the space has infinite rank.

For a vector space `V` over a field `K`, this is the same as the finite dimension
of `V` over `K`.
-/
noncomputable def finrank (R V : Type _) [Semiring R] [AddCommGroup V] [Module R V] : ℕ :=
  (Module.rank R V).toNat
#align finite_dimensional.finrank FiniteDimensional.finrank
-/

/- warning: finite_dimensional.finrank_eq_of_rank_eq -> FiniteDimensional.finrank_eq_of_rank_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_eq_of_rank_eq FiniteDimensional.finrank_eq_of_rank_eqₓ'. -/
theorem finrank_eq_of_rank_eq {n : ℕ} (h : Module.rank K V = ↑n) : finrank K V = n :=
  by
  apply_fun to_nat  at h
  rw [to_nat_cast] at h
  exact_mod_cast h
#align finite_dimensional.finrank_eq_of_rank_eq FiniteDimensional.finrank_eq_of_rank_eq

/- warning: finite_dimensional.finrank_le_of_rank_le -> FiniteDimensional.finrank_le_of_rank_le is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LE.le.{succ u2} Cardinal.{u2} Cardinal.instLECardinal.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_le_of_rank_le FiniteDimensional.finrank_le_of_rank_leₓ'. -/
theorem finrank_le_of_rank_le {n : ℕ} (h : Module.rank K V ≤ ↑n) : finrank K V ≤ n :=
  by
  rwa [← Cardinal.toNat_le_iff_le_of_lt_aleph0, to_nat_cast] at h
  · exact h.trans_lt (nat_lt_aleph_0 n)
  · exact nat_lt_aleph_0 n
#align finite_dimensional.finrank_le_of_rank_le FiniteDimensional.finrank_le_of_rank_le

/- warning: finite_dimensional.finrank_lt_of_rank_lt -> FiniteDimensional.finrank_lt_of_rank_lt is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LT.lt.{succ u2} Cardinal.{u2} (Preorder.toLT.{succ u2} Cardinal.{u2} (PartialOrder.toPreorder.{succ u2} Cardinal.{u2} Cardinal.partialOrder.{u2})) (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)) -> (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LT.lt.{succ u2} Cardinal.{u2} (Preorder.toLT.{succ u2} Cardinal.{u2} (PartialOrder.toPreorder.{succ u2} Cardinal.{u2} Cardinal.partialOrder.{u2})) (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)) -> (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) n)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_lt_of_rank_lt FiniteDimensional.finrank_lt_of_rank_ltₓ'. -/
theorem finrank_lt_of_rank_lt {n : ℕ} (h : Module.rank K V < ↑n) : finrank K V < n :=
  by
  rwa [← Cardinal.toNat_lt_iff_lt_of_lt_aleph0, to_nat_cast] at h
  · exact h.trans (nat_lt_aleph_0 n)
  · exact nat_lt_aleph_0 n
#align finite_dimensional.finrank_lt_of_rank_lt FiniteDimensional.finrank_lt_of_rank_lt

/- warning: finite_dimensional.rank_lt_of_finrank_lt -> FiniteDimensional.rank_lt_of_finrank_lt is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LT.lt.{0} Nat Nat.hasLt n (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (LT.lt.{succ u2} Cardinal.{u2} (Preorder.toLT.{succ u2} Cardinal.{u2} (PartialOrder.toPreorder.{succ u2} Cardinal.{u2} Cardinal.partialOrder.{u2})) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n) (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (LT.lt.{0} Nat instLTNat n (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (LT.lt.{succ u2} Cardinal.{u2} (Preorder.toLT.{succ u2} Cardinal.{u2} (PartialOrder.toPreorder.{succ u2} Cardinal.{u2} Cardinal.partialOrder.{u2})) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n) (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.rank_lt_of_finrank_lt FiniteDimensional.rank_lt_of_finrank_ltₓ'. -/
theorem rank_lt_of_finrank_lt {n : ℕ} (h : n < finrank K V) : ↑n < Module.rank K V :=
  by
  rwa [← Cardinal.toNat_lt_iff_lt_of_lt_aleph0, to_nat_cast]
  · exact nat_lt_aleph_0 n
  · contrapose! h
    rw [finrank, Cardinal.toNat_apply_of_aleph0_le h]
    exact n.zero_le
#align finite_dimensional.rank_lt_of_finrank_lt FiniteDimensional.rank_lt_of_finrank_lt

#print FiniteDimensional.finrank_le_finrank_of_rank_le_rank /-
theorem finrank_le_finrank_of_rank_le_rank
    (h : lift.{v'} (Module.rank K V) ≤ Cardinal.lift.{v} (Module.rank K V₂))
    (h' : Module.rank K V₂ < ℵ₀) : finrank K V ≤ finrank K V₂ := by
  simpa only [to_nat_lift] using to_nat_le_of_le_of_lt_aleph_0 (lift_lt_aleph_0.mpr h') h
#align finite_dimensional.finrank_le_finrank_of_rank_le_rank FiniteDimensional.finrank_le_finrank_of_rank_le_rank
-/

section

variable [Nontrivial K] [NoZeroSMulDivisors K V]

/- warning: finite_dimensional.nontrivial_of_finrank_pos -> FiniteDimensional.nontrivial_of_finrank_pos is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))], (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (Nontrivial.{u2} V)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))], (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (Nontrivial.{u2} V)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.nontrivial_of_finrank_pos FiniteDimensional.nontrivial_of_finrank_posₓ'. -/
/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/
theorem nontrivial_of_finrank_pos (h : 0 < finrank K V) : Nontrivial V :=
  rank_pos_iff_nontrivial.mp (rank_lt_of_finrank_lt h)
#align finite_dimensional.nontrivial_of_finrank_pos FiniteDimensional.nontrivial_of_finrank_pos

/- warning: finite_dimensional.nontrivial_of_finrank_eq_succ -> FiniteDimensional.nontrivial_of_finrank_eq_succ is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {n : Nat}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (Nat.succ n)) -> (Nontrivial.{u2} V)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] {n : Nat}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (Nat.succ n)) -> (Nontrivial.{u2} V)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.nontrivial_of_finrank_eq_succ FiniteDimensional.nontrivial_of_finrank_eq_succₓ'. -/
/-- A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a
natural number. -/
theorem nontrivial_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) : Nontrivial V :=
  nontrivial_of_finrank_pos (by rw [hn] <;> exact n.succ_pos)
#align finite_dimensional.nontrivial_of_finrank_eq_succ FiniteDimensional.nontrivial_of_finrank_eq_succ

/- warning: finite_dimensional.finrank_zero_of_subsingleton -> FiniteDimensional.finrank_zero_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [h : Subsingleton.{succ u2} V], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : Nontrivial.{u1} K] [_inst_7 : NoZeroSMulDivisors.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [h : Subsingleton.{succ u2} V], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_zero_of_subsingleton FiniteDimensional.finrank_zero_of_subsingletonₓ'. -/
/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/
theorem finrank_zero_of_subsingleton [h : Subsingleton V] : finrank K V = 0 :=
  by
  by_contra h0
  obtain ⟨x, y, hxy⟩ := nontrivial_of_finrank_pos (Nat.pos_of_ne_zero h0)
  exact hxy (Subsingleton.elim _ _)
#align finite_dimensional.finrank_zero_of_subsingleton FiniteDimensional.finrank_zero_of_subsingleton

end

section

variable [StrongRankCondition K]

#print FiniteDimensional.finrank_eq_card_basis /-
/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the
cardinality of the basis. -/
theorem finrank_eq_card_basis {ι : Type w} [Fintype ι] (h : Basis ι K V) :
    finrank K V = Fintype.card ι :=
  finrank_eq_of_rank_eq (rank_eq_card_basis h)
#align finite_dimensional.finrank_eq_card_basis FiniteDimensional.finrank_eq_card_basis
-/

#print FiniteDimensional.finrank_eq_card_finset_basis /-
/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the
cardinality of the basis. This lemma uses a `finset` instead of indexed types. -/
theorem finrank_eq_card_finset_basis {ι : Type w} {b : Finset ι} (h : Basis.{w} b K V) :
    finrank K V = Finset.card b := by rw [finrank_eq_card_basis h, Fintype.card_coe]
#align finite_dimensional.finrank_eq_card_finset_basis FiniteDimensional.finrank_eq_card_finset_basis
-/

variable (K)

#print FiniteDimensional.finrank_self /-
/-- A ring satisfying `strong_rank_condition` (such as a `division_ring`) is one-dimensional as a
module over itself. -/
@[simp]
theorem finrank_self : finrank K K = 1 :=
  finrank_eq_of_rank_eq (by simp)
#align finite_dimensional.finrank_self FiniteDimensional.finrank_self
-/

#print FiniteDimensional.finrank_fintype_fun_eq_card /-
/-- The vector space of functions on a fintype ι has finrank equal to the cardinality of ι. -/
@[simp]
theorem finrank_fintype_fun_eq_card {ι : Type v} [Fintype ι] : finrank K (ι → K) = Fintype.card ι :=
  finrank_eq_of_rank_eq rank_fun'
#align finite_dimensional.finrank_fintype_fun_eq_card FiniteDimensional.finrank_fintype_fun_eq_card
-/

#print FiniteDimensional.finrank_fin_fun /-
/-- The vector space of functions on `fin n` has finrank equal to `n`. -/
@[simp]
theorem finrank_fin_fun {n : ℕ} : finrank K (Fin n → K) = n := by simp
#align finite_dimensional.finrank_fin_fun FiniteDimensional.finrank_fin_fun
-/

end

end Ring

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

#print FiniteDimensional.Basis.subset_extend /-
theorem Basis.subset_extend {s : Set V} (hs : LinearIndependent K (coe : s → V)) :
    s ⊆ hs.extend (Set.subset_univ _) :=
  hs.subset_extend _
#align finite_dimensional.basis.subset_extend FiniteDimensional.Basis.subset_extend
-/

end DivisionRing

end FiniteDimensional

variable {K V}

section ZeroRank

variable [Ring K] [StrongRankCondition K] [AddCommGroup V] [Module K V] [Module.Free K V]

open FiniteDimensional

#print finrank_eq_zero_of_basis_imp_not_finite /-
theorem finrank_eq_zero_of_basis_imp_not_finite
    (h : ∀ s : Set V, Basis.{v} (s : Set V) K V → ¬s.Finite) : finrank K V = 0 :=
  by
  obtain ⟨_, ⟨b⟩⟩ := (Module.free_iff_set K V).mp ‹_›
  exact dif_neg fun rank_lt => h _ b (b.finite_index_of_rank_lt_aleph_0 rank_lt)
#align finrank_eq_zero_of_basis_imp_not_finite finrank_eq_zero_of_basis_imp_not_finite
-/

#print finrank_eq_zero_of_basis_imp_false /-
theorem finrank_eq_zero_of_basis_imp_false (h : ∀ s : Finset V, Basis.{v} (s : Set V) K V → False) :
    finrank K V = 0 :=
  finrank_eq_zero_of_basis_imp_not_finite fun s b hs =>
    h hs.toFinset
      (by
        convert b
        simp)
#align finrank_eq_zero_of_basis_imp_false finrank_eq_zero_of_basis_imp_false
-/

#print finrank_eq_zero_of_not_exists_basis /-
theorem finrank_eq_zero_of_not_exists_basis
    (h : ¬∃ s : Finset V, Nonempty (Basis (s : Set V) K V)) : finrank K V = 0 :=
  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩
#align finrank_eq_zero_of_not_exists_basis finrank_eq_zero_of_not_exists_basis
-/

#print finrank_eq_zero_of_not_exists_basis_finite /-
theorem finrank_eq_zero_of_not_exists_basis_finite
    (h : ¬∃ (s : Set V)(b : Basis.{v} (s : Set V) K V), s.Finite) : finrank K V = 0 :=
  finrank_eq_zero_of_basis_imp_not_finite fun s b hs => h ⟨s, b, hs⟩
#align finrank_eq_zero_of_not_exists_basis_finite finrank_eq_zero_of_not_exists_basis_finite
-/

#print finrank_eq_zero_of_not_exists_basis_finset /-
theorem finrank_eq_zero_of_not_exists_basis_finset (h : ¬∃ s : Finset V, Nonempty (Basis s K V)) :
    finrank K V = 0 :=
  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩
#align finrank_eq_zero_of_not_exists_basis_finset finrank_eq_zero_of_not_exists_basis_finset
-/

end ZeroRank

namespace LinearEquiv

open FiniteDimensional

variable [Ring K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂]

variable {R M M₂ : Type _} [Ring R] [AddCommGroup M] [AddCommGroup M₂]

variable [Module R M] [Module R M₂]

/- warning: linear_equiv.finrank_eq -> LinearEquiv.finrank_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_6 : Ring.{u1} R] [_inst_7 : AddCommGroup.{u2} M] [_inst_8 : AddCommGroup.{u3} M₂] [_inst_9 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7)] [_inst_10 : Module.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8)], (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) _inst_7 _inst_9) (FiniteDimensional.finrank.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) _inst_8 _inst_10))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_6 : Ring.{u3} R] [_inst_7 : AddCommGroup.{u2} M] [_inst_8 : AddCommGroup.{u1} M₂] [_inst_9 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7)] [_inst_10 : Module.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8)], (LinearEquiv.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_6))) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) _inst_7 _inst_9) (FiniteDimensional.finrank.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) _inst_8 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_equiv.finrank_eq LinearEquiv.finrank_eqₓ'. -/
/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/
theorem finrank_eq (f : M ≃ₗ[R] M₂) : finrank R M = finrank R M₂ :=
  by
  unfold finrank
  rw [← Cardinal.toNat_lift, f.lift_rank_eq, Cardinal.toNat_lift]
#align linear_equiv.finrank_eq LinearEquiv.finrank_eq

/- warning: linear_equiv.finrank_map_eq -> LinearEquiv.finrank_map_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_6 : Ring.{u1} R] [_inst_7 : AddCommGroup.{u2} M] [_inst_8 : AddCommGroup.{u3} M₂] [_inst_9 : Module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7)] [_inst_10 : Module.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8)] (f : LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (p : Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9), Eq.{1} Nat (FiniteDimensional.finrank.{u1, u3} R (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_10) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_10) M₂ (Submodule.setLike.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_10)) (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)))))) f) p)) (Ring.toSemiring.{u1} R _inst_6) (Submodule.addCommGroup.{u1, u3} R M₂ _inst_6 _inst_8 _inst_10 (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)))))) f) p)) (Submodule.module.{u1, u3} R M₂ (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_10 (Submodule.map.{u1, u1, u2, u3, max u2 u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6)))) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u3} R R M M₂ (Ring.toSemiring.{u1} R _inst_6) (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_6))) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)) (RingHomInvPair.ids.{u1} R (Ring.toSemiring.{u1} R _inst_6)))))) f) p))) (FiniteDimensional.finrank.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9) M (Submodule.setLike.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9)) p) (Ring.toSemiring.{u1} R _inst_6) (Submodule.addCommGroup.{u1, u2} R M _inst_6 _inst_7 _inst_9 p) (Submodule.module.{u1, u2} R M (Ring.toSemiring.{u1} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9 p))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u2}} {M₂ : Type.{u1}} [_inst_6 : Ring.{u3} R] [_inst_7 : AddCommGroup.{u2} M] [_inst_8 : AddCommGroup.{u1} M₂] [_inst_9 : Module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7)] [_inst_10 : Module.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8)] (f : LinearEquiv.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_6))) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10) (p : Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9), Eq.{1} Nat (FiniteDimensional.finrank.{u3, u1} R (Subtype.{succ u1} M₂ (fun (x : M₂) => Membership.mem.{u1, u1} M₂ (Submodule.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_10) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_10) M₂ (Submodule.setLike.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_10)) x (Submodule.map.{u3, u3, u2, u1, max u2 u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6)))) (LinearEquiv.toLinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_6))) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 f) p))) (Ring.toSemiring.{u3} R _inst_6) (Submodule.addCommGroup.{u3, u1} R M₂ _inst_6 _inst_8 _inst_10 (Submodule.map.{u3, u3, u2, u1, max u2 u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6)))) (LinearEquiv.toLinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_6))) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 f) p)) (Submodule.module.{u3, u1} R M₂ (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_10 (Submodule.map.{u3, u3, u2, u1, max u2 u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M M₂ (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6)))) (LinearEquiv.toLinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_6) (Ring.toSemiring.{u3} R _inst_6) (RingHom.id.{u3} R (NonAssocRing.toNonAssocSemiring.{u3} R (Ring.toNonAssocRing.{u3} R _inst_6))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_6))) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) (RingHomInvPair.ids.{u3} R (Ring.toSemiring.{u3} R _inst_6)) M M₂ (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) (AddCommGroup.toAddCommMonoid.{u1} M₂ _inst_8) _inst_9 _inst_10 f) p))) (FiniteDimensional.finrank.{u3, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9) M (Submodule.setLike.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9)) x p)) (Ring.toSemiring.{u3} R _inst_6) (Submodule.addCommGroup.{u3, u2} R M _inst_6 _inst_7 _inst_9 p) (Submodule.module.{u3, u2} R M (Ring.toSemiring.{u3} R _inst_6) (AddCommGroup.toAddCommMonoid.{u2} M _inst_7) _inst_9 p))
Case conversion may be inaccurate. Consider using '#align linear_equiv.finrank_map_eq LinearEquiv.finrank_map_eqₓ'. -/
/-- Pushforwards of finite-dimensional submodules along a `linear_equiv` have the same finrank. -/
theorem finrank_map_eq (f : M ≃ₗ[R] M₂) (p : Submodule R M) :
    finrank R (p.map (f : M →ₗ[R] M₂)) = finrank R p :=
  (f.submoduleMap p).finrank_eq.symm
#align linear_equiv.finrank_map_eq LinearEquiv.finrank_map_eq

end LinearEquiv

namespace LinearMap

open FiniteDimensional

section Ring

variable [Ring K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂]

/- warning: linear_map.finrank_range_of_inj -> LinearMap.finrank_range_of_inj is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] {f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, (Function.Injective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1)))) f)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u3} K (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) V₂ (Submodule.setLike.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5)) (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f)) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f)) (Submodule.module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] {f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, (Function.Injective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1)))) f)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u3} K (Subtype.{succ u3} V₂ (fun (x : V₂) => Membership.mem.{u3, u3} V₂ (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) V₂ (Submodule.setLike.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5)) x (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f))) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f)) (Submodule.module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K _inst_1) (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (NonAssocRing.toNonAssocSemiring.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1)))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K _inst_1)) f))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align linear_map.finrank_range_of_inj LinearMap.finrank_range_of_injₓ'. -/
/-- The dimensions of the domain and range of an injective linear map are equal. -/
theorem finrank_range_of_inj {f : V →ₗ[K] V₂} (hf : Function.Injective f) :
    finrank K f.range = finrank K V := by rw [(LinearEquiv.ofInjective f hf).finrank_eq]
#align linear_map.finrank_range_of_inj LinearMap.finrank_range_of_inj

end Ring

end LinearMap

open Module FiniteDimensional

section

variable [Ring K] [AddCommGroup V] [Module K V]

variable (K V)

/- warning: finrank_bot -> finrank_bot is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : Nontrivial.{u1} K], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : Nontrivial.{u1} K], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))
Case conversion may be inaccurate. Consider using '#align finrank_bot finrank_botₓ'. -/
@[simp]
theorem finrank_bot [Nontrivial K] : finrank K (⊥ : Submodule K V) = 0 :=
  finrank_eq_of_rank_eq (rank_bot _ _)
#align finrank_bot finrank_bot

/- warning: finrank_top -> finrank_top is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align finrank_top finrank_topₓ'. -/
@[simp]
theorem finrank_top : finrank K (⊤ : Submodule K V) = finrank K V :=
  by
  unfold finrank
  simp [rank_top]
#align finrank_top finrank_top

end

namespace Submodule

section Ring

variable [Ring K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂]

/- warning: submodule.lt_of_le_of_finrank_lt_finrank -> Submodule.lt_of_le_of_finrank_lt_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) s t) -> (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) s t)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t) -> (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t)
Case conversion may be inaccurate. Consider using '#align submodule.lt_of_le_of_finrank_lt_finrank Submodule.lt_of_le_of_finrank_lt_finrankₓ'. -/
theorem lt_of_le_of_finrank_lt_finrank {s t : Submodule K V} (le : s ≤ t)
    (lt : finrank K s < finrank K t) : s < t :=
  lt_of_le_of_ne le fun h => ne_of_lt lt (by rw [h])
#align submodule.lt_of_le_of_finrank_lt_finrank Submodule.lt_of_le_of_finrank_lt_finrank

/- warning: submodule.lt_top_of_finrank_lt_finrank -> Submodule.lt_top_of_finrank_lt_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) s (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (Ring.toSemiring.{u1} K _inst_1) (Submodule.addCommGroup.{u1, u2} K V _inst_1 _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3)) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.lt_top_of_finrank_lt_finrank Submodule.lt_top_of_finrank_lt_finrankₓ'. -/
theorem lt_top_of_finrank_lt_finrank {s : Submodule K V} (lt : finrank K s < finrank K V) : s < ⊤ :=
  by
  rw [← finrank_top K V] at lt
  exact lt_of_le_of_finrank_lt_finrank le_top lt
#align submodule.lt_top_of_finrank_lt_finrank Submodule.lt_top_of_finrank_lt_finrank

end Ring

end Submodule

section Span

open Submodule

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V]

variable (K)

#print Set.finrank /-
/-- The rank of a set of vectors as a natural number. -/
protected noncomputable def Set.finrank (s : Set V) : ℕ :=
  finrank K (span K s)
#align set.finrank Set.finrank
-/

variable {K}

#print finrank_span_le_card /-
theorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) ≤ s.toFinset.card :=
  finrank_le_of_rank_le (by simpa using rank_span_le s)
#align finrank_span_le_card finrank_span_le_card
-/

#print finrank_span_finset_le_card /-
theorem finrank_span_finset_le_card (s : Finset V) : (s : Set V).finrank K ≤ s.card :=
  calc
    (s : Set V).finrank K ≤ (s : Set V).toFinset.card := finrank_span_le_card s
    _ = s.card := by simp
    
#align finrank_span_finset_le_card finrank_span_finset_le_card
-/

/- warning: finrank_range_le_card -> finrank_range_le_card is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, LE.le.{0} Nat Nat.hasLe (Set.finrank.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u3} V ι b)) (Fintype.card.{u3} ι _inst_4)
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, LE.le.{0} Nat instLENat (Set.finrank.{u2, u3} K V _inst_1 _inst_2 _inst_3 (Set.range.{u3, succ u1} V ι b)) (Fintype.card.{u1} ι _inst_4)
Case conversion may be inaccurate. Consider using '#align finrank_range_le_card finrank_range_le_cardₓ'. -/
theorem finrank_range_le_card {ι : Type _} [Fintype ι] {b : ι → V} :
    (Set.range b).finrank K ≤ Fintype.card ι :=
  (finrank_span_le_card _).trans <| by
    rw [Set.toFinset_range]
    exact Finset.card_image_le
#align finrank_range_le_card finrank_range_le_card

/- warning: finrank_span_eq_card -> finrank_span_eq_card is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b)))) (Fintype.card.{u3} ι _inst_4))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b)))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (Submodule.addCommGroup.{u2, u3} K V (DivisionRing.toRing.{u2} K _inst_1) _inst_2 _inst_3 (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b))) (Submodule.module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b)))) (Fintype.card.{u1} ι _inst_4))
Case conversion may be inaccurate. Consider using '#align finrank_span_eq_card finrank_span_eq_cardₓ'. -/
theorem finrank_span_eq_card {ι : Type _} [Fintype ι] {b : ι → V} (hb : LinearIndependent K b) :
    finrank K (span K (Set.range b)) = Fintype.card ι :=
  finrank_eq_of_rank_eq
    (by
      have : Module.rank K (span K (Set.range b)) = (#Set.range b) := rank_span hb
      rwa [← lift_inj, mk_range_eq_of_injective hb.injective, Cardinal.mk_fintype, lift_nat_cast,
        lift_eq_nat_iff] at this)
#align finrank_span_eq_card finrank_span_eq_card

#print finrank_span_set_eq_card /-
theorem finrank_span_set_eq_card (s : Set V) [Fintype s] (hs : LinearIndependent K (coe : s → V)) :
    finrank K (span K s) = s.toFinset.card :=
  finrank_eq_of_rank_eq
    (by
      have : Module.rank K (span K s) = (#s) := rank_span_set hs
      rwa [Cardinal.mk_fintype, ← Set.toFinset_card] at this)
#align finrank_span_set_eq_card finrank_span_set_eq_card
-/

#print finrank_span_finset_eq_card /-
theorem finrank_span_finset_eq_card (s : Finset V) (hs : LinearIndependent K (coe : s → V)) :
    finrank K (span K (s : Set V)) = s.card :=
  by
  convert finrank_span_set_eq_card (↑s) hs
  ext
  simp
#align finrank_span_finset_eq_card finrank_span_finset_eq_card
-/

/- warning: span_lt_of_subset_of_card_lt_finrank -> span_lt_of_subset_of_card_lt_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s)] {t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (HasSubset.Subset.{u2} (Set.{u2} V) (Set.hasSubset.{u2} V) s ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) t)) -> (LT.lt.{0} Nat Nat.hasLt (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s) t)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (Set.Elem.{u2} V s)] {t : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (HasSubset.Subset.{u2} (Set.{u2} V) (Set.instHasSubsetSet.{u2} V) s (SetLike.coe.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) t)) -> (LT.lt.{0} Nat instLTNat (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s) t)
Case conversion may be inaccurate. Consider using '#align span_lt_of_subset_of_card_lt_finrank span_lt_of_subset_of_card_lt_finrankₓ'. -/
theorem span_lt_of_subset_of_card_lt_finrank {s : Set V} [Fintype s] {t : Submodule K V}
    (subset : s ⊆ t) (card_lt : s.toFinset.card < finrank K t) : span K s < t :=
  lt_of_le_of_finrank_lt_finrank (span_le.mpr subset)
    (lt_of_le_of_lt (finrank_span_le_card _) card_lt)
#align span_lt_of_subset_of_card_lt_finrank span_lt_of_subset_of_card_lt_finrank

/- warning: span_lt_top_of_card_lt_finrank -> span_lt_top_of_card_lt_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s)], (LT.lt.{0} Nat Nat.hasLt (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (Set.Elem.{u2} V s)], (LT.lt.{0} Nat instLTNat (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (LT.lt.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align span_lt_top_of_card_lt_finrank span_lt_top_of_card_lt_finrankₓ'. -/
theorem span_lt_top_of_card_lt_finrank {s : Set V} [Fintype s]
    (card_lt : s.toFinset.card < finrank K V) : span K s < ⊤ :=
  lt_top_of_finrank_lt_finrank (lt_of_le_of_lt (finrank_span_le_card _) card_lt)
#align span_lt_top_of_card_lt_finrank span_lt_top_of_card_lt_finrank

end DivisionRing

end Span

section Basis

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V]

/- warning: linear_independent_of_top_le_span_of_card_eq_finrank -> linearIndependent_of_top_le_span_of_card_eq_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) -> (Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, (LE.le.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Preorder.toLE.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.completeLattice.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) (Top.top.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b))) -> (Eq.{1} Nat (Fintype.card.{u1} ι _inst_4) (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3)) -> (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align linear_independent_of_top_le_span_of_card_eq_finrank linearIndependent_of_top_le_span_of_card_eq_finrankₓ'. -/
theorem linearIndependent_of_top_le_span_of_card_eq_finrank {ι : Type _} [Fintype ι] {b : ι → V}
    (spans : ⊤ ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) :
    LinearIndependent K b :=
  linearIndependent_iff'.mpr fun s g dependent i i_mem_s =>
    by
    by_contra gx_ne_zero
    -- We'll derive a contradiction by showing `b '' (univ \ {i})` of cardinality `n - 1`
    -- spans a vector space of dimension `n`.
    refine'
      not_le_of_gt
        (span_lt_top_of_card_lt_finrank
          (show (b '' (Set.univ \ {i})).toFinset.card < finrank K V from _))
        _
    ·
      calc
        (b '' (Set.univ \ {i})).toFinset.card = ((Set.univ \ {i}).toFinset.image b).card := by
          rw [Set.toFinset_card, Fintype.card_ofFinset]
        _ ≤ (Set.univ \ {i}).toFinset.card := Finset.card_image_le
        _ = (finset.univ.erase i).card := (congr_arg Finset.card (Finset.ext (by simp [and_comm'])))
        _ < finset.univ.card := (Finset.card_erase_lt_of_mem (Finset.mem_univ i))
        _ = finrank K V := card_eq
        
    -- We already have that `b '' univ` spans the whole space,
    -- so we only need to show that the span of `b '' (univ \ {i})` contains each `b j`.
    refine' spans.trans (span_le.mpr _)
    rintro _ ⟨j, rfl, rfl⟩
    -- The case that `j ≠ i` is easy because `b j ∈ b '' (univ \ {i})`.
    by_cases j_eq : j = i
    swap
    · refine' subset_span ⟨j, (Set.mem_diff _).mpr ⟨Set.mem_univ _, _⟩, rfl⟩
      exact mt set.mem_singleton_iff.mp j_eq
    -- To show `b i ∈ span (b '' (univ \ {i}))`, we use that it's a weighted sum
    -- of the other `b j`s.
    rw [j_eq, SetLike.mem_coe, show b i = -((g i)⁻¹ • (s.erase i).Sum fun j => g j • b j) from _]
    · refine' neg_mem (smul_mem _ _ (sum_mem fun k hk => _))
      obtain ⟨k_ne_i, k_mem⟩ := finset.mem_erase.mp hk
      refine' smul_mem _ _ (subset_span ⟨k, _, rfl⟩)
      simpa using k_mem
    -- To show `b i` is a weighted sum of the other `b j`s, we'll rewrite this sum
    -- to have the form of the assumption `dependent`.
    apply eq_neg_of_add_eq_zero_left
    calc
      (b i + (g i)⁻¹ • (s.erase i).Sum fun j => g j • b j) =
          (g i)⁻¹ • (g i • b i + (s.erase i).Sum fun j => g j • b j) :=
        by rw [smul_add, ← mul_smul, inv_mul_cancel gx_ne_zero, one_smul]
      _ = (g i)⁻¹ • 0 := (congr_arg _ _)
      _ = 0 := smul_zero _
      
    -- And then it's just a bit of manipulation with finite sums.
    rwa [← Finset.insert_erase i_mem_s, Finset.sum_insert (Finset.not_mem_erase _ _)] at dependent
#align linear_independent_of_top_le_span_of_card_eq_finrank linearIndependent_of_top_le_span_of_card_eq_finrank

/- warning: linear_independent_iff_card_eq_finrank_span -> linearIndependent_iff_card_eq_finrank_span is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, Iff (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (Set.finrank.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u3} V ι b)))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, Iff (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Eq.{1} Nat (Fintype.card.{u1} ι _inst_4) (Set.finrank.{u2, u3} K V _inst_1 _inst_2 _inst_3 (Set.range.{u3, succ u1} V ι b)))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_card_eq_finrank_span linearIndependent_iff_card_eq_finrank_spanₓ'. -/
/-- A finite family of vectors is linearly independent if and only if
its cardinality equals the dimension of its span. -/
theorem linearIndependent_iff_card_eq_finrank_span {ι : Type _} [Fintype ι] {b : ι → V} :
    LinearIndependent K b ↔ Fintype.card ι = (Set.range b).finrank K :=
  by
  constructor
  · intro h
    exact (finrank_span_eq_card h).symm
  · intro hc
    let f := Submodule.subtype (span K (Set.range b))
    let b' : ι → span K (Set.range b) := fun i =>
      ⟨b i, mem_span.2 fun p hp => hp (Set.mem_range_self _)⟩
    have hs : ⊤ ≤ span K (Set.range b') := by
      intro x
      have h : span K (f '' Set.range b') = map f (span K (Set.range b')) := span_image f
      have hf : f '' Set.range b' = Set.range b :=
        by
        ext x
        simp [Set.mem_image, Set.mem_range]
      rw [hf] at h
      have hx : (x : V) ∈ span K (Set.range b) := x.property
      conv at hx =>
        congr
        skip
        rw [h]
      simpa [mem_map] using hx
    have hi : f.ker = ⊥ := ker_subtype _
    convert(linearIndependent_of_top_le_span_of_card_eq_finrank hs hc).map' _ hi
#align linear_independent_iff_card_eq_finrank_span linearIndependent_iff_card_eq_finrank_span

/- warning: linear_independent_iff_card_le_finrank_span -> linearIndependent_iff_card_le_finrank_span is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, Iff (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LE.le.{0} Nat Nat.hasLe (Fintype.card.{u3} ι _inst_4) (Set.finrank.{u1, u2} K V _inst_1 _inst_2 _inst_3 (Set.range.{u2, succ u3} V ι b)))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, Iff (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (LE.le.{0} Nat instLENat (Fintype.card.{u1} ι _inst_4) (Set.finrank.{u2, u3} K V _inst_1 _inst_2 _inst_3 (Set.range.{u3, succ u1} V ι b)))
Case conversion may be inaccurate. Consider using '#align linear_independent_iff_card_le_finrank_span linearIndependent_iff_card_le_finrank_spanₓ'. -/
theorem linearIndependent_iff_card_le_finrank_span {ι : Type _} [Fintype ι] {b : ι → V} :
    LinearIndependent K b ↔ Fintype.card ι ≤ (Set.range b).finrank K := by
  rw [linearIndependent_iff_card_eq_finrank_span, finrank_range_le_card.le_iff_eq]
#align linear_independent_iff_card_le_finrank_span linearIndependent_iff_card_le_finrank_span

/- warning: basis_of_top_le_span_of_card_eq_finrank -> basisOfTopLeSpanOfCardEqFinrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] (b : ι -> V), (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) -> (Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] (b : ι -> V), (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) -> (Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u3, u1, u2} ι K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align basis_of_top_le_span_of_card_eq_finrank basisOfTopLeSpanOfCardEqFinrankₓ'. -/
/-- A family of `finrank K V` vectors forms a basis if they span the whole space. -/
noncomputable def basisOfTopLeSpanOfCardEqFinrank {ι : Type _} [Fintype ι] (b : ι → V)
    (le_span : ⊤ ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) : Basis ι K V :=
  Basis.mk (linearIndependent_of_top_le_span_of_card_eq_finrank le_span card_eq) le_span
#align basis_of_top_le_span_of_card_eq_finrank basisOfTopLeSpanOfCardEqFinrank

/- warning: coe_basis_of_top_le_span_of_card_eq_finrank -> coe_basisOfTopLeSpanOfCardEqFinrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Fintype.{u3} ι] (b : ι -> V) (le_span : LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b))) (card_eq : Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)), Eq.{max (succ u3) (succ u2)} (ι -> V) (coeFn.{max (succ u3) (succ u1) (succ u2), max (succ u3) (succ u2)} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (fun (_x : Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) => ι -> V) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u2), succ u3, succ u2} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (fun (_x : ι) => V) (Basis.funLike.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (basisOfTopLeSpanOfCardEqFinrank.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 ι _inst_4 b le_span card_eq)) b
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Fintype.{u1} ι] (b : ι -> V) (le_span : LE.le.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Preorder.toLE.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.completeLattice.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) (Top.top.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b))) (card_eq : Eq.{1} Nat (Fintype.card.{u1} ι _inst_4) (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3)), Eq.{max (succ u3) (succ u1)} (forall (a : ι), (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) a) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u1, succ u3} (Basis.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) _x) (Basis.funLike.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (basisOfTopLeSpanOfCardEqFinrank.{u2, u3, u1} K V _inst_1 _inst_2 _inst_3 ι _inst_4 b le_span card_eq)) b
Case conversion may be inaccurate. Consider using '#align coe_basis_of_top_le_span_of_card_eq_finrank coe_basisOfTopLeSpanOfCardEqFinrankₓ'. -/
@[simp]
theorem coe_basisOfTopLeSpanOfCardEqFinrank {ι : Type _} [Fintype ι] (b : ι → V)
    (le_span : ⊤ ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) :
    ⇑(basisOfTopLeSpanOfCardEqFinrank b le_span card_eq) = b :=
  Basis.coe_mk _ _
#align coe_basis_of_top_le_span_of_card_eq_finrank coe_basisOfTopLeSpanOfCardEqFinrank

/- warning: finset_basis_of_top_le_span_of_card_eq_finrank -> finsetBasisOfTopLeSpanOfCardEqFinrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Finset.{u2} V}, (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} V) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} V) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} V) (Set.{u2} V) (Finset.Set.hasCoeT.{u2} V))) s))) -> (Eq.{1} Nat (Finset.card.{u2} V s) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} V) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} V) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} V) (Set.{u2} V) (Finset.Set.hasCoeT.{u2} V))) s)) K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Finset.{u2} V}, (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Finset.toSet.{u2} V s))) -> (Eq.{1} Nat (Finset.card.{u2} V s) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u2, u1, u2} (Set.Elem.{u2} V (Finset.toSet.{u2} V s)) K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align finset_basis_of_top_le_span_of_card_eq_finrank finsetBasisOfTopLeSpanOfCardEqFinrankₓ'. -/
/-- A finset of `finrank K V` vectors forms a basis if they span the whole space. -/
@[simps repr_apply]
noncomputable def finsetBasisOfTopLeSpanOfCardEqFinrank {s : Finset V}
    (le_span : ⊤ ≤ span K (s : Set V)) (card_eq : s.card = finrank K V) : Basis (s : Set V) K V :=
  basisOfTopLeSpanOfCardEqFinrank (coe : (s : Set V) → V)
    ((@Subtype.range_coe_subtype _ fun x => x ∈ s).symm ▸ le_span)
    (trans (Fintype.card_coe _) card_eq)
#align finset_basis_of_top_le_span_of_card_eq_finrank finsetBasisOfTopLeSpanOfCardEqFinrank

/- warning: set_basis_of_top_le_span_of_card_eq_finrank -> setBasisOfTopLeSpanOfCardEqFinrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s)], (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) -> (Eq.{1} Nat (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Set.{u2} V} [_inst_4 : Fintype.{u2} (Set.Elem.{u2} V s)], (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) -> (Eq.{1} Nat (Finset.card.{u2} V (Set.toFinset.{u2} V s _inst_4)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Basis.{u2, u1, u2} (Set.Elem.{u2} V s) K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align set_basis_of_top_le_span_of_card_eq_finrank setBasisOfTopLeSpanOfCardEqFinrankₓ'. -/
/-- A set of `finrank K V` vectors forms a basis if they span the whole space. -/
@[simps repr_apply]
noncomputable def setBasisOfTopLeSpanOfCardEqFinrank {s : Set V} [Fintype s]
    (le_span : ⊤ ≤ span K s) (card_eq : s.toFinset.card = finrank K V) : Basis s K V :=
  basisOfTopLeSpanOfCardEqFinrank (coe : s → V) ((@Subtype.range_coe_subtype _ s).symm ▸ le_span)
    (trans s.toFinset_card.symm card_eq)
#align set_basis_of_top_le_span_of_card_eq_finrank setBasisOfTopLeSpanOfCardEqFinrank

end DivisionRing

end Basis

/-!
We now give characterisations of `finrank K V = 1` and `finrank K V ≤ 1`.
-/


section finrank_eq_one

variable [Ring K] [AddCommGroup V] [Module K V]

variable [NoZeroSMulDivisors K V] [StrongRankCondition K]

/- warning: finrank_eq_one -> finrank_eq_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [_inst_5 : StrongRankCondition.{u1} K (Ring.toSemiring.{u1} K _inst_1)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c v) w)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [_inst_5 : StrongRankCondition.{u1} K (Ring.toSemiring.{u1} K _inst_1)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) c v) w)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align finrank_eq_one finrank_eq_oneₓ'. -/
/-- If there is a nonzero vector and every other vector is a multiple of it,
then the module has dimension one. -/
theorem finrank_eq_one (v : V) (n : v ≠ 0) (h : ∀ w : V, ∃ c : K, c • v = w) : finrank K V = 1 :=
  by
  haveI := nontrivial_of_invariantBasisNumber K
  obtain ⟨b⟩ := (Basis.basis_singleton_iff PUnit).mpr ⟨v, n, h⟩
  rw [finrank_eq_card_basis b, Fintype.card_punit]
#align finrank_eq_one finrank_eq_one

/- warning: finrank_le_one -> finrank_le_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [_inst_5 : StrongRankCondition.{u1} K (Ring.toSemiring.{u1} K _inst_1)] (v : V), (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c v) w)) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : NoZeroSMulDivisors.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))] [_inst_5 : StrongRankCondition.{u1} K (Ring.toSemiring.{u1} K _inst_1)] (v : V), (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) c v) w)) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K _inst_1) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align finrank_le_one finrank_le_oneₓ'. -/
/-- If every vector is a multiple of some `v : V`, then `V` has dimension at most one.
-/
theorem finrank_le_one (v : V) (h : ∀ w : V, ∃ c : K, c • v = w) : finrank K V ≤ 1 :=
  by
  haveI := nontrivial_of_invariantBasisNumber K
  rcases eq_or_ne v 0 with (rfl | hn)
  · haveI :=
      subsingleton_of_forall_eq (0 : V) fun w =>
        by
        obtain ⟨c, rfl⟩ := h w
        simp
    rw [finrank_zero_of_subsingleton]
    exact zero_le_one
  · exact (finrank_eq_one v hn h).le
#align finrank_le_one finrank_le_one

end finrank_eq_one

section SubalgebraRank

open Module

variable {F E : Type _} [CommRing F] [Ring E] [Algebra F E]

/- warning: subalgebra.rank_to_submodule -> Subalgebra.rank_toSubmodule is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)] (S : Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3), Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (Submodule.addCommMonoid.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Submodule.module.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S))) (Module.rank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 S))))) (Subalgebra.module.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : CommRing.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2)] (S : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3), Eq.{succ (succ u1)} Cardinal.{u1} (Module.rank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) E (Submodule.setLike.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (a : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S))) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Submodule.addCommMonoid.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S)) (Submodule.module.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S))) (Module.rank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Ring.toNonAssocRing.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Subalgebra.toRing.{u2, u1} F E _inst_1 _inst_2 _inst_3 S))))) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S))
Case conversion may be inaccurate. Consider using '#align subalgebra.rank_to_submodule Subalgebra.rank_toSubmoduleₓ'. -/
@[simp]
theorem Subalgebra.rank_toSubmodule (S : Subalgebra F E) :
    Module.rank F S.toSubmodule = Module.rank F S :=
  rfl
#align subalgebra.rank_to_submodule Subalgebra.rank_toSubmodule

/- warning: subalgebra.finrank_to_submodule -> Subalgebra.finrank_toSubmodule is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)] (S : Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3), Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (Submodule.addCommGroup.{u1, u2} F E (CommRing.toRing.{u1} F _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Submodule.module.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toLE.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S))) (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 S)))) (Subalgebra.module.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : CommRing.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2)] (S : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3), Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) E (Submodule.setLike.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (a : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) a) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S))) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Submodule.addCommGroup.{u2, u1} F E (CommRing.toRing.{u2} F _inst_1) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S)) (Submodule.module.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (RelEmbedding.toEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (Subalgebra.toSubmodule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S))) (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Subalgebra.toRing.{u2, u1} F E _inst_1 _inst_2 _inst_3 S)) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S))
Case conversion may be inaccurate. Consider using '#align subalgebra.finrank_to_submodule Subalgebra.finrank_toSubmoduleₓ'. -/
@[simp]
theorem Subalgebra.finrank_toSubmodule (S : Subalgebra F E) :
    finrank F S.toSubmodule = finrank F S :=
  rfl
#align subalgebra.finrank_to_submodule Subalgebra.finrank_toSubmodule

#print subalgebra_top_rank_eq_submodule_top_rank /-
theorem subalgebra_top_rank_eq_submodule_top_rank :
    Module.rank F (⊤ : Subalgebra F E) = Module.rank F (⊤ : Submodule F E) :=
  by
  rw [← Algebra.top_toSubmodule]
  rfl
#align subalgebra_top_rank_eq_submodule_top_rank subalgebra_top_rank_eq_submodule_top_rank
-/

/- warning: subalgebra_top_finrank_eq_submodule_top_finrank -> subalgebra_top_finrank_eq_submodule_top_finrank is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (Subalgebra.module.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 (Top.top.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Submodule.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.hasTop.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (Submodule.addCommGroup.{u1, u2} F E (CommRing.toRing.{u1} F _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Top.top.{u2} (Submodule.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.hasTop.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Submodule.module.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Top.top.{u2} (Submodule.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.hasTop.{u1, u2} F E (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : CommRing.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2)], Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x (Top.top.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toTop.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x (Top.top.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toTop.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Subalgebra.toRing.{u2, u1} F E _inst_1 _inst_2 _inst_3 (Top.top.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toTop.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3 (Top.top.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toTop.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) E (Submodule.setLike.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (Top.top.{u1} (Submodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.instTopSubmodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Submodule.addCommGroup.{u2, u1} F E (CommRing.toRing.{u2} F _inst_1) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Top.top.{u1} (Submodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.instTopSubmodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Submodule.module.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Top.top.{u1} (Submodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.instTopSubmodule.{u2, u1} F E (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} E (NonAssocRing.toNonUnitalNonAssocRing.{u1} E (Ring.toNonAssocRing.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))
Case conversion may be inaccurate. Consider using '#align subalgebra_top_finrank_eq_submodule_top_finrank subalgebra_top_finrank_eq_submodule_top_finrankₓ'. -/
theorem subalgebra_top_finrank_eq_submodule_top_finrank :
    finrank F (⊤ : Subalgebra F E) = finrank F (⊤ : Submodule F E) :=
  by
  rw [← Algebra.top_toSubmodule]
  rfl
#align subalgebra_top_finrank_eq_submodule_top_finrank subalgebra_top_finrank_eq_submodule_top_finrank

#print Subalgebra.rank_top /-
theorem Subalgebra.rank_top : Module.rank F (⊤ : Subalgebra F E) = Module.rank F E :=
  by
  rw [subalgebra_top_rank_eq_submodule_top_rank]
  exact rank_top F E
#align subalgebra.rank_top Subalgebra.rank_top
-/

section

variable [StrongRankCondition F] [NoZeroSMulDivisors F E] [Nontrivial E]

/- warning: subalgebra.rank_bot -> Subalgebra.rank_bot is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : StrongRankCondition.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} F E (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (CommRing.toRing.{u1} F _inst_1)))))) (MulZeroClass.toHasZero.{u2} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} F E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} F E (MulZeroClass.toHasZero.{u1} F (MulZeroOneClass.toMulZeroClass.{u1} F (MonoidWithZero.toMulZeroOneClass.{u1} F (Semiring.toMonoidWithZero.{u1} F (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} F E (Semiring.toMonoidWithZero.{u1} F (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (Module.toMulActionWithZero.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))] [_inst_6 : Nontrivial.{u2} E], Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.module.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (OfNat.mk.{succ u2} Cardinal.{u2} 1 (One.one.{succ u2} Cardinal.{u2} Cardinal.hasOne.{u2})))
but is expected to have type
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : StrongRankCondition.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} F E (CommMonoidWithZero.toZero.{u1} F (CommSemiring.toCommMonoidWithZero.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1))) (MonoidWithZero.toZero.{u2} E (Semiring.toMonoidWithZero.{u2} E (Ring.toSemiring.{u2} E _inst_2))) (Algebra.toSMul.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)] [_inst_6 : Nontrivial.{u2} E], Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) x (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) x (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) x (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) x (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (Ring.toNonAssocRing.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) x (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (One.toOfNat1.{succ u2} Cardinal.{u2} Cardinal.instOneCardinal.{u2}))
Case conversion may be inaccurate. Consider using '#align subalgebra.rank_bot Subalgebra.rank_botₓ'. -/
@[simp]
theorem Subalgebra.rank_bot : Module.rank F (⊥ : Subalgebra F E) = 1 :=
  ((Subalgebra.toSubmoduleEquiv (⊥ : Subalgebra F E)).symm.trans <|
          LinearEquiv.ofEq _ _ Algebra.toSubmodule_bot).rank_eq.trans <|
    by
    letI := Module.nontrivial F E
    rw [rank_span_set]
    exacts[mk_singleton _, linearIndependent_singleton one_ne_zero]
#align subalgebra.rank_bot Subalgebra.rank_bot

/- warning: subalgebra.finrank_bot -> Subalgebra.finrank_bot is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : CommRing.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : StrongRankCondition.{u1} F (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1))] [_inst_5 : NoZeroSMulDivisors.{u1, u2} F E (MulZeroClass.toHasZero.{u1} F (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} F (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} F (NonAssocRing.toNonUnitalNonAssocRing.{u1} F (Ring.toNonAssocRing.{u1} F (CommRing.toRing.{u1} F _inst_1)))))) (MulZeroClass.toHasZero.{u2} E (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} F E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (SMulWithZero.toSmulZeroClass.{u1, u2} F E (MulZeroClass.toHasZero.{u1} F (MulZeroOneClass.toMulZeroClass.{u1} F (MonoidWithZero.toMulZeroOneClass.{u1} F (Semiring.toMonoidWithZero.{u1} F (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (MulActionWithZero.toSMulWithZero.{u1, u2} F E (Semiring.toMonoidWithZero.{u1} F (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2))))))) (Module.toMulActionWithZero.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (CommRing.toCommSemiring.{u1} F _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))] [_inst_6 : Nontrivial.{u2} E], Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toSemiring.{u1} F (CommRing.toRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Subalgebra.toRing.{u1, u2} F E _inst_1 _inst_2 _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (Subalgebra.module.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3 (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (CommRing.toCommSemiring.{u1} F _inst_1) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : CommRing.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2)] [_inst_4 : StrongRankCondition.{u2} F (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1))] [_inst_5 : NoZeroSMulDivisors.{u2, u1} F E (CommMonoidWithZero.toZero.{u2} F (CommSemiring.toCommMonoidWithZero.{u2} F (CommRing.toCommSemiring.{u2} F _inst_1))) (MonoidWithZero.toZero.{u1} E (Semiring.toMonoidWithZero.{u1} E (Ring.toSemiring.{u1} E _inst_2))) (Algebra.toSMul.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)] [_inst_6 : Nontrivial.{u1} E], Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Ring.toSemiring.{u2} F (CommRing.toRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Subalgebra.toRing.{u2, u1} F E _inst_1 _inst_2 _inst_3 (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3 (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (CommRing.toCommSemiring.{u2} F _inst_1) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))
Case conversion may be inaccurate. Consider using '#align subalgebra.finrank_bot Subalgebra.finrank_botₓ'. -/
@[simp]
theorem Subalgebra.finrank_bot : finrank F (⊥ : Subalgebra F E) = 1 :=
  finrank_eq_of_rank_eq (by simp)
#align subalgebra.finrank_bot Subalgebra.finrank_bot

end

end SubalgebraRank

