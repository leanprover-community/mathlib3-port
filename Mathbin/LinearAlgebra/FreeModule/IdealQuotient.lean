/-
Copyright (c) 2022 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen

! This file was ported from Lean 3 source module linear_algebra.free_module.ideal_quotient
! leanprover-community/mathlib commit 6623e6af705e97002a9054c1c05a980180276fc1
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Zmod.Quotient
import Mathbin.LinearAlgebra.FreeModule.Finite.Basic
import Mathbin.LinearAlgebra.FreeModule.Pid
import Mathbin.LinearAlgebra.QuotientPi

/-! # Ideals in free modules over PIDs

## Main results

 - `ideal.quotient_equiv_pi_span`: `S ⧸ I`, if `S` is finite free as a module over a PID `R`,
   can be written as a product of quotients of `R` by principal ideals.

-/


open BigOperators

variable {ι R S : Type _} [CommRing R] [CommRing S] [Algebra R S]

variable [IsDomain R] [IsPrincipalIdealRing R] [IsDomain S] [Fintype ι]

/- warning: ideal.quotient_equiv_pi_span -> Ideal.quotientEquivPiSpan is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] [_inst_4 : IsDomain.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))] [_inst_5 : IsPrincipalIdealRing.{u2} R (CommRing.toRing.{u2} R _inst_1)] [_inst_6 : IsDomain.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))] [_inst_7 : Fintype.{u1} ι] (I : Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (b : Basis.{u1, u2, u3} ι R S (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3)) (hI : Ne.{succ u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I (Bot.bot.{u3} (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Submodule.hasBot.{u3, u3} S S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))), LinearEquiv.{u2, u2, u3, max u1 u2} R R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)))) (Ideal.quotientEquivPiSpan._proof_1.{u2} R _inst_1) (Ideal.quotientEquivPiSpan._proof_2.{u2} R _inst_1) (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.hasQuotient.{u3} S _inst_2) I) (forall (i : ι), HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (AddCommGroup.toAddCommMonoid.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) (Ideal.hasQuotient.{u3} S _inst_2) I) (Submodule.Quotient.addCommGroup.{u3, u3} S S (CommRing.toRing.{u3} S _inst_2) (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) I)) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ring.toNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ideal.Quotient.commRing.{u2} R _inst_1 (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))))))))) (Submodule.Quotient.module'.{u3, u3, u2} S S (CommRing.toRing.{u3} S _inst_2) (NonUnitalNonAssocRing.toAddCommGroup.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2)))) (Semiring.toModule.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))) R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (SMulZeroClass.toHasSmul.{u2, u3} R S (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (SMulWithZero.toSmulZeroClass.{u2, u3} R S (MulZeroClass.toHasZero.{u2} R (MulZeroOneClass.toMulZeroClass.{u2} R (MonoidWithZero.toMulZeroOneClass.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R S (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (AddZeroClass.toHasZero.{u3} S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)))))))) (Module.toMulActionWithZero.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_2)) _inst_3) (Ideal.quotientEquivPiSpan._proof_3.{u2, u3} R S _inst_1 _inst_2 _inst_3) I) (Algebra.toModule.{u2, max u1 u2} R (forall (i : ι), HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toCommSemiring.{u2} R _inst_1) (Pi.semiring.{u1, u2} ι (fun (i : ι) => HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (fun (i : ι) => Ring.toSemiring.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ideal.Quotient.commRing.{u2} R _inst_1 (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i))))))) (Pi.algebra.{u1, u2, u2} ι R (fun (i : ι) => HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toCommSemiring.{u2} R _inst_1) (fun (i : ι) => Ring.toSemiring.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1))) (Ideal.hasQuotient.{u2} R _inst_1) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ideal.Quotient.commRing.{u2} R _inst_1 (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))))) (fun (i : ι) => Ideal.Quotient.algebra.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_1) _inst_1 (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Ideal.span.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.hasSingleton.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i))))))
but is expected to have type
  forall {ι : Type.{u1}} {R : Type.{u2}} {S : Type.{u3}} [_inst_1 : CommRing.{u2} R] [_inst_2 : CommRing.{u3} S] [_inst_3 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))] [_inst_4 : IsDomain.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))] [_inst_5 : IsPrincipalIdealRing.{u2} R (CommRing.toRing.{u2} R _inst_1)] [_inst_6 : IsDomain.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))] [_inst_7 : Fintype.{u1} ι] (I : Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (b : Basis.{u1, u2, u3} ι R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_2))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_3)) (hI : Ne.{succ u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) I (Bot.bot.{u3} (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Submodule.instBotSubmodule.{u3, u3} S S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))))) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)))))), LinearEquiv.{u2, u2, u3, max u1 u2} R R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))) (RingHomInvPair.ids.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (RingHomInvPair.ids.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (forall (i : ι), HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (NonAssocRing.toNonUnitalNonAssocRing.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (Ring.toNonAssocRing.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (CommRing.toRing.{u3} (HasQuotient.Quotient.{u3, u3} S (Ideal.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u3} S _inst_2) I) (Ideal.Quotient.commRing.{u3} S _inst_2 I)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ring.toNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ideal.Quotient.commRing.{u2} R _inst_1 (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))))))))) (Submodule.Quotient.module'.{u3, u3, u2} S S (CommRing.toRing.{u3} S _inst_2) (Ring.toAddCommGroup.{u3} S (CommRing.toRing.{u3} S _inst_2)) (Semiring.toModule.{u3} S (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2))) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Algebra.toSMul.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_3) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_3) (IsScalarTower.right.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_1) (CommSemiring.toSemiring.{u3} S (CommRing.toCommSemiring.{u3} S _inst_2)) _inst_3) I) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ring.toNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} R (Ideal.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} R _inst_1) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))) (Ideal.Quotient.commRing.{u2} R _inst_1 (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i))))))))) (fun (i : ι) => Submodule.Quotient.module.{u2, u2} R R (CommRing.toRing.{u2} R _inst_1) (Ring.toAddCommGroup.{u2} R (CommRing.toRing.{u2} R _inst_1)) (Semiring.toModule.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1))) (Ideal.span.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)) (Singleton.singleton.{u2, u2} R (Set.{u2} R) (Set.instSingletonSet.{u2} R) (Ideal.smithCoeffs.{u1, u2, u3} ι R _inst_1 _inst_4 _inst_5 S _inst_2 _inst_6 _inst_3 (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))))
Case conversion may be inaccurate. Consider using '#align ideal.quotient_equiv_pi_span Ideal.quotientEquivPiSpanₓ'. -/
/-- We can write the quotient of an ideal over a PID as a product of quotients by principal ideals.
-/
noncomputable def Ideal.quotientEquivPiSpan (I : Ideal S) (b : Basis ι R S) (hI : I ≠ ⊥) :
    (S ⧸ I) ≃ₗ[R] ∀ i, R ⧸ Ideal.span ({I.smithCoeffs b hI i} : Set R) :=
  by
  -- Choose `e : S ≃ₗ I` and a basis `b'` for `S` that turns the map
  -- `f := ((submodule.subtype I).restrict_scalars R).comp e` into a diagonal matrix:
  -- there is an `a : ι → ℤ` such that `f (b' i) = a i • b' i`.
  let a := I.smith_coeffs b hI
  let b' := I.ring_basis b hI
  let ab := I.self_basis b hI
  have ab_eq := I.self_basis_def b hI
  let e : S ≃ₗ[R] I := b'.equiv ab (Equiv.refl _)
  let f : S →ₗ[R] S := (I.subtype.restrict_scalars R).comp (e : S →ₗ[R] I)
  let f_apply : ∀ x, f x = b'.equiv ab (Equiv.refl _) x := fun x => rfl
  have ha : ∀ i, f (b' i) = a i • b' i := by
    intro i
    rw [f_apply, b'.equiv_apply, Equiv.refl_apply, ab_eq]
  have mem_I_iff : ∀ x, x ∈ I ↔ ∀ i, a i ∣ b'.repr x i :=
    by
    intro x
    simp_rw [ab.mem_ideal_iff', ab_eq]
    have : ∀ (c : ι → R) (i), b'.repr (∑ j : ι, c j • a j • b' j) i = a i * c i :=
      by
      intro c i
      simp only [← MulAction.mul_smul, b'.repr_sum_self, mul_comm]
    constructor
    · rintro ⟨c, rfl⟩ i
      exact ⟨c i, this c i⟩
    · rintro ha
      choose c hc using ha
      exact ⟨c, b'.ext_elem fun i => trans (hc i) (this c i).symm⟩
  -- Now we map everything through the linear equiv `S ≃ₗ (ι → R)`,
  -- which maps `I` to `I' := Π i, a i ℤ`.
  let I' : Submodule R (ι → R) := Submodule.pi Set.univ fun i => Ideal.span ({a i} : Set R)
  have : Submodule.map (b'.equiv_fun : S →ₗ[R] ι → R) (I.restrict_scalars R) = I' :=
    by
    ext x
    simp only [Submodule.mem_map, Submodule.mem_pi, Ideal.mem_span_singleton, Set.mem_univ,
      Submodule.restrictScalars_mem, mem_I_iff, smul_eq_mul, forall_true_left, LinearEquiv.coe_coe,
      Basis.equivFun_apply]
    constructor
    · rintro ⟨y, hy, rfl⟩ i
      exact hy i
    · rintro hdvd
      refine' ⟨∑ i, x i • b' i, fun i => _, _⟩ <;> rwa [b'.repr_sum_self]
      · exact hdvd i
  refine' ((Submodule.Quotient.restrictScalarsEquiv R I).restrictScalars R).symm.trans _
  any_goals apply RingHom.id
  any_goals infer_instance
  refine' (Submodule.Quotient.equiv (I.restrict_scalars R) I' b'.equiv_fun this).trans _
  any_goals apply RingHom.id
  any_goals infer_instance
  classical
    let this :=
      Submodule.quotientPi (show ∀ i, Submodule R R from fun i => Ideal.span ({a i} : Set R))
    exact this
#align ideal.quotient_equiv_pi_span Ideal.quotientEquivPiSpan

/- warning: ideal.quotient_equiv_pi_zmod -> Ideal.quotientEquivPiZMod is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_6 : IsDomain.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))] [_inst_7 : Fintype.{u1} ι] (I : Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (b : Basis.{u1, 0, u2} ι Int S Int.semiring (AddCommGroup.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (AddCommGroup.intModule.{u2} S (NonUnitalNonAssocRing.toAddCommGroup.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2)))))) (hI : Ne.{succ u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) I (Bot.bot.{u2} (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Submodule.hasBot.{u2, u2} S S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2)))))), AddEquiv.{u2, u1} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasQuotient.{u2} S _inst_2) I) (forall (i : ι), ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_1 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (Distrib.toHasAdd.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasQuotient.{u2} S _inst_2) I) (Ring.toDistrib.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasQuotient.{u2} S _inst_2) I) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_2))) (Ideal.hasQuotient.{u2} S _inst_2) I) (Ideal.Quotient.commRing.{u2} S _inst_2 I)))) (Pi.instAdd.{u1, 0} ι (fun (i : ι) => ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_2 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (fun (i : ι) => Distrib.toHasAdd.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_3 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (Ring.toDistrib.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_3 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (CommRing.toRing.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_3 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (ZMod.commRing (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.commRing Ideal.quotientEquivPiZMod._proof_3 (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i)))))))
but is expected to have type
  forall {ι : Type.{u1}} {S : Type.{u2}} [_inst_2 : CommRing.{u2} S] [_inst_6 : IsDomain.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))] [_inst_7 : Fintype.{u1} ι] (I : Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (b : Basis.{u1, 0, u2} ι Int S Int.instSemiringInt (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonUnitalNonAssocRing.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_2))))) (AddCommGroup.intModule.{u2} S (Ring.toAddCommGroup.{u2} S (CommRing.toRing.{u2} S _inst_2)))) (hI : Ne.{succ u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) I (Bot.bot.{u2} (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Submodule.instBotSubmodule.{u2, u2} S S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (Semiring.toNonAssocSemiring.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))))) (Semiring.toModule.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2)))))), AddEquiv.{u2, u1} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (forall (i : ι), ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (Distrib.toAdd.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (NonUnitalNonAssocSemiring.toDistrib.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (Ring.toNonAssocRing.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (CommRing.toRing.{u2} (HasQuotient.Quotient.{u2, u2} S (Ideal.{u2} S (CommSemiring.toSemiring.{u2} S (CommRing.toCommSemiring.{u2} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u2} S _inst_2) I) (Ideal.Quotient.commRing.{u2} S _inst_2 I))))))) (Pi.instAdd.{u1, 0} ι (fun (i : ι) => ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (fun (i : ι) => Distrib.toAdd.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (NonUnitalNonAssocSemiring.toDistrib.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (NonAssocRing.toNonUnitalNonAssocRing.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (Ring.toNonAssocRing.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (CommRing.toRing.{0} (ZMod (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))) (ZMod.commRing (Int.natAbs (Ideal.smithCoeffs.{u1, 0, u2} ι Int Int.instCommRingInt (LinearOrderedRing.isDomain.{0} Int (LinearOrderedCommRing.toLinearOrderedRing.{0} Int Int.linearOrderedCommRing)) (EuclideanDomain.to_principal_ideal_domain.{0} Int Int.euclideanDomain) S _inst_2 _inst_6 (algebraInt.{u2} S (CommRing.toRing.{u2} S _inst_2)) (Finite.of_fintype.{u1} ι _inst_7) b I hI i))))))))))
Case conversion may be inaccurate. Consider using '#align ideal.quotient_equiv_pi_zmod Ideal.quotientEquivPiZModₓ'. -/
/-- Ideal quotients over a free finite extension of `ℤ` are isomorphic to a direct product of
`zmod`. -/
noncomputable def Ideal.quotientEquivPiZMod (I : Ideal S) (b : Basis ι ℤ S) (hI : I ≠ ⊥) :
    S ⧸ I ≃+ ∀ i, ZMod (I.smithCoeffs b hI i).natAbs :=
  let a := I.smithCoeffs b hI
  let e := I.quotientEquivPiSpan b hI
  let e' : (∀ i : ι, ℤ ⧸ Ideal.span ({a i} : Set ℤ)) ≃+ ∀ i : ι, ZMod (a i).natAbs :=
    AddEquiv.piCongrRight fun i => ↑(Int.quotientSpanEquivZMod (a i))
  (↑(e : (S ⧸ I) ≃ₗ[ℤ] _) : S ⧸ I ≃+ _).trans e'
#align ideal.quotient_equiv_pi_zmod Ideal.quotientEquivPiZMod

/- warning: ideal.fintype_quotient_of_free_of_ne_bot -> Ideal.fintypeQuotientOfFreeOfNeBot is a dubious translation:
lean 3 declaration is
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_6 : IsDomain.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))] [_inst_8 : Module.Free.{0, u1} Int S Int.semiring (AddCommGroup.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toAddCommGroup.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (AddCommGroup.intModule.{u1} S (NonUnitalNonAssocRing.toAddCommGroup.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))))] [_inst_9 : Module.Finite.{0, u1} Int S Int.semiring (AddCommGroup.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toAddCommGroup.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (AddCommGroup.intModule.{u1} S (NonUnitalNonAssocRing.toAddCommGroup.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2)))))] (I : Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))), (Ne.{succ u1} (Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) I (Bot.bot.{u1} (Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Submodule.hasBot.{u1, u1} S S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2)))))) -> (Fintype.{u1} (HasQuotient.Quotient.{u1, u1} S (Ideal.{u1} S (Ring.toSemiring.{u1} S (CommRing.toRing.{u1} S _inst_2))) (Ideal.hasQuotient.{u1} S _inst_2) I))
but is expected to have type
  forall {S : Type.{u1}} [_inst_2 : CommRing.{u1} S] [_inst_6 : IsDomain.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))] [_inst_8 : Module.Free.{0, u1} Int S Int.instSemiringInt (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (AddCommGroup.intModule.{u1} S (Ring.toAddCommGroup.{u1} S (CommRing.toRing.{u1} S _inst_2)))] [_inst_9 : Module.Finite.{0, u1} Int S Int.instSemiringInt (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} S (NonAssocRing.toNonUnitalNonAssocRing.{u1} S (Ring.toNonAssocRing.{u1} S (CommRing.toRing.{u1} S _inst_2))))) (AddCommGroup.intModule.{u1} S (Ring.toAddCommGroup.{u1} S (CommRing.toRing.{u1} S _inst_2)))] (I : Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))), (Ne.{succ u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) I (Bot.bot.{u1} (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Submodule.instBotSubmodule.{u1, u1} S S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} S (Semiring.toNonAssocSemiring.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))))) (Semiring.toModule.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2)))))) -> (Fintype.{u1} (HasQuotient.Quotient.{u1, u1} S (Ideal.{u1} S (CommSemiring.toSemiring.{u1} S (CommRing.toCommSemiring.{u1} S _inst_2))) (Ideal.instHasQuotientIdealToSemiringToCommSemiring.{u1} S _inst_2) I))
Case conversion may be inaccurate. Consider using '#align ideal.fintype_quotient_of_free_of_ne_bot Ideal.fintypeQuotientOfFreeOfNeBotₓ'. -/
/-- A nonzero ideal over a free finite extension of `ℤ` has a finite quotient.

Can't be an instance because of the side condition `I ≠ ⊥`, and more importantly,
because the choice of `fintype` instance is non-canonical.
-/
noncomputable def Ideal.fintypeQuotientOfFreeOfNeBot [Module.Free ℤ S] [Module.Finite ℤ S]
    (I : Ideal S) (hI : I ≠ ⊥) : Fintype (S ⧸ I) :=
  by
  let b := Module.Free.chooseBasis ℤ S
  let a := I.smithCoeffs b hI
  let e := I.quotientEquivPiZMod b hI
  haveI : ∀ i, NeZero (a i).natAbs := fun i =>
        ⟨Int.natAbs_ne_zero_of_ne_zero (Ideal.smithCoeffs_ne_zero b I hI i)⟩ <;>
      classical skip <;>
    exact Fintype.ofEquiv (∀ i, ZMod (a i).natAbs) e.symm
#align ideal.fintype_quotient_of_free_of_ne_bot Ideal.fintypeQuotientOfFreeOfNeBot

