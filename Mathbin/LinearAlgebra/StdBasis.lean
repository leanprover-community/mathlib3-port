/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl

! This file was ported from Lean 3 source module linear_algebra.std_basis
! leanprover-community/mathlib commit f2edd790f6c6e1d660515f76768f63cb717434d7
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Matrix.Basis
import Mathbin.LinearAlgebra.Basis
import Mathbin.LinearAlgebra.Pi

/-!
# The standard basis

This file defines the standard basis `pi.basis (s : ∀ j, basis (ι j) R (M j))`,
which is the `Σ j, ι j`-indexed basis of Π j, M j`. The basis vectors are given by
`pi.basis s ⟨j, i⟩ j' = linear_map.std_basis R M j' (s j) i = if j = j' then s i else 0`.

The standard basis on `R^η`, i.e. `η → R` is called `pi.basis_fun`.

To give a concrete example, `linear_map.std_basis R (λ (i : fin 3), R) i 1`
gives the `i`th unit basis vector in `R³`, and `pi.basis_fun R (fin 3)` proves
this is a basis over `fin 3 → R`.

## Main definitions

 - `linear_map.std_basis R M`: if `x` is a basis vector of `M i`, then
   `linear_map.std_basis R M i x` is the `i`th standard basis vector of `Π i, M i`.
 - `pi.basis s`: given a basis `s i` for each `M i`, the standard basis on `Π i, M i`
 - `pi.basis_fun R η`: the standard basis on `R^η`, i.e. `η → R`, given by
   `pi.basis_fun R η i j = if i = j then 1 else 0`.
 - `matrix.std_basis R n m`: the standard basis on `matrix n m R`, given by
   `matrix.std_basis R n m (i, j) i' j' = if (i, j) = (i', j') then 1 else 0`.

-/


open Function Submodule

open BigOperators

namespace LinearMap

variable (R : Type _) {ι : Type _} [Semiring R] (φ : ι → Type _) [∀ i, AddCommMonoid (φ i)]
  [∀ i, Module R (φ i)] [DecidableEq ι]

#print LinearMap.stdBasis /-
/-- The standard basis of the product of `φ`. -/
def stdBasis : ∀ i : ι, φ i →ₗ[R] ∀ i, φ i :=
  single
#align linear_map.std_basis LinearMap.stdBasis
-/

/- warning: linear_map.std_basis_apply -> LinearMap.stdBasis_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (b : φ i), Eq.{max (succ u2) (succ u3)} (forall (i : ι), φ i) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (φ i) -> (forall (i : ι), φ i)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b) (Function.update.{succ u2, succ u3} ι (fun (i : ι) => φ i) (fun (a : ι) (b : ι) => _inst_4 a b) (OfNat.ofNat.{max u2 u3} (forall (a : ι), φ a) 0 (OfNat.mk.{max u2 u3} (forall (a : ι), φ a) 0 (Zero.zero.{max u2 u3} (forall (a : ι), φ a) (Pi.instZero.{u2, u3} ι (fun (a : ι) => φ a) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (φ i) (AddMonoid.toAddZeroClass.{u3} (φ i) (AddCommMonoid.toAddMonoid.{u3} (φ i) (_inst_2 i)))))))) i b)
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (i : ι) (b : φ i), Eq.{max (succ u3) (succ u2)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) b) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (φ i) (fun (_x : φ i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b) (Function.update.{succ u3, succ u2} ι (fun (i : ι) => φ i) (fun (a : ι) (b : ι) => _inst_4 a b) (OfNat.ofNat.{max u3 u2} (forall (a : ι), φ a) 0 (Zero.toOfNat0.{max u3 u2} (forall (a : ι), φ a) (Pi.instZero.{u3, u2} ι (fun (a : ι) => φ a) (fun (i : ι) => AddMonoid.toZero.{u2} (φ i) (AddCommMonoid.toAddMonoid.{u2} (φ i) (_inst_2 i)))))) i b)
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_apply LinearMap.stdBasis_applyₓ'. -/
theorem stdBasis_apply (i : ι) (b : φ i) : stdBasis R φ i b = update 0 i b :=
  rfl
#align linear_map.std_basis_apply LinearMap.stdBasis_apply

/- warning: linear_map.std_basis_apply' -> LinearMap.stdBasis_apply' is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (i' : ι), Eq.{succ u1} ((fun (_x : ι) => R) i') (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i))) (fun (_x : LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i))) => R -> (forall (i : ι), (fun (_x : ι) => R) i)) (LinearMap.hasCoeToFun.{u1, u1, u1, max u2 u1} R R ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u1} R ι _inst_1 (fun (_x : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) (fun (a : ι) (b : ι) => _inst_4 a b) i) (OfNat.ofNat.{u1} ((fun (_x : ι) => R) i) 1 (OfNat.mk.{u1} ((fun (_x : ι) => R) i) 1 (One.one.{u1} ((fun (_x : ι) => R) i) (AddMonoidWithOne.toOne.{u1} ((fun (_x : ι) => R) i) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))))))) i') (ite.{succ u1} ((fun (_x : ι) => R) i') (Eq.{succ u2} ι i i') (_inst_4 i i') (OfNat.ofNat.{u1} ((fun (_x : ι) => R) i') 1 (OfNat.mk.{u1} ((fun (_x : ι) => R) i') 1 (One.one.{u1} ((fun (_x : ι) => R) i') (AddMonoidWithOne.toOne.{u1} ((fun (_x : ι) => R) i') (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ((fun (_x : ι) => R) i') (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ((fun (_x : ι) => R) i') (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i') _inst_1))))))) (OfNat.ofNat.{u1} ((fun (_x : ι) => R) i') 0 (OfNat.mk.{u1} ((fun (_x : ι) => R) i') 0 (Zero.zero.{u1} ((fun (_x : ι) => R) i') (MulZeroClass.toHasZero.{u1} ((fun (_x : ι) => R) i') (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} ((fun (_x : ι) => R) i') (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i') (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i') _inst_1))))))))
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_4 : DecidableEq.{succ u1} ι] (i : ι) (i' : ι), Eq.{succ u2} R (FunLike.coe.{max (succ u2) (succ u1), succ u2, max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R (ι -> R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1)))) (Semiring.toModule.{u2} R _inst_1) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => ι -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u2, max u2 u1} R R R (ι -> R) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1)))) (Semiring.toModule.{u2} R _inst_1) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u1, u2} R ι _inst_1 (fun (_x : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) (fun (a : ι) (b : ι) => _inst_4 a b) i) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1))) i') (ite.{succ u2} R (Eq.{succ u1} ι i i') (_inst_4 i i') (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_apply' LinearMap.stdBasis_apply'ₓ'. -/
@[simp]
theorem stdBasis_apply' (i i' : ι) : (stdBasis R (fun _x : ι => R) i) 1 i' = ite (i = i') 1 0 :=
  by
  rw [LinearMap.stdBasis_apply, Function.update_apply, Pi.zero_apply]
  congr 1; rw [eq_iff_iff, eq_comm]
#align linear_map.std_basis_apply' LinearMap.stdBasis_apply'

/- warning: linear_map.coe_std_basis -> LinearMap.coe_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{max (succ u3) (succ (max u2 u3))} ((φ i) -> (forall (i : ι), φ i)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) => (φ i) -> (forall (i : ι), φ i)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (Pi.single.{u2, u3} ι (fun (i : ι) => φ i) (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddZeroClass.toHasZero.{u3} (φ i) (AddMonoid.toAddZeroClass.{u3} (φ i) (AddCommMonoid.toAddMonoid.{u3} (φ i) (_inst_2 i)))) i)
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (i : ι), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : φ i), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (φ i) (fun (_x : φ i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (Pi.single.{u3, u2} ι φ (fun (a : ι) (b : ι) => _inst_4 a b) (fun (i : ι) => AddMonoid.toZero.{u2} (φ i) (AddCommMonoid.toAddMonoid.{u2} (φ i) (_inst_2 i))) i)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_std_basis LinearMap.coe_stdBasisₓ'. -/
theorem coe_stdBasis (i : ι) : ⇑(stdBasis R φ i) = Pi.single i :=
  rfl
#align linear_map.coe_std_basis LinearMap.coe_stdBasis

/- warning: linear_map.std_basis_same -> LinearMap.stdBasis_same is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (b : φ i), Eq.{succ u3} (φ i) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (φ i) -> (forall (i : ι), φ i)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b i) b
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (b : φ i), Eq.{succ u3} (φ i) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (φ i) (fun (_x : φ i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b i) b
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_same LinearMap.stdBasis_sameₓ'. -/
@[simp]
theorem stdBasis_same (i : ι) (b : φ i) : stdBasis R φ i b i = b :=
  Pi.single_eq_same i b
#align linear_map.std_basis_same LinearMap.stdBasis_same

/- warning: linear_map.std_basis_ne -> LinearMap.stdBasis_ne is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (j : ι), (Ne.{succ u2} ι j i) -> (forall (b : φ i), Eq.{succ u3} (φ j) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i))) => (φ i) -> (forall (i : ι), φ i)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 ((fun (i : ι) => _inst_2 i) i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => (fun (i : ι) => _inst_2 i) i)) ((fun (i : ι) => _inst_3 i) i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => (fun (i : ι) => _inst_2 i) i) (fun (i : ι) => (fun (i : ι) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b j) (OfNat.ofNat.{u3} (φ j) 0 (OfNat.mk.{u3} (φ j) 0 (Zero.zero.{u3} (φ j) (AddZeroClass.toHasZero.{u3} (φ j) (AddMonoid.toAddZeroClass.{u3} (φ j) (AddCommMonoid.toAddMonoid.{u3} (φ j) (_inst_2 j))))))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (i : ι) (j : ι), (Ne.{succ u3} ι j i) -> (forall (b : φ i), Eq.{succ u2} (φ j) (FunLike.coe.{max (succ u3) (succ u2), succ u2, max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (φ i) (fun (_x : φ i) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : φ i) => forall (i : ι), φ i) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) b j) (OfNat.ofNat.{u2} (φ j) 0 (Zero.toOfNat0.{u2} (φ j) (AddMonoid.toZero.{u2} (φ j) (AddCommMonoid.toAddMonoid.{u2} (φ j) (_inst_2 j))))))
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_ne LinearMap.stdBasis_neₓ'. -/
theorem stdBasis_ne (i j : ι) (h : j ≠ i) (b : φ i) : stdBasis R φ i b j = 0 :=
  Pi.single_eq_of_ne h b
#align linear_map.std_basis_ne LinearMap.stdBasis_ne

/- warning: linear_map.std_basis_eq_pi_diag -> LinearMap.stdBasis_eq_pi_diag is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) (LinearMap.pi.{u1, u3, u2, u3} R (φ i) ι _inst_1 (_inst_2 i) (_inst_3 i) (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (LinearMap.diag.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (i : ι), Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i) (LinearMap.pi.{u1, u2, u3, u2} R (φ i) ι _inst_1 (_inst_2 i) (_inst_3 i) (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (LinearMap.diag.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i))
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_eq_pi_diag LinearMap.stdBasis_eq_pi_diagₓ'. -/
theorem stdBasis_eq_pi_diag (i : ι) : stdBasis R φ i = pi (diag i) :=
  by
  ext (x j)
  convert(update_apply 0 x i j _).symm
  rfl
#align linear_map.std_basis_eq_pi_diag LinearMap.stdBasis_eq_pi_diag

/- warning: linear_map.ker_std_basis -> LinearMap.ker_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{succ u3} (Submodule.{u1, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)) (LinearMap.ker.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (Bot.bot.{u3} (Submodule.{u1, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)) (Submodule.hasBot.{u1, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)))
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u1}} [_inst_1 : Semiring.{u2} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u2, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u1} ι] (i : ι), Eq.{succ u3} (Submodule.{u2, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)) (LinearMap.ker.{u2, u2, u3, max u1 u3, max u1 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u1, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u1, u3, u2} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (LinearMap.{u2, u2, u3, max u1 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u1, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u1, u3, u2} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u2, u2, u3, max u1 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u1, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u1, u3, u2} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u1, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (Bot.bot.{u3} (Submodule.{u2, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)) (Submodule.instBotSubmodule.{u2, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i)))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_std_basis LinearMap.ker_stdBasisₓ'. -/
theorem ker_stdBasis (i : ι) : ker (stdBasis R φ i) = ⊥ :=
  ker_eq_bot_of_injective <| Pi.single_injective _ _
#align linear_map.ker_std_basis LinearMap.ker_stdBasis

/- warning: linear_map.proj_comp_std_basis -> LinearMap.proj_comp_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (j : ι), Eq.{succ u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u3} R R R (φ j) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 j) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) j)) (LinearMap.diag.{u1, u2, u3} R ι _inst_1 φ (fun (j : ι) => _inst_2 j) (fun (j : ι) => _inst_3 j) (fun (a : ι) (b : ι) => _inst_4 a b) j i)
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u1}} [_inst_1 : Semiring.{u2} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u2, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u1} ι] (i : ι) (j : ι), Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.comp.{u2, u2, u2, u3, max u1 u3, u3} R R R (φ j) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u1, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 j) (Pi.module.{u1, u3, u2} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.proj.{u2, u1, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u2, u1, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) j)) (LinearMap.diag.{u2, u1, u3} R ι _inst_1 φ (fun (j : ι) => _inst_2 j) (fun (j : ι) => _inst_3 j) (fun (a : ι) (b : ι) => _inst_4 a b) j i)
Case conversion may be inaccurate. Consider using '#align linear_map.proj_comp_std_basis LinearMap.proj_comp_stdBasisₓ'. -/
theorem proj_comp_stdBasis (i j : ι) : (proj i).comp (stdBasis R φ j) = diag j i := by
  rw [std_basis_eq_pi_diag, proj_pi]
#align linear_map.proj_comp_std_basis LinearMap.proj_comp_stdBasis

/- warning: linear_map.proj_std_basis_same -> LinearMap.proj_stdBasis_same is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{succ u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (φ i) (_inst_2 i) (_inst_2 i) (_inst_3 i) (_inst_3 i)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u3} R R R (φ i) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (LinearMap.id.{u1, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i))
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u1}} [_inst_1 : Semiring.{u2} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u2, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u1} ι] (i : ι), Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (φ i) (φ i) (_inst_2 i) (_inst_2 i) (_inst_3 i) (_inst_3 i)) (LinearMap.comp.{u2, u2, u2, u3, max u1 u3, u3} R R R (φ i) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u1, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 i) (Pi.module.{u1, u3, u2} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomCompTriple.ids.{u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.proj.{u2, u1, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u2, u1, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)) (LinearMap.id.{u2, u3} R (φ i) _inst_1 (_inst_2 i) (_inst_3 i))
Case conversion may be inaccurate. Consider using '#align linear_map.proj_std_basis_same LinearMap.proj_stdBasis_sameₓ'. -/
theorem proj_stdBasis_same (i : ι) : (proj i).comp (stdBasis R φ i) = id :=
  LinearMap.ext <| stdBasis_same R φ i
#align linear_map.proj_std_basis_same LinearMap.proj_stdBasis_same

/- warning: linear_map.proj_std_basis_ne -> LinearMap.proj_stdBasis_ne is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (i : ι) (j : ι), (Ne.{succ u2} ι i j) -> (Eq.{succ u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u3} R R R (φ j) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 j) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) j)) (OfNat.ofNat.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) 0 (OfNat.mk.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) 0 (Zero.zero.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.hasZero.{u1, u1, u3, u3} R R (φ j) (φ i) _inst_1 _inst_1 (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (i : ι) (j : ι), (Ne.{succ u3} ι i j) -> (Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.comp.{u1, u1, u1, u2, max u3 u2, u2} R R R (φ j) (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (_inst_3 j) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u3, u2} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) j)) (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) 0 (Zero.toOfNat0.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ j) (φ i) (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i)) (LinearMap.instZeroLinearMap.{u1, u1, u2, u2} R R (φ j) (φ i) _inst_1 _inst_1 (_inst_2 j) (_inst_2 i) (_inst_3 j) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_map.proj_std_basis_ne LinearMap.proj_stdBasis_neₓ'. -/
theorem proj_stdBasis_ne (i j : ι) (h : i ≠ j) : (proj i).comp (stdBasis R φ j) = 0 :=
  LinearMap.ext <| stdBasis_ne R φ _ _ h
#align linear_map.proj_std_basis_ne LinearMap.proj_stdBasis_ne

/- warning: linear_map.supr_range_std_basis_le_infi_ker_proj -> LinearMap.supᵢ_range_stdBasis_le_infᵢ_ker_proj is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (I : Set.{u2} ι) (J : Set.{u2} ι), (Disjoint.{u2} (Set.{u2} ι) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} ι) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} ι) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} ι) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} ι) (Set.completeBooleanAlgebra.{u2} ι)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} ι) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} ι) (Set.booleanAlgebra.{u2} ι))) I J) -> (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteSemilatticeInf.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (infᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) => LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (I : Set.{u3} ι) (J : Set.{u3} ι), (Disjoint.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} ι) (Preorder.toLE.{u3} (Set.{u3} ι) (PartialOrder.toPreorder.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) I J) -> (LE.le.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Preorder.toLE.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (PartialOrder.toPreorder.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (infᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) => LinearMap.ker.{u1, u1, max u3 u2, u2, max u3 u2} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, u2} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u3, u2} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))))
Case conversion may be inaccurate. Consider using '#align linear_map.supr_range_std_basis_le_infi_ker_proj LinearMap.supᵢ_range_stdBasis_le_infᵢ_ker_projₓ'. -/
theorem supᵢ_range_stdBasis_le_infᵢ_ker_proj (I J : Set ι) (h : Disjoint I J) :
    (⨆ i ∈ I, range (stdBasis R φ i)) ≤ ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) :=
  by
  refine' supᵢ_le fun i => supᵢ_le fun hi => range_le_iff_comap.2 _
  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]
  rintro b - j hj
  rw [proj_std_basis_ne R φ j i, zero_apply]
  rintro rfl
  exact h.le_bot ⟨hi, hj⟩
#align linear_map.supr_range_std_basis_le_infi_ker_proj LinearMap.supᵢ_range_stdBasis_le_infᵢ_ker_proj

/- warning: linear_map.infi_ker_proj_le_supr_range_std_basis -> LinearMap.infᵢ_ker_proj_le_supᵢ_range_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] {I : Finset.{u2} ι} {J : Set.{u2} ι}, (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.hasSubset.{u2} ι) (Set.univ.{u2} ι) (Union.union.{u2} (Set.{u2} ι) (Set.hasUnion.{u2} ι) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) I) J)) -> (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteSemilatticeInf.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) (infᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) => LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i I) (fun (H : Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i I) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] {I : Finset.{u3} ι} {J : Set.{u3} ι}, (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (Set.univ.{u3} ι) (Union.union.{u3} (Set.{u3} ι) (Set.instUnionSet.{u3} ι) (Finset.toSet.{u3} ι I) J)) -> (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))))) (infᵢ.{max u2 u3, succ u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) => LinearMap.ker.{u1, u1, max u2 u3, u2, max u2 u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u3, u2} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))) (supᵢ.{max u2 u3, succ u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i I) (fun (H : Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i I) => LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))))
Case conversion may be inaccurate. Consider using '#align linear_map.infi_ker_proj_le_supr_range_std_basis LinearMap.infᵢ_ker_proj_le_supᵢ_range_stdBasisₓ'. -/
theorem infᵢ_ker_proj_le_supᵢ_range_stdBasis {I : Finset ι} {J : Set ι} (hu : Set.univ ⊆ ↑I ∪ J) :
    (⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i)) ≤ ⨆ i ∈ I, range (stdBasis R φ i) :=
  SetLike.le_def.2
    (by
      intro b hb
      simp only [mem_infi, mem_ker, proj_apply] at hb
      rw [←
        show (∑ i in I, std_basis R φ i (b i)) = b by
          ext i
          rw [Finset.sum_apply, ← std_basis_same R φ i (b i)]
          refine' Finset.sum_eq_single i (fun j hjI ne => std_basis_ne _ _ _ _ Ne.symm _) _
          intro hiI
          rw [std_basis_same]
          exact hb _ ((hu trivial).resolve_left hiI)]
      exact sum_mem_bsupr fun i hi => mem_range_self (std_basis R φ i) (b i))
#align linear_map.infi_ker_proj_le_supr_range_std_basis LinearMap.infᵢ_ker_proj_le_supᵢ_range_stdBasis

/- warning: linear_map.supr_range_std_basis_eq_infi_ker_proj -> LinearMap.supᵢ_range_stdBasis_eq_infᵢ_ker_proj is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] {I : Set.{u2} ι} {J : Set.{u2} ι}, (Disjoint.{u2} (Set.{u2} ι) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} ι) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} ι) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} ι) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} ι) (Set.completeBooleanAlgebra.{u2} ι)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} ι) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} ι) (Set.booleanAlgebra.{u2} ι))) I J) -> (HasSubset.Subset.{u2} (Set.{u2} ι) (Set.hasSubset.{u2} ι) (Set.univ.{u2} ι) (Union.union.{u2} (Set.{u2} ι) (Set.hasUnion.{u2} ι) I J)) -> (Set.Finite.{u2} ι I) -> (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (infᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasInf.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) => LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u2, u3} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] {I : Set.{u3} ι} {J : Set.{u3} ι}, (Disjoint.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} ι) (Preorder.toLE.{u3} (Set.{u3} ι) (PartialOrder.toPreorder.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) I J) -> (HasSubset.Subset.{u3} (Set.{u3} ι) (Set.instHasSubsetSet.{u3} ι) (Set.univ.{u3} ι) (Union.union.{u3} (Set.{u3} ι) (Set.instUnionSet.{u3} ι) I J)) -> (Set.Finite.{u3} ι I) -> (Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (infᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) ι (fun (i : ι) => infᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instInfSetSubmodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) => LinearMap.ker.{u1, u1, max u3 u2, u2, max u3 u2} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (forall (i : ι), φ i) (φ i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u3 u2, u2} R R (forall (i : ι), φ i) (φ i) _inst_1 _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_2 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (_inst_3 i) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.proj.{u1, u3, u2} R ι _inst_1 (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) i)))))
Case conversion may be inaccurate. Consider using '#align linear_map.supr_range_std_basis_eq_infi_ker_proj LinearMap.supᵢ_range_stdBasis_eq_infᵢ_ker_projₓ'. -/
theorem supᵢ_range_stdBasis_eq_infᵢ_ker_proj {I J : Set ι} (hd : Disjoint I J)
    (hu : Set.univ ⊆ I ∪ J) (hI : Set.Finite I) :
    (⨆ i ∈ I, range (stdBasis R φ i)) = ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) :=
  by
  refine' le_antisymm (supr_range_std_basis_le_infi_ker_proj _ _ _ _ hd) _
  have : Set.univ ⊆ ↑hI.to_finset ∪ J := by rwa [hI.coe_to_finset]
  refine' le_trans (infi_ker_proj_le_supr_range_std_basis R φ this) (supᵢ_mono fun i => _)
  rw [Set.Finite.mem_toFinset]
  exact le_rfl
#align linear_map.supr_range_std_basis_eq_infi_ker_proj LinearMap.supᵢ_range_stdBasis_eq_infᵢ_ker_proj

/- warning: linear_map.supr_range_std_basis -> LinearMap.supᵢ_range_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] [_inst_5 : Finite.{succ u2} ι], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i))) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.hasTop.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] [_inst_5 : Finite.{succ u3} ι], Eq.{max (succ u3) (succ u2)} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i))) (Top.top.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.instTopSubmodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))
Case conversion may be inaccurate. Consider using '#align linear_map.supr_range_std_basis LinearMap.supᵢ_range_stdBasisₓ'. -/
theorem supᵢ_range_stdBasis [Finite ι] : (⨆ i, range (stdBasis R φ i)) = ⊤ :=
  by
  cases nonempty_fintype ι
  convert top_unique (infi_emptyset.ge.trans <| infi_ker_proj_le_supr_range_std_basis R φ _)
  ·
    exact
      funext fun i =>
        ((@supᵢ_pos _ _ _ fun h => range <| std_basis R φ i) <| Finset.mem_univ i).symm
  · rw [Finset.coe_univ, Set.union_empty]
#align linear_map.supr_range_std_basis LinearMap.supᵢ_range_stdBasis

/- warning: linear_map.disjoint_std_basis_std_basis -> LinearMap.disjoint_stdBasis_stdBasis is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u3}) [_inst_2 : forall (i : ι), AddCommMonoid.{u3} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u3} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u2} ι] (I : Set.{u2} ι) (J : Set.{u2} ι), (Disjoint.{u2} (Set.{u2} ι) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} ι) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} ι) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} ι) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} ι) (Set.completeBooleanAlgebra.{u2} ι)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} ι) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} ι) (Set.booleanAlgebra.{u2} ι))) I J) -> (Disjoint.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteSemilatticeInf.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toCompleteSemilatticeInf.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Submodule.orderBot.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i I) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (supᵢ.{max u2 u3, succ u2} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u2 u3, 0} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u2 u3} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) (fun (H : Membership.Mem.{u2, u2} ι (Set.{u2} ι) (Set.hasMem.{u2} ι) i J) => LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u2, u3} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u2, u3} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))))
but is expected to have type
  forall (R : Type.{u1}) {ι : Type.{u3}} [_inst_1 : Semiring.{u1} R] (φ : ι -> Type.{u2}) [_inst_2 : forall (i : ι), AddCommMonoid.{u2} (φ i)] [_inst_3 : forall (i : ι), Module.{u1, u2} R (φ i) _inst_1 (_inst_2 i)] [_inst_4 : DecidableEq.{succ u3} ι] (I : Set.{u3} ι) (J : Set.{u3} ι), (Disjoint.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) (BoundedOrder.toOrderBot.{u3} (Set.{u3} ι) (Preorder.toLE.{u3} (Set.{u3} ι) (PartialOrder.toPreorder.{u3} (Set.{u3} ι) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))))) (CompleteLattice.toBoundedOrder.{u3} (Set.{u3} ι) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} ι) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} ι) (Set.instCompleteBooleanAlgebraSet.{u3} ι)))))) I J) -> (Disjoint.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i I) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))) (supᵢ.{max u3 u2, succ u3} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) ι (fun (i : ι) => supᵢ.{max u3 u2, 0} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (ConditionallyCompleteLattice.toSupSet.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (CompleteLattice.toConditionallyCompleteLattice.{max u3 u2} (Submodule.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (Submodule.completeLattice.{u1, max u3 u2} R (forall (i : ι), φ i) _inst_1 (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))))) (Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) (fun (H : Membership.mem.{u3, u3} ι (Set.{u3} ι) (Set.instMembershipSet.{u3} ι) i J) => LinearMap.range.{u1, u1, u2, max u3 u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (φ i) (forall (i : ι), φ i) (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i))) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u2} R R (φ i) (forall (i : ι), φ i) _inst_1 _inst_1 (_inst_2 i) (Pi.addCommMonoid.{u3, u2} ι (fun (i : ι) => φ i) (fun (i : ι) => _inst_2 i)) (_inst_3 i) (Pi.module.{u3, u2, u1} ι (fun (i : ι) => φ i) R _inst_1 (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.stdBasis.{u1, u3, u2} R ι _inst_1 φ (fun (i : ι) => _inst_2 i) (fun (i : ι) => _inst_3 i) (fun (a : ι) (b : ι) => _inst_4 a b) i)))))
Case conversion may be inaccurate. Consider using '#align linear_map.disjoint_std_basis_std_basis LinearMap.disjoint_stdBasis_stdBasisₓ'. -/
theorem disjoint_stdBasis_stdBasis (I J : Set ι) (h : Disjoint I J) :
    Disjoint (⨆ i ∈ I, range (stdBasis R φ i)) (⨆ i ∈ J, range (stdBasis R φ i)) :=
  by
  refine'
    Disjoint.mono (supr_range_std_basis_le_infi_ker_proj _ _ _ _ <| disjoint_compl_right)
      (supr_range_std_basis_le_infi_ker_proj _ _ _ _ <| disjoint_compl_right) _
  simp only [disjoint_iff_inf_le, SetLike.le_def, mem_infi, mem_inf, mem_ker, mem_bot, proj_apply,
    funext_iff]
  rintro b ⟨hI, hJ⟩ i
  classical
    by_cases hiI : i ∈ I
    · by_cases hiJ : i ∈ J
      · exact (h.le_bot ⟨hiI, hiJ⟩).elim
      · exact hJ i hiJ
    · exact hI i hiI
#align linear_map.disjoint_std_basis_std_basis LinearMap.disjoint_stdBasis_stdBasis

/- warning: linear_map.std_basis_eq_single -> LinearMap.stdBasis_eq_single is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {ι : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_4 : DecidableEq.{succ u2} ι] {a : R}, Eq.{max (succ u2) (succ u1)} (ι -> (forall (i : ι), (fun (_x : ι) => R) i)) (fun (i : ι) => coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i))) (fun (_x : LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i))) => R -> (forall (i : ι), (fun (_x : ι) => R) i)) (LinearMap.hasCoeToFun.{u1, u1, u1, max u2 u1} R R ((fun (_x : ι) => R) i) (forall (i : ι), (fun (_x : ι) => R) i) _inst_1 _inst_1 ((fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i)) ((fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => (fun (_x : ι) => R) i) R _inst_1 (fun (i : ι) => (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) i) (fun (i : ι) => (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u1} R ι _inst_1 (fun (_x : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u1} R _inst_1) (fun (a : ι) (b : ι) => _inst_4 a b) i) a) (fun (i : ι) => coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u2, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (fun (_x : Finsupp.{u2, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) => ι -> R) (Finsupp.coeFun.{u2, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Finsupp.single.{u2, u1} ι R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) i a))
but is expected to have type
  forall (R : Type.{u2}) {ι : Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_4 : DecidableEq.{succ u1} ι] {a : R}, Eq.{max (succ u2) (succ u1)} (ι -> ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => ι -> R) a)) (fun (i : ι) => FunLike.coe.{max (succ u2) (succ u1), succ u2, max (succ u2) (succ u1)} (LinearMap.{u2, u2, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) R (ι -> R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1))) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1)))) (Semiring.toModule.{u2} R _inst_1) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => ι -> R) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u2, max u2 u1} R R R (ι -> R) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1))) (Pi.addCommMonoid.{u1, u2} ι (fun (i : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1)))) (Semiring.toModule.{u2} R _inst_1) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => R) R _inst_1 (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.2287 : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u1, u2} R ι _inst_1 (fun (_x : ι) => R) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} ((fun (_x : ι) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) (Semiring.toNonAssocSemiring.{u2} ((fun (_x : ι) => R) i) _inst_1))) (fun (i : ι) => Semiring.toModule.{u2} R _inst_1) (fun (a : ι) (b : ι) => _inst_4 a b) i) a) (fun (i : ι) => FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => R) _x) (Finsupp.funLike.{u1, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.single.{u1, u2} ι R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) i a))
Case conversion may be inaccurate. Consider using '#align linear_map.std_basis_eq_single LinearMap.stdBasis_eq_singleₓ'. -/
theorem stdBasis_eq_single {a : R} :
    (fun i : ι => (stdBasis R (fun _ : ι => R) i) a) = fun i : ι => Finsupp.single i a :=
  funext fun i => (Finsupp.single_eq_pi_single i a).symm
#align linear_map.std_basis_eq_single LinearMap.stdBasis_eq_single

end LinearMap

namespace Pi

open LinearMap

open Set

variable {R : Type _}

section Module

variable {η : Type _} {ιs : η → Type _} {Ms : η → Type _}

/- warning: pi.linear_independent_std_basis -> Pi.linearIndependent_stdBasis is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {η : Type.{u2}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : forall (i : η), AddCommGroup.{u4} (Ms i)] [_inst_3 : forall (i : η), Module.{u1, u4} R (Ms i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i))] [_inst_4 : DecidableEq.{succ u2} η] (v : forall (j : η), (ιs j) -> (Ms j)), (forall (i : η), LinearIndependent.{u3, u1, u4} (ιs i) R (Ms i) (v i) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (_inst_3 i)) -> (LinearIndependent.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (forall (i : η), Ms i) (fun (ji : Sigma.{u2, u3} η (fun (j : η) => ιs j)) => coeFn.{max (succ u4) (succ (max u2 u4)), max (succ u4) (succ (max u2 u4))} (LinearMap.{u1, u1, u4, max u2 u4} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) ((fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i)) ((fun (i : η) => _inst_3 i) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u1} R _inst_1) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i) (fun (i : η) => (fun (i : η) => _inst_3 i) i))) (fun (_x : LinearMap.{u1, u1, u4, max u2 u4} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) ((fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i)) ((fun (i : η) => _inst_3 i) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u1} R _inst_1) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i) (fun (i : η) => (fun (i : η) => _inst_3 i) i))) => (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) -> (forall (i : η), Ms i)) (LinearMap.hasCoeToFun.{u1, u1, u4, max u2 u4} R R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) ((fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i)) ((fun (i : η) => _inst_3 i) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u1} R _inst_1) (fun (i : η) => (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) i) (fun (i : η) => (fun (i : η) => _inst_3 i) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.stdBasis.{u1, u2, u4} R η (Ring.toSemiring.{u1} R _inst_1) Ms (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i) (fun (a : η) (b : η) => _inst_4 a b) (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (v (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji) (Sigma.snd.{u2, u3} η (fun (j : η) => ιs j) ji))) (Ring.toSemiring.{u1} R _inst_1) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i))) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u1} R _inst_1) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u4} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i)))
but is expected to have type
  forall {R : Type.{u4}} {η : Type.{u2}} {ιs : η -> Type.{u1}} {Ms : η -> Type.{u3}} [_inst_1 : Ring.{u4} R] [_inst_2 : forall (i : η), AddCommGroup.{u3} (Ms i)] [_inst_3 : forall (i : η), Module.{u4, u3} R (Ms i) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i))] [_inst_4 : DecidableEq.{succ u2} η] (v : forall (j : η), (ιs j) -> (Ms j)), (forall (i : η), LinearIndependent.{u1, u4, u3} (ιs i) R (Ms i) (v i) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i)) (_inst_3 i)) -> (LinearIndependent.{max u2 u1, u4, max u2 u3} (Sigma.{u2, u1} η (fun (j : η) => ιs j)) R (forall (i : η), Ms i) (fun (ji : Sigma.{u2, u1} η (fun (j : η) => ιs j)) => FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u4, u4, u3, max u2 u3} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (Ms (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) (AddCommGroup.toAddCommMonoid.{u3} (Ms (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji))) (Pi.addCommMonoid.{u2, u3} η (fun (i : η) => Ms i) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i))) (_inst_3 (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (Pi.module.{u2, u3, u4} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u4} R _inst_1) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i))) (Ms (Sigma.fst.{u2, u1} η (fun (i : η) => ιs i) ji)) (fun (_x : Ms (Sigma.fst.{u2, u1} η (fun (i : η) => ιs i) ji)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Ms (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) => forall (i : η), Ms i) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, max u2 u3} R R (Ms (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (Ms (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji))) (Pi.addCommMonoid.{u2, u3} η (fun (i : η) => Ms i) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i))) (_inst_3 (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (Pi.module.{u2, u3, u4} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u4} R _inst_1) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i)) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1)))) (LinearMap.stdBasis.{u4, u2, u3} R η (Ring.toSemiring.{u4} R _inst_1) Ms (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i) (fun (a : η) (b : η) => _inst_4 a b) (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji)) (v (Sigma.fst.{u2, u1} η (fun (j : η) => ιs j) ji) (Sigma.snd.{u2, u1} η (fun (j : η) => ιs j) ji))) (Ring.toSemiring.{u4} R _inst_1) (Pi.addCommMonoid.{u2, u3} η (fun (i : η) => Ms i) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i))) (Pi.module.{u2, u3, u4} η (fun (i : η) => Ms i) R (Ring.toSemiring.{u4} R _inst_1) (fun (i : η) => AddCommGroup.toAddCommMonoid.{u3} (Ms i) (_inst_2 i)) (fun (i : η) => _inst_3 i)))
Case conversion may be inaccurate. Consider using '#align pi.linear_independent_std_basis Pi.linearIndependent_stdBasisₓ'. -/
theorem linearIndependent_stdBasis [Ring R] [∀ i, AddCommGroup (Ms i)] [∀ i, Module R (Ms i)]
    [DecidableEq η] (v : ∀ j, ιs j → Ms j) (hs : ∀ i, LinearIndependent R (v i)) :
    LinearIndependent R fun ji : Σj, ιs j => stdBasis R Ms ji.1 (v ji.1 ji.2) :=
  by
  have hs' : ∀ j : η, LinearIndependent R fun i : ιs j => std_basis R Ms j (v j i) :=
    by
    intro j
    exact (hs j).map' _ (ker_std_basis _ _ _)
  apply linearIndependent_unionᵢ_finite hs'
  · intro j J _ hiJ
    simp [(Set.unionᵢ.equations._eqn_1 _).symm, Submodule.span_image, Submodule.span_unionᵢ]
    have h₀ :
      ∀ j, span R (range fun i : ιs j => std_basis R Ms j (v j i)) ≤ range (std_basis R Ms j) :=
      by
      intro j
      rw [span_le, LinearMap.range_coe]
      apply range_comp_subset_range
    have h₁ :
      span R (range fun i : ιs j => std_basis R Ms j (v j i)) ≤
        ⨆ i ∈ {j}, range (std_basis R Ms i) :=
      by
      rw [@supᵢ_singleton _ _ _ fun i => LinearMap.range (std_basis R (fun j : η => Ms j) i)]
      apply h₀
    have h₂ :
      (⨆ j ∈ J, span R (range fun i : ιs j => std_basis R Ms j (v j i))) ≤
        ⨆ j ∈ J, range (std_basis R (fun j : η => Ms j) j) :=
      supᵢ₂_mono fun i _ => h₀ i
    have h₃ : Disjoint (fun i : η => i ∈ {j}) J := by
      convert Set.disjoint_singleton_left.2 hiJ using 0
    exact (disjoint_std_basis_std_basis _ _ _ _ h₃).mono h₁ h₂
#align pi.linear_independent_std_basis Pi.linearIndependent_stdBasis

variable [Semiring R] [∀ i, AddCommMonoid (Ms i)] [∀ i, Module R (Ms i)]

variable [Fintype η]

section

open LinearEquiv

#print Pi.basis /-
/-- `pi.basis (s : ∀ j, basis (ιs j) R (Ms j))` is the `Σ j, ιs j`-indexed basis on `Π j, Ms j`
given by `s j` on each component.

For the standard basis over `R` on the finite-dimensional space `η → R` see `pi.basis_fun`.
-/
protected noncomputable def basis (s : ∀ j, Basis (ιs j) R (Ms j)) :
    Basis (Σj, ιs j) R (∀ j, Ms j) :=
  by
  -- The `add_comm_monoid (Π j, Ms j)` instance was hard to find.
  -- Defining this in tactic mode seems to shake up instance search enough that it works by itself.
  refine' Basis.ofRepr (_ ≪≫ₗ (Finsupp.sigmaFinsuppLEquivPiFinsupp R).symm)
  exact LinearEquiv.piCongrRight fun j => (s j).repr
#align pi.basis Pi.basis
-/

/- warning: pi.basis_repr_std_basis -> Pi.basis_repr_stdBasis is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {η : Type.{u2}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : η), AddCommMonoid.{u4} (Ms i)] [_inst_3 : forall (i : η), Module.{u1, u4} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u2} η] [_inst_5 : DecidableEq.{succ u2} η] (s : forall (j : η), Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (j : η) (i : ιs j), Eq.{max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ (max u2 u4)) (succ (max (max u2 u3) u1)), max (succ (max u2 u4)) (succ (max (max u2 u3) u1))} (LinearEquiv.{u1, u1, max u2 u4, max (max u2 u3) u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearEquiv.{u1, u1, max u2 u4, max (max u2 u3) u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => (forall (j : η), Ms j) -> (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u4, max (max u2 u3) u1} R R (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (Basis.repr.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Pi.basis.{u1, u2, u3, u4} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s)) (coeFn.{max (succ u4) (succ (max u2 u4)), max (succ u4) (succ (max u2 u4))} (LinearMap.{u1, u1, u4, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Ms j) (forall (i : η), Ms i) (_inst_2 j) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (fun (_x : LinearMap.{u1, u1, u4, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Ms j) (forall (i : η), Ms i) (_inst_2 j) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) => (Ms j) -> (forall (i : η), Ms i)) (LinearMap.hasCoeToFun.{u1, u1, u4, max u2 u4} R R (Ms j) (forall (i : η), Ms i) _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u4} R η _inst_1 (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i) (fun (j : η) => _inst_3 j) (fun (a : η) (b : η) => _inst_5 a b) j) (coeFn.{max (succ u3) (succ u1) (succ u4), max (succ u3) (succ u4)} (Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (fun (_x : Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) => (ιs j) -> (Ms j)) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u4), succ u3, succ u4} (Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (ιs j) (fun (_x : ιs j) => Ms j) (Basis.funLike.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j))) (s j) i))) (Finsupp.single.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Sigma.mk.{u2, u3} η (fun (j : η) => ιs j) j i) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} R (NonAssocSemiring.toAddCommMonoidWithOne.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))))
but is expected to have type
  forall {R : Type.{u2}} {η : Type.{u4}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : forall (i : η), AddCommMonoid.{u1} (Ms i)] [_inst_3 : forall (i : η), Module.{u2, u1} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u4} η] [_inst_5 : DecidableEq.{succ u4} η] (s : forall (j : η), Basis.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (j : η) (i : ιs j), Eq.{max (max (succ u2) (succ u4)) (succ u3)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (j : η), Ms j) => Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (FunLike.coe.{max (succ u1) (succ u4), succ u1, max (succ u1) (succ u4)} (LinearMap.{u2, u2, u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Ms j) (forall (i : η), Ms i) (_inst_2 j) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Ms j) (fun (a : Ms j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Ms j) => forall (i : η), Ms i) a) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u1 u4} R R (Ms j) (forall (i : η), Ms i) _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u4, u1} R η _inst_1 Ms (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i) (fun (a : η) (b : η) => _inst_5 a b) j) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (ιs j) (fun (a : ιs j) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ιs j) => Ms j) a) (Basis.funLike.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (s j) i))) (FunLike.coe.{max (max (max (succ u2) (succ u4)) (succ u3)) (succ u1), max (succ u4) (succ u1), max (max (succ u2) (succ u4)) (succ u3)} (LinearEquiv.{u2, u2, max u4 u1, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (forall (j : η), Ms j) (fun (_x : forall (j : η), Ms j) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (j : η), Ms j) => Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _x) (SMulHomClass.toFunLike.{max (max (max u2 u4) u3) u1, u2, max u4 u1, max (max u2 u4) u3} (LinearEquiv.{u2, u2, max u4 u1, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) R (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, max u4 u1} R (forall (j : η), Ms j) (AddMonoid.toZero.{max u4 u1} (forall (j : η), Ms j) (AddCommMonoid.toAddMonoid.{max u4 u1} (forall (j : η), Ms j) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u2, max u4 u1} R (forall (j : η), Ms j) (AddMonoid.toAddZeroClass.{max u4 u1} (forall (j : η), Ms j) (AddCommMonoid.toAddMonoid.{max u4 u1} (forall (j : η), Ms j) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u2, max u4 u1} R (forall (j : η), Ms j) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u1} (forall (j : η), Ms j) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i))) (Module.toDistribMulAction.{u2, max u4 u1} R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u2, max (max u2 u4) u3} R (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddMonoid.toZero.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u2, max (max u2 u4) u3} R (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddMonoid.toAddZeroClass.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u2, max (max u2 u4) u3} R (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, max (max u2 u4) u3} R (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u4) u3) u1, u2, max u4 u1, max (max u2 u4) u3} (LinearEquiv.{u2, u2, max u4 u1, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) R (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u4 u1} (forall (j : η), Ms j) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max (max u2 u4) u3} (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, max u4 u1} R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Module.toDistribMulAction.{u2, max (max u2 u4) u3} R (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SemilinearMapClass.distribMulActionHomClass.{u2, max u4 u1, max (max u2 u4) u3, max (max (max u2 u4) u3) u1} R (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (LinearEquiv.{u2, u2, max u4 u1, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max u4 u1, max (max u2 u4) u3, max (max (max u2 u4) u3) u1} R R (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (LinearEquiv.{u2, u2, max u4 u1, max u2 u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max u4 u1, max (max u2 u4) u3} R R (forall (j : η), Ms j) (Finsupp.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u4 u3, u2, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (Basis.repr.{max u4 u3, u2, max u4 u1} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Pi.basis.{u2, u4, u3, u1} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s)) (FunLike.coe.{max (succ u1) (succ u4), succ u1, max (succ u1) (succ u4)} (LinearMap.{u2, u2, u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Ms j) (forall (i : η), Ms i) (_inst_2 j) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Ms j) (fun (_x : Ms j) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Ms j) => forall (i : η), Ms i) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u1 u4} R R (Ms j) (forall (i : η), Ms i) _inst_1 _inst_1 (_inst_2 j) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 j) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u4, u1} R η _inst_1 Ms (fun (i : η) => _inst_2 i) (fun (j : η) => _inst_3 j) (fun (a : η) (b : η) => _inst_5 a b) j) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (ιs j) (fun (_x : ιs j) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ιs j) => Ms j) _x) (Basis.funLike.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (s j) i))) (Finsupp.single.{max u4 u3, u2} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (Sigma.mk.{u4, u3} η (fun (j : η) => ιs j) j i) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (Semiring.toOne.{u2} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align pi.basis_repr_std_basis Pi.basis_repr_stdBasisₓ'. -/
@[simp]
theorem basis_repr_stdBasis [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (j i) :
    (Pi.basis s).repr (stdBasis R _ j (s j i)) = Finsupp.single ⟨j, i⟩ 1 :=
  by
  ext ⟨j', i'⟩
  by_cases hj : j = j'
  · subst hj
    simp only [Pi.basis, LinearEquiv.trans_apply, Basis.repr_self, std_basis_same,
      LinearEquiv.piCongrRight, Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply]
    symm
    exact
      Finsupp.single_apply_left
        (fun i i' (h : (⟨j, i⟩ : Σj, ιs j) = ⟨j, i'⟩) => eq_of_hEq (Sigma.mk.inj h).2) _ _ _
  simp only [Pi.basis, LinearEquiv.trans_apply, Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply,
    LinearEquiv.piCongrRight]
  dsimp
  rw [std_basis_ne _ _ _ _ (Ne.symm hj), LinearEquiv.map_zero, Finsupp.zero_apply,
    Finsupp.single_eq_of_ne]
  rintro ⟨⟩
  contradiction
#align pi.basis_repr_std_basis Pi.basis_repr_stdBasis

/- warning: pi.basis_apply -> Pi.basis_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {η : Type.{u2}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : η), AddCommMonoid.{u4} (Ms i)] [_inst_3 : forall (i : η), Module.{u1, u4} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u2} η] [_inst_5 : DecidableEq.{succ u2} η] (s : forall (j : η), Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (ji : Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)), Eq.{max (succ u2) (succ u4)} (forall (j : η), (fun (j : η) => Ms j) j) (coeFn.{max (succ (max u2 u3)) (succ u1) (succ (max u2 u4)), max (succ (max u2 u3)) (succ (max u2 u4))} (Basis.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) R (forall (j : η), (fun (j : η) => Ms j) j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => (fun (j : η) => Ms j) j) (fun (i : η) => (fun (j : η) => _inst_2 j) i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => (fun (j : η) => Ms j) j) R _inst_1 (fun (i : η) => (fun (j : η) => _inst_2 j) i) (fun (i : η) => (fun (j : η) => _inst_3 j) i))) (fun (_x : Basis.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) R (forall (j : η), (fun (j : η) => Ms j) j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => (fun (j : η) => Ms j) j) (fun (i : η) => (fun (j : η) => _inst_2 j) i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => (fun (j : η) => Ms j) j) R _inst_1 (fun (i : η) => (fun (j : η) => _inst_2 j) i) (fun (i : η) => (fun (j : η) => _inst_3 j) i))) => (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) -> (forall (j : η), (fun (j : η) => Ms j) j)) (FunLike.hasCoeToFun.{max (succ (max u2 u3)) (succ u1) (succ (max u2 u4)), succ (max u2 u3), succ (max u2 u4)} (Basis.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) R (forall (j : η), (fun (j : η) => Ms j) j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => (fun (j : η) => Ms j) j) (fun (i : η) => (fun (j : η) => _inst_2 j) i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => (fun (j : η) => Ms j) j) R _inst_1 (fun (i : η) => (fun (j : η) => _inst_2 j) i) (fun (i : η) => (fun (j : η) => _inst_3 j) i))) (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) (fun (_x : Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) => forall (j : η), (fun (j : η) => Ms j) j) (Basis.funLike.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j)) R (forall (j : η), (fun (j : η) => Ms j) j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => (fun (j : η) => Ms j) j) (fun (i : η) => (fun (j : η) => _inst_2 j) i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => (fun (j : η) => Ms j) j) R _inst_1 (fun (i : η) => (fun (j : η) => _inst_2 j) i) (fun (i : η) => (fun (j : η) => _inst_3 j) i)))) (Pi.basis.{u1, u2, u3, u4} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s) ji) (coeFn.{max (succ u4) (succ (max u2 u4)), max (succ u4) (succ (max u2 u4))} (LinearMap.{u1, u1, u4, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (forall (i : η), Ms i) (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (fun (_x : LinearMap.{u1, u1, u4, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (forall (i : η), Ms i) (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) => (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) -> (forall (i : η), Ms i)) (LinearMap.hasCoeToFun.{u1, u1, u4, max u2 u4} R R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (forall (i : η), Ms i) _inst_1 _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.addCommMonoid.{u2, u4} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Pi.module.{u2, u4, u1} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u4} R η _inst_1 Ms (fun (i : η) => _inst_2 i) (fun (j : η) => _inst_3 j) (fun (a : η) (b : η) => _inst_5 a b) (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (coeFn.{max (succ u3) (succ u1) (succ u4), max (succ u3) (succ u4)} (Basis.{u3, u1, u4} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji))) (fun (_x : Basis.{u3, u1, u4} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji))) => (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) -> (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji))) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u4), succ u3, succ u4} (Basis.{u3, u1, u4} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji))) (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (fun (_x : ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) => Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Basis.funLike.{u3, u1, u4} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)))) (s (Sigma.fst.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)) (Sigma.snd.{u2, u3} η (fun (j : η) => (fun (j : η) => ιs j) j) ji)))
but is expected to have type
  forall {R : Type.{u2}} {η : Type.{u4}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u1}} [_inst_1 : Semiring.{u2} R] [_inst_2 : forall (i : η), AddCommMonoid.{u1} (Ms i)] [_inst_3 : forall (i : η), Module.{u2, u1} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u4} η] [_inst_5 : DecidableEq.{succ u4} η] (s : forall (j : η), Basis.{u3, u2, u1} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (ji : Sigma.{u4, u3} η (fun (j : η) => ιs j)), Eq.{max (succ u4) (succ u1)} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u3} η (fun (j : η) => ιs j)) => forall (j : η), Ms j) ji) (FunLike.coe.{max (max (max (succ u2) (succ u4)) (succ u3)) (succ u1), max (succ u4) (succ u3), max (succ u4) (succ u1)} (Basis.{max u3 u4, u2, max u4 u1} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Sigma.{u4, u3} η (fun (j : η) => ιs j)) (fun (_x : Sigma.{u4, u3} η (fun (j : η) => ιs j)) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : Sigma.{u4, u3} η (fun (j : η) => ιs j)) => forall (j : η), Ms j) _x) (Basis.funLike.{max u4 u3, u2, max u4 u1} (Sigma.{u4, u3} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u4, u1} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u4, u1, u2} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Pi.basis.{u2, u4, u3, u1} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s) ji) (FunLike.coe.{max (succ u4) (succ u1), succ u1, max (succ u4) (succ u1)} (LinearMap.{u2, u2, u1, max u4 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) (_inst_2 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Ms (Sigma.fst.{u4, u3} η (fun (i : η) => ιs i) ji)) (fun (_x : Ms (Sigma.fst.{u4, u3} η (fun (i : η) => ιs i) ji)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) => forall (i : η), Ms i) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, max u4 u1} R R (Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (forall (i : η), Ms i) _inst_1 _inst_1 (_inst_2 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (Pi.addCommMonoid.{u4, u1} η (fun (i : η) => Ms i) (fun (i : η) => _inst_2 i)) (_inst_3 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (Pi.module.{u4, u1, u2} η (fun (i : η) => Ms i) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (LinearMap.stdBasis.{u2, u4, u1} R η _inst_1 Ms (fun (i : η) => _inst_2 i) (fun (j : η) => _inst_3 j) (fun (a : η) (b : η) => _inst_5 a b) (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u3, succ u1} (Basis.{u3, u2, u1} (ιs (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) R (Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji))) (ιs (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (fun (_x : ιs (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ιs (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) => Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) _x) (Basis.funLike.{u3, u2, u1} (ιs (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) R (Ms (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji))) (s (Sigma.fst.{u4, u3} η (fun (j : η) => ιs j) ji)) (Sigma.snd.{u4, u3} η (fun (j : η) => ιs j) ji)))
Case conversion may be inaccurate. Consider using '#align pi.basis_apply Pi.basis_applyₓ'. -/
@[simp]
theorem basis_apply [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (ji) :
    Pi.basis s ji = stdBasis R _ ji.1 (s ji.1 ji.2) :=
  Basis.apply_eq_iff.mpr (by simp)
#align pi.basis_apply Pi.basis_apply

/- warning: pi.basis_repr -> Pi.basis_repr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {η : Type.{u2}} {ιs : η -> Type.{u3}} {Ms : η -> Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : forall (i : η), AddCommMonoid.{u4} (Ms i)] [_inst_3 : forall (i : η), Module.{u1, u4} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u2} η] (s : forall (j : η), Basis.{u3, u1, u4} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (x : forall (j : η), Ms j) (ji : Sigma.{u2, u3} η (fun (j : η) => ιs j)), Eq.{succ u1} R (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ (max u2 u3)) (succ u1)} (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (fun (_x : Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) => (Sigma.{u2, u3} η (fun (j : η) => ιs j)) -> R) (Finsupp.coeFun.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ (max u2 u4)) (succ (max (max u2 u3) u1)), max (succ (max u2 u4)) (succ (max (max u2 u3) u1))} (LinearEquiv.{u1, u1, max u2 u4, max (max u2 u3) u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearEquiv.{u1, u1, max u2 u4, max (max u2 u3) u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => (forall (j : η), Ms j) -> (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u4, max (max u2 u3) u1} R R (forall (j : η), Ms j) (Finsupp.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u2 u3, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u2 u3, u1, u1} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (Basis.repr.{max u2 u3, u1, max u2 u4} (Sigma.{u2, u3} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u2, u4} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u2, u4, u1} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Pi.basis.{u1, u2, u3, u4} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s)) x) ji) (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (fun (_x : Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) => (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) -> R) (Finsupp.coeFun.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{max (succ u4) (succ (max u3 u1)), max (succ u4) (succ (max u3 u1))} (LinearEquiv.{u1, u1, u4, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u3, u1, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearEquiv.{u1, u1, u4, max u3 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u3, u1, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) -> (Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearEquiv.hasCoeToFun.{u1, u1, u4, max u3 u1} R R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u3, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u3, u1, u1} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (Basis.repr.{u3, u1, u4} (ιs (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) R (Ms (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji)) (s (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji))) (x (Sigma.fst.{u2, u3} η (fun (j : η) => ιs j) ji))) (Sigma.snd.{u2, u3} η (fun (j : η) => ιs j) ji))
but is expected to have type
  forall {R : Type.{u3}} {η : Type.{u1}} {ιs : η -> Type.{u4}} {Ms : η -> Type.{u2}} [_inst_1 : Semiring.{u3} R] [_inst_2 : forall (i : η), AddCommMonoid.{u2} (Ms i)] [_inst_3 : forall (i : η), Module.{u3, u2} R (Ms i) _inst_1 (_inst_2 i)] [_inst_4 : Fintype.{u1} η] (s : forall (j : η), Basis.{u4, u3, u2} (ιs j) R (Ms j) _inst_1 (_inst_2 j) (_inst_3 j)) (x : forall (j : η), Ms j) (ji : Sigma.{u1, u4} η (fun (j : η) => ιs j)), Eq.{succ u3} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u4} η (fun (j : η) => ιs j)) => R) ji) (FunLike.coe.{max (succ (max u1 u4)) (succ u3), succ (max u1 u4), succ u3} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Sigma.{u1, u4} η (fun (j : η) => ιs j)) (fun (_x : Sigma.{u1, u4} η (fun (j : η) => ιs j)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : Sigma.{u1, u4} η (fun (j : η) => ιs j)) => R) _x) (Finsupp.funLike.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (FunLike.coe.{max (max (max (succ u3) (succ u1)) (succ u4)) (succ u2), max (succ u1) (succ u2), max (max (succ u3) (succ u1)) (succ u4)} (LinearEquiv.{u3, u3, max u1 u2, max u3 u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (forall (j : η), Ms j) (fun (_x : forall (j : η), Ms j) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : forall (j : η), Ms j) => Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (SMulHomClass.toFunLike.{max (max (max u3 u1) u4) u2, u3, max u1 u2, max (max u3 u1) u4} (LinearEquiv.{u3, u3, max u1 u2, max u3 u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) R (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (SMulZeroClass.toSMul.{u3, max u1 u2} R (forall (j : η), Ms j) (AddMonoid.toZero.{max u1 u2} (forall (j : η), Ms j) (AddCommMonoid.toAddMonoid.{max u1 u2} (forall (j : η), Ms j) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)))) (DistribSMul.toSMulZeroClass.{u3, max u1 u2} R (forall (j : η), Ms j) (AddMonoid.toAddZeroClass.{max u1 u2} (forall (j : η), Ms j) (AddCommMonoid.toAddMonoid.{max u1 u2} (forall (j : η), Ms j) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)))) (DistribMulAction.toDistribSMul.{u3, max u1 u2} R (forall (j : η), Ms j) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u2} (forall (j : η), Ms j) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i))) (Module.toDistribMulAction.{u3, max u1 u2} R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)))))) (SMulZeroClass.toSMul.{u3, max (max u3 u1) u4} R (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddMonoid.toZero.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u3, max (max u3 u1) u4} R (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddMonoid.toAddZeroClass.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u3, max (max u3 u1) u4} R (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Module.toDistribMulAction.{u3, max (max u3 u1) u4} R (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u3 u1) u4) u2, u3, max u1 u2, max (max u3 u1) u4} (LinearEquiv.{u3, u3, max u1 u2, max u3 u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) R (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u1 u2} (forall (j : η), Ms j) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i))) (AddCommMonoid.toAddMonoid.{max (max u3 u1) u4} (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Module.toDistribMulAction.{u3, max u1 u2} R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i))) (Module.toDistribMulAction.{u3, max (max u3 u1) u4} R (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SemilinearMapClass.distribMulActionHomClass.{u3, max u1 u2, max (max u3 u1) u4, max (max (max u3 u1) u4) u2} R (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (LinearEquiv.{u3, u3, max u1 u2, max u3 u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, max u1 u2, max (max u3 u1) u4, max (max (max u3 u1) u4) u2} R R (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (LinearEquiv.{u3, u3, max u1 u2, max u3 u1 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, max u1 u2, max (max u3 u1) u4} R R (forall (j : η), Ms j) (Finsupp.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Finsupp.addCommMonoid.{max u1 u4, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Finsupp.module.{max u1 u4, u3, u3} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (Basis.repr.{max u1 u4, u3, max u1 u2} (Sigma.{u1, u4} η (fun (j : η) => ιs j)) R (forall (j : η), Ms j) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => Ms j) (fun (i : η) => _inst_2 i)) (Pi.module.{u1, u2, u3} η (fun (j : η) => Ms j) R _inst_1 (fun (i : η) => _inst_2 i) (fun (i : η) => _inst_3 i)) (Pi.basis.{u3, u1, u4, u2} R η (fun (j : η) => ιs j) (fun (j : η) => Ms j) _inst_1 (fun (j : η) => _inst_2 j) (fun (j : η) => _inst_3 j) _inst_4 s)) x) ji) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (fun (_x : ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) => R) _x) (Finsupp.funLike.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), succ u2, max (succ u3) (succ u4)} (LinearEquiv.{u3, u3, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (fun (_x : Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) => Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u2, u3, u2, max u3 u4} (LinearEquiv.{u3, u3, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (SMulZeroClass.toSMul.{u3, u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (AddMonoid.toZero.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (AddCommMonoid.toAddMonoid.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)))) (DistribSMul.toSMulZeroClass.{u3, u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (AddMonoid.toAddZeroClass.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (AddCommMonoid.toAddMonoid.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)))) (DistribMulAction.toDistribSMul.{u3, u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji))) (Module.toDistribMulAction.{u3, u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)))))) (SMulZeroClass.toSMul.{u3, max u3 u4} R (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddMonoid.toZero.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u3, max u3 u4} R (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddMonoid.toAddZeroClass.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u3, max u3 u4} R (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Module.toDistribMulAction.{u3, max u3 u4} R (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u2, u3, u2, max u3 u4} (LinearEquiv.{u3, u3, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji))) (AddCommMonoid.toAddMonoid.{max u3 u4} (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))))) (Module.toDistribMulAction.{u3, u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji))) (Module.toDistribMulAction.{u3, max u3 u4} R (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, max u3 u4, max (max u3 u4) u2} R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (LinearEquiv.{u3, u3, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, max u3 u4, max (max u3 u4) u2} R R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (LinearEquiv.{u3, u3, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1))) _inst_1 _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, max u3 u4} R R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R _inst_1))) _inst_1 _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.addCommMonoid.{u4, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)))) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (Finsupp.module.{u4, u3, u3} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (Semiring.toModule.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomInvPair.ids.{u3} R _inst_1) (RingHomInvPair.ids.{u3} R _inst_1)))))) (Basis.repr.{u4, u3, u2} (ιs (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) R (Ms (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) _inst_1 (_inst_2 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (_inst_3 (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji)) (s (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji))) (x (Sigma.fst.{u1, u4} η (fun (j : η) => ιs j) ji))) (Sigma.snd.{u1, u4} η (fun (j : η) => ιs j) ji))
Case conversion may be inaccurate. Consider using '#align pi.basis_repr Pi.basis_reprₓ'. -/
@[simp]
theorem basis_repr (s : ∀ j, Basis (ιs j) R (Ms j)) (x) (ji) :
    (Pi.basis s).repr x ji = (s ji.1).repr (x ji.1) ji.2 :=
  rfl
#align pi.basis_repr Pi.basis_repr

end

section

variable (R η)

#print Pi.basisFun /-
/-- The basis on `η → R` where the `i`th basis vector is `function.update 0 i 1`. -/
noncomputable def basisFun : Basis η R (∀ j : η, R) :=
  Basis.ofEquivFun (LinearEquiv.refl _ _)
#align pi.basis_fun Pi.basisFun
-/

/- warning: pi.basis_fun_apply -> Pi.basisFun_apply is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (η : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_4 : Fintype.{u2} η] [_inst_5 : DecidableEq.{succ u2} η] (i : η), Eq.{max (succ u2) (succ u1)} (η -> R) (coeFn.{max (succ u2) (succ u1) (succ (max u2 u1)), max (succ u2) (succ (max u2 u1))} (Basis.{u2, u1, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : Basis.{u2, u1, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => η -> η -> R) (FunLike.hasCoeToFun.{max (succ u2) (succ u1) (succ (max u2 u1)), succ u2, succ (max u2 u1)} (Basis.{u2, u1, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) η (fun (_x : η) => η -> R) (Basis.funLike.{u2, u1, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)))) (Pi.basisFun.{u1, u2} R η _inst_1 _inst_4) i) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ u1) (succ (max u2 u1))} (LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (i : η) => R) i) (forall (i : η), (fun (i : η) => R) i) ((fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} η (fun (i : η) => (fun (i : η) => R) i) (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i)) ((fun (i : η) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} η (fun (i : η) => (fun (i : η) => R) i) R _inst_1 (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (fun (i : η) => (fun (i : η) => Semiring.toModule.{u1} R _inst_1) i))) (fun (_x : LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) ((fun (i : η) => R) i) (forall (i : η), (fun (i : η) => R) i) ((fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} η (fun (i : η) => (fun (i : η) => R) i) (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i)) ((fun (i : η) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} η (fun (i : η) => (fun (i : η) => R) i) R _inst_1 (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (fun (i : η) => (fun (i : η) => Semiring.toModule.{u1} R _inst_1) i))) => R -> (forall (i : η), (fun (i : η) => R) i)) (LinearMap.hasCoeToFun.{u1, u1, u1, max u2 u1} R R ((fun (i : η) => R) i) (forall (i : η), (fun (i : η) => R) i) _inst_1 _inst_1 ((fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (Pi.addCommMonoid.{u2, u1} η (fun (i : η) => (fun (i : η) => R) i) (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i)) ((fun (i : η) => Semiring.toModule.{u1} R _inst_1) i) (Pi.module.{u2, u1, u1} η (fun (i : η) => (fun (i : η) => R) i) R _inst_1 (fun (i : η) => (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) i) (fun (i : η) => (fun (i : η) => Semiring.toModule.{u1} R _inst_1) i)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u1} R η _inst_1 (fun (i : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1) (fun (a : η) (b : η) => _inst_5 a b) i) (OfNat.ofNat.{u1} ((fun (i : η) => R) i) 1 (OfNat.mk.{u1} ((fun (i : η) => R) i) 1 (One.one.{u1} ((fun (i : η) => R) i) (AddMonoidWithOne.toOne.{u1} ((fun (i : η) => R) i) (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toAddCommMonoidWithOne.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))))))))
but is expected to have type
  forall (R : Type.{u1}) (η : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_4 : Fintype.{u2} η] [_inst_5 : DecidableEq.{succ u2} η] (i : η), Eq.{max (succ u1) (succ u2)} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : η) => η -> R) i) (FunLike.coe.{max (succ u1) (succ u2), succ u2, max (succ u1) (succ u2)} (Basis.{u2, u1, max u1 u2} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u1, u1} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1))) η (fun (_x : η) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : η) => η -> R) _x) (Basis.funLike.{u2, u1, max u1 u2} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.module.{u2, u1, u1} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1))) (Pi.basisFun.{u1, u2} R η _inst_1 _inst_4) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) R (η -> R) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1))) (Pi.addCommMonoid.{u2, u1} η (fun (i : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Pi.module.{u2, u1, u1} η (fun (i : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : R) => η -> R) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u1, max u1 u2} R R R (η -> R) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1))) (Pi.addCommMonoid.{u2, u1} η (fun (i : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1)))) (Semiring.toModule.{u1} R _inst_1) (Pi.module.{u2, u1, u1} η (fun (i : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3637 : η) => R) i) _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.stdBasis.{u1, u2, u1} R η _inst_1 (fun (i : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} ((fun (i : η) => R) i) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} ((fun (i : η) => R) i) (Semiring.toNonAssocSemiring.{u1} ((fun (i : η) => R) i) _inst_1))) (fun (i : η) => Semiring.toModule.{u1} R _inst_1) (fun (a : η) (b : η) => _inst_5 a b) i) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (Semiring.toOne.{u1} R _inst_1))))
Case conversion may be inaccurate. Consider using '#align pi.basis_fun_apply Pi.basisFun_applyₓ'. -/
@[simp]
theorem basisFun_apply [DecidableEq η] (i) : basisFun R η i = stdBasis R (fun i : η => R) i 1 := by
  simp only [basis_fun, Basis.coe_ofEquivFun, LinearEquiv.refl_symm, LinearEquiv.refl_apply,
    std_basis_apply]
#align pi.basis_fun_apply Pi.basisFun_apply

/- warning: pi.basis_fun_repr -> Pi.basisFun_repr is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (η : Type.{u2}) [_inst_1 : Semiring.{u1} R] [_inst_4 : Fintype.{u2} η] (x : η -> R) (i : η), Eq.{succ u1} R (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (fun (_x : Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) => η -> R) (Finsupp.coeFun.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (coeFn.{succ (max u2 u1), succ (max u2 u1)} (LinearEquiv.{u1, u1, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (η -> R) (Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.addCommMonoid.{u2, u1} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) (fun (_x : LinearEquiv.{u1, u1, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (η -> R) (Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.addCommMonoid.{u2, u1} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1))) => (η -> R) -> (Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u1, max u2 u1} R R (η -> R) (Finsupp.{u2, u1} η R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) _inst_1 _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Finsupp.addCommMonoid.{u2, u1} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Finsupp.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (Basis.repr.{u2, u1, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u2, u1} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (Pi.Function.module.{u2, u1, u1} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Semiring.toModule.{u1} R _inst_1)) (Pi.basisFun.{u1, u2} R η _inst_1 _inst_4)) x) i) (x i)
but is expected to have type
  forall (R : Type.{u2}) (η : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_4 : Fintype.{u1} η] (x : η -> R) (i : η), Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : η) => R) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) η (fun (_x : η) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : η) => R) _x) (Finsupp.funLike.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (LinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (η -> R) (fun (_x : η -> R) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : η -> R) => Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _x) (SMulHomClass.toFunLike.{max u2 u1, u2, max u2 u1, max u2 u1} (LinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) R (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (SMulZeroClass.toSMul.{u2, max u2 u1} R (η -> R) (AddMonoid.toZero.{max u2 u1} (η -> R) (AddCommMonoid.toAddMonoid.{max u2 u1} (η -> R) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u2, max u2 u1} R (η -> R) (AddMonoid.toAddZeroClass.{max u2 u1} (η -> R) (AddCommMonoid.toAddMonoid.{max u2 u1} (η -> R) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u2, max u2 u1} R (η -> R) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u1} (η -> R) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, max u2 u1} R (η -> R) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)))))) (SMulZeroClass.toSMul.{u2, max u2 u1} R (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddMonoid.toZero.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribSMul.toSMulZeroClass.{u2, max u2 u1} R (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))))) (DistribMulAction.toDistribSMul.{u2, max u2 u1} R (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, max u2 u1} R (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)))))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u2, max u2 u1, max u2 u1} (LinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) R (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u1} (η -> R) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))))) (Module.toDistribMulAction.{u2, max u2 u1} R (η -> R) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1))) (Module.toDistribMulAction.{u2, max u2 u1} R (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) (SemilinearMapClass.distribMulActionHomClass.{u2, max u2 u1, max u2 u1, max u2 u1} R (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (LinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, max u2 u1, max u2 u1, max u2 u1} R R (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (LinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, max u2 u1, max u2 u1} R R (η -> R) (Finsupp.{u1, u2} η R (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1))) _inst_1 _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Finsupp.addCommMonoid.{u1, u2} η R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Finsupp.module.{u1, u2, u2} η R R _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (Semiring.toModule.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (RingHomInvPair.ids.{u2} R _inst_1) (RingHomInvPair.ids.{u2} R _inst_1)))))) (Basis.repr.{u1, u2, max u2 u1} η R (η -> R) _inst_1 (Pi.addCommMonoid.{u1, u2} η (fun (j : η) => R) (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)))) (Pi.module.{u1, u2, u2} η (fun (x._@.Mathlib.LinearAlgebra.StdBasis._hyg.3573 : η) => R) R _inst_1 (fun (i : η) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1))) (fun (i : η) => Semiring.toModule.{u2} R _inst_1)) (Pi.basisFun.{u2, u1} R η _inst_1 _inst_4)) x) i) (x i)
Case conversion may be inaccurate. Consider using '#align pi.basis_fun_repr Pi.basisFun_reprₓ'. -/
@[simp]
theorem basisFun_repr (x : η → R) (i : η) : (Pi.basisFun R η).repr x i = x i := by simp [basis_fun]
#align pi.basis_fun_repr Pi.basisFun_repr

end

end Module

end Pi

namespace Matrix

variable (R : Type _) (m n : Type _) [Fintype m] [Fintype n] [Semiring R]

#print Matrix.stdBasis /-
/-- The standard basis of `matrix m n R`. -/
noncomputable def stdBasis : Basis (m × n) R (Matrix m n R) :=
  Basis.reindex (Pi.basis fun i : m => Pi.basisFun R n) (Equiv.sigmaEquivProd _ _)
#align matrix.std_basis Matrix.stdBasis
-/

variable {n m}

#print Matrix.stdBasis_eq_stdBasisMatrix /-
theorem stdBasis_eq_stdBasisMatrix (i : n) (j : m) [DecidableEq n] [DecidableEq m] :
    stdBasis R n m (i, j) = stdBasisMatrix i j (1 : R) :=
  by
  ext (a b)
  by_cases hi : i = a <;> by_cases hj : j = b
  · simp [std_basis, hi, hj]
  · simp [std_basis, hi, hj, Ne.symm hj, LinearMap.stdBasis_ne]
  · simp [std_basis, hi, hj, Ne.symm hi, LinearMap.stdBasis_ne]
  · simp [std_basis, hi, hj, Ne.symm hj, Ne.symm hi, LinearMap.stdBasis_ne]
#align matrix.std_basis_eq_std_basis_matrix Matrix.stdBasis_eq_stdBasisMatrix
-/

end Matrix

