/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module linear_algebra.affine_space.slope
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.AffineMap
import Mathbin.Tactic.FieldSimp

/-!
# Slope of a function

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define the slope of a function `f : k → PE` taking values in an affine space over
`k` and prove some basic theorems about `slope`. The `slope` function naturally appears in the Mean
Value Theorem, and in the proof of the fact that a function with nonnegative second derivative on an
interval is convex on this interval.

## Tags

affine space, slope
-/


open AffineMap

variable {k E PE : Type _} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE]

include E

#print slope /-
/-- `slope f a b = (b - a)⁻¹ • (f b -ᵥ f a)` is the slope of a function `f` on the interval
`[a, b]`. Note that `slope f a a = 0`, not the derivative of `f` at `a`. -/
def slope (f : k → PE) (a b : k) : E :=
  (b - a)⁻¹ • (f b -ᵥ f a)
#align slope slope
-/

/- warning: slope_fun_def -> slope_fun_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE), Eq.{max (succ u1) (succ u2)} (k -> k -> E) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f) (fun (a : k) (b : k) => SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a)) (VSub.vsub.{u2, u3} E PE (AddTorsor.toHasVsub.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4) (f b) (f a)))
but is expected to have type
  forall {k : Type.{u3}} {E : Type.{u2}} {PE : Type.{u1}} [_inst_1 : Field.{u3} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} k E (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE), Eq.{max (succ u3) (succ u2)} (k -> k -> E) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f) (fun (a : k) (b : k) => HSMul.hSMul.{u3, u2, u2} k E E (instHSMul.{u3, u2} k E (SMulZeroClass.toSMul.{u3, u2} k E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k E (CommMonoidWithZero.toZero.{u3} k (CommGroupWithZero.toCommMonoidWithZero.{u3} k (Semifield.toCommGroupWithZero.{u3} k (Field.toSemifield.{u3} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k E (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k E (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (Inv.inv.{u3} k (Field.toInv.{u3} k _inst_1) (HSub.hSub.{u3, u3, u3} k k k (instHSub.{u3} k (Ring.toSub.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) b a)) (VSub.vsub.{u2, u1} E PE (AddTorsor.toVSub.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4) (f b) (f a)))
Case conversion may be inaccurate. Consider using '#align slope_fun_def slope_fun_defₓ'. -/
theorem slope_fun_def (f : k → PE) : slope f = fun a b => (b - a)⁻¹ • (f b -ᵥ f a) :=
  rfl
#align slope_fun_def slope_fun_def

omit E

/- warning: slope_def_field -> slope_def_field is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Field.{u1} k] (f : k -> k) (a : k) (b : k), Eq.{succ u1} k (slope.{u1, u1, u1} k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) f a b) (HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (DivInvMonoid.toHasDiv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) (f b) (f a)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Field.{u1} k] (f : k -> k) (a : k) (b : k), Eq.{succ u1} k (slope.{u1, u1, u1} k k k _inst_1 (Ring.toAddCommGroup.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) f a b) (HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (Field.toDiv.{u1} k _inst_1)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (f b) (f a)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) b a))
Case conversion may be inaccurate. Consider using '#align slope_def_field slope_def_fieldₓ'. -/
theorem slope_def_field (f : k → k) (a b : k) : slope f a b = (f b - f a) / (b - a) :=
  (div_eq_inv_mul _ _).symm
#align slope_def_field slope_def_field

/- warning: slope_fun_def_field -> slope_fun_def_field is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Field.{u1} k] (f : k -> k) (a : k), Eq.{succ u1} (k -> k) (slope.{u1, u1, u1} k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) f a) (fun (b : k) => HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (DivInvMonoid.toHasDiv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) (f b) (f a)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Field.{u1} k] (f : k -> k) (a : k), Eq.{succ u1} (k -> k) (slope.{u1, u1, u1} k k k _inst_1 (Ring.toAddCommGroup.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) f a) (fun (b : k) => HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (Field.toDiv.{u1} k _inst_1)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (f b) (f a)) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) b a))
Case conversion may be inaccurate. Consider using '#align slope_fun_def_field slope_fun_def_fieldₓ'. -/
theorem slope_fun_def_field (f : k → k) (a : k) : slope f a = fun b => (f b - f a) / (b - a) :=
  (div_eq_inv_mul _ _).symm
#align slope_fun_def_field slope_fun_def_field

/- warning: slope_same -> slope_same is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k), Eq.{succ u2} E (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a a) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] (f : k -> PE) (a : k), Eq.{succ u3} E (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a a) (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align slope_same slope_sameₓ'. -/
@[simp]
theorem slope_same (f : k → PE) (a : k) : (slope f a a : E) = 0 := by
  rw [slope, sub_self, inv_zero, zero_smul]
#align slope_same slope_same

include E

/- warning: slope_def_module -> slope_def_module is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (f : k -> E) (a : k) (b : k), Eq.{succ u2} E (slope.{u1, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) f a b) (SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a)) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toHasSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) (f b) (f a)))
but is expected to have type
  forall {k : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (f : k -> E) (a : k) (b : k), Eq.{succ u2} E (slope.{u1, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) f a b) (HSMul.hSMul.{u1, u2, u2} k E E (instHSMul.{u1, u2} k E (SMulZeroClass.toSMul.{u1, u2} k E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k E (CommMonoidWithZero.toZero.{u1} k (CommGroupWithZero.toCommMonoidWithZero.{u1} k (Semifield.toCommGroupWithZero.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k E (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (Inv.inv.{u1} k (Field.toInv.{u1} k _inst_1) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) b a)) (HSub.hSub.{u2, u2, u2} E E E (instHSub.{u2} E (SubNegMonoid.toSub.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))) (f b) (f a)))
Case conversion may be inaccurate. Consider using '#align slope_def_module slope_def_moduleₓ'. -/
theorem slope_def_module (f : k → E) (a b : k) : slope f a b = (b - a)⁻¹ • (f b - f a) :=
  rfl
#align slope_def_module slope_def_module

/- warning: sub_smul_slope -> sub_smul_slope is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u2} E (SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (VSub.vsub.{u2, u3} E PE (AddTorsor.toHasVsub.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4) (f b) (f a))
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} k E E (instHSMul.{u2, u3} k E (SMulZeroClass.toSMul.{u2, u3} k E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k E (CommMonoidWithZero.toZero.{u2} k (CommGroupWithZero.toCommMonoidWithZero.{u2} k (Semifield.toCommGroupWithZero.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k E (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) b a) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (VSub.vsub.{u3, u1} E PE (AddTorsor.toVSub.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2) _inst_4) (f b) (f a))
Case conversion may be inaccurate. Consider using '#align sub_smul_slope sub_smul_slopeₓ'. -/
@[simp]
theorem sub_smul_slope (f : k → PE) (a b : k) : (b - a) • slope f a b = f b -ᵥ f a :=
  by
  rcases eq_or_ne a b with (rfl | hne)
  · rw [sub_self, zero_smul, vsub_self]
  · rw [slope, smul_inv_smul₀ (sub_ne_zero.2 hne.symm)]
#align sub_smul_slope sub_smul_slope

/- warning: sub_smul_slope_vadd -> sub_smul_slope_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u3} PE (VAdd.vadd.{u2, u3} E PE (AddAction.toHasVadd.{u2, u3} E PE (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4)) (SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (f a)) (f b)
but is expected to have type
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u3} PE (HVAdd.hVAdd.{u2, u3, u3} E PE PE (instHVAdd.{u2, u3} E PE (AddAction.toVAdd.{u2, u3} E PE (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4))) (HSMul.hSMul.{u1, u2, u2} k E E (instHSMul.{u1, u2} k E (SMulZeroClass.toSMul.{u1, u2} k E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k E (CommMonoidWithZero.toZero.{u1} k (CommGroupWithZero.toCommMonoidWithZero.{u1} k (Semifield.toCommGroupWithZero.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k E (DivisionSemiring.toSemiring.{u1} k (Semifield.toDivisionSemiring.{u1} k (Field.toSemifield.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) b a) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (f a)) (f b)
Case conversion may be inaccurate. Consider using '#align sub_smul_slope_vadd sub_smul_slope_vaddₓ'. -/
theorem sub_smul_slope_vadd (f : k → PE) (a b : k) : (b - a) • slope f a b +ᵥ f a = f b := by
  rw [sub_smul_slope, vsub_vadd]
#align sub_smul_slope_vadd sub_smul_slope_vadd

/- warning: slope_vadd_const -> slope_vadd_const is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> E) (c : PE), Eq.{max (succ u1) (succ u2)} (k -> k -> E) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 (fun (x : k) => VAdd.vadd.{u2, u3} E PE (AddAction.toHasVadd.{u2, u3} E PE (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4)) (f x) c)) (slope.{u1, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) f)
but is expected to have type
  forall {k : Type.{u3}} {E : Type.{u2}} {PE : Type.{u1}} [_inst_1 : Field.{u3} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} k E (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> E) (c : PE), Eq.{max (succ u3) (succ u2)} (k -> k -> E) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 (fun (x : k) => HVAdd.hVAdd.{u2, u1, u1} E PE PE (instHVAdd.{u2, u1} E PE (AddAction.toVAdd.{u2, u1} E PE (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AddTorsor.toAddAction.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2) _inst_4))) (f x) c)) (slope.{u3, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) f)
Case conversion may be inaccurate. Consider using '#align slope_vadd_const slope_vadd_constₓ'. -/
@[simp]
theorem slope_vadd_const (f : k → E) (c : PE) : (slope fun x => f x +ᵥ c) = slope f :=
  by
  ext (a b)
  simp only [slope, vadd_vsub_vadd_cancel_right, vsub_eq_sub]
#align slope_vadd_const slope_vadd_const

/- warning: slope_sub_smul -> slope_sub_smul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] (f : k -> E) {a : k} {b : k}, (Ne.{succ u1} k a b) -> (Eq.{succ u2} E (slope.{u1, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (fun (x : k) => SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) x a) (f x)) a b) (f b))
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] (f : k -> E) {a : k} {b : k}, (Ne.{succ u2} k a b) -> (Eq.{succ u1} E (slope.{u2, u1, u1} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) (fun (x : k) => HSMul.hSMul.{u2, u1, u1} k E E (instHSMul.{u2, u1} k E (SMulZeroClass.toSMul.{u2, u1} k E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k E (CommMonoidWithZero.toZero.{u2} k (CommGroupWithZero.toCommMonoidWithZero.{u2} k (Semifield.toCommGroupWithZero.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k E (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3))))) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) x a) (f x)) a b) (f b))
Case conversion may be inaccurate. Consider using '#align slope_sub_smul slope_sub_smulₓ'. -/
@[simp]
theorem slope_sub_smul (f : k → E) {a b : k} (h : a ≠ b) :
    slope (fun x => (x - a) • f x) a b = f b := by
  simp [slope, inv_smul_smul₀ (sub_ne_zero.2 h.symm)]
#align slope_sub_smul slope_sub_smul

/- warning: eq_of_slope_eq_zero -> eq_of_slope_eq_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] {f : k -> PE} {a : k} {b : k}, (Eq.{succ u2} E (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} PE (f a) (f b))
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] {f : k -> PE} {a : k} {b : k}, (Eq.{succ u3} E (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2)))))))) -> (Eq.{succ u1} PE (f a) (f b))
Case conversion may be inaccurate. Consider using '#align eq_of_slope_eq_zero eq_of_slope_eq_zeroₓ'. -/
theorem eq_of_slope_eq_zero {f : k → PE} {a b : k} (h : slope f a b = (0 : E)) : f a = f b := by
  rw [← sub_smul_slope_vadd f a b, h, smul_zero, zero_vadd]
#align eq_of_slope_eq_zero eq_of_slope_eq_zero

/- warning: affine_map.slope_comp -> AffineMap.slope_comp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] {F : Type.{u4}} {PF : Type.{u5}} [_inst_5 : AddCommGroup.{u4} F] [_inst_6 : Module.{u1, u4} k F (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u4} F _inst_5)] [_inst_7 : AddTorsor.{u4, u5} F PF (AddCommGroup.toAddGroup.{u4} F _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k E PE F PF (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : k -> PE) (a : k) (b : k), Eq.{succ u4} F (slope.{u1, u4, u5} k F PF _inst_1 _inst_5 _inst_6 _inst_7 (Function.comp.{succ u1, succ u3, succ u5} k PE PF (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k E PE F PF (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k E PE F PF (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => PE -> PF) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k E PE F PF (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) g) a b) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u4} F _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u4} F _inst_5) _inst_3 _inst_6) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k E F (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u4} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (AffineMap.linear.{u1, u2, u3, u4, u5} k E PE F PF (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 g a b))
but is expected to have type
  forall {k : Type.{u3}} {E : Type.{u2}} {PE : Type.{u1}} [_inst_1 : Field.{u3} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} k E (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] {F : Type.{u5}} {PF : Type.{u4}} [_inst_5 : AddCommGroup.{u5} F] [_inst_6 : Module.{u3, u5} k F (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u5} F _inst_5)] [_inst_7 : AddTorsor.{u5, u4} F PF (AddCommGroup.toAddGroup.{u5} F _inst_5)] (f : AffineMap.{u3, u2, u1, u5, u4} k E PE F PF (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : k -> PE) (a : k) (b : k), Eq.{succ u5} F (slope.{u3, u5, u4} k F PF _inst_1 _inst_5 _inst_6 _inst_7 (Function.comp.{succ u3, succ u1, succ u4} k PE PF (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u5)) (succ u4), succ u1, succ u4} (AffineMap.{u3, u2, u1, u5, u4} k E PE F PF (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) PE (fun (_x : PE) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : PE) => PF) _x) (AffineMap.funLike.{u3, u2, u1, u5, u4} k E PE F PF (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) g) a b) (FunLike.coe.{max (succ u2) (succ u5), succ u2, succ u5} (LinearMap.{u3, u3, u2, u5} k k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u5} F _inst_5) _inst_3 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u5} k k E F (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u5} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))))) (AffineMap.linear.{u3, u2, u1, u5, u4} k E PE F PF (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 g a b))
Case conversion may be inaccurate. Consider using '#align affine_map.slope_comp AffineMap.slope_compₓ'. -/
theorem AffineMap.slope_comp {F PF : Type _} [AddCommGroup F] [Module k F] [AddTorsor F PF]
    (f : PE →ᵃ[k] PF) (g : k → PE) (a b : k) : slope (f ∘ g) a b = f.linear (slope g a b) := by
  simp only [slope, (· ∘ ·), f.linear.map_smul, f.linear_map_vsub]
#align affine_map.slope_comp AffineMap.slope_comp

/- warning: linear_map.slope_comp -> LinearMap.slope_comp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_5 : AddCommGroup.{u3} F] [_inst_6 : Module.{u1, u3} k F (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5)] (f : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) (g : k -> E) (a : k) (b : k), Eq.{succ u3} F (slope.{u1, u3, u3} k F F _inst_1 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_5)) (Function.comp.{succ u1, succ u2, succ u3} k E F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} k k E F (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) f) g) a b) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} k k E F (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) f (slope.{u1, u2, u2} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) g a b))
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u2, u1} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u3}} [_inst_5 : AddCommGroup.{u3} F] [_inst_6 : Module.{u2, u3} k F (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5)] (f : LinearMap.{u2, u2, u1, u3} k k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) (g : k -> E) (a : k) (b : k), Eq.{succ u3} F (slope.{u2, u3, u3} k F F _inst_1 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_5)) (Function.comp.{succ u2, succ u1, succ u3} k E F (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} k k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} k k E F (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))))) f) g) a b) (FunLike.coe.{max (succ u1) (succ u3), succ u1, succ u3} (LinearMap.{u2, u2, u1, u3} k k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))))) E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, u1, u3} k k E F (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_5) _inst_3 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))))) f (slope.{u2, u1, u1} k E E _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)) g a b))
Case conversion may be inaccurate. Consider using '#align linear_map.slope_comp LinearMap.slope_compₓ'. -/
theorem LinearMap.slope_comp {F : Type _} [AddCommGroup F] [Module k F] (f : E →ₗ[k] F) (g : k → E)
    (a b : k) : slope (f ∘ g) a b = f (slope g a b) :=
  f.toAffineMap.slope_comp g a b
#align linear_map.slope_comp LinearMap.slope_comp

/- warning: slope_comm -> slope_comm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u2} E (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b a)
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] (f : k -> PE) (a : k) (b : k), Eq.{succ u3} E (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b a)
Case conversion may be inaccurate. Consider using '#align slope_comm slope_commₓ'. -/
theorem slope_comm (f : k → PE) (a b : k) : slope f a b = slope f b a := by
  rw [slope, slope, ← neg_vsub_eq_vsub_rev, smul_neg, ← neg_smul, neg_inv, neg_sub]
#align slope_comm slope_comm

/- warning: sub_div_sub_smul_slope_add_sub_div_sub_smul_slope -> sub_div_sub_smul_slope_add_sub_div_sub_smul_slope is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k) (c : k), Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (DivInvMonoid.toHasDiv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) b a) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) c a)) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (SMul.smul.{u1, u2} k E (SMulZeroClass.toHasSmul.{u1, u2} k E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k E (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k E (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (DivInvMonoid.toHasDiv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) c b) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) c a)) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b c))) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a c)
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] (f : k -> PE) (a : k) (b : k) (c : k), Eq.{succ u3} E (HAdd.hAdd.{u3, u3, u3} E E E (instHAdd.{u3} E (AddZeroClass.toAdd.{u3} E (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_2)))))) (HSMul.hSMul.{u2, u3, u3} k E E (instHSMul.{u2, u3} k E (SMulZeroClass.toSMul.{u2, u3} k E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k E (CommMonoidWithZero.toZero.{u2} k (CommGroupWithZero.toCommMonoidWithZero.{u2} k (Semifield.toCommGroupWithZero.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k E (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) (HDiv.hDiv.{u2, u2, u2} k k k (instHDiv.{u2} k (Field.toDiv.{u2} k _inst_1)) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) b a) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) c a)) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)) (HSMul.hSMul.{u2, u3, u3} k E E (instHSMul.{u2, u3} k E (SMulZeroClass.toSMul.{u2, u3} k E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k E (CommMonoidWithZero.toZero.{u2} k (CommGroupWithZero.toCommMonoidWithZero.{u2} k (Semifield.toCommGroupWithZero.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k E (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1)))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) (HDiv.hDiv.{u2, u2, u2} k k k (instHDiv.{u2} k (Field.toDiv.{u2} k _inst_1)) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) c b) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) c a)) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b c))) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a c)
Case conversion may be inaccurate. Consider using '#align sub_div_sub_smul_slope_add_sub_div_sub_smul_slope sub_div_sub_smul_slope_add_sub_div_sub_smul_slopeₓ'. -/
/-- `slope f a c` is a linear combination of `slope f a b` and `slope f b c`. This version
explicitly provides coefficients. If `a ≠ c`, then the sum of the coefficients is `1`, so it is
actually an affine combination, see `line_map_slope_slope_sub_div_sub`. -/
theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope (f : k → PE) (a b c : k) :
    ((b - a) / (c - a)) • slope f a b + ((c - b) / (c - a)) • slope f b c = slope f a c :=
  by
  by_cases hab : a = b
  · subst hab
    rw [sub_self, zero_div, zero_smul, zero_add]
    by_cases hac : a = c
    · simp [hac]
    · rw [div_self (sub_ne_zero.2 <| Ne.symm hac), one_smul]
  by_cases hbc : b = c;
  · subst hbc
    simp [sub_ne_zero.2 (Ne.symm hab)]
  rw [add_comm]
  simp_rw [slope, div_eq_inv_mul, mul_smul, ← smul_add,
    smul_inv_smul₀ (sub_ne_zero.2 <| Ne.symm hab), smul_inv_smul₀ (sub_ne_zero.2 <| Ne.symm hbc),
    vsub_add_vsub_cancel]
#align sub_div_sub_smul_slope_add_sub_div_sub_smul_slope sub_div_sub_smul_slope_add_sub_div_sub_smul_slope

/- warning: line_map_slope_slope_sub_div_sub -> lineMap_slope_slope_sub_div_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k) (c : k), (Ne.{succ u1} k a c) -> (Eq.{succ u2} E (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) => k -> E) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b c)) (HDiv.hDiv.{u1, u1, u1} k k k (instHDiv.{u1} k (DivInvMonoid.toHasDiv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) c b) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))))) c a))) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a c))
but is expected to have type
  forall {k : Type.{u3}} {E : Type.{u2}} {PE : Type.{u1}} [_inst_1 : Field.{u3} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} k E (DivisionSemiring.toSemiring.{u3} k (Semifield.toDivisionSemiring.{u3} k (Field.toSemifield.{u3} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u1} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k) (c : k), (Ne.{succ u3} k a c) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => E) (HDiv.hDiv.{u3, u3, u3} k k k (instHDiv.{u3} k (Field.toDiv.{u3} k _inst_1)) (HSub.hSub.{u3, u3, u3} k k k (instHSub.{u3} k (Ring.toSub.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) c b) (HSub.hSub.{u3, u3, u3} k k k (instHSub.{u3} k (Ring.toSub.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) c a))) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AffineMap.{u3, u3, u3, u2, u2} k k k E E (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) (Ring.toAddCommGroup.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => E) _x) (AffineMap.funLike.{u3, u3, u3, u2, u2} k k k E E (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) (Ring.toAddCommGroup.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u3, u2, u2} k E E (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f b c)) (HDiv.hDiv.{u3, u3, u3} k k k (instHDiv.{u3} k (Field.toDiv.{u3} k _inst_1)) (HSub.hSub.{u3, u3, u3} k k k (instHSub.{u3} k (Ring.toSub.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) c b) (HSub.hSub.{u3, u3, u3} k k k (instHSub.{u3} k (Ring.toSub.{u3} k (DivisionRing.toRing.{u3} k (Field.toDivisionRing.{u3} k _inst_1)))) c a))) (slope.{u3, u2, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a c))
Case conversion may be inaccurate. Consider using '#align line_map_slope_slope_sub_div_sub lineMap_slope_slope_sub_div_subₓ'. -/
/-- `slope f a c` is an affine combination of `slope f a b` and `slope f b c`. This version uses
`line_map` to express this property. -/
theorem lineMap_slope_slope_sub_div_sub (f : k → PE) (a b c : k) (h : a ≠ c) :
    lineMap (slope f a b) (slope f b c) ((c - b) / (c - a)) = slope f a c := by
  field_simp [sub_ne_zero.2 h.symm, ← sub_div_sub_smul_slope_add_sub_div_sub_smul_slope f a b c,
    line_map_apply_module]
#align line_map_slope_slope_sub_div_sub lineMap_slope_slope_sub_div_sub

/- warning: line_map_slope_line_map_slope_line_map -> lineMap_slope_lineMap_slope_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {E : Type.{u2}} {PE : Type.{u3}} [_inst_1 : Field.{u1} k] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} k E (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_4 : AddTorsor.{u2, u3} E PE (AddCommGroup.toAddGroup.{u2} E _inst_2)] (f : k -> PE) (a : k) (b : k) (r : k), Eq.{succ u2} E (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) => k -> E) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} k k k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k E E (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f (coeFn.{succ u1, succ u1} (AffineMap.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (fun (_x : AffineMap.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) => k -> k) (AffineMap.hasCoeToFun.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AffineMap.lineMap.{u1, u1, u1} k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) a b) r) b) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a (coeFn.{succ u1, succ u1} (AffineMap.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (fun (_x : AffineMap.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) => k -> k) (AffineMap.hasCoeToFun.{u1, u1, u1, u1, u1} k k k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))))) (AffineMap.lineMap.{u1, u1, u1} k k k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k (Field.toDivisionRing.{u1} k _inst_1)))))) a b) r))) r) (slope.{u1, u2, u3} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)
but is expected to have type
  forall {k : Type.{u2}} {E : Type.{u3}} {PE : Type.{u1}} [_inst_1 : Field.{u2} k] [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} k E (DivisionSemiring.toSemiring.{u2} k (Semifield.toDivisionSemiring.{u2} k (Field.toSemifield.{u2} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] [_inst_4 : AddTorsor.{u3, u1} E PE (AddCommGroup.toAddGroup.{u3} E _inst_2)] (f : k -> PE) (a : k) (b : k) (r : k), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => E) r) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AffineMap.{u2, u2, u2, u3, u3} k k k E E (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_2))) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => E) _x) (AffineMap.funLike.{u2, u2, u2, u3, u3} k k k E E (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_2))) (AffineMap.lineMap.{u2, u3, u3} k E E (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_2)) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f (FunLike.coe.{succ u2, succ u2, succ u2} (AffineMap.{u2, u2, u2, u2, u2} k k k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))))) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => k) _x) (AffineMap.funLike.{u2, u2, u2, u2, u2} k k k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))))) (AffineMap.lineMap.{u2, u2, u2} k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) a b) r) b) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a (FunLike.coe.{succ u2, succ u2, succ u2} (AffineMap.{u2, u2, u2, u2, u2} k k k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))))) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => k) _x) (AffineMap.funLike.{u2, u2, u2, u2, u2} k k k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))))) (AffineMap.lineMap.{u2, u2, u2} k k k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)) (Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1)))) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k (Field.toDivisionRing.{u2} k _inst_1))))) a b) r))) r) (slope.{u2, u3, u1} k E PE _inst_1 _inst_2 _inst_3 _inst_4 f a b)
Case conversion may be inaccurate. Consider using '#align line_map_slope_line_map_slope_line_map lineMap_slope_lineMap_slope_lineMapₓ'. -/
/-- `slope f a b` is an affine combination of `slope f a (line_map a b r)` and
`slope f (line_map a b r) b`. We use `line_map` to express this property. -/
theorem lineMap_slope_lineMap_slope_lineMap (f : k → PE) (a b r : k) :
    lineMap (slope f (lineMap a b r) b) (slope f a (lineMap a b r)) r = slope f a b :=
  by
  obtain rfl | hab : a = b ∨ a ≠ b := Classical.em _; · simp
  rw [slope_comm _ a, slope_comm _ a, slope_comm _ _ b]
  convert lineMap_slope_slope_sub_div_sub f b (line_map a b r) a hab.symm using 2
  rw [line_map_apply_ring, eq_div_iff (sub_ne_zero.2 hab), sub_mul, one_mul, mul_sub, ← sub_sub,
    sub_sub_cancel]
#align line_map_slope_line_map_slope_line_map lineMap_slope_lineMap_slope_lineMap

