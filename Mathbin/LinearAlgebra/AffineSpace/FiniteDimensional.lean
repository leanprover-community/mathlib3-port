/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module linear_algebra.affine_space.finite_dimensional
! leanprover-community/mathlib commit 67e606eaea14c7854bdc556bd53d98aefdf76ec0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.Basis
import Mathbin.LinearAlgebra.FiniteDimensional

/-!
# Finite-dimensional subspaces of affine spaces.

This file provides a few results relating to finite-dimensional
subspaces of affine spaces.

## Main definitions

* `collinear` defines collinear sets of points as those that span a
  subspace of dimension at most 1.

-/


noncomputable section

open BigOperators Affine

section AffineSpace'

variable (k : Type _) {V : Type _} {P : Type _}

variable {ι : Type _}

include V

open AffineSubspace FiniteDimensional Module

variable [DivisionRing k] [AddCommGroup V] [Module k V] [affine_space V P]

/- warning: finite_dimensional_vector_span_of_finite -> finiteDimensional_vectorSpan_of_finite is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Finite.{u3} P s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Finite.{u3} P s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align finite_dimensional_vector_span_of_finite finiteDimensional_vectorSpan_of_finiteₓ'. -/
/-- The `vector_span` of a finite set is finite-dimensional. -/
theorem finiteDimensional_vectorSpan_of_finite {s : Set P} (h : Set.Finite s) :
    FiniteDimensional k (vectorSpan k s) :=
  span_of_finite k <| h.vsub h
#align finite_dimensional_vector_span_of_finite finiteDimensional_vectorSpan_of_finite

#print finiteDimensional_vectorSpan_range /-
/-- The `vector_span` of a family indexed by a `fintype` is
finite-dimensional. -/
instance finiteDimensional_vectorSpan_range [Finite ι] (p : ι → P) :
    FiniteDimensional k (vectorSpan k (Set.range p)) :=
  finiteDimensional_vectorSpan_of_finite k (Set.finite_range _)
#align finite_dimensional_vector_span_range finiteDimensional_vectorSpan_range
-/

#print finiteDimensional_vectorSpan_image_of_finite /-
/-- The `vector_span` of a subset of a family indexed by a `fintype`
is finite-dimensional. -/
instance finiteDimensional_vectorSpan_image_of_finite [Finite ι] (p : ι → P) (s : Set ι) :
    FiniteDimensional k (vectorSpan k (p '' s)) :=
  finiteDimensional_vectorSpan_of_finite k (Set.toFinite _)
#align finite_dimensional_vector_span_image_of_finite finiteDimensional_vectorSpan_image_of_finite
-/

/- warning: finite_dimensional_direction_affine_span_of_finite -> finiteDimensional_direction_affineSpan_of_finite is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Finite.{u3} P s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Finite.{u3} P s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional_direction_affine_span_of_finite finiteDimensional_direction_affineSpan_of_finiteₓ'. -/
/-- The direction of the affine span of a finite set is
finite-dimensional. -/
theorem finiteDimensional_direction_affineSpan_of_finite {s : Set P} (h : Set.Finite s) :
    FiniteDimensional k (affineSpan k s).direction :=
  (direction_affineSpan k s).symm ▸ finiteDimensional_vectorSpan_of_finite k h
#align finite_dimensional_direction_affine_span_of_finite finiteDimensional_direction_affineSpan_of_finite

#print finiteDimensional_direction_affineSpan_range /-
/-- The direction of the affine span of a family indexed by a
`fintype` is finite-dimensional. -/
instance finiteDimensional_direction_affineSpan_range [Finite ι] (p : ι → P) :
    FiniteDimensional k (affineSpan k (Set.range p)).direction :=
  finiteDimensional_direction_affineSpan_of_finite k (Set.finite_range _)
#align finite_dimensional_direction_affine_span_range finiteDimensional_direction_affineSpan_range
-/

#print finiteDimensional_direction_affineSpan_image_of_finite /-
/-- The direction of the affine span of a subset of a family indexed
by a `fintype` is finite-dimensional. -/
instance finiteDimensional_direction_affineSpan_image_of_finite [Finite ι] (p : ι → P) (s : Set ι) :
    FiniteDimensional k (affineSpan k (p '' s)).direction :=
  finiteDimensional_direction_affineSpan_of_finite k (Set.toFinite _)
#align finite_dimensional_direction_affine_span_image_of_finite finiteDimensional_direction_affineSpan_image_of_finite
-/

/- warning: finite_of_fin_dim_affine_independent -> finite_of_fin_dim_affineIndependent is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : FiniteDimensional.{u1, u2} k V _inst_1 _inst_2 _inst_3] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Finite.{succ u4} ι)
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u2}} {ι : Type.{u1}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] [_inst_5 : FiniteDimensional.{u4, u3} k V _inst_1 _inst_2 _inst_3] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Finite.{succ u1} ι)
Case conversion may be inaccurate. Consider using '#align finite_of_fin_dim_affine_independent finite_of_fin_dim_affineIndependentₓ'. -/
/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/
theorem finite_of_fin_dim_affineIndependent [FiniteDimensional k V] {p : ι → P}
    (hi : AffineIndependent k p) : Finite ι :=
  by
  nontriviality ι; inhabit ι
  rw [affineIndependent_iff_linearIndependent_vsub k p default] at hi
  letI : IsNoetherian k V := IsNoetherian.iff_fg.2 inferInstance
  exact
    (Set.finite_singleton default).finite_of_compl (Set.finite_coe_iff.1 hi.finite_of_is_noetherian)
#align finite_of_fin_dim_affine_independent finite_of_fin_dim_affineIndependent

/- warning: finite_set_of_fin_dim_affine_independent -> finite_set_of_fin_dim_affineIndependent is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : FiniteDimensional.{u1, u2} k V _inst_1 _inst_2 _inst_3] {s : Set.{u4} ι} {f : (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) f) -> (Set.Finite.{u4} ι s)
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u1}} {ι : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] [_inst_5 : FiniteDimensional.{u4, u3} k V _inst_1 _inst_2 _inst_3] {s : Set.{u2} ι} {f : (Set.Elem.{u2} ι s) -> P}, (AffineIndependent.{u4, u3, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.Elem.{u2} ι s) f) -> (Set.Finite.{u2} ι s)
Case conversion may be inaccurate. Consider using '#align finite_set_of_fin_dim_affine_independent finite_set_of_fin_dim_affineIndependentₓ'. -/
/-- An affine-independent subset of a finite-dimensional affine space is finite. -/
theorem finite_set_of_fin_dim_affineIndependent [FiniteDimensional k V] {s : Set ι} {f : s → P}
    (hi : AffineIndependent k f) : s.Finite :=
  @Set.toFinite _ s (finite_of_fin_dim_affineIndependent k hi)
#align finite_set_of_fin_dim_affine_independent finite_set_of_fin_dim_affineIndependent

open Classical

variable {k}

/- warning: affine_independent.finrank_vector_span_image_finset -> AffineIndependent.finrank_vectorSpan_image_finset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u4} ι} {n : Nat}, (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s)))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s)))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))))) n))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} {ι : Type.{u1}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u1} ι} {n : Nat}, (Eq.{1} Nat (Finset.card.{u1} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u4, u3} k (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x (vectorSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))))) (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (Submodule.addCommGroup.{u4, u3} k V (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s)))) (Submodule.module.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (vectorSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))))) n))
Case conversion may be inaccurate. Consider using '#align affine_independent.finrank_vector_span_image_finset AffineIndependent.finrank_vectorSpan_image_finsetₓ'. -/
/-- The `vector_span` of a finite subset of an affinely independent
family has dimension one less than its cardinality. -/
theorem AffineIndependent.finrank_vectorSpan_image_finset {p : ι → P} (hi : AffineIndependent k p)
    {s : Finset ι} {n : ℕ} (hc : Finset.card s = n + 1) :
    finrank k (vectorSpan k (s.image p : Set P)) = n :=
  by
  have hi' := hi.range.mono (Set.image_subset_range p ↑s)
  have hc' : (s.image p).card = n + 1 := by rwa [s.card_image_of_injective hi.injective]
  have hn : (s.image p).Nonempty := by simp [hc', ← Finset.card_pos]
  rcases hn with ⟨p₁, hp₁⟩
  have hp₁' : p₁ ∈ p '' s := by simpa using hp₁
  rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁', ← Finset.coe_singleton, ←
    Finset.coe_image, ← Finset.coe_sdiff, Finset.sdiff_singleton_eq_erase, ← Finset.coe_image] at
    hi'
  have hc : (Finset.image (fun p : P => p -ᵥ p₁) ((Finset.image p s).eraseₓ p₁)).card = n :=
    by
    rw [Finset.card_image_of_injective _ (vsub_left_injective _), Finset.card_erase_of_mem hp₁]
    exact Nat.pred_eq_of_eq_succ hc'
  rwa [vectorSpan_eq_span_vsub_finset_right_ne k hp₁, finrank_span_finset_eq_card, hc]
#align affine_independent.finrank_vector_span_image_finset AffineIndependent.finrank_vectorSpan_image_finset

/- warning: affine_independent.finrank_vector_span -> AffineIndependent.finrank_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))) n))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) n))
Case conversion may be inaccurate. Consider using '#align affine_independent.finrank_vector_span AffineIndependent.finrank_vectorSpanₓ'. -/
/-- The `vector_span` of a finite affinely independent family has
dimension one less than its cardinality. -/
theorem AffineIndependent.finrank_vectorSpan [Fintype ι] {p : ι → P} (hi : AffineIndependent k p)
    {n : ℕ} (hc : Fintype.card ι = n + 1) : finrank k (vectorSpan k (Set.range p)) = n :=
  by
  rw [← Finset.card_univ] at hc
  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]
  exact hi.finrank_vector_span_image_finset hc
#align affine_independent.finrank_vector_span AffineIndependent.finrank_vectorSpan

/- warning: affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one -> AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : FiniteDimensional.{u1, u2} k V _inst_1 _inst_2 _inst_3] [_inst_6 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Eq.{1} Nat (Fintype.card.{u4} ι _inst_6) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u1}} {ι : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] [_inst_5 : FiniteDimensional.{u4, u3} k V _inst_1 _inst_2 _inst_3] [_inst_6 : Fintype.{u2} ι] {p : ι -> P}, (AffineIndependent.{u4, u3, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Eq.{1} Nat (Fintype.card.{u2} ι _inst_6) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u2} P ι p)) (Top.top.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_oneₓ'. -/
/-- The `vector_span` of a finite affinely independent family whose
cardinality is one more than that of the finite-dimensional space is
`⊤`. -/
theorem AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one [FiniteDimensional k V]
    [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) (hc : Fintype.card ι = finrank k V + 1) :
    vectorSpan k (Set.range p) = ⊤ :=
  eq_top_of_finrank_eq <| hi.finrank_vectorSpan hc
#align affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one

variable (k)

/- warning: finrank_vector_span_image_finset_le -> finrank_vectorSpan_image_finset_le is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : ι -> P) (s : Finset.{u4} ι) {n : Nat}, (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s)))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s)))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))))) n)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : ι -> P) (s : Finset.{u4} ι) {n : Nat}, (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u1} P (Finset.image.{u4, u1} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u1} P a b)) p s))))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u1} P (Finset.image.{u4, u1} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u1} P a b)) p s)))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u1} P (Finset.image.{u4, u1} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u1} P a b)) p s))))) n)
Case conversion may be inaccurate. Consider using '#align finrank_vector_span_image_finset_le finrank_vectorSpan_image_finset_leₓ'. -/
/-- The `vector_span` of `n + 1` points in an indexed family has
dimension at most `n`. -/
theorem finrank_vectorSpan_image_finset_le (p : ι → P) (s : Finset ι) {n : ℕ}
    (hc : Finset.card s = n + 1) : finrank k (vectorSpan k (s.image p : Set P)) ≤ n :=
  by
  have hn : (s.image p).Nonempty :=
    by
    rw [Finset.Nonempty.image_iff, ← Finset.card_pos, hc]
    apply Nat.succ_pos
  rcases hn with ⟨p₁, hp₁⟩
  rw [vectorSpan_eq_span_vsub_finset_right_ne k hp₁]
  refine' le_trans (finrank_span_finset_le_card (((s.image p).eraseₓ p₁).image fun p => p -ᵥ p₁)) _
  rw [Finset.card_image_of_injective _ (vsub_left_injective p₁), Finset.card_erase_of_mem hp₁,
    tsub_le_iff_right, ← hc]
  apply Finset.card_image_le
#align finrank_vector_span_image_finset_le finrank_vectorSpan_image_finset_le

/- warning: finrank_vector_span_range_le -> finrank_vectorSpan_range_le is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))) n)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) n)
Case conversion may be inaccurate. Consider using '#align finrank_vector_span_range_le finrank_vectorSpan_range_leₓ'. -/
/-- The `vector_span` of an indexed family of `n + 1` points has
dimension at most `n`. -/
theorem finrank_vectorSpan_range_le [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) :
    finrank k (vectorSpan k (Set.range p)) ≤ n :=
  by
  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]
  rw [← Finset.card_univ] at hc
  exact finrank_vectorSpan_image_finset_le _ _ _ hc
#align finrank_vector_span_range_le finrank_vectorSpan_range_le

/- warning: affine_independent_iff_finrank_vector_span_eq -> affineIndependent_iff_finrank_vectorSpan_eq is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Iff (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))) n))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Iff (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (Eq.{1} Nat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) n))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_finrank_vector_span_eq affineIndependent_iff_finrank_vectorSpan_eqₓ'. -/
/-- `n + 1` points are affinely independent if and only if their
`vector_span` has dimension `n`. -/
theorem affineIndependent_iff_finrank_vectorSpan_eq [Fintype ι] (p : ι → P) {n : ℕ}
    (hc : Fintype.card ι = n + 1) :
    AffineIndependent k p ↔ finrank k (vectorSpan k (Set.range p)) = n :=
  by
  have hn : Nonempty ι := by simp [← Fintype.card_pos_iff, hc]
  cases' hn with i₁
  rw [affineIndependent_iff_linearIndependent_vsub _ _ i₁,
    linearIndependent_iff_card_eq_finrank_span, eq_comm,
    vectorSpan_range_eq_span_range_vsub_right_ne k p i₁]
  congr
  rw [← Finset.card_univ] at hc
  rw [Fintype.subtype_card]
  simp [Finset.filter_ne', Finset.card_erase_of_mem, hc]
#align affine_independent_iff_finrank_vector_span_eq affineIndependent_iff_finrank_vectorSpan_eq

/- warning: affine_independent_iff_le_finrank_vector_span -> affineIndependent_iff_le_finrank_vectorSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Iff (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (LE.le.{0} Nat Nat.hasLe n (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Iff (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (LE.le.{0} Nat instLENat n (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))))))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_le_finrank_vector_span affineIndependent_iff_le_finrank_vectorSpanₓ'. -/
/-- `n + 1` points are affinely independent if and only if their
`vector_span` has dimension at least `n`. -/
theorem affineIndependent_iff_le_finrank_vectorSpan [Fintype ι] (p : ι → P) {n : ℕ}
    (hc : Fintype.card ι = n + 1) :
    AffineIndependent k p ↔ n ≤ finrank k (vectorSpan k (Set.range p)) :=
  by
  rw [affineIndependent_iff_finrank_vectorSpan_eq k p hc]
  constructor
  · rintro rfl
    rfl
  · exact fun hle => le_antisymm (finrank_vectorSpan_range_le k p hc) hle
#align affine_independent_iff_le_finrank_vector_span affineIndependent_iff_le_finrank_vectorSpan

/- warning: affine_independent_iff_not_finrank_vector_span_le -> affineIndependent_iff_not_finrank_vectorSpan_le is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> (Iff (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (Not (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))) n)))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) -> (Iff (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) (Not (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) n)))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_not_finrank_vector_span_le affineIndependent_iff_not_finrank_vectorSpan_leₓ'. -/
/-- `n + 2` points are affinely independent if and only if their
`vector_span` does not have dimension at most `n`. -/
theorem affineIndependent_iff_not_finrank_vectorSpan_le [Fintype ι] (p : ι → P) {n : ℕ}
    (hc : Fintype.card ι = n + 2) :
    AffineIndependent k p ↔ ¬finrank k (vectorSpan k (Set.range p)) ≤ n := by
  rw [affineIndependent_iff_le_finrank_vectorSpan k p hc, ← Nat.lt_iff_add_one_le, lt_iff_not_ge]
#align affine_independent_iff_not_finrank_vector_span_le affineIndependent_iff_not_finrank_vectorSpan_le

/- warning: finrank_vector_span_le_iff_not_affine_independent -> finrank_vectorSpan_le_iff_not_affineIndependent is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) -> (Iff (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))) n) (Not (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p)))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) -> (Iff (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))) n) (Not (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p)))
Case conversion may be inaccurate. Consider using '#align finrank_vector_span_le_iff_not_affine_independent finrank_vectorSpan_le_iff_not_affineIndependentₓ'. -/
/-- `n + 2` points have a `vector_span` with dimension at most `n` if
and only if they are not affinely independent. -/
theorem finrank_vectorSpan_le_iff_not_affineIndependent [Fintype ι] (p : ι → P) {n : ℕ}
    (hc : Fintype.card ι = n + 2) :
    finrank k (vectorSpan k (Set.range p)) ≤ n ↔ ¬AffineIndependent k p :=
  (not_iff_comm.1 (affineIndependent_iff_not_finrank_vectorSpan_le k p hc).symm).symm
#align finrank_vector_span_le_iff_not_affine_independent finrank_vectorSpan_le_iff_not_affineIndependent

variable {k}

/- warning: affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one -> AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u4} ι} {sm : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) sm) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)], (LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))) sm) -> (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) sm) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))) sm))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} {ι : Type.{u1}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u1} ι} {sm : Submodule.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3} [_inst_5 : FiniteDimensional.{u4, u3} k (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x sm)) _inst_1 (Submodule.addCommGroup.{u4, u3} k V (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 sm)], (LE.le.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Preorder.toLE.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.completeLattice.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) (vectorSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))) sm) -> (Eq.{1} Nat (Finset.card.{u1} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u4, u3} k (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x sm)) (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (Submodule.addCommGroup.{u4, u3} k V (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 sm)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))) sm))
Case conversion may be inaccurate. Consider using '#align affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_oneₓ'. -/
/-- If the `vector_span` of a finite subset of an affinely independent
family lies in a submodule with dimension one less than its
cardinality, it equals that submodule. -/
theorem AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}
    (hi : AffineIndependent k p) {s : Finset ι} {sm : Submodule k V} [FiniteDimensional k sm]
    (hle : vectorSpan k (s.image p : Set P) ≤ sm) (hc : Finset.card s = finrank k sm + 1) :
    vectorSpan k (s.image p : Set P) = sm :=
  eq_of_le_of_finrank_eq hle <| hi.finrank_vectorSpan_image_finset hc
#align affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one

/- warning: affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one -> AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {sm : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) sm) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)], (LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) sm) -> (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) sm) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) sm))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {sm : Submodule.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x sm)) _inst_1 (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)], (LE.le.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)) sm) -> (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x sm)) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 sm) (Submodule.module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 sm)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)) sm))
Case conversion may be inaccurate. Consider using '#align affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_oneₓ'. -/
/-- If the `vector_span` of a finite affinely independent
family lies in a submodule with dimension one less than its
cardinality, it equals that submodule. -/
theorem AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}
    (hi : AffineIndependent k p) {sm : Submodule k V} [FiniteDimensional k sm]
    (hle : vectorSpan k (Set.range p) ≤ sm) (hc : Fintype.card ι = finrank k sm + 1) :
    vectorSpan k (Set.range p) = sm :=
  eq_of_le_of_finrank_eq hle <| hi.finrank_vectorSpan hc
#align affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one

/- warning: affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one -> AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u4} ι} {sp : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp))], (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))) sp) -> (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Finset.{u3} P) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (Finset.{u3} P) (Set.{u3} P) (Finset.Set.hasCoeT.{u3} P))) (Finset.image.{u4, u3} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u3} P a b)) p s))) sp))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} {ι : Type.{u1}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {s : Finset.{u1} ι} {sp : AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4} [_inst_5 : FiniteDimensional.{u4, u3} k (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) _inst_1 (Submodule.addCommGroup.{u4, u3} k V (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp))], (LE.le.{u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4))))) (affineSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))) sp) -> (Eq.{1} Nat (Finset.card.{u1} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u4, u3} k (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (Submodule.addCommGroup.{u4, u3} k V (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u4, u3} k V (Ring.toSemiring.{u4} k (DivisionRing.toRing.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (AffineSubspace.direction.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Finset.toSet.{u2} P (Finset.image.{u1, u2} ι P (fun (a : P) (b : P) => Classical.propDecidable (Eq.{succ u2} P a b)) p s))) sp))
Case conversion may be inaccurate. Consider using '#align affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_oneₓ'. -/
/-- If the `affine_span` of a finite subset of an affinely independent
family lies in an affine subspace whose direction has dimension one
less than its cardinality, it equals that subspace. -/
theorem AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}
    (hi : AffineIndependent k p) {s : Finset ι} {sp : AffineSubspace k P}
    [FiniteDimensional k sp.direction] (hle : affineSpan k (s.image p : Set P) ≤ sp)
    (hc : Finset.card s = finrank k sp.direction + 1) : affineSpan k (s.image p : Set P) = sp :=
  by
  have hn : s.nonempty := by
    rw [← Finset.card_pos, hc]
    apply Nat.succ_pos
  refine' eq_of_direction_eq_of_nonempty_of_le _ ((hn.image _).to_set.affineSpan _) hle
  have hd := direction_le hle
  rw [direction_affineSpan] at hd⊢
  exact hi.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hd hc
#align affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one

/- warning: affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one -> AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {sp : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4} [_inst_6 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp))], (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) sp) -> (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) sp))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u3, u2, u1, u4} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (forall {sp : AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4} [_inst_6 : FiniteDimensional.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) _inst_1 (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp))], (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4))))) (affineSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)) sp) -> (Eq.{1} Nat (Fintype.card.{u4} ι _inst_5) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 sp))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)) sp))
Case conversion may be inaccurate. Consider using '#align affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_oneₓ'. -/
/-- If the `affine_span` of a finite affinely independent family lies
in an affine subspace whose direction has dimension one less than its
cardinality, it equals that subspace. -/
theorem AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}
    (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]
    (hle : affineSpan k (Set.range p) ≤ sp) (hc : Fintype.card ι = finrank k sp.direction + 1) :
    affineSpan k (Set.range p) = sp :=
  by
  rw [← Finset.card_univ] at hc
  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image] at hle⊢
  exact hi.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc
#align affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one

/- warning: affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one -> AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} {ι : Type.{u4}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : FiniteDimensional.{u1, u2} k V _inst_1 _inst_2 _inst_3] [_inst_6 : Fintype.{u4} ι] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) (Eq.{1} Nat (Fintype.card.{u4} ι _inst_6) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u1}} {ι : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] [_inst_5 : FiniteDimensional.{u4, u3} k V _inst_1 _inst_2 _inst_3] [_inst_6 : Fintype.{u2} ι] {p : ι -> P}, (AffineIndependent.{u4, u3, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p) -> (Iff (Eq.{succ u1} (AffineSubspace.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u2} P ι p)) (Top.top.{u1} (AffineSubspace.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u1} (AffineSubspace.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u3, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4)))) (Eq.{1} Nat (Fintype.card.{u2} ι _inst_6) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))
Case conversion may be inaccurate. Consider using '#align affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_oneₓ'. -/
/-- The `affine_span` of a finite affinely independent family is `⊤` iff the
family's cardinality is one more than that of the finite-dimensional space. -/
theorem AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one [FiniteDimensional k V]
    [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) :
    affineSpan k (Set.range p) = ⊤ ↔ Fintype.card ι = finrank k V + 1 :=
  by
  constructor
  · intro h_tot
    let n := Fintype.card ι - 1
    have hn : Fintype.card ι = n + 1 :=
      (Nat.succ_pred_eq_of_pos (card_pos_of_affine_span_eq_top k V P h_tot)).symm
    rw [hn, ← finrank_top, ← (vector_span_eq_top_of_affine_span_eq_top k V P) h_tot, ←
      hi.finrank_vector_span hn]
  · intro hc
    rw [← finrank_top, ← direction_top k V P] at hc
    exact hi.affine_span_eq_of_le_of_card_eq_finrank_add_one le_top hc
#align affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one

/- warning: affine.simplex.span_eq_top -> Affine.Simplex.span_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_5 : FiniteDimensional.{u1, u2} k V _inst_1 _inst_2 _inst_3] {n : Nat} (T : Affine.Simplex.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) n), (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) _inst_2 _inst_3) n) -> (Eq.{succ u2} (AffineSubspace.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (affineSpan.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (Set.range.{u2, 1} V (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) n T))) (Top.top.{u2} (AffineSubspace.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (CompleteLattice.toHasTop.{u2} (AffineSubspace.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AffineSubspace.completeLattice.{u1, u2, u2} k V V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_5 : FiniteDimensional.{u2, u1} k V _inst_1 _inst_2 _inst_3] {n : Nat} (T : Affine.Simplex.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) n), (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) _inst_2 _inst_3) n) -> (Eq.{succ u1} (AffineSubspace.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (affineSpan.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) (Set.range.{u1, 1} V (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) n T))) (Top.top.{u1} (AffineSubspace.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (CompleteLattice.toTop.{u1} (AffineSubspace.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u1} k V V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))))))
Case conversion may be inaccurate. Consider using '#align affine.simplex.span_eq_top Affine.Simplex.span_eq_topₓ'. -/
theorem Affine.Simplex.span_eq_top [FiniteDimensional k V] {n : ℕ} (T : Affine.Simplex k V n)
    (hrank : finrank k V = n) : affineSpan k (Set.range T.points) = ⊤ := by
  rw [AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one T.independent,
    Fintype.card_fin, hrank]
#align affine.simplex.span_eq_top Affine.Simplex.span_eq_top

#print finiteDimensional_vectorSpan_insert /-
/-- The `vector_span` of adding a point to a finite-dimensional subspace is finite-dimensional. -/
instance finiteDimensional_vectorSpan_insert (s : AffineSubspace k P)
    [FiniteDimensional k s.direction] (p : P) :
    FiniteDimensional k (vectorSpan k (insert p (s : Set P))) :=
  by
  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]
  rcases(s : Set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)
  · rw [coe_eq_bot_iff] at hs
    rw [hs, bot_coe, span_empty, bot_coe, direction_affineSpan]
    convert finiteDimensional_bot _ _ <;> simp
  · rw [affine_span_coe, direction_affine_span_insert hp₀]
    infer_instance
#align finite_dimensional_vector_span_insert finiteDimensional_vectorSpan_insert
-/

#print finiteDimensional_direction_affineSpan_insert /-
/-- The direction of the affine span of adding a point to a finite-dimensional subspace is
finite-dimensional. -/
instance finiteDimensional_direction_affineSpan_insert (s : AffineSubspace k P)
    [FiniteDimensional k s.direction] (p : P) :
    FiniteDimensional k (affineSpan k (insert p (s : Set P))).direction :=
  (direction_affineSpan k (insert p (s : Set P))).symm ▸ finiteDimensional_vectorSpan_insert s p
#align finite_dimensional_direction_affine_span_insert finiteDimensional_direction_affineSpan_insert
-/

variable (k)

#print finiteDimensional_vectorSpan_insert_set /-
/-- The `vector_span` of adding a point to a set with a finite-dimensional `vector_span` is
finite-dimensional. -/
instance finiteDimensional_vectorSpan_insert_set (s : Set P) [FiniteDimensional k (vectorSpan k s)]
    (p : P) : FiniteDimensional k (vectorSpan k (insert p s)) :=
  by
  haveI : FiniteDimensional k (affineSpan k s).direction :=
    (direction_affineSpan k s).symm ▸ inferInstance
  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, direction_affineSpan]
  exact finiteDimensional_vectorSpan_insert (affineSpan k s) p
#align finite_dimensional_vector_span_insert_set finiteDimensional_vectorSpan_insert_set
-/

#print Collinear /-
/-- A set of points is collinear if their `vector_span` has dimension
at most `1`. -/
def Collinear (s : Set P) : Prop :=
  Module.rank k (vectorSpan k s) ≤ 1
#align collinear Collinear
-/

/- warning: collinear_iff_rank_le_one -> collinear_iff_rank_le_one is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} (Module.rank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommMonoid.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (OfNat.mk.{succ u2} Cardinal.{u2} 1 (One.one.{succ u2} Cardinal.{u2} Cardinal.hasOne.{u2}))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{succ u1} Cardinal.{u1} Cardinal.instLECardinal.{u1} (Module.rank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommMonoid.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{succ u1} Cardinal.{u1} 1 (One.toOfNat1.{succ u1} Cardinal.{u1} Cardinal.instOneCardinal.{u1})))
Case conversion may be inaccurate. Consider using '#align collinear_iff_rank_le_one collinear_iff_rank_le_oneₓ'. -/
/-- The definition of `collinear`. -/
theorem collinear_iff_rank_le_one (s : Set P) :
    Collinear k s ↔ Module.rank k (vectorSpan k s) ≤ 1 :=
  Iff.rfl
#align collinear_iff_rank_le_one collinear_iff_rank_le_one

variable {k}

/- warning: collinear_iff_finrank_le_one -> collinear_iff_finrank_le_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))], Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))], Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align collinear_iff_finrank_le_one collinear_iff_finrank_le_oneₓ'. -/
/-- A set of points, whose `vector_span` is finite-dimensional, is
collinear if and only if their `vector_span` has dimension at most
`1`. -/
theorem collinear_iff_finrank_le_one {s : Set P} [FiniteDimensional k (vectorSpan k s)] :
    Collinear k s ↔ finrank k (vectorSpan k s) ≤ 1 :=
  by
  have h := collinear_iff_rank_le_one k s
  rw [← finrank_eq_rank] at h
  exact_mod_cast h
#align collinear_iff_finrank_le_one collinear_iff_finrank_le_one

/- warning: collinear.finrank_le_one -> Collinear.finrank_le_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))], (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))], (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align collinear.finrank_le_one Collinear.finrank_le_oneₓ'. -/
alias collinear_iff_finrank_le_one ↔ Collinear.finrank_le_one _
#align collinear.finrank_le_one Collinear.finrank_le_one

/- warning: collinear.subset -> Collinear.subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s₁ s₂) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s₁ s₂) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁)
Case conversion may be inaccurate. Consider using '#align collinear.subset Collinear.subsetₓ'. -/
/-- A subset of a collinear set is collinear. -/
theorem Collinear.subset {s₁ s₂ : Set P} (hs : s₁ ⊆ s₂) (h : Collinear k s₂) : Collinear k s₁ :=
  (rank_le_of_submodule (vectorSpan k s₁) (vectorSpan k s₂) (vectorSpan_mono k hs)).trans h
#align collinear.subset Collinear.subset

/- warning: collinear.finite_dimensional_vector_span -> Collinear.finiteDimensional_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align collinear.finite_dimensional_vector_span Collinear.finiteDimensional_vectorSpanₓ'. -/
/-- The `vector_span` of collinear points is finite-dimensional. -/
theorem Collinear.finiteDimensional_vectorSpan {s : Set P} (h : Collinear k s) :
    FiniteDimensional k (vectorSpan k s) :=
  IsNoetherian.iff_fg.1
    (IsNoetherian.iff_rank_lt_aleph0.2 (lt_of_le_of_lt h Cardinal.one_lt_aleph0))
#align collinear.finite_dimensional_vector_span Collinear.finiteDimensional_vectorSpan

/- warning: collinear.finite_dimensional_direction_affine_span -> Collinear.finiteDimensional_direction_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
Case conversion may be inaccurate. Consider using '#align collinear.finite_dimensional_direction_affine_span Collinear.finiteDimensional_direction_affineSpanₓ'. -/
/-- The direction of the affine span of collinear points is finite-dimensional. -/
theorem Collinear.finiteDimensional_direction_affineSpan {s : Set P} (h : Collinear k s) :
    FiniteDimensional k (affineSpan k s).direction :=
  (direction_affineSpan k s).symm ▸ h.finiteDimensional_vectorSpan
#align collinear.finite_dimensional_direction_affine_span Collinear.finiteDimensional_direction_affineSpan

variable (k P)

/- warning: collinear_empty -> collinear_empty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} (P : Type.{u1}) [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} P) (Set.instEmptyCollectionSet.{u1} P))
Case conversion may be inaccurate. Consider using '#align collinear_empty collinear_emptyₓ'. -/
/-- The empty set is collinear. -/
theorem collinear_empty : Collinear k (∅ : Set P) :=
  by
  rw [collinear_iff_rank_le_one, vectorSpan_empty]
  simp
#align collinear_empty collinear_empty

variable {P}

/- warning: collinear_singleton -> collinear_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p)
Case conversion may be inaccurate. Consider using '#align collinear_singleton collinear_singletonₓ'. -/
/-- A single point is collinear. -/
theorem collinear_singleton (p : P) : Collinear k ({p} : Set P) :=
  by
  rw [collinear_iff_rank_le_one, vectorSpan_singleton]
  simp
#align collinear_singleton collinear_singleton

variable {k}

/- warning: collinear_iff_of_mem -> collinear_iff_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p₀ : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₀ s) -> (Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Exists.{succ u2} V (fun (v : V) => forall (p : P), (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Exists.{succ u1} k (fun (r : k) => Eq.{succ u3} P p (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r v) p₀))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p₀ : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₀ s) -> (Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Exists.{succ u1} V (fun (v : V) => forall (p : P), (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Exists.{succ u2} k (fun (r : k) => Eq.{succ u3} P p (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r v) p₀))))))
Case conversion may be inaccurate. Consider using '#align collinear_iff_of_mem collinear_iff_of_memₓ'. -/
/-- Given a point `p₀` in a set of points, that set is collinear if and
only if the points can all be expressed as multiples of the same
vector, added to `p₀`. -/
theorem collinear_iff_of_mem {s : Set P} {p₀ : P} (h : p₀ ∈ s) :
    Collinear k s ↔ ∃ v : V, ∀ p ∈ s, ∃ r : k, p = r • v +ᵥ p₀ :=
  by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  · rintro ⟨v₀, hv⟩
    use v₀
    intro p hp
    obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  · rintro ⟨v, hp₀v⟩
    use v
    intro w hw
    have hs : vectorSpan k s ≤ k ∙ v :=
      by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ⟨p, hp, rfl⟩
      rcases hp₀v p hp with ⟨r, rfl⟩
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'
#align collinear_iff_of_mem collinear_iff_of_mem

/- warning: collinear_iff_exists_forall_eq_smul_vadd -> collinear_iff_exists_forall_eq_smul_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Exists.{succ u3} P (fun (p₀ : P) => Exists.{succ u2} V (fun (v : V) => forall (p : P), (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Exists.{succ u1} k (fun (r : k) => Eq.{succ u3} P p (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r v) p₀))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Exists.{succ u3} P (fun (p₀ : P) => Exists.{succ u1} V (fun (v : V) => forall (p : P), (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Exists.{succ u2} k (fun (r : k) => Eq.{succ u3} P p (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r v) p₀))))))
Case conversion may be inaccurate. Consider using '#align collinear_iff_exists_forall_eq_smul_vadd collinear_iff_exists_forall_eq_smul_vaddₓ'. -/
/-- A set of points is collinear if and only if they can all be
expressed as multiples of the same vector, added to the same base
point. -/
theorem collinear_iff_exists_forall_eq_smul_vadd (s : Set P) :
    Collinear k s ↔ ∃ (p₀ : P)(v : V), ∀ p ∈ s, ∃ r : k, p = r • v +ᵥ p₀ :=
  by
  rcases Set.eq_empty_or_nonempty s with (rfl | ⟨⟨p₁, hp₁⟩⟩)
  · simp [collinear_empty]
  · rw [collinear_iff_of_mem hp₁]
    constructor
    · exact fun h => ⟨p₁, h⟩
    · rintro ⟨p, v, hv⟩
      use v
      intro p₂ hp₂
      rcases hv p₂ hp₂ with ⟨r, rfl⟩
      rcases hv p₁ hp₁ with ⟨r₁, rfl⟩
      use r - r₁
      simp [vadd_vadd, ← add_smul]
#align collinear_iff_exists_forall_eq_smul_vadd collinear_iff_exists_forall_eq_smul_vadd

variable (k)

/- warning: collinear_pair -> collinear_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))
Case conversion may be inaccurate. Consider using '#align collinear_pair collinear_pairₓ'. -/
/-- Two points are collinear. -/
theorem collinear_pair (p₁ p₂ : P) : Collinear k ({p₁, p₂} : Set P) :=
  by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  use p₁, p₂ -ᵥ p₁
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp
  cases hp
  · use 0
    simp [hp]
  · use 1
    simp [hp]
#align collinear_pair collinear_pair

variable {k}

/- warning: affine_independent_iff_not_collinear -> affineIndependent_iff_not_collinear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> P}, Iff (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p) (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, 1} P (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> P}, Iff (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p) (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u1, 1} P (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p)))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_not_collinear affineIndependent_iff_not_collinearₓ'. -/
/-- Three points are affinely independent if and only if they are not
collinear. -/
theorem affineIndependent_iff_not_collinear {p : Fin 3 → P} :
    AffineIndependent k p ↔ ¬Collinear k (Set.range p) := by
  rw [collinear_iff_finrank_le_one,
    affineIndependent_iff_not_finrank_vectorSpan_le k p (Fintype.card_fin 3)]
#align affine_independent_iff_not_collinear affineIndependent_iff_not_collinear

/- warning: collinear_iff_not_affine_independent -> collinear_iff_not_affineIndependent is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> P}, Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, 1} P (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p)) (Not (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> P}, Iff (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u1, 1} P (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p)) (Not (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p))
Case conversion may be inaccurate. Consider using '#align collinear_iff_not_affine_independent collinear_iff_not_affineIndependentₓ'. -/
/-- Three points are collinear if and only if they are not affinely
independent. -/
theorem collinear_iff_not_affineIndependent {p : Fin 3 → P} :
    Collinear k (Set.range p) ↔ ¬AffineIndependent k p := by
  rw [collinear_iff_finrank_le_one,
    finrank_vectorSpan_le_iff_not_affineIndependent k p (Fintype.card_fin 3)]
#align collinear_iff_not_affine_independent collinear_iff_not_affineIndependent

/- warning: affine_independent_iff_not_collinear_set -> affineIndependent_iff_not_collinear_set is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, Iff (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))) (Matrix.vecCons.{u3} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) p₁ (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₂ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₃ (Matrix.vecEmpty.{u3} P))))) (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, Iff (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Matrix.vecCons.{u1} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) p₁ (Matrix.vecCons.{u1} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₂ (Matrix.vecCons.{u1} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₃ (Matrix.vecEmpty.{u1} P))))) (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃)))))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_not_collinear_set affineIndependent_iff_not_collinear_setₓ'. -/
/-- Three points are affinely independent if and only if they are not collinear. -/
theorem affineIndependent_iff_not_collinear_set {p₁ p₂ p₃ : P} :
    AffineIndependent k ![p₁, p₂, p₃] ↔ ¬Collinear k ({p₁, p₂, p₃} : Set P) := by
  simp [affineIndependent_iff_not_collinear, -Set.union_singleton]
#align affine_independent_iff_not_collinear_set affineIndependent_iff_not_collinear_set

/- warning: collinear_iff_not_affine_independent_set -> collinear_iff_not_affineIndependent_set is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))) (Not (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))) (Matrix.vecCons.{u3} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) p₁ (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₂ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₃ (Matrix.vecEmpty.{u3} P))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, Iff (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃)))) (Not (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Matrix.vecCons.{u1} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) p₁ (Matrix.vecCons.{u1} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₂ (Matrix.vecCons.{u1} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₃ (Matrix.vecEmpty.{u1} P))))))
Case conversion may be inaccurate. Consider using '#align collinear_iff_not_affine_independent_set collinear_iff_not_affineIndependent_setₓ'. -/
/-- Three points are collinear if and only if they are not affinely independent. -/
theorem collinear_iff_not_affineIndependent_set {p₁ p₂ p₃ : P} :
    Collinear k ({p₁, p₂, p₃} : Set P) ↔ ¬AffineIndependent k ![p₁, p₂, p₃] :=
  affineIndependent_iff_not_collinear_set.not_left.symm
#align collinear_iff_not_affine_independent_set collinear_iff_not_affineIndependent_set

/- warning: affine_independent_iff_not_collinear_of_ne -> affineIndependent_iff_not_collinear_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> P} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₁ i₂) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₁ i₃) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₂ i₃) -> (Iff (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p) (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (p i₁) (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (p i₂) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (p i₃)))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> P} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₁ i₂) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₁ i₃) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₂ i₃) -> (Iff (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p) (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (p i₁) (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (p i₂) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) (p i₃)))))))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_not_collinear_of_ne affineIndependent_iff_not_collinear_of_neₓ'. -/
/-- Three points are affinely independent if and only if they are not collinear. -/
theorem affineIndependent_iff_not_collinear_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂)
    (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) :
    AffineIndependent k p ↔ ¬Collinear k ({p i₁, p i₂, p i₃} : Set P) :=
  by
  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} := by decide!
  rw [affineIndependent_iff_not_collinear, ← Set.image_univ, ← Finset.coe_univ, hu,
    Finset.coe_insert, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_pair]
#align affine_independent_iff_not_collinear_of_ne affineIndependent_iff_not_collinear_of_ne

/- warning: collinear_iff_not_affine_independent_of_ne -> collinear_iff_not_affineIndependent_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> P} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₁ i₂) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₁ i₃) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) i₂ i₃) -> (Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (p i₁) (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (p i₂) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (p i₃))))) (Not (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (OfNat.mk.{0} Nat 3 (bit1.{0} Nat Nat.hasOne Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) -> P} {i₁ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₂ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))} {i₃ : Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))}, (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₁ i₂) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₁ i₃) -> (Ne.{1} (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) i₂ i₃) -> (Iff (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (p i₁) (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) (p i₂) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) (p i₃))))) (Not (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3))) p)))
Case conversion may be inaccurate. Consider using '#align collinear_iff_not_affine_independent_of_ne collinear_iff_not_affineIndependent_of_neₓ'. -/
/-- Three points are collinear if and only if they are not affinely independent. -/
theorem collinear_iff_not_affineIndependent_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂)
    (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) :
    Collinear k ({p i₁, p i₂, p i₃} : Set P) ↔ ¬AffineIndependent k p :=
  (affineIndependent_iff_not_collinear_of_ne h₁₂ h₁₃ h₂₃).not_left.symm
#align collinear_iff_not_affine_independent_of_ne collinear_iff_not_affineIndependent_of_ne

/- warning: ne₁₂_of_not_collinear -> ne₁₂_of_not_collinear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))) -> (Ne.{succ u3} P p₁ p₂)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃))))) -> (Ne.{succ u1} P p₁ p₂)
Case conversion may be inaccurate. Consider using '#align ne₁₂_of_not_collinear ne₁₂_of_not_collinearₓ'. -/
/-- If three points are not collinear, the first and second are different. -/
theorem ne₁₂_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₁ ≠ p₂ :=
  by
  rintro rfl
  simpa [collinear_pair] using h
#align ne₁₂_of_not_collinear ne₁₂_of_not_collinear

/- warning: ne₁₃_of_not_collinear -> ne₁₃_of_not_collinear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))) -> (Ne.{succ u3} P p₁ p₃)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃))))) -> (Ne.{succ u1} P p₁ p₃)
Case conversion may be inaccurate. Consider using '#align ne₁₃_of_not_collinear ne₁₃_of_not_collinearₓ'. -/
/-- If three points are not collinear, the first and third are different. -/
theorem ne₁₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₁ ≠ p₃ :=
  by
  rintro rfl
  simpa [collinear_pair] using h
#align ne₁₃_of_not_collinear ne₁₃_of_not_collinear

/- warning: ne₂₃_of_not_collinear -> ne₂₃_of_not_collinear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))) -> (Ne.{succ u3} P p₂ p₃)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Not (Collinear.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃))))) -> (Ne.{succ u1} P p₂ p₃)
Case conversion may be inaccurate. Consider using '#align ne₂₃_of_not_collinear ne₂₃_of_not_collinearₓ'. -/
/-- If three points are not collinear, the second and third are different. -/
theorem ne₂₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₂ ≠ p₃ :=
  by
  rintro rfl
  simpa [collinear_pair] using h
#align ne₂₃_of_not_collinear ne₂₃_of_not_collinear

/- warning: collinear.mem_affine_span_of_mem_of_ne -> Collinear.mem_affineSpan_of_mem_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₁ s) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₂ s) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₃ s) -> (Ne.{succ u3} P p₁ p₂) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₁ s) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₂ s) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₃ s) -> (Ne.{succ u3} P p₁ p₂) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))))
Case conversion may be inaccurate. Consider using '#align collinear.mem_affine_span_of_mem_of_ne Collinear.mem_affineSpan_of_mem_of_neₓ'. -/
/-- A point in a collinear set of points lies in the affine span of any two distinct points of
that set. -/
theorem Collinear.mem_affineSpan_of_mem_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P}
    (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : p₃ ∈ line[k, p₁, p₂] :=
  by
  rw [collinear_iff_of_mem hp₁] at h
  rcases h with ⟨v, h⟩
  rcases h p₂ hp₂ with ⟨r₂, rfl⟩
  rcases h p₃ hp₃ with ⟨r₃, rfl⟩
  rw [vadd_left_mem_affineSpan_pair]
  refine' ⟨r₃ / r₂, _⟩
  have h₂ : r₂ ≠ 0 := by
    rintro rfl
    simpa using hp₁p₂
  simp [smul_smul, h₂]
#align collinear.mem_affine_span_of_mem_of_ne Collinear.mem_affineSpan_of_mem_of_ne

/- warning: collinear.affine_span_eq_of_ne -> Collinear.affineSpan_eq_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₁ s) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₂ s) -> (Ne.{succ u3} P p₁ p₂) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₁ s) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₂ s) -> (Ne.{succ u3} P p₁ p₂) -> (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂))) (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align collinear.affine_span_eq_of_ne Collinear.affineSpan_eq_of_neₓ'. -/
/-- The affine span of any two distinct points of a collinear set of points equals the affine
span of the whole set. -/
theorem Collinear.affineSpan_eq_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ : P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : line[k, p₁, p₂] = affineSpan k s :=
  le_antisymm (affineSpan_mono _ (Set.insert_subset.2 ⟨hp₁, Set.singleton_subset_iff.2 hp₂⟩))
    (affineSpan_le.2 fun p hp => h.mem_affineSpan_of_mem_of_ne hp₁ hp₂ hp hp₁p₂)
#align collinear.affine_span_eq_of_ne Collinear.affineSpan_eq_of_ne

/- warning: collinear.collinear_insert_iff_of_ne -> Collinear.collinear_insert_iff_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₂ s) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₃ s) -> (Ne.{succ u3} P p₂ p₃) -> (Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ s)) (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₂ s) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₃ s) -> (Ne.{succ u3} P p₂ p₃) -> (Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ s)) (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))))))
Case conversion may be inaccurate. Consider using '#align collinear.collinear_insert_iff_of_ne Collinear.collinear_insert_iff_of_neₓ'. -/
/-- Given a collinear set of points, and two distinct points `p₂` and `p₃` in it, a point `p₁` is
collinear with the set if and only if it is collinear with `p₂` and `p₃`. -/
theorem Collinear.collinear_insert_iff_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P}
    (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₂p₃ : p₂ ≠ p₃) :
    Collinear k (insert p₁ s) ↔ Collinear k ({p₁, p₂, p₃} : Set P) :=
  by
  have hv : vectorSpan k (insert p₁ s) = vectorSpan k ({p₁, p₂, p₃} : Set P) :=
    by
    conv_lhs => rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]
    conv_rhs => rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]
    rw [h.affine_span_eq_of_ne hp₂ hp₃ hp₂p₃]
  rw [Collinear, Collinear, hv]
#align collinear.collinear_insert_iff_of_ne Collinear.collinear_insert_iff_of_ne

/- warning: collinear_insert_iff_of_mem_affine_span -> collinear_insert_iff_of_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) -> (Iff (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s)) (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) -> (Iff (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s)) (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align collinear_insert_iff_of_mem_affine_span collinear_insert_iff_of_mem_affineSpanₓ'. -/
/-- Adding a point in the affine span of a set does not change whether that set is collinear. -/
theorem collinear_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :
    Collinear k (insert p s) ↔ Collinear k s := by
  rw [Collinear, Collinear, vectorSpan_insert_eq_vectorSpan h]
#align collinear_insert_iff_of_mem_affine_span collinear_insert_iff_of_mem_affineSpan

/- warning: collinear_insert_of_mem_affine_span_pair -> collinear_insert_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃)))) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))))
Case conversion may be inaccurate. Consider using '#align collinear_insert_of_mem_affine_span_pair collinear_insert_of_mem_affineSpan_pairₓ'. -/
/-- If a point lies in the affine span of two points, those three points are collinear. -/
theorem collinear_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :
    Collinear k ({p₁, p₂, p₃} : Set P) :=
  by
  rw [collinear_insert_iff_of_mem_affineSpan h]
  exact collinear_pair _ _ _
#align collinear_insert_of_mem_affine_span_pair collinear_insert_of_mem_affineSpan_pair

/- warning: collinear_insert_insert_of_mem_affine_span_pair -> collinear_insert_insert_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄)))) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₄)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₄)))) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₄)))))
Case conversion may be inaccurate. Consider using '#align collinear_insert_insert_of_mem_affine_span_pair collinear_insert_insert_of_mem_affineSpan_pairₓ'. -/
/-- If two points lie in the affine span of two points, those four points are collinear. -/
theorem collinear_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ : P} (h₁ : p₁ ∈ line[k, p₃, p₄])
    (h₂ : p₂ ∈ line[k, p₃, p₄]) : Collinear k ({p₁, p₂, p₃, p₄} : Set P) :=
  by
  rw [collinear_insert_iff_of_mem_affineSpan
      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₁),
    collinear_insert_iff_of_mem_affineSpan h₂]
  exact collinear_pair _ _ _
#align collinear_insert_insert_of_mem_affine_span_pair collinear_insert_insert_of_mem_affineSpan_pair

/- warning: collinear_insert_insert_insert_of_mem_affine_span_pair -> collinear_insert_insert_insert_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₃ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅))))))
Case conversion may be inaccurate. Consider using '#align collinear_insert_insert_insert_of_mem_affine_span_pair collinear_insert_insert_insert_of_mem_affineSpan_pairₓ'. -/
/-- If three points lie in the affine span of two points, those five points are collinear. -/
theorem collinear_insert_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P}
    (h₁ : p₁ ∈ line[k, p₄, p₅]) (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) :
    Collinear k ({p₁, p₂, p₃, p₄, p₅} : Set P) :=
  by
  rw [collinear_insert_iff_of_mem_affineSpan
      ((AffineSubspace.le_def' _ _).1
        (affineSpan_mono k ((Set.subset_insert _ _).trans (Set.subset_insert _ _))) _ h₁),
    collinear_insert_iff_of_mem_affineSpan
      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₂),
    collinear_insert_iff_of_mem_affineSpan h₃]
  exact collinear_pair _ _ _
#align collinear_insert_insert_insert_of_mem_affine_span_pair collinear_insert_insert_insert_of_mem_affineSpan_pair

/- warning: collinear_insert_insert_insert_left_of_mem_affine_span_pair -> collinear_insert_insert_insert_left_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₄)))))
Case conversion may be inaccurate. Consider using '#align collinear_insert_insert_insert_left_of_mem_affine_span_pair collinear_insert_insert_insert_left_of_mem_affineSpan_pairₓ'. -/
/-- If three points lie in the affine span of two points, the first four points are collinear. -/
theorem collinear_insert_insert_insert_left_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P}
    (h₁ : p₁ ∈ line[k, p₄, p₅]) (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) :
    Collinear k ({p₁, p₂, p₃, p₄} : Set P) :=
  by
  refine' (collinear_insert_insert_insert_of_mem_affineSpan_pair h₁ h₂ h₃).Subset _
  simp [Set.insert_subset_insert]
#align collinear_insert_insert_insert_left_of_mem_affine_span_pair collinear_insert_insert_insert_left_of_mem_affineSpan_pair

/- warning: collinear_triple_of_mem_affine_span_pair -> collinear_triple_of_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₅)))) -> (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P} {p₅ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₄ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₅)))) -> (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))))
Case conversion may be inaccurate. Consider using '#align collinear_triple_of_mem_affine_span_pair collinear_triple_of_mem_affineSpan_pairₓ'. -/
/-- If three points lie in the affine span of two points, the first three points are collinear. -/
theorem collinear_triple_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P} (h₁ : p₁ ∈ line[k, p₄, p₅])
    (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) : Collinear k ({p₁, p₂, p₃} : Set P) :=
  by
  refine' (collinear_insert_insert_insert_left_of_mem_affineSpan_pair h₁ h₂ h₃).Subset _
  simp [Set.insert_subset_insert]
#align collinear_triple_of_mem_affine_span_pair collinear_triple_of_mem_affineSpan_pair

variable (k)

#print Coplanar /-
/-- A set of points is coplanar if their `vector_span` has dimension at most `2`. -/
def Coplanar (s : Set P) : Prop :=
  Module.rank k (vectorSpan k s) ≤ 2
#align coplanar Coplanar
-/

variable {k}

/- warning: coplanar.finite_dimensional_vector_span -> Coplanar.finiteDimensional_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align coplanar.finite_dimensional_vector_span Coplanar.finiteDimensional_vectorSpanₓ'. -/
/-- The `vector_span` of coplanar points is finite-dimensional. -/
theorem Coplanar.finiteDimensional_vectorSpan {s : Set P} (h : Coplanar k s) :
    FiniteDimensional k (vectorSpan k s) :=
  by
  refine' IsNoetherian.iff_fg.1 (IsNoetherian.iff_rank_lt_aleph0.2 (lt_of_le_of_lt h _))
  simp
#align coplanar.finite_dimensional_vector_span Coplanar.finiteDimensional_vectorSpan

/- warning: coplanar.finite_dimensional_direction_affine_span -> Coplanar.finiteDimensional_direction_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))))
Case conversion may be inaccurate. Consider using '#align coplanar.finite_dimensional_direction_affine_span Coplanar.finiteDimensional_direction_affineSpanₓ'. -/
/-- The direction of the affine span of coplanar points is finite-dimensional. -/
theorem Coplanar.finiteDimensional_direction_affineSpan {s : Set P} (h : Coplanar k s) :
    FiniteDimensional k (affineSpan k s).direction :=
  (direction_affineSpan k s).symm ▸ h.finiteDimensional_vectorSpan
#align coplanar.finite_dimensional_direction_affine_span Coplanar.finiteDimensional_direction_affineSpan

/- warning: coplanar_iff_finrank_le_two -> coplanar_iff_finrank_le_two is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))], Iff (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))], Iff (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align coplanar_iff_finrank_le_two coplanar_iff_finrank_le_twoₓ'. -/
/-- A set of points, whose `vector_span` is finite-dimensional, is coplanar if and only if their
`vector_span` has dimension at most `2`. -/
theorem coplanar_iff_finrank_le_two {s : Set P} [FiniteDimensional k (vectorSpan k s)] :
    Coplanar k s ↔ finrank k (vectorSpan k s) ≤ 2 :=
  by
  have h : Coplanar k s ↔ Module.rank k (vectorSpan k s) ≤ 2 := Iff.rfl
  rw [← finrank_eq_rank] at h
  exact_mod_cast h
#align coplanar_iff_finrank_le_two coplanar_iff_finrank_le_two

/- warning: coplanar.finrank_le_two -> Coplanar.finrank_le_two is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))], (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} [_inst_5 : FiniteDimensional.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))], (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))
Case conversion may be inaccurate. Consider using '#align coplanar.finrank_le_two Coplanar.finrank_le_twoₓ'. -/
alias coplanar_iff_finrank_le_two ↔ Coplanar.finrank_le_two _
#align coplanar.finrank_le_two Coplanar.finrank_le_two

/- warning: coplanar.subset -> Coplanar.subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s₁ s₂) -> (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s₁ s₂) -> (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂) -> (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁)
Case conversion may be inaccurate. Consider using '#align coplanar.subset Coplanar.subsetₓ'. -/
/-- A subset of a coplanar set is coplanar. -/
theorem Coplanar.subset {s₁ s₂ : Set P} (hs : s₁ ⊆ s₂) (h : Coplanar k s₂) : Coplanar k s₁ :=
  (rank_le_of_submodule (vectorSpan k s₁) (vectorSpan k s₂) (vectorSpan_mono k hs)).trans h
#align coplanar.subset Coplanar.subset

/- warning: collinear.coplanar -> Collinear.coplanar is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align collinear.coplanar Collinear.coplanarₓ'. -/
/-- Collinear points are coplanar. -/
theorem Collinear.coplanar {s : Set P} (h : Collinear k s) : Coplanar k s :=
  le_trans h one_le_two
#align collinear.coplanar Collinear.coplanar

variable (k) (P)

/- warning: coplanar_empty -> coplanar_empty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} (P : Type.{u1}) [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Coplanar.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} P) (Set.instEmptyCollectionSet.{u1} P))
Case conversion may be inaccurate. Consider using '#align coplanar_empty coplanar_emptyₓ'. -/
/-- The empty set is coplanar. -/
theorem coplanar_empty : Coplanar k (∅ : Set P) :=
  (collinear_empty k P).Coplanar
#align coplanar_empty coplanar_empty

variable {P}

/- warning: coplanar_singleton -> coplanar_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Coplanar.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p)
Case conversion may be inaccurate. Consider using '#align coplanar_singleton coplanar_singletonₓ'. -/
/-- A single point is coplanar. -/
theorem coplanar_singleton (p : P) : Coplanar k ({p} : Set P) :=
  (collinear_singleton k p).Coplanar
#align coplanar_singleton coplanar_singleton

/- warning: coplanar_pair -> coplanar_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Coplanar.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))
Case conversion may be inaccurate. Consider using '#align coplanar_pair coplanar_pairₓ'. -/
/-- Two points are coplanar. -/
theorem coplanar_pair (p₁ p₂ : P) : Coplanar k ({p₁, p₂} : Set P) :=
  (collinear_pair k p₁ p₂).Coplanar
#align coplanar_pair coplanar_pair

variable {k}

/- warning: coplanar_insert_iff_of_mem_affine_span -> coplanar_insert_iff_of_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) -> (Iff (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s)) (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)) p (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) -> (Iff (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s)) (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align coplanar_insert_iff_of_mem_affine_span coplanar_insert_iff_of_mem_affineSpanₓ'. -/
/-- Adding a point in the affine span of a set does not change whether that set is coplanar. -/
theorem coplanar_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :
    Coplanar k (insert p s) ↔ Coplanar k s := by
  rw [Coplanar, Coplanar, vectorSpan_insert_eq_vectorSpan h]
#align coplanar_insert_iff_of_mem_affine_span coplanar_insert_iff_of_mem_affineSpan

end AffineSpace'

section DivisionRing

variable {k : Type _} {V : Type _} {P : Type _}

include V

open AffineSubspace FiniteDimensional Module

variable [DivisionRing k] [AddCommGroup V] [Module k V] [affine_space V P]

/- warning: finrank_vector_span_insert_le -> finrank_vectorSpan_insert_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (p : P), LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) s)))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) s)))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))) s))))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (p : P), LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) s))))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) s)))) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) s))))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u3, u2} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (Submodule.addCommGroup.{u3, u2} k V (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align finrank_vector_span_insert_le finrank_vectorSpan_insert_leₓ'. -/
/-- Adding a point to a finite-dimensional subspace increases the dimension by at most one. -/
theorem finrank_vectorSpan_insert_le (s : AffineSubspace k P) (p : P) :
    finrank k (vectorSpan k (insert p (s : Set P))) ≤ finrank k s.direction + 1 :=
  by
  by_cases hf : FiniteDimensional k s.direction; swap
  · have hf' : ¬FiniteDimensional k (vectorSpan k (insert p (s : Set P))) :=
      by
      intro h
      have h' : s.direction ≤ vectorSpan k (insert p (s : Set P)) :=
        by
        conv_lhs => rw [← affine_span_coe s, direction_affineSpan]
        exact vectorSpan_mono k (Set.subset_insert _ _)
      exact hf (Submodule.finiteDimensional_of_le h')
    rw [finrank_of_infinite_dimensional hf, finrank_of_infinite_dimensional hf', zero_add]
    exact zero_le_one
  haveI := hf
  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]
  rcases(s : Set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)
  · rw [coe_eq_bot_iff] at hs
    rw [hs, bot_coe, span_empty, bot_coe, direction_affineSpan, direction_bot, finrank_bot,
      zero_add]
    convert zero_le_one' ℕ
    rw [← finrank_bot k V]
    convert rfl <;> simp
  · rw [affine_span_coe, direction_affine_span_insert hp₀, add_comm]
    refine' (Submodule.finrank_add_le_finrank_add_finrank _ _).trans (add_le_add_right _ _)
    refine' finrank_le_one ⟨p -ᵥ p₀, Submodule.mem_span_singleton_self _⟩ fun v => _
    have h := v.property
    rw [Submodule.mem_span_singleton] at h
    rcases h with ⟨c, hc⟩
    refine' ⟨c, _⟩
    ext
    exact hc
#align finrank_vector_span_insert_le finrank_vectorSpan_insert_le

variable (k)

/- warning: finrank_vector_span_insert_le_set -> finrank_vectorSpan_insert_le_set is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P) (p : P), LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s))) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (Submodule.addCommGroup.{u1, u2} k V (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (vectorSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P) (p : P), LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s)))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s)))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u2, u1} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (Submodule.addCommGroup.{u2, u1} k V (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (vectorSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align finrank_vector_span_insert_le_set finrank_vectorSpan_insert_le_setₓ'. -/
/-- Adding a point to a set with a finite-dimensional span increases the dimension by at most
one. -/
theorem finrank_vectorSpan_insert_le_set (s : Set P) (p : P) :
    finrank k (vectorSpan k (insert p s)) ≤ finrank k (vectorSpan k s) + 1 :=
  by
  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, direction_affineSpan]
  refine' (finrank_vectorSpan_insert_le _ _).trans (add_le_add_right _ _)
  rw [direction_affineSpan]
#align finrank_vector_span_insert_le_set finrank_vectorSpan_insert_le_set

variable {k}

/- warning: collinear.coplanar_insert -> Collinear.coplanar_insert is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall (p : P), Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p s))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Collinear.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) -> (forall (p : P), Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p s))
Case conversion may be inaccurate. Consider using '#align collinear.coplanar_insert Collinear.coplanar_insertₓ'. -/
/-- Adding a point to a collinear set produces a coplanar set. -/
theorem Collinear.coplanar_insert {s : Set P} (h : Collinear k s) (p : P) :
    Coplanar k (insert p s) :=
  by
  haveI := h.finite_dimensional_vector_span
  rw [coplanar_iff_finrank_le_two]
  exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)
#align collinear.coplanar_insert Collinear.coplanar_insert

/- warning: coplanar_of_finrank_eq_two -> coplanar_of_finrank_eq_two is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align coplanar_of_finrank_eq_two coplanar_of_finrank_eq_twoₓ'. -/
/-- A set of points in a two-dimensional space is coplanar. -/
theorem coplanar_of_finrank_eq_two (s : Set P) (h : finrank k V = 2) : Coplanar k s :=
  by
  haveI := finite_dimensional_of_finrank_eq_succ h
  rw [coplanar_iff_finrank_le_two, ← h]
  exact Submodule.finrank_le _
#align coplanar_of_finrank_eq_two coplanar_of_finrank_eq_two

/- warning: coplanar_of_fact_finrank_eq_two -> coplanar_of_fact_finrank_eq_two is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P) [h : Fact (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))], Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P) [h : Fact (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))], Coplanar.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s
Case conversion may be inaccurate. Consider using '#align coplanar_of_fact_finrank_eq_two coplanar_of_fact_finrank_eq_twoₓ'. -/
/-- A set of points in a two-dimensional space is coplanar. -/
theorem coplanar_of_fact_finrank_eq_two (s : Set P) [h : Fact (finrank k V = 2)] : Coplanar k s :=
  coplanar_of_finrank_eq_two s h.out
#align coplanar_of_fact_finrank_eq_two coplanar_of_fact_finrank_eq_two

variable (k)

/- warning: coplanar_triple -> coplanar_triple is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P) (p₃ : P), Coplanar.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P) (p₃ : P), Coplanar.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₂ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₃)))
Case conversion may be inaccurate. Consider using '#align coplanar_triple coplanar_tripleₓ'. -/
/-- Three points are coplanar. -/
theorem coplanar_triple (p₁ p₂ p₃ : P) : Coplanar k ({p₁, p₂, p₃} : Set P) :=
  (collinear_pair k p₂ p₃).coplanar_insert p₁
#align coplanar_triple coplanar_triple

end DivisionRing

namespace AffineBasis

universe u₁ u₂ u₃ u₄

variable {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄}

variable [AddCommGroup V] [affine_space V P]

section DivisionRing

variable [DivisionRing k] [Module k V]

include V

#print AffineBasis.finiteDimensional /-
protected theorem finiteDimensional [Finite ι] (b : AffineBasis ι k P) : FiniteDimensional k V :=
  let ⟨i⟩ := b.Nonempty
  FiniteDimensional.of_fintype_basis (b.basisOf i)
#align affine_basis.finite_dimensional AffineBasis.finiteDimensional
-/

#print AffineBasis.finite /-
protected theorem finite [FiniteDimensional k V] (b : AffineBasis ι k P) : Finite ι :=
  finite_of_fin_dim_affineIndependent k b.ind
#align affine_basis.finite AffineBasis.finite
-/

#print AffineBasis.finite_set /-
protected theorem finite_set [FiniteDimensional k V] {s : Set ι} (b : AffineBasis s k P) :
    s.Finite :=
  finite_set_of_fin_dim_affineIndependent k b.ind
#align affine_basis.finite_set AffineBasis.finite_set
-/

#print AffineBasis.card_eq_finrank_add_one /-
theorem card_eq_finrank_add_one [Fintype ι] (b : AffineBasis ι k P) :
    Fintype.card ι = FiniteDimensional.finrank k V + 1 :=
  haveI := b.finite_dimensional
  b.ind.affine_span_eq_top_iff_card_eq_finrank_add_one.mp b.tot
#align affine_basis.card_eq_finrank_add_one AffineBasis.card_eq_finrank_add_one
-/

variable {k V P}

#print AffineBasis.exists_affineBasis_of_finiteDimensional /-
theorem exists_affineBasis_of_finiteDimensional [Fintype ι] [FiniteDimensional k V]
    (h : Fintype.card ι = FiniteDimensional.finrank k V + 1) : Nonempty (AffineBasis ι k P) :=
  by
  obtain ⟨s, b, hb⟩ := AffineBasis.exists_affineBasis k V P
  lift s to Finset P using b.finite_set
  refine' ⟨b.reindex <| Fintype.equivOfCardEq _⟩
  rw [h, ← b.card_eq_finrank_add_one]
#align affine_basis.exists_affine_basis_of_finite_dimensional AffineBasis.exists_affineBasis_of_finiteDimensional
-/

end DivisionRing

end AffineBasis

