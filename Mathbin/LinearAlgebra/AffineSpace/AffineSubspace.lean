/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module linear_algebra.affine_space.affine_subspace
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.AffineEquiv

/-!
# Affine spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines affine subspaces (over modules) and the affine span of a set of points.

## Main definitions

* `affine_subspace k P` is the type of affine subspaces.  Unlike
  affine spaces, affine subspaces are allowed to be empty, and lemmas
  that do not apply to empty affine subspaces have `nonempty`
  hypotheses.  There is a `complete_lattice` structure on affine
  subspaces.
* `affine_subspace.direction` gives the `submodule` spanned by the
  pairwise differences of points in an `affine_subspace`.  There are
  various lemmas relating to the set of vectors in the `direction`,
  and relating the lattice structure on affine subspaces to that on
  their directions.
* `affine_subspace.parallel`, notation `∥`, gives the property of two affine subspaces being
  parallel (one being a translate of the other).
* `affine_span` gives the affine subspace spanned by a set of points,
  with `vector_span` giving its direction.  `affine_span` is defined
  in terms of `span_points`, which gives an explicit description of
  the points contained in the affine span; `span_points` itself should
  generally only be used when that description is required, with
  `affine_span` being the main definition for other purposes.  Two
  other descriptions of the affine span are proved equivalent: it is
  the `Inf` of affine subspaces containing the points, and (if
  `[nontrivial k]`) it contains exactly those points that are affine
  combinations of points in the given set.

## Implementation notes

`out_param` is used in the definiton of `add_torsor V P` to make `V` an implicit argument (deduced
from `P`) in most cases; `include V` is needed in many cases for `V`, and type classes using it, to
be added as implicit arguments to individual lemmas.  As for modules, `k` is an explicit argument
rather than implied by `P` or `V`.

This file only provides purely algebraic definitions and results.
Those depending on analysis or topology are defined elsewhere; see
`analysis.normed_space.add_torsor` and `topology.algebra.affine`.

## References

* https://en.wikipedia.org/wiki/Affine_space
* https://en.wikipedia.org/wiki/Principal_homogeneous_space
-/


noncomputable section

open BigOperators Affine

open Set

section

variable (k : Type _) {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]

variable [affine_space V P]

include V

#print vectorSpan /-
/-- The submodule spanning the differences of a (possibly empty) set
of points. -/
def vectorSpan (s : Set P) : Submodule k V :=
  Submodule.span k (s -ᵥ s)
#align vector_span vectorSpan
-/

#print vectorSpan_def /-
/-- The definition of `vector_span`, for rewriting. -/
theorem vectorSpan_def (s : Set P) : vectorSpan k s = Submodule.span k (s -ᵥ s) :=
  rfl
#align vector_span_def vectorSpan_def
-/

/- warning: vector_span_mono -> vectorSpan_mono is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s₁ s₂) -> (LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
but is expected to have type
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s₁ s₂) -> (LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
Case conversion may be inaccurate. Consider using '#align vector_span_mono vectorSpan_monoₓ'. -/
/-- `vector_span` is monotone. -/
theorem vectorSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : vectorSpan k s₁ ≤ vectorSpan k s₂ :=
  Submodule.span_mono (vsub_self_mono h)
#align vector_span_mono vectorSpan_mono

variable (P)

/- warning: vector_span_empty -> vectorSpan_empty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))) (Bot.bot.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} (P : Type.{u1}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)], Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (EmptyCollection.emptyCollection.{u1} (Set.{u1} P) (Set.instEmptyCollectionSet.{u1} P))) (Bot.bot.{u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align vector_span_empty vectorSpan_emptyₓ'. -/
/-- The `vector_span` of the empty set is `⊥`. -/
@[simp]
theorem vectorSpan_empty : vectorSpan k (∅ : Set P) = (⊥ : Submodule k V) := by
  rw [vectorSpan_def, vsub_empty, Submodule.span_empty]
#align vector_span_empty vectorSpan_empty

variable {P}

/- warning: vector_span_singleton -> vectorSpan_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)) (Bot.bot.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (p : P), Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p)) (Bot.bot.{u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align vector_span_singleton vectorSpan_singletonₓ'. -/
/-- The `vector_span` of a single point is `⊥`. -/
@[simp]
theorem vectorSpan_singleton (p : P) : vectorSpan k ({p} : Set P) = ⊥ := by simp [vectorSpan_def]
#align vector_span_singleton vectorSpan_singleton

#print vsub_set_subset_vectorSpan /-
/-- The `s -ᵥ s` lies within the `vector_span k s`. -/
theorem vsub_set_subset_vectorSpan (s : Set P) : s -ᵥ s ⊆ ↑(vectorSpan k s) :=
  Submodule.subset_span
#align vsub_set_subset_vector_span vsub_set_subset_vectorSpan
-/

#print vsub_mem_vectorSpan /-
/-- Each pairwise difference is in the `vector_span`. -/
theorem vsub_mem_vectorSpan {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :
    p1 -ᵥ p2 ∈ vectorSpan k s :=
  vsub_set_subset_vectorSpan k s (vsub_mem_vsub hp1 hp2)
#align vsub_mem_vector_span vsub_mem_vectorSpan
-/

#print spanPoints /-
/-- The points in the affine span of a (possibly empty) set of
points. Use `affine_span` instead to get an `affine_subspace k P`. -/
def spanPoints (s : Set P) : Set P :=
  { p | ∃ p1 ∈ s, ∃ v ∈ vectorSpan k s, p = v +ᵥ p1 }
#align span_points spanPoints
-/

/- warning: mem_span_points -> mem_spanPoints is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (s : Set.{u3} P), (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P) (s : Set.{u3} P), (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align mem_span_points mem_spanPointsₓ'. -/
/-- A point in a set is in its affine span. -/
theorem mem_spanPoints (p : P) (s : Set P) : p ∈ s → p ∈ spanPoints k s
  | hp => ⟨p, hp, 0, Submodule.zero_mem _, (zero_vadd V p).symm⟩
#align mem_span_points mem_spanPoints

/- warning: subset_span_points -> subset_spanPoints is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align subset_span_points subset_spanPointsₓ'. -/
/-- A set is contained in its `span_points`. -/
theorem subset_spanPoints (s : Set P) : s ⊆ spanPoints k s := fun p => mem_spanPoints k p s
#align subset_span_points subset_spanPoints

/- warning: span_points_nonempty -> spanPoints_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Iff (Set.Nonempty.{u3} P (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.Nonempty.{u3} P s)
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Iff (Set.Nonempty.{u3} P (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.Nonempty.{u3} P s)
Case conversion may be inaccurate. Consider using '#align span_points_nonempty spanPoints_nonemptyₓ'. -/
/-- The `span_points` of a set is nonempty if and only if that set
is. -/
@[simp]
theorem spanPoints_nonempty (s : Set P) : (spanPoints k s).Nonempty ↔ s.Nonempty :=
  by
  constructor
  · contrapose
    rw [Set.not_nonempty_iff_eq_empty, Set.not_nonempty_iff_eq_empty]
    intro h
    simp [h, spanPoints]
  · exact fun h => h.mono (subset_spanPoints _ _)
#align span_points_nonempty spanPoints_nonempty

/- warning: vadd_mem_span_points_of_mem_span_points_of_mem_vector_span -> vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P} {v : V}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p : P} {v : V}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) v (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) v p) (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align vadd_mem_span_points_of_mem_span_points_of_mem_vector_span vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpanₓ'. -/
/-- Adding a point in the affine span and a vector in the spanning
submodule produces a point in the affine span. -/
theorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan {s : Set P} {p : P} {v : V}
    (hp : p ∈ spanPoints k s) (hv : v ∈ vectorSpan k s) : v +ᵥ p ∈ spanPoints k s :=
  by
  rcases hp with ⟨p2, ⟨hp2, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩
  rw [hv2p, vadd_vadd]
  use p2, hp2, v + v2, (vectorSpan k s).add_mem hv hv2, rfl
#align vadd_mem_span_points_of_mem_span_points_of_mem_vector_span vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan

/- warning: vsub_mem_vector_span_of_mem_span_points_of_mem_span_points -> vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p1 : P} {p2 : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p1 (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p2 (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p1 p2) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p1 : P} {p2 : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p1 (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p2 (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p1 p2) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align vsub_mem_vector_span_of_mem_span_points_of_mem_span_points vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPointsₓ'. -/
/-- Subtracting two points in the affine span produces a vector in the
spanning submodule. -/
theorem vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints {s : Set P} {p1 p2 : P}
    (hp1 : p1 ∈ spanPoints k s) (hp2 : p2 ∈ spanPoints k s) : p1 -ᵥ p2 ∈ vectorSpan k s :=
  by
  rcases hp1 with ⟨p1a, ⟨hp1a, ⟨v1, ⟨hv1, hv1p⟩⟩⟩⟩
  rcases hp2 with ⟨p2a, ⟨hp2a, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩
  rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +ᵥ p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]
  have hv1v2 : v1 - v2 ∈ vectorSpan k s :=
    by
    rw [sub_eq_add_neg]
    apply (vectorSpan k s).add_mem hv1
    rw [← neg_one_smul k v2]
    exact (vectorSpan k s).smul_mem (-1 : k) hv2
  refine' (vectorSpan k s).add_mem _ hv1v2
  exact vsub_mem_vectorSpan k hp1a hp2a
#align vsub_mem_vector_span_of_mem_span_points_of_mem_span_points vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints

end

#print AffineSubspace /-
/-- An `affine_subspace k P` is a subset of an `affine_space V P`
that, if not empty, has an affine space structure induced by a
corresponding subspace of the `module k V`. -/
structure AffineSubspace (k : Type _) {V : Type _} (P : Type _) [Ring k] [AddCommGroup V]
  [Module k V] [affine_space V P] where
  carrier : Set P
  smul_vsub_vadd_mem :
    ∀ (c : k) {p1 p2 p3 : P},
      p1 ∈ carrier → p2 ∈ carrier → p3 ∈ carrier → c • (p1 -ᵥ p2 : V) +ᵥ p3 ∈ carrier
#align affine_subspace AffineSubspace
-/

namespace Submodule

variable {k V : Type _} [Ring k] [AddCommGroup V] [Module k V]

#print Submodule.toAffineSubspace /-
/-- Reinterpret `p : submodule k V` as an `affine_subspace k V`. -/
def toAffineSubspace (p : Submodule k V) : AffineSubspace k V
    where
  carrier := p
  smul_vsub_vadd_mem c p₁ p₂ p₃ h₁ h₂ h₃ := p.add_mem (p.smul_mem _ (p.sub_mem h₁ h₂)) h₃
#align submodule.to_affine_subspace Submodule.toAffineSubspace
-/

end Submodule

namespace AffineSubspace

variable (k : Type _) {V : Type _} (P : Type _) [Ring k] [AddCommGroup V] [Module k V]
  [affine_space V P]

include V

instance : SetLike (AffineSubspace k P) P
    where
  coe := carrier
  coe_injective' p q _ := by cases p <;> cases q <;> congr

/- warning: affine_subspace.mem_coe -> AffineSubspace.mem_coe is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4), Iff (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} (P : Type.{u1}) [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4), Iff (Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) p (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_coe AffineSubspace.mem_coeₓ'. -/
/-- A point is in an affine subspace coerced to a set if and only if
it is in that affine subspace. -/
@[simp]
theorem mem_coe (p : P) (s : AffineSubspace k P) : p ∈ (s : Set P) ↔ p ∈ s :=
  Iff.rfl
#align affine_subspace.mem_coe AffineSubspace.mem_coe

variable {k P}

#print AffineSubspace.direction /-
/-- The direction of an affine subspace is the submodule spanned by
the pairwise differences of points.  (Except in the case of an empty
affine subspace, where the direction is the zero submodule, every
vector in the direction is the difference of two points in the affine
subspace.) -/
def direction (s : AffineSubspace k P) : Submodule k V :=
  vectorSpan k (s : Set P)
#align affine_subspace.direction AffineSubspace.direction
-/

/- warning: affine_subspace.direction_eq_vector_span -> AffineSubspace.direction_eq_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (vectorSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_eq_vector_span AffineSubspace.direction_eq_vectorSpanₓ'. -/
/-- The direction equals the `vector_span`. -/
theorem direction_eq_vectorSpan (s : AffineSubspace k P) : s.direction = vectorSpan k (s : Set P) :=
  rfl
#align affine_subspace.direction_eq_vector_span AffineSubspace.direction_eq_vectorSpan

#print AffineSubspace.directionOfNonempty /-
/-- Alternative definition of the direction when the affine subspace
is nonempty.  This is defined so that the order on submodules (as used
in the definition of `submodule.span`) can be used in the proof of
`coe_direction_eq_vsub_set`, and is not intended to be used beyond
that proof. -/
def directionOfNonempty {s : AffineSubspace k P} (h : (s : Set P).Nonempty) : Submodule k V
    where
  carrier := (s : Set P) -ᵥ s
  zero_mem' := by
    cases' h with p hp
    exact vsub_self p ▸ vsub_mem_vsub hp hp
  add_mem' := by
    intro a b ha hb
    rcases ha with ⟨p1, p2, hp1, hp2, rfl⟩
    rcases hb with ⟨p3, p4, hp3, hp4, rfl⟩
    rw [← vadd_vsub_assoc]
    refine' vsub_mem_vsub _ hp4
    convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp3
    rw [one_smul]
  smul_mem' := by
    intro c v hv
    rcases hv with ⟨p1, p2, hp1, hp2, rfl⟩
    rw [← vadd_vsub (c • (p1 -ᵥ p2)) p2]
    refine' vsub_mem_vsub _ hp2
    exact s.smul_vsub_vadd_mem c hp1 hp2 hp2
#align affine_subspace.direction_of_nonempty AffineSubspace.directionOfNonempty
-/

/- warning: affine_subspace.direction_of_nonempty_eq_direction -> AffineSubspace.directionOfNonempty_eq_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} (h : Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.directionOfNonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s h) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} (h : Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)), Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.directionOfNonempty.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s h) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_of_nonempty_eq_direction AffineSubspace.directionOfNonempty_eq_directionₓ'. -/
/-- `direction_of_nonempty` gives the same submodule as
`direction`. -/
theorem directionOfNonempty_eq_direction {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :
    directionOfNonempty h = s.direction :=
  le_antisymm (vsub_set_subset_vectorSpan k s) (Submodule.span_le.2 Set.Subset.rfl)
#align affine_subspace.direction_of_nonempty_eq_direction AffineSubspace.directionOfNonempty_eq_direction

/- warning: affine_subspace.coe_direction_eq_vsub_set -> AffineSubspace.coe_direction_eq_vsub_set is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)) -> (Eq.{succ u2} (Set.{u2} V) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (VSub.vsub.{u2, u3} (Set.{u2} V) (Set.{u3} P) (Set.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) -> (Eq.{succ u2} (Set.{u2} V) (SetLike.coe.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (VSub.vsub.{u2, u1} (Set.{u2} V) (Set.{u1} P) (Set.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_direction_eq_vsub_set AffineSubspace.coe_direction_eq_vsub_setₓ'. -/
/-- The set of vectors in the direction of a nonempty affine subspace
is given by `vsub_set`. -/
theorem coe_direction_eq_vsub_set {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :
    (s.direction : Set V) = (s : Set P) -ᵥ s :=
  directionOfNonempty_eq_direction h ▸ rfl
#align affine_subspace.coe_direction_eq_vsub_set AffineSubspace.coe_direction_eq_vsub_set

/- warning: affine_subspace.mem_direction_iff_eq_vsub -> AffineSubspace.mem_direction_iff_eq_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)) -> (forall (v : V), Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u3} P (fun (p1 : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) => Exists.{succ u3} P (fun (p2 : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) => Eq.{succ u2} V v (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p1 p2)))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) -> (forall (v : V), Iff (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u1} P (fun (p1 : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) (Exists.{succ u1} P (fun (p2 : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (Eq.{succ u2} V v (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p1 p2)))))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_direction_iff_eq_vsub AffineSubspace.mem_direction_iff_eq_vsubₓ'. -/
/-- A vector is in the direction of a nonempty affine subspace if and
only if it is the subtraction of two vectors in the subspace. -/
theorem mem_direction_iff_eq_vsub {s : AffineSubspace k P} (h : (s : Set P).Nonempty) (v : V) :
    v ∈ s.direction ↔ ∃ p1 ∈ s, ∃ p2 ∈ s, v = p1 -ᵥ p2 :=
  by
  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set h]
  exact
    ⟨fun ⟨p1, p2, hp1, hp2, hv⟩ => ⟨p1, hp1, p2, hp2, hv.symm⟩, fun ⟨p1, hp1, p2, hp2, hv⟩ =>
      ⟨p1, p2, hp1, hp2, hv.symm⟩⟩
#align affine_subspace.mem_direction_iff_eq_vsub AffineSubspace.mem_direction_iff_eq_vsub

/- warning: affine_subspace.vadd_mem_of_mem_direction -> AffineSubspace.vadd_mem_of_mem_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {v : V}, (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {v : V}, (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v p) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vadd_mem_of_mem_direction AffineSubspace.vadd_mem_of_mem_directionₓ'. -/
/-- Adding a vector in the direction to a point in the subspace
produces a point in the subspace. -/
theorem vadd_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction) {p : P}
    (hp : p ∈ s) : v +ᵥ p ∈ s :=
  by
  rw [mem_direction_iff_eq_vsub ⟨p, hp⟩] at hv
  rcases hv with ⟨p1, hp1, p2, hp2, hv⟩
  rw [hv]
  convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp
  rw [one_smul]
#align affine_subspace.vadd_mem_of_mem_direction AffineSubspace.vadd_mem_of_mem_direction

/- warning: affine_subspace.vsub_mem_direction -> AffineSubspace.vsub_mem_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) -> (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p1 p2) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) -> (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p1 p2) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vsub_mem_direction AffineSubspace.vsub_mem_directionₓ'. -/
/-- Subtracting two points in the subspace produces a vector in the
direction. -/
theorem vsub_mem_direction {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :
    p1 -ᵥ p2 ∈ s.direction :=
  vsub_mem_vectorSpan k hp1 hp2
#align affine_subspace.vsub_mem_direction AffineSubspace.vsub_mem_direction

/- warning: affine_subspace.vadd_mem_iff_mem_direction -> AffineSubspace.vadd_mem_iff_mem_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} (v : V) {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) s) (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} (v : V) {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v p) s) (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vadd_mem_iff_mem_direction AffineSubspace.vadd_mem_iff_mem_directionₓ'. -/
/-- Adding a vector to a point in a subspace produces a point in the
subspace if and only if the vector is in the direction. -/
theorem vadd_mem_iff_mem_direction {s : AffineSubspace k P} (v : V) {p : P} (hp : p ∈ s) :
    v +ᵥ p ∈ s ↔ v ∈ s.direction :=
  ⟨fun h => by simpa using vsub_mem_direction h hp, fun h => vadd_mem_of_mem_direction h hp⟩
#align affine_subspace.vadd_mem_iff_mem_direction AffineSubspace.vadd_mem_iff_mem_direction

/- warning: affine_subspace.vadd_mem_iff_mem_of_mem_direction -> AffineSubspace.vadd_mem_iff_mem_of_mem_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {v : V}, (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall {p : P}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) s) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {v : V}, (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall {p : P}, Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v p) s) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vadd_mem_iff_mem_of_mem_direction AffineSubspace.vadd_mem_iff_mem_of_mem_directionₓ'. -/
/-- Adding a vector in the direction to a point produces a point in the subspace if and only if
the original point is in the subspace. -/
theorem vadd_mem_iff_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction)
    {p : P} : v +ᵥ p ∈ s ↔ p ∈ s :=
  by
  refine' ⟨fun h => _, fun h => vadd_mem_of_mem_direction hv h⟩
  convert vadd_mem_of_mem_direction (Submodule.neg_mem _ hv) h
  simp
#align affine_subspace.vadd_mem_iff_mem_of_mem_direction AffineSubspace.vadd_mem_iff_mem_of_mem_direction

/- warning: affine_subspace.coe_direction_eq_vsub_set_right -> AffineSubspace.coe_direction_eq_vsub_set_right is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u2} (Set.{u2} V) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.image.{u3, u2} P V (fun (_x : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x p) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u2} (Set.{u2} V) (SetLike.coe.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.image.{u1, u2} P V (fun (_x : P) => VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x p) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_direction_eq_vsub_set_right AffineSubspace.coe_direction_eq_vsub_set_rightₓ'. -/
/-- Given a point in an affine subspace, the set of vectors in its
direction equals the set of vectors subtracting that point on the
right. -/
theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :
    (s.direction : Set V) = (· -ᵥ p) '' s :=
  by
  rw [coe_direction_eq_vsub_set ⟨p, hp⟩]
  refine' le_antisymm _ _
  · rintro v ⟨p1, p2, hp1, hp2, rfl⟩
    exact ⟨p1 -ᵥ p2 +ᵥ p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _⟩
  · rintro v ⟨p2, hp2, rfl⟩
    exact ⟨p2, p, hp2, hp, rfl⟩
#align affine_subspace.coe_direction_eq_vsub_set_right AffineSubspace.coe_direction_eq_vsub_set_right

/- warning: affine_subspace.coe_direction_eq_vsub_set_left -> AffineSubspace.coe_direction_eq_vsub_set_left is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u2} (Set.{u2} V) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Set.{u2} V) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.image.{u3, u2} P V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u2} (Set.{u2} V) (SetLike.coe.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.image.{u1, u2} P V ((fun (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.2822 : P) (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.2824 : P) => VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.2822 x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.2824) p) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_direction_eq_vsub_set_left AffineSubspace.coe_direction_eq_vsub_set_leftₓ'. -/
/-- Given a point in an affine subspace, the set of vectors in its
direction equals the set of vectors subtracting that point on the
left. -/
theorem coe_direction_eq_vsub_set_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :
    (s.direction : Set V) = (· -ᵥ ·) p '' s := by
  ext v
  rw [SetLike.mem_coe, ← Submodule.neg_mem_iff, ← SetLike.mem_coe,
    coe_direction_eq_vsub_set_right hp, Set.mem_image_iff_bex, Set.mem_image_iff_bex]
  conv_lhs =>
    congr
    ext
    rw [← neg_vsub_eq_vsub_rev, neg_inj]
#align affine_subspace.coe_direction_eq_vsub_set_left AffineSubspace.coe_direction_eq_vsub_set_left

/- warning: affine_subspace.mem_direction_iff_eq_vsub_right -> AffineSubspace.mem_direction_iff_eq_vsub_right is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (v : V), Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u3} P (fun (p2 : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) => Eq.{succ u2} V v (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (v : V), Iff (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u1} P (fun (p2 : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (Eq.{succ u2} V v (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_direction_iff_eq_vsub_right AffineSubspace.mem_direction_iff_eq_vsub_rightₓ'. -/
/-- Given a point in an affine subspace, a vector is in its direction
if and only if it results from subtracting that point on the right. -/
theorem mem_direction_iff_eq_vsub_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :
    v ∈ s.direction ↔ ∃ p2 ∈ s, v = p2 -ᵥ p :=
  by
  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_right hp]
  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩
#align affine_subspace.mem_direction_iff_eq_vsub_right AffineSubspace.mem_direction_iff_eq_vsub_right

/- warning: affine_subspace.mem_direction_iff_eq_vsub_left -> AffineSubspace.mem_direction_iff_eq_vsub_left is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (v : V), Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u3} P (fun (p2 : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) => Eq.{succ u2} V v (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p2)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (v : V), Iff (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Exists.{succ u1} P (fun (p2 : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s) (Eq.{succ u2} V v (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p2)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_direction_iff_eq_vsub_left AffineSubspace.mem_direction_iff_eq_vsub_leftₓ'. -/
/-- Given a point in an affine subspace, a vector is in its direction
if and only if it results from subtracting that point on the left. -/
theorem mem_direction_iff_eq_vsub_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :
    v ∈ s.direction ↔ ∃ p2 ∈ s, v = p -ᵥ p2 :=
  by
  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_left hp]
  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩
#align affine_subspace.mem_direction_iff_eq_vsub_left AffineSubspace.mem_direction_iff_eq_vsub_left

/- warning: affine_subspace.vsub_right_mem_direction_iff_mem -> AffineSubspace.vsub_right_mem_direction_iff_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (p2 : P), Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (p2 : P), Iff (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vsub_right_mem_direction_iff_mem AffineSubspace.vsub_right_mem_direction_iff_memₓ'. -/
/-- Given a point in an affine subspace, a result of subtracting that
point on the right is in the direction if and only if the other point
is in the subspace. -/
theorem vsub_right_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :
    p2 -ᵥ p ∈ s.direction ↔ p2 ∈ s :=
  by
  rw [mem_direction_iff_eq_vsub_right hp]
  simp
#align affine_subspace.vsub_right_mem_direction_iff_mem AffineSubspace.vsub_right_mem_direction_iff_mem

/- warning: affine_subspace.vsub_left_mem_direction_iff_mem -> AffineSubspace.vsub_left_mem_direction_iff_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (p2 : P), Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p2) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (forall (p2 : P), Iff (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p2) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vsub_left_mem_direction_iff_mem AffineSubspace.vsub_left_mem_direction_iff_memₓ'. -/
/-- Given a point in an affine subspace, a result of subtracting that
point on the left is in the direction if and only if the other point
is in the subspace. -/
theorem vsub_left_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :
    p -ᵥ p2 ∈ s.direction ↔ p2 ∈ s :=
  by
  rw [mem_direction_iff_eq_vsub_left hp]
  simp
#align affine_subspace.vsub_left_mem_direction_iff_mem AffineSubspace.vsub_left_mem_direction_iff_mem

/- warning: affine_subspace.coe_injective -> AffineSubspace.coe_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Function.Injective.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Function.Injective.{succ u3, succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_injective AffineSubspace.coe_injectiveₓ'. -/
/-- Two affine subspaces are equal if they have the same points. -/
theorem coe_injective : Function.Injective (coe : AffineSubspace k P → Set P) :=
  SetLike.coe_injective
#align affine_subspace.coe_injective AffineSubspace.coe_injective

/- warning: affine_subspace.ext -> AffineSubspace.ext is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (forall (x : P), Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x p) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x q)) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) p q)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (forall (x : P), Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x p) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x q)) -> (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) p q)
Case conversion may be inaccurate. Consider using '#align affine_subspace.ext AffineSubspace.extₓ'. -/
@[ext]
theorem ext {p q : AffineSubspace k P} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=
  SetLike.ext h
#align affine_subspace.ext AffineSubspace.ext

/- warning: affine_subspace.ext_iff -> AffineSubspace.ext_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4), Iff (Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s₁) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s₂)) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ s₂)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4), Iff (Eq.{succ u1} (Set.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₂)) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ s₂)
Case conversion may be inaccurate. Consider using '#align affine_subspace.ext_iff AffineSubspace.ext_iffₓ'. -/
@[simp]
theorem ext_iff (s₁ s₂ : AffineSubspace k P) : (s₁ : Set P) = s₂ ↔ s₁ = s₂ :=
  SetLike.ext'_iff.symm
#align affine_subspace.ext_iff AffineSubspace.ext_iff

/- warning: affine_subspace.ext_of_direction_eq -> AffineSubspace.ext_of_direction_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s2)) -> (Set.Nonempty.{u3} P (Inter.inter.{u3} (Set.{u3} P) (Set.hasInter.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s2))) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s1 s2)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s2)) -> (Set.Nonempty.{u1} P (Inter.inter.{u1} (Set.{u1} P) (Set.instInterSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s2))) -> (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s1 s2)
Case conversion may be inaccurate. Consider using '#align affine_subspace.ext_of_direction_eq AffineSubspace.ext_of_direction_eqₓ'. -/
/-- Two affine subspaces with the same direction and nonempty
intersection are equal. -/
theorem ext_of_direction_eq {s1 s2 : AffineSubspace k P} (hd : s1.direction = s2.direction)
    (hn : ((s1 : Set P) ∩ s2).Nonempty) : s1 = s2 :=
  by
  ext p
  have hq1 := Set.mem_of_mem_inter_left hn.some_mem
  have hq2 := Set.mem_of_mem_inter_right hn.some_mem
  constructor
  · intro hp
    rw [← vsub_vadd p hn.some]
    refine' vadd_mem_of_mem_direction _ hq2
    rw [← hd]
    exact vsub_mem_direction hp hq1
  · intro hp
    rw [← vsub_vadd p hn.some]
    refine' vadd_mem_of_mem_direction _ hq1
    rw [hd]
    exact vsub_mem_direction hp hq2
#align affine_subspace.ext_of_direction_eq AffineSubspace.ext_of_direction_eq

#print AffineSubspace.toAddTorsor /-
-- See note [reducible non instances]
/-- This is not an instance because it loops with `add_torsor.nonempty`. -/
@[reducible]
def toAddTorsor (s : AffineSubspace k P) [Nonempty s] : AddTorsor s.direction s
    where
  vadd a b := ⟨(a : V) +ᵥ (b : P), vadd_mem_of_mem_direction a.2 b.2⟩
  zero_vadd := by simp
  add_vadd a b c := by
    ext
    apply add_vadd
  vsub a b := ⟨(a : P) -ᵥ (b : P), (vsub_left_mem_direction_iff_mem a.2 _).mpr b.2⟩
  Nonempty := by infer_instance
  vsub_vadd' a b := by
    ext
    apply AddTorsor.vsub_vadd'
  vadd_vsub' a b := by
    ext
    apply AddTorsor.vadd_vsub'
#align affine_subspace.to_add_torsor AffineSubspace.toAddTorsor
-/

attribute [local instance] to_add_torsor

/- warning: affine_subspace.coe_vsub -> AffineSubspace.coe_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)] (a : coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (b : coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s), Eq.{succ u2} V ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))))) (VSub.vsub.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (AddTorsor.toHasVsub.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (AddCommGroup.toAddGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) a b)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))) a) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))) b))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))] (a : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (b : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)), Eq.{succ u2} V (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (VSub.vsub.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (AddTorsor.toVSub.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (AddCommGroup.toAddGroup.{u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) a b)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) a) (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) b))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_vsub AffineSubspace.coe_vsubₓ'. -/
@[simp, norm_cast]
theorem coe_vsub (s : AffineSubspace k P) [Nonempty s] (a b : s) : ↑(a -ᵥ b) = (a : P) -ᵥ (b : P) :=
  rfl
#align affine_subspace.coe_vsub AffineSubspace.coe_vsub

/- warning: affine_subspace.coe_vadd -> AffineSubspace.coe_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)] (a : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (b : coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s), Eq.{succ u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))) (VAdd.vadd.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (AddAction.toHasVadd.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (SubNegMonoid.toAddMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AddGroup.toSubNegMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AddCommGroup.toAddGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))))) (AddTorsor.toAddAction.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) (AddCommGroup.toAddGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5))) a b)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))))) a) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))) b))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))] (a : Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (b : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)), Eq.{succ u1} P (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) (HVAdd.hVAdd.{u2, u1, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (instHVAdd.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (AddAction.toVAdd.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (AddSubmonoid.toAddMonoid.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (Submodule.toAddSubmonoid.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AddTorsor.toAddAction.{u2, u1} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (AddCommGroup.toAddGroup.{u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)))) a b)) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Set.{u2} V) (Set.instMembershipSet.{u2} V) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) a) (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) b))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_vadd AffineSubspace.coe_vaddₓ'. -/
@[simp, norm_cast]
theorem coe_vadd (s : AffineSubspace k P) [Nonempty s] (a : s.direction) (b : s) :
    ↑(a +ᵥ b) = (a : V) +ᵥ (b : P) :=
  rfl
#align affine_subspace.coe_vadd AffineSubspace.coe_vadd

#print AffineSubspace.subtype /-
/-- Embedding of an affine subspace to the ambient space, as an affine map. -/
protected def subtype (s : AffineSubspace k P) [Nonempty s] : s →ᵃ[k] P
    where
  toFun := coe
  linear := s.direction.Subtype
  map_vadd' p v := rfl
#align affine_subspace.subtype AffineSubspace.subtype
-/

/- warning: affine_subspace.subtype_linear -> AffineSubspace.subtype_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)], Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) V (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) _inst_3) (AffineMap.linear.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4 (AffineSubspace.subtype.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) (Submodule.subtype.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))], Eq.{succ u2} (LinearMap.{u3, u3, u2, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) V (AddCommGroup.toAddCommMonoid.{u2} (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) _inst_3) (AffineMap.linear.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4 (AffineSubspace.subtype.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) (Submodule.subtype.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.subtype_linear AffineSubspace.subtype_linearₓ'. -/
@[simp]
theorem subtype_linear (s : AffineSubspace k P) [Nonempty s] :
    s.Subtype.linear = s.direction.Subtype :=
  rfl
#align affine_subspace.subtype_linear AffineSubspace.subtype_linear

/- warning: affine_subspace.subtype_apply -> AffineSubspace.subtype_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)] (p : coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s), Eq.{succ u3} P (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) -> P) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) p) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))) p)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))] (p : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)), Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => P) p) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u1} (AffineMap.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (fun (_x : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => P) _x) (AffineMap.funLike.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) p) (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)) p)
Case conversion may be inaccurate. Consider using '#align affine_subspace.subtype_apply AffineSubspace.subtype_applyₓ'. -/
theorem subtype_apply (s : AffineSubspace k P) [Nonempty s] (p : s) : s.Subtype p = p :=
  rfl
#align affine_subspace.subtype_apply AffineSubspace.subtype_apply

/- warning: affine_subspace.coe_subtype -> AffineSubspace.coeSubtype is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)], Eq.{succ u3} ((fun (_x : AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) -> P) (AffineSubspace.subtype.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) -> P) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))], Eq.{succ u1} (forall (a : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => P) a) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u1} (AffineMap.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (fun (_x : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => P) _x) (AffineMap.funLike.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5)) (Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_subtype AffineSubspace.coeSubtypeₓ'. -/
@[simp]
theorem coeSubtype (s : AffineSubspace k P) [Nonempty s] : (s.Subtype : s → P) = coe :=
  rfl
#align affine_subspace.coe_subtype AffineSubspace.coeSubtype

/- warning: affine_subspace.injective_subtype -> AffineSubspace.injective_subtype is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s)], Function.Injective.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) P (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) -> P) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) s) V P _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : Nonempty.{succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s))], Function.Injective.{succ u1, succ u1} (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) P (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u1} (AffineMap.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) (fun (_x : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) => P) _x) (AffineMap.funLike.{u3, u2, u1, u2, u1} k (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Subtype.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x s)) V P _inst_1 (Submodule.addCommGroup.{u3, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Submodule.module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (AffineSubspace.toAddTorsor.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5) _inst_2 _inst_3 _inst_4) (AffineSubspace.subtype.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s _inst_5))
Case conversion may be inaccurate. Consider using '#align affine_subspace.injective_subtype AffineSubspace.injective_subtypeₓ'. -/
theorem injective_subtype (s : AffineSubspace k P) [Nonempty s] : Function.Injective s.Subtype :=
  Subtype.coe_injective
#align affine_subspace.injective_subtype AffineSubspace.injective_subtype

/- warning: affine_subspace.eq_iff_direction_eq_of_mem -> AffineSubspace.eq_iff_direction_eq_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s₁) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s₂) -> (Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ s₂) (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s₁) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s₂) -> (Iff (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ s₂) (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.eq_iff_direction_eq_of_mem AffineSubspace.eq_iff_direction_eq_of_memₓ'. -/
/-- Two affine subspaces with nonempty intersection are equal if and
only if their directions are equal. -/
theorem eq_iff_direction_eq_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁)
    (h₂ : p ∈ s₂) : s₁ = s₂ ↔ s₁.direction = s₂.direction :=
  ⟨fun h => h ▸ rfl, fun h => ext_of_direction_eq h ⟨p, h₁, h₂⟩⟩
#align affine_subspace.eq_iff_direction_eq_of_mem AffineSubspace.eq_iff_direction_eq_of_mem

#print AffineSubspace.mk' /-
/-- Construct an affine subspace from a point and a direction. -/
def mk' (p : P) (direction : Submodule k V) : AffineSubspace k P
    where
  carrier := { q | ∃ v ∈ direction, q = v +ᵥ p }
  smul_vsub_vadd_mem c p1 p2 p3 hp1 hp2 hp3 :=
    by
    rcases hp1 with ⟨v1, hv1, hp1⟩
    rcases hp2 with ⟨v2, hv2, hp2⟩
    rcases hp3 with ⟨v3, hv3, hp3⟩
    use c • (v1 - v2) + v3, direction.add_mem (direction.smul_mem c (direction.sub_mem hv1 hv2)) hv3
    simp [hp1, hp2, hp3, vadd_vadd]
#align affine_subspace.mk' AffineSubspace.mk'
-/

/- warning: affine_subspace.self_mem_mk' -> AffineSubspace.self_mem_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction)
Case conversion may be inaccurate. Consider using '#align affine_subspace.self_mem_mk' AffineSubspace.self_mem_mk'ₓ'. -/
/-- An affine subspace constructed from a point and a direction contains
that point. -/
theorem self_mem_mk' (p : P) (direction : Submodule k V) : p ∈ mk' p direction :=
  ⟨0, ⟨direction.zero_mem, (zero_vadd _ _).symm⟩⟩
#align affine_subspace.self_mem_mk' AffineSubspace.self_mem_mk'

/- warning: affine_subspace.vadd_mem_mk' -> AffineSubspace.vadd_mem_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {v : V} (p : P) {direction : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v direction) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {v : V} (p : P) {direction : Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v direction) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) v p) (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vadd_mem_mk' AffineSubspace.vadd_mem_mk'ₓ'. -/
/-- An affine subspace constructed from a point and a direction contains
the result of adding a vector in that direction to that point. -/
theorem vadd_mem_mk' {v : V} (p : P) {direction : Submodule k V} (hv : v ∈ direction) :
    v +ᵥ p ∈ mk' p direction :=
  ⟨v, hv, rfl⟩
#align affine_subspace.vadd_mem_mk' AffineSubspace.vadd_mem_mk'

/- warning: affine_subspace.mk'_nonempty -> AffineSubspace.mk'_nonempty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mk'_nonempty AffineSubspace.mk'_nonemptyₓ'. -/
/-- An affine subspace constructed from a point and a direction is
nonempty. -/
theorem mk'_nonempty (p : P) (direction : Submodule k V) : (mk' p direction : Set P).Nonempty :=
  ⟨p, self_mem_mk' p direction⟩
#align affine_subspace.mk'_nonempty AffineSubspace.mk'_nonempty

/- warning: affine_subspace.direction_mk' -> AffineSubspace.direction_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction)) direction
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (direction : Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p direction)) direction
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_mk' AffineSubspace.direction_mk'ₓ'. -/
/-- The direction of an affine subspace constructed from a point and a
direction. -/
@[simp]
theorem direction_mk' (p : P) (direction : Submodule k V) :
    (mk' p direction).direction = direction := by
  ext v
  rw [mem_direction_iff_eq_vsub (mk'_nonempty _ _)]
  constructor
  · rintro ⟨p1, ⟨v1, hv1, hp1⟩, p2, ⟨v2, hv2, hp2⟩, hv⟩
    rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]
    exact direction.sub_mem hv1 hv2
  · exact fun hv => ⟨v +ᵥ p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm⟩
#align affine_subspace.direction_mk' AffineSubspace.direction_mk'

/- warning: affine_subspace.mem_mk'_iff_vsub_mem -> AffineSubspace.mem_mk'_iff_vsub_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {direction : Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₁ direction)) (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁) direction)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {direction : Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₁ direction)) (Membership.mem.{u2, u2} V (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁) direction)
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_mk'_iff_vsub_mem AffineSubspace.mem_mk'_iff_vsub_memₓ'. -/
/-- A point lies in an affine subspace constructed from another point and a direction if and only
if their difference is in that direction. -/
theorem mem_mk'_iff_vsub_mem {p₁ p₂ : P} {direction : Submodule k V} :
    p₂ ∈ mk' p₁ direction ↔ p₂ -ᵥ p₁ ∈ direction :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · rw [← direction_mk' p₁ direction]
    exact vsub_mem_direction h (self_mem_mk' _ _)
  · rw [← vsub_vadd p₂ p₁]
    exact vadd_mem_mk' p₁ h
#align affine_subspace.mem_mk'_iff_vsub_mem AffineSubspace.mem_mk'_iff_vsub_mem

/- warning: affine_subspace.mk'_eq -> AffineSubspace.mk'_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.mk'.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) s)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p s) -> (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.mk'.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.mk'_eq AffineSubspace.mk'_eqₓ'. -/
/-- Constructing an affine subspace from a point in a subspace and
that subspace's direction yields the original subspace. -/
@[simp]
theorem mk'_eq {s : AffineSubspace k P} {p : P} (hp : p ∈ s) : mk' p s.direction = s :=
  ext_of_direction_eq (direction_mk' p s.direction) ⟨p, Set.mem_inter (self_mem_mk' _ _) hp⟩
#align affine_subspace.mk'_eq AffineSubspace.mk'_eq

/- warning: affine_subspace.span_points_subset_coe_of_subset_coe -> AffineSubspace.spanPoints_subset_coe_of_subset_coe is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s1)) -> (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s1))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {s1 : AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s1)) -> (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s1))
Case conversion may be inaccurate. Consider using '#align affine_subspace.span_points_subset_coe_of_subset_coe AffineSubspace.spanPoints_subset_coe_of_subset_coeₓ'. -/
/-- If an affine subspace contains a set of points, it contains the
`span_points` of that set. -/
theorem spanPoints_subset_coe_of_subset_coe {s : Set P} {s1 : AffineSubspace k P} (h : s ⊆ s1) :
    spanPoints k s ⊆ s1 := by
  rintro p ⟨p1, hp1, v, hv, hp⟩
  rw [hp]
  have hp1s1 : p1 ∈ (s1 : Set P) := Set.mem_of_mem_of_subset hp1 h
  refine' vadd_mem_of_mem_direction _ hp1s1
  have hs : vectorSpan k s ≤ s1.direction := vectorSpan_mono k h
  rw [SetLike.le_def] at hs
  rw [← SetLike.mem_coe]
  exact Set.mem_of_mem_of_subset hv hs
#align affine_subspace.span_points_subset_coe_of_subset_coe AffineSubspace.spanPoints_subset_coe_of_subset_coe

end AffineSubspace

/- warning: affine_map.line_map_mem -> AffineMap.lineMap_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p₀ : P} {p₁ : P} (c : k), (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₀ Q) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ Q) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) Q)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {Q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p₀ : P} {p₁ : P} (c : k), (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₀ Q) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ Q) -> (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u3, u3, u3, u2, u1} k k k V P _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) _x) (AffineMap.funLike.{u3, u3, u3, u2, u1} k k k V P _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) Q)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_mem AffineMap.lineMap_memₓ'. -/
theorem AffineMap.lineMap_mem {k V P : Type _} [Ring k] [AddCommGroup V] [Module k V]
    [AddTorsor V P] {Q : AffineSubspace k P} {p₀ p₁ : P} (c : k) (h₀ : p₀ ∈ Q) (h₁ : p₁ ∈ Q) :
    AffineMap.lineMap p₀ p₁ c ∈ Q :=
  by
  rw [AffineMap.lineMap_apply]
  exact Q.smul_vsub_vadd_mem c h₁ h₀ h₀
#align affine_map.line_map_mem AffineMap.lineMap_mem

section affineSpan

variable (k : Type _) {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]
  [affine_space V P]

include V

#print affineSpan /-
/-- The affine span of a set of points is the smallest affine subspace
containing those points. (Actually defined here in terms of spans in
modules.) -/
def affineSpan (s : Set P) : AffineSubspace k P
    where
  carrier := spanPoints k s
  smul_vsub_vadd_mem c p1 p2 p3 hp1 hp2 hp3 :=
    vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan k hp3
      ((vectorSpan k s).smul_mem c
        (vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints k hp1 hp2))
#align affine_span affineSpan
-/

/- warning: coe_affine_span -> coe_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (spanPoints.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Eq.{succ u3} (Set.{u3} P) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (spanPoints.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)
Case conversion may be inaccurate. Consider using '#align coe_affine_span coe_affineSpanₓ'. -/
/-- The affine span, converted to a set, is `span_points`. -/
@[simp]
theorem coe_affineSpan (s : Set P) : (affineSpan k s : Set P) = spanPoints k s :=
  rfl
#align coe_affine_span coe_affineSpan

/- warning: subset_affine_span -> subset_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align subset_affine_span subset_affineSpanₓ'. -/
/-- A set is contained in its affine span. -/
theorem subset_affineSpan (s : Set P) : s ⊆ affineSpan k s :=
  subset_spanPoints k s
#align subset_affine_span subset_affineSpan

#print direction_affineSpan /-
/-- The direction of the affine span is the `vector_span`. -/
theorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s :=
  by
  apply le_antisymm
  · refine' Submodule.span_le.2 _
    rintro v ⟨p1, p3, ⟨p2, hp2, v1, hv1, hp1⟩, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩
    rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, SetLike.mem_coe]
    exact
      (vectorSpan k s).sub_mem ((vectorSpan k s).add_mem hv1 (vsub_mem_vectorSpan k hp2 hp4)) hv2
  · exact vectorSpan_mono k (subset_spanPoints k s)
#align direction_affine_span direction_affineSpan
-/

/- warning: mem_affine_span -> mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : P} {s : Set.{u3} P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p : P} {s : Set.{u3} P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align mem_affine_span mem_affineSpanₓ'. -/
/-- A point in a set is in its affine span. -/
theorem mem_affineSpan {p : P} {s : Set P} (hp : p ∈ s) : p ∈ affineSpan k s :=
  mem_spanPoints k p s hp
#align mem_affine_span mem_affineSpan

end affineSpan

namespace AffineSubspace

variable {k : Type _} {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]
  [S : affine_space V P]

include S

instance : CompleteLattice (AffineSubspace k P) :=
  {
    PartialOrder.lift (coe : AffineSubspace k P → Set P)
      coe_injective with
    sup := fun s1 s2 => affineSpan k (s1 ∪ s2)
    le_sup_left := fun s1 s2 =>
      Set.Subset.trans (Set.subset_union_left s1 s2) (subset_spanPoints k _)
    le_sup_right := fun s1 s2 =>
      Set.Subset.trans (Set.subset_union_right s1 s2) (subset_spanPoints k _)
    sup_le := fun s1 s2 s3 hs1 hs2 => spanPoints_subset_coe_of_subset_coe (Set.union_subset hs1 hs2)
    inf := fun s1 s2 =>
      mk (s1 ∩ s2) fun c p1 p2 p3 hp1 hp2 hp3 =>
        ⟨s1.smul_vsub_vadd_mem c hp1.1 hp2.1 hp3.1, s2.smul_vsub_vadd_mem c hp1.2 hp2.2 hp3.2⟩
    inf_le_left := fun _ _ => Set.inter_subset_left _ _
    inf_le_right := fun _ _ => Set.inter_subset_right _ _
    le_inf := fun _ _ _ => Set.subset_inter
    top :=
      { carrier := Set.univ
        smul_vsub_vadd_mem := fun _ _ _ _ _ _ _ => Set.mem_univ _ }
    le_top := fun _ _ _ => Set.mem_univ _
    bot :=
      { carrier := ∅
        smul_vsub_vadd_mem := fun _ _ _ _ => False.elim }
    bot_le := fun _ _ => False.elim
    sSup := fun s => affineSpan k (⋃ s' ∈ s, (s' : Set P))
    sInf := fun s =>
      mk (⋂ s' ∈ s, (s' : Set P)) fun c p1 p2 p3 hp1 hp2 hp3 =>
        Set.mem_iInter₂.2 fun s2 hs2 => by
          rw [Set.mem_iInter₂] at *
          exact s2.smul_vsub_vadd_mem c (hp1 s2 hs2) (hp2 s2 hs2) (hp3 s2 hs2)
    le_sup := fun _ _ h => Set.Subset.trans (Set.subset_biUnion_of_mem h) (subset_spanPoints k _)
    sup_le := fun _ _ h => spanPoints_subset_coe_of_subset_coe (Set.iUnion₂_subset h)
    inf_le := fun _ _ => Set.biInter_subset_of_mem
    le_inf := fun _ _ => Set.subset_iInter₂ }

instance : Inhabited (AffineSubspace k P) :=
  ⟨⊤⟩

/- warning: affine_subspace.le_def -> AffineSubspace.le_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) (HasSubset.Subset.{u1} (Set.{u1} P) (Set.instHasSubsetSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.le_def AffineSubspace.le_defₓ'. -/
/-- The `≤` order on subspaces is the same as that on the corresponding
sets. -/
theorem le_def (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ (s1 : Set P) ⊆ s2 :=
  Iff.rfl
#align affine_subspace.le_def AffineSubspace.le_def

/- warning: affine_subspace.le_def' -> AffineSubspace.le_def' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) (forall (p : P), (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) (forall (p : P), (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s1) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.le_def' AffineSubspace.le_def'ₓ'. -/
/-- One subspace is less than or equal to another if and only if all
its points are in the second subspace. -/
theorem le_def' (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ ∀ p ∈ s1, p ∈ s2 :=
  Iff.rfl
#align affine_subspace.le_def' AffineSubspace.le_def'

/- warning: affine_subspace.lt_def -> AffineSubspace.lt_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (LT.lt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) (HasSSubset.SSubset.{u3} (Set.{u3} P) (Set.hasSsubset.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (LT.lt.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLT.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) (HasSSubset.SSubset.{u1} (Set.{u1} P) (Set.instHasSSubsetSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.lt_def AffineSubspace.lt_defₓ'. -/
/-- The `<` order on subspaces is the same as that on the corresponding
sets. -/
theorem lt_def (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ (s1 : Set P) ⊂ s2 :=
  Iff.rfl
#align affine_subspace.lt_def AffineSubspace.lt_def

/- warning: affine_subspace.not_le_iff_exists -> AffineSubspace.not_le_iff_exists is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (Not (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2)) (Exists.{succ u3} P (fun (p : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1) => Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (Not (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2)) (Exists.{succ u1} P (fun (p : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s1) (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s2))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.not_le_iff_exists AffineSubspace.not_le_iff_existsₓ'. -/
/-- One subspace is not less than or equal to another if and only if
it has a point not in the second subspace. -/
theorem not_le_iff_exists (s1 s2 : AffineSubspace k P) : ¬s1 ≤ s2 ↔ ∃ p ∈ s1, p ∉ s2 :=
  Set.not_subset
#align affine_subspace.not_le_iff_exists AffineSubspace.not_le_iff_exists

/- warning: affine_subspace.exists_of_lt -> AffineSubspace.exists_of_lt is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (LT.lt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) -> (Exists.{succ u3} P (fun (p : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2) => Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (LT.lt.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLT.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) -> (Exists.{succ u1} P (fun (p : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s2) (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s1))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.exists_of_lt AffineSubspace.exists_of_ltₓ'. -/
/-- If a subspace is less than another, there is a point only in the
second. -/
theorem exists_of_lt {s1 s2 : AffineSubspace k P} (h : s1 < s2) : ∃ p ∈ s2, p ∉ s1 :=
  Set.exists_of_ssubset h
#align affine_subspace.exists_of_lt AffineSubspace.exists_of_lt

/- warning: affine_subspace.lt_iff_le_and_exists -> AffineSubspace.lt_iff_le_and_exists is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (LT.lt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) (And (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) (Exists.{succ u3} P (fun (p : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2) (fun (H : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2) => Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (LT.lt.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLT.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) (And (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) (Exists.{succ u1} P (fun (p : P) => And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s2) (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s1)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.lt_iff_le_and_exists AffineSubspace.lt_iff_le_and_existsₓ'. -/
/-- A subspace is less than another if and only if it is less than or
equal to the second subspace and there is a point only in the
second. -/
theorem lt_iff_le_and_exists (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ s1 ≤ s2 ∧ ∃ p ∈ s2, p ∉ s1 :=
  by rw [lt_iff_le_not_le, not_le_iff_exists]
#align affine_subspace.lt_iff_le_and_exists AffineSubspace.lt_iff_le_and_exists

/- warning: affine_subspace.eq_of_direction_eq_of_nonempty_of_le -> AffineSubspace.eq_of_direction_eq_of_nonempty_of_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₂)) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s₁)) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s₁ s₂) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) s₁ s₂)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₂)) -> (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s₁)) -> (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s₁ s₂) -> (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s₁ s₂)
Case conversion may be inaccurate. Consider using '#align affine_subspace.eq_of_direction_eq_of_nonempty_of_le AffineSubspace.eq_of_direction_eq_of_nonempty_of_leₓ'. -/
/-- If an affine subspace is nonempty and contained in another with
the same direction, they are equal. -/
theorem eq_of_direction_eq_of_nonempty_of_le {s₁ s₂ : AffineSubspace k P}
    (hd : s₁.direction = s₂.direction) (hn : (s₁ : Set P).Nonempty) (hle : s₁ ≤ s₂) : s₁ = s₂ :=
  let ⟨p, hp⟩ := hn
  ext_of_direction_eq hd ⟨p, hp, hle hp⟩
#align affine_subspace.eq_of_direction_eq_of_nonempty_of_le AffineSubspace.eq_of_direction_eq_of_nonempty_of_le

variable (k V)

/- warning: affine_subspace.affine_span_eq_Inf -> AffineSubspace.affineSpan_eq_sInf is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (InfSet.sInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))) (setOf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (fun (s' : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) => HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s'))))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (InfSet.sInf.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toInfSet.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))) (setOf.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (fun (s' : AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) => HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) s'))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_eq_Inf AffineSubspace.affineSpan_eq_sInfₓ'. -/
/-- The affine span is the `Inf` of subspaces containing the given
points. -/
theorem affineSpan_eq_sInf (s : Set P) : affineSpan k s = sInf { s' | s ⊆ s' } :=
  le_antisymm (spanPoints_subset_coe_of_subset_coe <| Set.subset_iInter₂ fun _ => id)
    (sInf_le (subset_spanPoints k _))
#align affine_subspace.affine_span_eq_Inf AffineSubspace.affineSpan_eq_sInf

variable (P)

/- warning: affine_subspace.gi -> AffineSubspace.gi is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], GaloisInsertion.{u3, u3} (Set.{u3} P) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (Set.{u3} P) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} P) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} P) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} P) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} P) (Set.completeBooleanAlgebra.{u3} P))))))) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))))
but is expected to have type
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], GaloisInsertion.{u3, u3} (Set.{u3} P) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (Set.{u3} P) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Set.{u3} P) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Set.{u3} P) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} P) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} P) (Set.instCompleteBooleanAlgebraSet.{u3} P))))))) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.coe.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))
Case conversion may be inaccurate. Consider using '#align affine_subspace.gi AffineSubspace.giₓ'. -/
/-- The Galois insertion formed by `affine_span` and coercion back to
a set. -/
protected def gi : GaloisInsertion (affineSpan k) (coe : AffineSubspace k P → Set P)
    where
  choice s _ := affineSpan k s
  gc s1 s2 :=
    ⟨fun h => Set.Subset.trans (subset_spanPoints k s1) h, spanPoints_subset_coe_of_subset_coe⟩
  le_l_u _ := subset_spanPoints k _
  choice_eq _ _ := rfl
#align affine_subspace.gi AffineSubspace.gi

/- warning: affine_subspace.span_empty -> AffineSubspace.span_empty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))) (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.instEmptyCollectionSet.{u3} P))) (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.span_empty AffineSubspace.span_emptyₓ'. -/
/-- The span of the empty set is `⊥`. -/
@[simp]
theorem span_empty : affineSpan k (∅ : Set P) = ⊥ :=
  (AffineSubspace.gi k V P).gc.l_bot
#align affine_subspace.span_empty AffineSubspace.span_empty

/- warning: affine_subspace.span_univ -> AffineSubspace.span_univ is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.univ.{u3} P)) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.univ.{u3} P)) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.span_univ AffineSubspace.span_univₓ'. -/
/-- The span of `univ` is `⊤`. -/
@[simp]
theorem span_univ : affineSpan k (Set.univ : Set P) = ⊤ :=
  eq_top_iff.2 <| subset_spanPoints k _
#align affine_subspace.span_univ AffineSubspace.span_univ

variable {k V P}

/- warning: affine_span_le -> affineSpan_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, Iff (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) Q) (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) Q))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {Q : AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S}, Iff (LE.le.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) Q) (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) Q))
Case conversion may be inaccurate. Consider using '#align affine_span_le affineSpan_leₓ'. -/
theorem affineSpan_le {s : Set P} {Q : AffineSubspace k P} : affineSpan k s ≤ Q ↔ s ⊆ (Q : Set P) :=
  (AffineSubspace.gi k V P).gc _ _
#align affine_span_le affineSpan_le

variable (k V) {P} {p₁ p₂ : P}

/- warning: affine_subspace.coe_affine_span_singleton -> AffineSubspace.coe_affineSpan_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p))) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P), Eq.{succ u3} (Set.{u3} P) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p))) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p)
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_affine_span_singleton AffineSubspace.coe_affineSpan_singletonₓ'. -/
/-- The affine span of a single point, coerced to a set, contains just
that point. -/
@[simp]
theorem coe_affineSpan_singleton (p : P) : (affineSpan k ({p} : Set P) : Set P) = {p} :=
  by
  ext x
  rw [mem_coe, ← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_singleton p)) _,
    direction_affineSpan]
  simp
#align affine_subspace.coe_affine_span_singleton AffineSubspace.coe_affineSpan_singleton

/- warning: affine_subspace.mem_affine_span_singleton -> AffineSubspace.mem_affineSpan_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p₁ (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (Eq.{succ u3} P p₁ p₂)
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P}, Iff (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)) p₁ (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂))) (Eq.{succ u3} P p₁ p₂)
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_affine_span_singleton AffineSubspace.mem_affineSpan_singletonₓ'. -/
/-- A point is in the affine span of a single point if and only if
they are equal. -/
@[simp]
theorem mem_affineSpan_singleton : p₁ ∈ affineSpan k ({p₂} : Set P) ↔ p₁ = p₂ := by simp [← mem_coe]
#align affine_subspace.mem_affine_span_singleton AffineSubspace.mem_affineSpan_singleton

/- warning: affine_subspace.preimage_coe_affine_span_singleton -> AffineSubspace.preimage_coe_affineSpan_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (x : P), Eq.{succ u3} (Set.{u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x)))) (Set.preimage.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))) P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))) P (coeSubtype.{succ u3} P (fun (x_1 : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) x_1 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x)))))))) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x)) (Set.univ.{u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) x))))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (x : P), Eq.{succ u3} (Set.{u3} (Subtype.{succ u3} P (fun (x_1 : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x_1 (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) x)))))) (Set.preimage.{u3, u3} (Subtype.{succ u3} P (fun (x_1 : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x_1 (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) x))))) P (Subtype.val.{succ u3} P (fun (x_1 : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x_1 (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) x))))) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) x)) (Set.univ.{u3} (Subtype.{succ u3} P (fun (x_1 : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x_1 (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) x))))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.preimage_coe_affine_span_singleton AffineSubspace.preimage_coe_affineSpan_singletonₓ'. -/
@[simp]
theorem preimage_coe_affineSpan_singleton (x : P) :
    (coe : affineSpan k ({x} : Set P) → P) ⁻¹' {x} = univ :=
  eq_univ_of_forall fun y => (AffineSubspace.mem_affineSpan_singleton _ _).1 y.2
#align affine_subspace.preimage_coe_affine_span_singleton AffineSubspace.preimage_coe_affineSpan_singleton

/- warning: affine_subspace.span_union -> AffineSubspace.span_union is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P) (t : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) s t)) (Sup.sup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S t))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P) (t : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Union.union.{u3} (Set.{u3} P) (Set.instUnionSet.{u3} P) s t)) (Sup.sup.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toSup.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S t))
Case conversion may be inaccurate. Consider using '#align affine_subspace.span_union AffineSubspace.span_unionₓ'. -/
/-- The span of a union of sets is the sup of their spans. -/
theorem span_union (s t : Set P) : affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t :=
  (AffineSubspace.gi k V P).gc.l_sup
#align affine_subspace.span_union AffineSubspace.span_union

/- warning: affine_subspace.span_Union -> AffineSubspace.span_iUnion is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : ι -> (Set.{u3} P)), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.iUnion.{u3, succ u4} P ι (fun (i : ι) => s i))) (iSup.{u3, succ u4} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))) ι (fun (i : ι) => affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (s i)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : ι -> (Set.{u3} P)), Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.iUnion.{u3, succ u4} P ι (fun (i : ι) => s i))) (iSup.{u3, succ u4} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toSupSet.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))) ι (fun (i : ι) => affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (s i)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.span_Union AffineSubspace.span_iUnionₓ'. -/
/-- The span of a union of an indexed family of sets is the sup of
their spans. -/
theorem span_iUnion {ι : Type _} (s : ι → Set P) :
    affineSpan k (⋃ i, s i) = ⨆ i, affineSpan k (s i) :=
  (AffineSubspace.gi k V P).gc.l_iSup
#align affine_subspace.span_Union AffineSubspace.span_iUnion

variable (P)

/- warning: affine_subspace.top_coe -> AffineSubspace.top_coe is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Set.univ.{u3} P)
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Eq.{succ u3} (Set.{u3} P) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Set.univ.{u3} P)
Case conversion may be inaccurate. Consider using '#align affine_subspace.top_coe AffineSubspace.top_coeₓ'. -/
/-- `⊤`, coerced to a set, is the whole set of points. -/
@[simp]
theorem top_coe : ((⊤ : AffineSubspace k P) : Set P) = Set.univ :=
  rfl
#align affine_subspace.top_coe AffineSubspace.top_coe

variable {P}

/- warning: affine_subspace.mem_top -> AffineSubspace.mem_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P), Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_top AffineSubspace.mem_topₓ'. -/
/-- All points are in `⊤`. -/
theorem mem_top (p : P) : p ∈ (⊤ : AffineSubspace k P) :=
  Set.mem_univ p
#align affine_subspace.mem_top AffineSubspace.mem_top

variable (P)

/- warning: affine_subspace.direction_top -> AffineSubspace.direction_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u3}) (P : Type.{u1}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)], Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (AffineSubspace.direction.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S (Top.top.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S)))) (Top.top.{u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_top AffineSubspace.direction_topₓ'. -/
/-- The direction of `⊤` is the whole module as a submodule. -/
@[simp]
theorem direction_top : (⊤ : AffineSubspace k P).direction = ⊤ :=
  by
  cases' S.nonempty with p
  ext v
  refine' ⟨imp_intro Submodule.mem_top, fun hv => _⟩
  have hpv : (v +ᵥ p -ᵥ p : V) ∈ (⊤ : AffineSubspace k P).direction :=
    vsub_mem_direction (mem_top k V _) (mem_top k V _)
  rwa [vadd_vsub] at hpv
#align affine_subspace.direction_top AffineSubspace.direction_top

/- warning: affine_subspace.bot_coe -> AffineSubspace.bot_coe is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Eq.{succ u3} (Set.{u3} P) (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.instEmptyCollectionSet.{u3} P))
Case conversion may be inaccurate. Consider using '#align affine_subspace.bot_coe AffineSubspace.bot_coeₓ'. -/
/-- `⊥`, coerced to a set, is the empty set. -/
@[simp]
theorem bot_coe : ((⊥ : AffineSubspace k P) : Set P) = ∅ :=
  rfl
#align affine_subspace.bot_coe AffineSubspace.bot_coe

/- warning: affine_subspace.bot_ne_top -> AffineSubspace.bot_ne_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Ne.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)], Ne.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.bot_ne_top AffineSubspace.bot_ne_topₓ'. -/
theorem bot_ne_top : (⊥ : AffineSubspace k P) ≠ ⊤ :=
  by
  intro contra
  rw [← ext_iff, bot_coe, top_coe] at contra
  exact Set.empty_ne_univ contra
#align affine_subspace.bot_ne_top AffineSubspace.bot_ne_top

instance : Nontrivial (AffineSubspace k P) :=
  ⟨⟨⊥, ⊤, bot_ne_top k V P⟩⟩

/- warning: affine_subspace.nonempty_of_affine_span_eq_top -> AffineSubspace.nonempty_of_affineSpan_eq_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Set.Nonempty.{u3} P s)
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Set.Nonempty.{u3} P s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.nonempty_of_affine_span_eq_top AffineSubspace.nonempty_of_affineSpan_eq_topₓ'. -/
theorem nonempty_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = ⊤) : s.Nonempty :=
  by
  rw [Set.nonempty_iff_ne_empty]
  rintro rfl
  rw [AffineSubspace.span_empty] at h
  exact bot_ne_top k V P h
#align affine_subspace.nonempty_of_affine_span_eq_top AffineSubspace.nonempty_of_affineSpan_eq_top

/- warning: affine_subspace.vector_span_eq_top_of_affine_span_eq_top -> AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.vector_span_eq_top_of_affine_span_eq_top AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_topₓ'. -/
/-- If the affine span of a set is `⊤`, then the vector span of the same set is the `⊤`. -/
theorem vectorSpan_eq_top_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = ⊤) :
    vectorSpan k s = ⊤ := by rw [← direction_affineSpan, h, direction_top]
#align affine_subspace.vector_span_eq_top_of_affine_span_eq_top AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top

/- warning: affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty -> AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Nonempty.{u3} P s) -> (Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Nonempty.{u3} P s) -> (Iff (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonemptyₓ'. -/
/-- For a nonempty set, the affine span is `⊤` iff its vector span is `⊤`. -/
theorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty {s : Set P} (hs : s.Nonempty) :
    affineSpan k s = ⊤ ↔ vectorSpan k s = ⊤ :=
  by
  refine' ⟨vector_span_eq_top_of_affine_span_eq_top k V P, _⟩
  intro h
  suffices Nonempty (affineSpan k s)
    by
    obtain ⟨p, hp : p ∈ affineSpan k s⟩ := this
    rw [eq_iff_direction_eq_of_mem hp (mem_top k V p), direction_affineSpan, h, direction_top]
  obtain ⟨x, hx⟩ := hs
  exact ⟨⟨x, mem_affineSpan k hx⟩⟩
#align affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty

/- warning: affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial -> AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} [_inst_4 : Nontrivial.{u3} P], Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} [_inst_4 : Nontrivial.{u3} P], Iff (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivialₓ'. -/
/-- For a non-trivial space, the affine span of a set is `⊤` iff its vector span is `⊤`. -/
theorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial {s : Set P} [Nontrivial P] :
    affineSpan k s = ⊤ ↔ vectorSpan k s = ⊤ :=
  by
  cases' s.eq_empty_or_nonempty with hs hs
  · simp [hs, subsingleton_iff_bot_eq_top, AddTorsor.subsingleton_iff V P, not_subsingleton]
  · rw [affine_span_eq_top_iff_vector_span_eq_top_of_nonempty k V P hs]
#align affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial

/- warning: affine_subspace.card_pos_of_affine_span_eq_top -> AffineSubspace.card_pos_of_affineSpan_eq_top is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_4 : Fintype.{u4} ι] {p : ι -> P}, (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.range.{u3, succ u4} P ι p)) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Fintype.card.{u4} ι _inst_4))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) (P : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_4 : Fintype.{u4} ι] {p : ι -> P}, (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (Set.range.{u3, succ u4} P ι p)) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Fintype.card.{u4} ι _inst_4))
Case conversion may be inaccurate. Consider using '#align affine_subspace.card_pos_of_affine_span_eq_top AffineSubspace.card_pos_of_affineSpan_eq_topₓ'. -/
theorem card_pos_of_affineSpan_eq_top {ι : Type _} [Fintype ι] {p : ι → P}
    (h : affineSpan k (range p) = ⊤) : 0 < Fintype.card ι :=
  by
  obtain ⟨-, ⟨i, -⟩⟩ := nonempty_of_affine_span_eq_top k V P h
  exact fintype.card_pos_iff.mpr ⟨i⟩
#align affine_subspace.card_pos_of_affine_span_eq_top AffineSubspace.card_pos_of_affineSpan_eq_top

variable {P}

/- warning: affine_subspace.not_mem_bot -> AffineSubspace.not_mem_bot is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P), Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P), Not (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.not_mem_bot AffineSubspace.not_mem_botₓ'. -/
/-- No points are in `⊥`. -/
theorem not_mem_bot (p : P) : p ∉ (⊥ : AffineSubspace k P) :=
  Set.not_mem_empty p
#align affine_subspace.not_mem_bot AffineSubspace.not_mem_bot

variable (P)

/- warning: affine_subspace.direction_bot -> AffineSubspace.direction_bot is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) (P : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)], Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Bot.bot.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u3}) (P : Type.{u1}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)], Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (AffineSubspace.direction.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S (Bot.bot.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 S)))) (Bot.bot.{u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_bot AffineSubspace.direction_botₓ'. -/
/-- The direction of `⊥` is the submodule `⊥`. -/
@[simp]
theorem direction_bot : (⊥ : AffineSubspace k P).direction = ⊥ := by
  rw [direction_eq_vector_span, bot_coe, vectorSpan_def, vsub_empty, Submodule.span_empty]
#align affine_subspace.direction_bot AffineSubspace.direction_bot

variable {k V P}

/- warning: affine_subspace.coe_eq_bot_iff -> AffineSubspace.coe_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) Q) (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (Eq.{succ u1} (Set.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q) (EmptyCollection.emptyCollection.{u1} (Set.{u1} P) (Set.instEmptyCollectionSet.{u1} P))) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_eq_bot_iff AffineSubspace.coe_eq_bot_iffₓ'. -/
@[simp]
theorem coe_eq_bot_iff (Q : AffineSubspace k P) : (Q : Set P) = ∅ ↔ Q = ⊥ :=
  coe_injective.eq_iff' (bot_coe _ _ _)
#align affine_subspace.coe_eq_bot_iff AffineSubspace.coe_eq_bot_iff

/- warning: affine_subspace.coe_eq_univ_iff -> AffineSubspace.coe_eq_univ_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (Eq.{succ u3} (Set.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) Q) (Set.univ.{u3} P)) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Q (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (Eq.{succ u1} (Set.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q) (Set.univ.{u1} P)) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q (Top.top.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_eq_univ_iff AffineSubspace.coe_eq_univ_iffₓ'. -/
@[simp]
theorem coe_eq_univ_iff (Q : AffineSubspace k P) : (Q : Set P) = univ ↔ Q = ⊤ :=
  coe_injective.eq_iff' (top_coe _ _ _)
#align affine_subspace.coe_eq_univ_iff AffineSubspace.coe_eq_univ_iff

/- warning: affine_subspace.nonempty_iff_ne_bot -> AffineSubspace.nonempty_iff_ne_bot is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) Q)) (Ne.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q)) (Ne.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.nonempty_iff_ne_bot AffineSubspace.nonempty_iff_ne_botₓ'. -/
theorem nonempty_iff_ne_bot (Q : AffineSubspace k P) : (Q : Set P).Nonempty ↔ Q ≠ ⊥ :=
  by
  rw [nonempty_iff_ne_empty]
  exact not_congr Q.coe_eq_bot_iff
#align affine_subspace.nonempty_iff_ne_bot AffineSubspace.nonempty_iff_ne_bot

/- warning: affine_subspace.eq_bot_or_nonempty -> AffineSubspace.eq_bot_or_nonempty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Or (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) Q))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (Q : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Or (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) Q))
Case conversion may be inaccurate. Consider using '#align affine_subspace.eq_bot_or_nonempty AffineSubspace.eq_bot_or_nonemptyₓ'. -/
theorem eq_bot_or_nonempty (Q : AffineSubspace k P) : Q = ⊥ ∨ (Q : Set P).Nonempty :=
  by
  rw [nonempty_iff_ne_bot]
  apply eq_or_ne
#align affine_subspace.eq_bot_or_nonempty AffineSubspace.eq_bot_or_nonempty

/- warning: affine_subspace.subsingleton_of_subsingleton_span_eq_top -> AffineSubspace.subsingleton_of_subsingleton_span_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Subsingleton.{u3} P s) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Subsingleton.{succ u3} P)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Subsingleton.{u3} P s) -> (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Subsingleton.{succ u3} P)
Case conversion may be inaccurate. Consider using '#align affine_subspace.subsingleton_of_subsingleton_span_eq_top AffineSubspace.subsingleton_of_subsingleton_span_eq_topₓ'. -/
theorem subsingleton_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.Subsingleton)
    (h₂ : affineSpan k s = ⊤) : Subsingleton P :=
  by
  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂
  have : s = {p} := subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])
  rw [this, ← AffineSubspace.ext_iff, AffineSubspace.coe_affineSpan_singleton,
    AffineSubspace.top_coe, eq_comm, ← subsingleton_iff_singleton (mem_univ _)] at h₂
  exact subsingleton_of_univ_subsingleton h₂
#align affine_subspace.subsingleton_of_subsingleton_span_eq_top AffineSubspace.subsingleton_of_subsingleton_span_eq_top

/- warning: affine_subspace.eq_univ_of_subsingleton_span_eq_top -> AffineSubspace.eq_univ_of_subsingleton_span_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Subsingleton.{u3} P s) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Eq.{succ u3} (Set.{u3} P) s (Set.univ.{u3} P))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Subsingleton.{u3} P s) -> (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S)))) -> (Eq.{succ u3} (Set.{u3} P) s (Set.univ.{u3} P))
Case conversion may be inaccurate. Consider using '#align affine_subspace.eq_univ_of_subsingleton_span_eq_top AffineSubspace.eq_univ_of_subsingleton_span_eq_topₓ'. -/
theorem eq_univ_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.Subsingleton)
    (h₂ : affineSpan k s = ⊤) : s = (univ : Set P) :=
  by
  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂
  have : s = {p} := subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])
  rw [this, eq_comm, ← subsingleton_iff_singleton (mem_univ p), subsingleton_univ_iff]
  exact subsingleton_of_subsingleton_span_eq_top h₁ h₂
#align affine_subspace.eq_univ_of_subsingleton_span_eq_top AffineSubspace.eq_univ_of_subsingleton_span_eq_top

/- warning: affine_subspace.direction_eq_top_iff_of_nonempty -> AffineSubspace.direction_eq_top_iff_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s)) -> (Iff (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) s (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s)) -> (Iff (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s) (Top.top.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s (Top.top.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toTop.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_eq_top_iff_of_nonempty AffineSubspace.direction_eq_top_iff_of_nonemptyₓ'. -/
/-- A nonempty affine subspace is `⊤` if and only if its direction is
`⊤`. -/
@[simp]
theorem direction_eq_top_iff_of_nonempty {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :
    s.direction = ⊤ ↔ s = ⊤ := by
  constructor
  · intro hd
    rw [← direction_top k V P] at hd
    refine' ext_of_direction_eq hd _
    simp [h]
  · rintro rfl
    simp
#align affine_subspace.direction_eq_top_iff_of_nonempty AffineSubspace.direction_eq_top_iff_of_nonempty

/- warning: affine_subspace.inf_coe -> AffineSubspace.inf_coe is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Eq.{succ u3} (Set.{u3} P) (Inf.inf.{u3} (Set.{u3} P) (SemilatticeInf.toHasInf.{u3} (Set.{u3} P) (Lattice.toSemilatticeInf.{u3} (Set.{u3} P) (ConditionallyCompleteLattice.toLattice.{u3} (Set.{u3} P) (CompleteLattice.toConditionallyCompleteLattice.{u3} (Set.{u3} P) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} P) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} P) (Set.completeBooleanAlgebra.{u3} P)))))))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) (Inter.inter.{u3} (Set.{u3} P) (Set.hasInter.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Eq.{succ u1} (Set.{u1} P) (Inf.inf.{u1} (Set.{u1} P) (Lattice.toInf.{u1} (Set.{u1} P) (ConditionallyCompleteLattice.toLattice.{u1} (Set.{u1} P) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Set.{u1} P) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} P) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} P) (Set.instCompleteBooleanAlgebraSet.{u1} P))))))) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) (Inter.inter.{u1} (Set.{u1} P) (Set.instInterSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.inf_coe AffineSubspace.inf_coeₓ'. -/
/-- The inf of two affine subspaces, coerced to a set, is the
intersection of the two sets of points. -/
@[simp]
theorem inf_coe (s1 s2 : AffineSubspace k P) : (s1 ⊓ s2 : Set P) = s1 ∩ s2 :=
  rfl
#align affine_subspace.inf_coe AffineSubspace.inf_coe

/- warning: affine_subspace.mem_inf_iff -> AffineSubspace.mem_inf_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2)) (And (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s1) (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p (Inf.inf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toInf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2)) (And (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s1) (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_inf_iff AffineSubspace.mem_inf_iffₓ'. -/
/-- A point is in the inf of two affine subspaces if and only if it is
in both of them. -/
theorem mem_inf_iff (p : P) (s1 s2 : AffineSubspace k P) : p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2 :=
  Iff.rfl
#align affine_subspace.mem_inf_iff AffineSubspace.mem_inf_iff

/- warning: affine_subspace.direction_inf -> AffineSubspace.direction_inf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2)) (Inf.inf.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), LE.le.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toInf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2)) (Inf.inf.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instInfSubmodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_inf AffineSubspace.direction_infₓ'. -/
/-- The direction of the inf of two affine subspaces is less than or
equal to the inf of their directions. -/
theorem direction_inf (s1 s2 : AffineSubspace k P) :
    (s1 ⊓ s2).direction ≤ s1.direction ⊓ s2.direction :=
  by
  repeat' rw [direction_eq_vector_span, vectorSpan_def]
  exact
    le_inf (sInf_le_sInf fun p hp => trans (vsub_self_mono (inter_subset_left _ _)) hp)
      (sInf_le_sInf fun p hp => trans (vsub_self_mono (inter_subset_right _ _)) hp)
#align affine_subspace.direction_inf AffineSubspace.direction_inf

/- warning: affine_subspace.direction_inf_of_mem -> AffineSubspace.direction_inf_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s₁) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p s₂) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s₁ s₂)) (Inf.inf.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s₁) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p s₂) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toInf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) s₁ s₂)) (Inf.inf.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instInfSubmodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₂)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_inf_of_mem AffineSubspace.direction_inf_of_memₓ'. -/
/-- If two affine subspaces have a point in common, the direction of
their inf equals the inf of their directions. -/
theorem direction_inf_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :
    (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction :=
  by
  ext v
  rw [Submodule.mem_inf, ← vadd_mem_iff_mem_direction v h₁, ← vadd_mem_iff_mem_direction v h₂, ←
    vadd_mem_iff_mem_direction v ((mem_inf_iff p s₁ s₂).2 ⟨h₁, h₂⟩), mem_inf_iff]
#align affine_subspace.direction_inf_of_mem AffineSubspace.direction_inf_of_mem

/- warning: affine_subspace.direction_inf_of_mem_inf -> AffineSubspace.direction_inf_of_mem_inf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {p : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)) p (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s₁ s₂)) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s₁ s₂)) (Inf.inf.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {p : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)) p (Inf.inf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toInf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) s₁ s₂)) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (Inf.inf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toInf.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S)))) s₁ s₂)) (Inf.inf.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instInfSubmodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s₂)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_inf_of_mem_inf AffineSubspace.direction_inf_of_mem_infₓ'. -/
/-- If two affine subspaces have a point in their inf, the direction
of their inf equals the inf of their directions. -/
theorem direction_inf_of_mem_inf {s₁ s₂ : AffineSubspace k P} {p : P} (h : p ∈ s₁ ⊓ s₂) :
    (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction :=
  direction_inf_of_mem ((mem_inf_iff p s₁ s₂).1 h).1 ((mem_inf_iff p s₁ s₂).1 h).2
#align affine_subspace.direction_inf_of_mem_inf AffineSubspace.direction_inf_of_mem_inf

/- warning: affine_subspace.direction_le -> AffineSubspace.direction_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) -> (LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) -> (LE.le.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_le AffineSubspace.direction_leₓ'. -/
/-- If one affine subspace is less than or equal to another, the same
applies to their directions. -/
theorem direction_le {s1 s2 : AffineSubspace k P} (h : s1 ≤ s2) : s1.direction ≤ s2.direction :=
  by
  repeat' rw [direction_eq_vector_span, vectorSpan_def]
  exact vectorSpan_mono k h
#align affine_subspace.direction_le AffineSubspace.direction_le

/- warning: affine_subspace.direction_lt_of_nonempty -> AffineSubspace.direction_lt_of_nonempty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (LT.lt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toHasLt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1 s2) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1)) -> (LT.lt.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLt.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (LT.lt.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Preorder.toLT.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2) -> (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1)) -> (LT.lt.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_lt_of_nonempty AffineSubspace.direction_lt_of_nonemptyₓ'. -/
/-- If one nonempty affine subspace is less than another, the same
applies to their directions -/
theorem direction_lt_of_nonempty {s1 s2 : AffineSubspace k P} (h : s1 < s2)
    (hn : (s1 : Set P).Nonempty) : s1.direction < s2.direction :=
  by
  cases' hn with p hp
  rw [lt_iff_le_and_exists] at h
  rcases h with ⟨hle, p2, hp2, hp2s1⟩
  rw [SetLike.lt_iff_le_and_exists]
  use direction_le hle, p2 -ᵥ p, vsub_mem_direction hp2 (hle hp)
  intro hm
  rw [vsub_right_mem_direction_iff_mem hp p2] at hm
  exact hp2s1 hm
#align affine_subspace.direction_lt_of_nonempty AffineSubspace.direction_lt_of_nonempty

/- warning: affine_subspace.sup_direction_le -> AffineSubspace.sup_direction_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), LE.le.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Sup.sup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), LE.le.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2)) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (Sup.sup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2))
Case conversion may be inaccurate. Consider using '#align affine_subspace.sup_direction_le AffineSubspace.sup_direction_leₓ'. -/
/-- The sup of the directions of two affine subspaces is less than or
equal to the direction of their sup. -/
theorem sup_direction_le (s1 s2 : AffineSubspace k P) :
    s1.direction ⊔ s2.direction ≤ (s1 ⊔ s2).direction :=
  by
  repeat' rw [direction_eq_vector_span, vectorSpan_def]
  exact
    sup_le
      (sInf_le_sInf fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_left : s1 ≤ s1 ⊔ s2)) hp)
      (sInf_le_sInf fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_right : s2 ≤ s1 ⊔ s2)) hp)
#align affine_subspace.sup_direction_le AffineSubspace.sup_direction_le

/- warning: affine_subspace.sup_direction_lt_of_nonempty_of_inter_empty -> AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1)) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) -> (Eq.{succ u3} (Set.{u3} P) (Inter.inter.{u3} (Set.{u3} P) (Set.hasInter.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))) -> (LT.lt.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLt.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (Sup.sup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1)) -> (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) -> (Eq.{succ u1} (Set.{u1} P) (Inter.inter.{u1} (Set.{u1} P) (Set.instInterSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) (EmptyCollection.emptyCollection.{u1} (Set.{u1} P) (Set.instEmptyCollectionSet.{u1} P))) -> (LT.lt.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2)) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (Sup.sup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (SemilatticeSup.toSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (Lattice.toSemilatticeSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S))))) s1 s2)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.sup_direction_lt_of_nonempty_of_inter_empty AffineSubspace.sup_direction_lt_of_nonempty_of_inter_emptyₓ'. -/
/-- The sup of the directions of two nonempty affine subspaces with
empty intersection is less than the direction of their sup. -/
theorem sup_direction_lt_of_nonempty_of_inter_empty {s1 s2 : AffineSubspace k P}
    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty) (he : (s1 ∩ s2 : Set P) = ∅) :
    s1.direction ⊔ s2.direction < (s1 ⊔ s2).direction :=
  by
  cases' h1 with p1 hp1
  cases' h2 with p2 hp2
  rw [SetLike.lt_iff_le_and_exists]
  use sup_direction_le s1 s2, p2 -ᵥ p1,
    vsub_mem_direction ((le_sup_right : s2 ≤ s1 ⊔ s2) hp2) ((le_sup_left : s1 ≤ s1 ⊔ s2) hp1)
  intro h
  rw [Submodule.mem_sup] at h
  rcases h with ⟨v1, hv1, v2, hv2, hv1v2⟩
  rw [← sub_eq_zero, sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm v1, add_assoc, ←
    vadd_vsub_assoc, ← neg_neg v2, add_comm, ← sub_eq_add_neg, ← vsub_vadd_eq_vsub_sub,
    vsub_eq_zero_iff_eq] at hv1v2
  refine' Set.Nonempty.ne_empty _ he
  use v1 +ᵥ p1, vadd_mem_of_mem_direction hv1 hp1
  rw [hv1v2]
  exact vadd_mem_of_mem_direction (Submodule.neg_mem _ hv2) hp2
#align affine_subspace.sup_direction_lt_of_nonempty_of_inter_empty AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty

/- warning: affine_subspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top -> AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1)) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2)) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) -> (Set.Nonempty.{u3} P (Inter.inter.{u3} (Set.{u3} P) (Set.hasInter.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1)) -> (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2)) (Top.top.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) -> (Set.Nonempty.{u1} P (Inter.inter.{u1} (Set.{u1} P) (Set.instInterSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_topₓ'. -/
/-- If the directions of two nonempty affine subspaces span the whole
module, they have nonempty intersection. -/
theorem inter_nonempty_of_nonempty_of_sup_direction_eq_top {s1 s2 : AffineSubspace k P}
    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)
    (hd : s1.direction ⊔ s2.direction = ⊤) : ((s1 : Set P) ∩ s2).Nonempty :=
  by
  by_contra h
  rw [Set.not_nonempty_iff_eq_empty] at h
  have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h
  rw [hd] at hlt
  exact not_top_lt hlt
#align affine_subspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top

/- warning: affine_subspace.inter_eq_singleton_of_nonempty_of_is_compl -> AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1)) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) -> (IsCompl.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (CompleteLattice.toBoundedOrder.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S s2)) -> (Exists.{succ u3} P (fun (p : P) => Eq.{succ u3} (Set.{u3} P) (Inter.inter.{u3} (Set.{u3} P) (Set.hasInter.{u3} P) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s1) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s2)) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S}, (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1)) -> (Set.Nonempty.{u1} P (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) -> (IsCompl.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (CompleteLattice.toBoundedOrder.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S s2)) -> (Exists.{succ u1} P (fun (p : P) => Eq.{succ u1} (Set.{u1} P) (Inter.inter.{u1} (Set.{u1} P) (Set.instInterSet.{u1} P) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s1) (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s2)) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.inter_eq_singleton_of_nonempty_of_is_compl AffineSubspace.inter_eq_singleton_of_nonempty_of_isComplₓ'. -/
/-- If the directions of two nonempty affine subspaces are complements
of each other, they intersect in exactly one point. -/
theorem inter_eq_singleton_of_nonempty_of_isCompl {s1 s2 : AffineSubspace k P}
    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)
    (hd : IsCompl s1.direction s2.direction) : ∃ p, (s1 : Set P) ∩ s2 = {p} :=
  by
  cases' inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp
  use p
  ext q
  rw [Set.mem_singleton_iff]
  constructor
  · rintro ⟨hq1, hq2⟩
    have hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction :=
      ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩
    rwa [hd.inf_eq_bot, Submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp
  · exact fun h => h.symm ▸ hp
#align affine_subspace.inter_eq_singleton_of_nonempty_of_is_compl AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl

/- warning: affine_subspace.affine_span_coe -> AffineSubspace.affineSpan_coe is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S)))) s)) s
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S), Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 S) s)) s
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_coe AffineSubspace.affineSpan_coeₓ'. -/
/-- Coercing a subspace to a set then taking the affine span produces
the original subspace. -/
@[simp]
theorem affineSpan_coe (s : AffineSubspace k P) : affineSpan k (s : Set P) = s :=
  by
  refine' le_antisymm _ (subset_spanPoints _ _)
  rintro p ⟨p1, hp1, v, hv, rfl⟩
  exact vadd_mem_of_mem_direction hv hp1
#align affine_subspace.affine_span_coe AffineSubspace.affineSpan_coe

end AffineSubspace

section AffineSpace'

variable (k : Type _) {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]
  [affine_space V P]

variable {ι : Type _}

include V

open AffineSubspace Set

#print vectorSpan_eq_span_vsub_set_left /-
/-- The `vector_span` is the span of the pairwise subtractions with a
given point on the left. -/
theorem vectorSpan_eq_span_vsub_set_left {s : Set P} {p : P} (hp : p ∈ s) :
    vectorSpan k s = Submodule.span k ((· -ᵥ ·) p '' s) :=
  by
  rw [vectorSpan_def]
  refine' le_antisymm _ (Submodule.span_mono _)
  · rw [Submodule.span_le]
    rintro v ⟨p1, p2, hp1, hp2, hv⟩
    rw [← vsub_sub_vsub_cancel_left p1 p2 p] at hv
    rw [← hv, SetLike.mem_coe, Submodule.mem_span]
    exact fun m hm => Submodule.sub_mem _ (hm ⟨p2, hp2, rfl⟩) (hm ⟨p1, hp1, rfl⟩)
  · rintro v ⟨p2, hp2, hv⟩
    exact ⟨p, p2, hp, hp2, hv⟩
#align vector_span_eq_span_vsub_set_left vectorSpan_eq_span_vsub_set_left
-/

#print vectorSpan_eq_span_vsub_set_right /-
/-- The `vector_span` is the span of the pairwise subtractions with a
given point on the right. -/
theorem vectorSpan_eq_span_vsub_set_right {s : Set P} {p : P} (hp : p ∈ s) :
    vectorSpan k s = Submodule.span k ((· -ᵥ p) '' s) :=
  by
  rw [vectorSpan_def]
  refine' le_antisymm _ (Submodule.span_mono _)
  · rw [Submodule.span_le]
    rintro v ⟨p1, p2, hp1, hp2, hv⟩
    rw [← vsub_sub_vsub_cancel_right p1 p2 p] at hv
    rw [← hv, SetLike.mem_coe, Submodule.mem_span]
    exact fun m hm => Submodule.sub_mem _ (hm ⟨p1, hp1, rfl⟩) (hm ⟨p2, hp2, rfl⟩)
  · rintro v ⟨p2, hp2, hv⟩
    exact ⟨p2, p, hp2, hp, hv⟩
#align vector_span_eq_span_vsub_set_right vectorSpan_eq_span_vsub_set_right
-/

/- warning: vector_span_eq_span_vsub_set_left_ne -> vectorSpan_eq_span_vsub_set_left_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)))))
but is expected to have type
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V ((fun (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11110 : P) (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11112 : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toVSub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11110 x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11112) p) (SDiff.sdiff.{u3} (Set.{u3} P) (Set.instSDiffSet.{u3} P) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p)))))
Case conversion may be inaccurate. Consider using '#align vector_span_eq_span_vsub_set_left_ne vectorSpan_eq_span_vsub_set_left_neₓ'. -/
/-- The `vector_span` is the span of the pairwise subtractions with a
given point on the left, excluding the subtraction of that point from
itself. -/
theorem vectorSpan_eq_span_vsub_set_left_ne {s : Set P} {p : P} (hp : p ∈ s) :
    vectorSpan k s = Submodule.span k ((· -ᵥ ·) p '' (s \ {p})) :=
  by
  conv_lhs =>
    rw [vectorSpan_eq_span_vsub_set_left k hp, ← Set.insert_eq_of_mem hp, ←
      Set.insert_diff_singleton, Set.image_insert_eq]
  simp [Submodule.span_insert_eq_span]
#align vector_span_eq_span_vsub_set_left_ne vectorSpan_eq_span_vsub_set_left_ne

/- warning: vector_span_eq_span_vsub_set_right_ne -> vectorSpan_eq_span_vsub_set_right_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V (fun (_x : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x p) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p)))))
but is expected to have type
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V (fun (_x : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toVSub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x p) (SDiff.sdiff.{u3} (Set.{u3} P) (Set.instSDiffSet.{u3} P) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p)))))
Case conversion may be inaccurate. Consider using '#align vector_span_eq_span_vsub_set_right_ne vectorSpan_eq_span_vsub_set_right_neₓ'. -/
/-- The `vector_span` is the span of the pairwise subtractions with a
given point on the right, excluding the subtraction of that point from
itself. -/
theorem vectorSpan_eq_span_vsub_set_right_ne {s : Set P} {p : P} (hp : p ∈ s) :
    vectorSpan k s = Submodule.span k ((· -ᵥ p) '' (s \ {p})) :=
  by
  conv_lhs =>
    rw [vectorSpan_eq_span_vsub_set_right k hp, ← Set.insert_eq_of_mem hp, ←
      Set.insert_diff_singleton, Set.image_insert_eq]
  simp [Submodule.span_insert_eq_span]
#align vector_span_eq_span_vsub_set_right_ne vectorSpan_eq_span_vsub_set_right_ne

#print vectorSpan_eq_span_vsub_finset_right_ne /-
/-- The `vector_span` is the span of the pairwise subtractions with a
given point on the right, excluding the subtraction of that point from
itself. -/
theorem vectorSpan_eq_span_vsub_finset_right_ne [DecidableEq P] [DecidableEq V] {s : Finset P}
    {p : P} (hp : p ∈ s) :
    vectorSpan k (s : Set P) = Submodule.span k ((s.eraseₓ p).image (· -ᵥ p)) := by
  simp [vectorSpan_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
#align vector_span_eq_span_vsub_finset_right_ne vectorSpan_eq_span_vsub_finset_right_ne
-/

/- warning: vector_span_image_eq_span_vsub_set_left_ne -> vectorSpan_image_eq_span_vsub_set_left_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) {s : Set.{u4} ι} {i : ι}, (Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) i s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p i)) (Set.image.{u4, u3} ι P p (SDiff.sdiff.{u4} (Set.{u4} ι) (BooleanAlgebra.toHasSdiff.{u4} (Set.{u4} ι) (Set.booleanAlgebra.{u4} ι)) s (Singleton.singleton.{u4, u4} ι (Set.{u4} ι) (Set.hasSingleton.{u4} ι) i))))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) {s : Set.{u4} ι} {i : ι}, (Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) i s) -> (Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u1} ι P p s)) (Submodule.span.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.image.{u1, u3} P V ((fun (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11418 : P) (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11420 : P) => VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11418 x._@.Mathlib.LinearAlgebra.AffineSpace.AffineSubspace._hyg.11420) (p i)) (Set.image.{u4, u1} ι P p (SDiff.sdiff.{u4} (Set.{u4} ι) (Set.instSDiffSet.{u4} ι) s (Singleton.singleton.{u4, u4} ι (Set.{u4} ι) (Set.instSingletonSet.{u4} ι) i))))))
Case conversion may be inaccurate. Consider using '#align vector_span_image_eq_span_vsub_set_left_ne vectorSpan_image_eq_span_vsub_set_left_neₓ'. -/
/-- The `vector_span` of the image of a function is the span of the
pairwise subtractions with a given point on the left, excluding the
subtraction of that point from itself. -/
theorem vectorSpan_image_eq_span_vsub_set_left_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :
    vectorSpan k (p '' s) = Submodule.span k ((· -ᵥ ·) (p i) '' (p '' (s \ {i}))) :=
  by
  conv_lhs =>
    rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi, ←
      Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]
  simp [Submodule.span_insert_eq_span]
#align vector_span_image_eq_span_vsub_set_left_ne vectorSpan_image_eq_span_vsub_set_left_ne

/- warning: vector_span_image_eq_span_vsub_set_right_ne -> vectorSpan_image_eq_span_vsub_set_right_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) {s : Set.{u4} ι} {i : ι}, (Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) i s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.image.{u3, u2} P V (fun (_x : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) _x (p i)) (Set.image.{u4, u3} ι P p (SDiff.sdiff.{u4} (Set.{u4} ι) (BooleanAlgebra.toHasSdiff.{u4} (Set.{u4} ι) (Set.booleanAlgebra.{u4} ι)) s (Singleton.singleton.{u4, u4} ι (Set.{u4} ι) (Set.hasSingleton.{u4} ι) i))))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) {s : Set.{u4} ι} {i : ι}, (Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) i s) -> (Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u1} ι P p s)) (Submodule.span.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.image.{u1, u3} P V (fun (_x : P) => VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) _x (p i)) (Set.image.{u4, u1} ι P p (SDiff.sdiff.{u4} (Set.{u4} ι) (Set.instSDiffSet.{u4} ι) s (Singleton.singleton.{u4, u4} ι (Set.{u4} ι) (Set.instSingletonSet.{u4} ι) i))))))
Case conversion may be inaccurate. Consider using '#align vector_span_image_eq_span_vsub_set_right_ne vectorSpan_image_eq_span_vsub_set_right_neₓ'. -/
/-- The `vector_span` of the image of a function is the span of the
pairwise subtractions with a given point on the right, excluding the
subtraction of that point from itself. -/
theorem vectorSpan_image_eq_span_vsub_set_right_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :
    vectorSpan k (p '' s) = Submodule.span k ((· -ᵥ p i) '' (p '' (s \ {i}))) :=
  by
  conv_lhs =>
    rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi,
      ← Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]
  simp [Submodule.span_insert_eq_span]
#align vector_span_image_eq_span_vsub_set_right_ne vectorSpan_image_eq_span_vsub_set_right_ne

/- warning: vector_span_range_eq_span_range_vsub_left -> vectorSpan_range_eq_span_range_vsub_left is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i0 : ι), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u4} V ι (fun (i : ι) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p i0) (p i))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u4}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i0 : ι), Eq.{succ u4} (Submodule.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3) (vectorSpan.{u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} P ι p)) (Submodule.span.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3 (Set.range.{u4, succ u1} V ι (fun (i : ι) => VSub.vsub.{u4, u2} V P (AddTorsor.toVSub.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) _inst_4) (p i0) (p i))))
Case conversion may be inaccurate. Consider using '#align vector_span_range_eq_span_range_vsub_left vectorSpan_range_eq_span_range_vsub_leftₓ'. -/
/-- The `vector_span` of an indexed family is the span of the pairwise
subtractions with a given point on the left. -/
theorem vectorSpan_range_eq_span_range_vsub_left (p : ι → P) (i0 : ι) :
    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => p i0 -ᵥ p i) := by
  rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_range_self i0), ← Set.range_comp]
#align vector_span_range_eq_span_range_vsub_left vectorSpan_range_eq_span_range_vsub_left

/- warning: vector_span_range_eq_span_range_vsub_right -> vectorSpan_range_eq_span_range_vsub_right is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i0 : ι), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u4} V ι (fun (i : ι) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p i) (p i0))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u4}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i0 : ι), Eq.{succ u4} (Submodule.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3) (vectorSpan.{u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} P ι p)) (Submodule.span.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3 (Set.range.{u4, succ u1} V ι (fun (i : ι) => VSub.vsub.{u4, u2} V P (AddTorsor.toVSub.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) _inst_4) (p i) (p i0))))
Case conversion may be inaccurate. Consider using '#align vector_span_range_eq_span_range_vsub_right vectorSpan_range_eq_span_range_vsub_rightₓ'. -/
/-- The `vector_span` of an indexed family is the span of the pairwise
subtractions with a given point on the right. -/
theorem vectorSpan_range_eq_span_range_vsub_right (p : ι → P) (i0 : ι) :
    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => p i -ᵥ p i0) := by
  rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_range_self i0), ← Set.range_comp]
#align vector_span_range_eq_span_range_vsub_right vectorSpan_range_eq_span_range_vsub_right

/- warning: vector_span_range_eq_span_range_vsub_left_ne -> vectorSpan_range_eq_span_range_vsub_left_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i₀ : ι), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u4} V (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) (fun (i : Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p i₀) (p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀))))) i)))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u4}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i₀ : ι), Eq.{succ u4} (Submodule.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3) (vectorSpan.{u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} P ι p)) (Submodule.span.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3 (Set.range.{u4, succ u1} V (Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀)) (fun (i : Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀)) => VSub.vsub.{u4, u2} V P (AddTorsor.toVSub.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) _inst_4) (p i₀) (p (Subtype.val.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀) i)))))
Case conversion may be inaccurate. Consider using '#align vector_span_range_eq_span_range_vsub_left_ne vectorSpan_range_eq_span_range_vsub_left_neₓ'. -/
/-- The `vector_span` of an indexed family is the span of the pairwise
subtractions with a given point on the left, excluding the subtraction
of that point from itself. -/
theorem vectorSpan_range_eq_span_range_vsub_left_ne (p : ι → P) (i₀ : ι) :
    vectorSpan k (Set.range p) =
      Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => p i₀ -ᵥ p i) :=
  by
  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_left_ne k _ (Set.mem_univ i₀)]
  congr with v
  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists,
    Subtype.coe_mk]
  constructor
  · rintro ⟨x, ⟨i₁, ⟨⟨hi₁u, hi₁⟩, rfl⟩⟩, hv⟩
    exact ⟨i₁, hi₁, hv⟩
  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩
#align vector_span_range_eq_span_range_vsub_left_ne vectorSpan_range_eq_span_range_vsub_left_ne

/- warning: vector_span_range_eq_span_range_vsub_right_ne -> vectorSpan_range_eq_span_range_vsub_right_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i₀ : ι), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u4} V (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) (fun (i : Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀)) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i₀))))) i)) (p i₀))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u4}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i₀ : ι), Eq.{succ u4} (Submodule.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3) (vectorSpan.{u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u1} P ι p)) (Submodule.span.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3 (Set.range.{u4, succ u1} V (Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀)) (fun (i : Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀)) => VSub.vsub.{u4, u2} V P (AddTorsor.toVSub.{u4, u2} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) _inst_4) (p (Subtype.val.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i₀) i)) (p i₀))))
Case conversion may be inaccurate. Consider using '#align vector_span_range_eq_span_range_vsub_right_ne vectorSpan_range_eq_span_range_vsub_right_neₓ'. -/
/-- The `vector_span` of an indexed family is the span of the pairwise
subtractions with a given point on the right, excluding the subtraction
of that point from itself. -/
theorem vectorSpan_range_eq_span_range_vsub_right_ne (p : ι → P) (i₀ : ι) :
    vectorSpan k (Set.range p) =
      Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => p i -ᵥ p i₀) :=
  by
  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_right_ne k _ (Set.mem_univ i₀)]
  congr with v
  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists,
    Subtype.coe_mk]
  constructor
  · rintro ⟨x, ⟨i₁, ⟨⟨hi₁u, hi₁⟩, rfl⟩⟩, hv⟩
    exact ⟨i₁, hi₁, hv⟩
  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩
#align vector_span_range_eq_span_range_vsub_right_ne vectorSpan_range_eq_span_range_vsub_right_ne

section

variable {s : Set P}

/- warning: affine_span_nonempty -> affineSpan_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, Iff (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Set.Nonempty.{u3} P s)
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, Iff (Set.Nonempty.{u3} P (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))) (Set.Nonempty.{u3} P s)
Case conversion may be inaccurate. Consider using '#align affine_span_nonempty affineSpan_nonemptyₓ'. -/
/-- The affine span of a set is nonempty if and only if that set is. -/
theorem affineSpan_nonempty : (affineSpan k s : Set P).Nonempty ↔ s.Nonempty :=
  spanPoints_nonempty k s
#align affine_span_nonempty affineSpan_nonempty

/- warning: set.nonempty.affine_span -> Set.Nonempty.affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (Set.Nonempty.{u3} P s) -> (Set.Nonempty.{u3} P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (Set.Nonempty.{u3} P s) -> (Set.Nonempty.{u3} P (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align set.nonempty.affine_span Set.Nonempty.affineSpanₓ'. -/
alias affineSpan_nonempty ↔ _ _root_.set.nonempty.affine_span
#align set.nonempty.affine_span Set.Nonempty.affineSpan

/-- The affine span of a nonempty set is nonempty. -/
instance [Nonempty s] : Nonempty (affineSpan k s) :=
  ((nonempty_coe_sort.1 ‹_›).affineSpan _).to_subtype

/- warning: affine_span_eq_bot -> affineSpan_eq_bot is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u3} (Set.{u3} P) s (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, Iff (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u3} (Set.{u3} P) s (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.instEmptyCollectionSet.{u3} P)))
Case conversion may be inaccurate. Consider using '#align affine_span_eq_bot affineSpan_eq_botₓ'. -/
/-- The affine span of a set is `⊥` if and only if that set is empty. -/
@[simp]
theorem affineSpan_eq_bot : affineSpan k s = ⊥ ↔ s = ∅ := by
  rw [← not_iff_not, ← Ne.def, ← Ne.def, ← nonempty_iff_ne_bot, affineSpan_nonempty,
    nonempty_iff_ne_empty]
#align affine_span_eq_bot affineSpan_eq_bot

/- warning: bot_lt_affine_span -> bot_lt_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, Iff (LT.lt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLt.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.Nonempty.{u3} P s)
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, Iff (LT.lt.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLT.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) (Bot.bot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (Set.Nonempty.{u3} P s)
Case conversion may be inaccurate. Consider using '#align bot_lt_affine_span bot_lt_affineSpanₓ'. -/
@[simp]
theorem bot_lt_affineSpan : ⊥ < affineSpan k s ↔ s.Nonempty :=
  by
  rw [bot_lt_iff_ne_bot, nonempty_iff_ne_empty]
  exact (affineSpan_eq_bot _).Not
#align bot_lt_affine_span bot_lt_affineSpan

end

variable {k}

/- warning: affine_span_induction -> affineSpan_induction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {x : P} {s : Set.{u3} P} {p : P -> Prop}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall (x : P), (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s) -> (p x)) -> (forall (c : k) (u : P) (v : P) (w : P), (p u) -> (p v) -> (p w) -> (p (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) u v)) w))) -> (p x)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {x : P} {s : Set.{u3} P} {p : P -> Prop}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> (forall (x : P), (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x s) -> (p x)) -> (forall (c : k) (u : P) (v : P) (w : P), (p u) -> (p v) -> (p w) -> (p (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) c (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) u v)) w))) -> (p x)
Case conversion may be inaccurate. Consider using '#align affine_span_induction affineSpan_inductionₓ'. -/
/-- An induction principle for span membership. If `p` holds for all elements of `s` and is
preserved under certain affine combinations, then `p` holds for all elements of the span of `s`.
-/
theorem affineSpan_induction {x : P} {s : Set P} {p : P → Prop} (h : x ∈ affineSpan k s)
    (Hs : ∀ x : P, x ∈ s → p x)
    (Hc : ∀ (c : k) (u v w : P), p u → p v → p w → p (c • (u -ᵥ v) +ᵥ w)) : p x :=
  (@affineSpan_le _ _ _ _ _ _ _ _ ⟨p, Hc⟩).mpr Hs h
#align affine_span_induction affineSpan_induction

/- warning: affine_span_induction' -> affineSpan_induction' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p : forall (x : P), (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> Prop}, (forall (y : P) (hys : Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) y s), p y (subset_affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s y hys)) -> (forall (c : k) (u : P) (hu : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) u (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (v : P) (hv : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) v (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (w : P) (hw : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) w (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)), (p u hu) -> (p v hv) -> (p w hw) -> (p (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) u v)) w) (AffineSubspace.smul_vsub_vadd_mem.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) c u v w hu hv hw))) -> (forall {x : P} (h : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)), p x h)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p : forall (x : P), (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) -> Prop}, (forall (y : P) (hys : Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) y s), p y (subset_affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s y hys)) -> (forall (c : k) (u : P) (hu : Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) u (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (v : P) (hv : Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) v (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)) (w : P) (hw : Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) w (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)), (p u hu) -> (p v hv) -> (p w hw) -> (p (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) c (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) u v)) w) (AffineSubspace.smul_vsub_vadd_mem.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s) c u v w hu hv hw))) -> (forall {x : P} (h : Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)), p x h)
Case conversion may be inaccurate. Consider using '#align affine_span_induction' affineSpan_induction'ₓ'. -/
/-- A dependent version of `affine_span_induction`. -/
theorem affineSpan_induction' {s : Set P} {p : ∀ x, x ∈ affineSpan k s → Prop}
    (Hs : ∀ (y) (hys : y ∈ s), p y (subset_affineSpan k _ hys))
    (Hc :
      ∀ (c : k) (u hu v hv w hw),
        p u hu →
          p v hv → p w hw → p (c • (u -ᵥ v) +ᵥ w) (AffineSubspace.smul_vsub_vadd_mem _ _ hu hv hw))
    {x : P} (h : x ∈ affineSpan k s) : p x h :=
  by
  refine' Exists.elim _ fun (hx : x ∈ affineSpan k s) (hc : p x hx) => hc
  refine' @affineSpan_induction k V P _ _ _ _ _ _ _ h _ _
  · exact fun y hy => ⟨subset_affineSpan _ _ hy, Hs y hy⟩
  ·
    exact fun c u v w hu hv hw =>
      Exists.elim hu fun hu' hu =>
        Exists.elim hv fun hv' hv =>
          Exists.elim hw fun hw' hw =>
            ⟨AffineSubspace.smul_vsub_vadd_mem _ _ hu' hv' hw', Hc _ _ _ _ _ _ _ hu hv hw⟩
#align affine_span_induction' affineSpan_induction'

section WithLocalInstance

attribute [local instance] AffineSubspace.toAddTorsor

/- warning: affine_span_coe_preimage_eq_top -> affineSpan_coe_preimage_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (A : Set.{u3} P) [_inst_5 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) A)], Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (affineSpan.nonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (affineSpan.{u1, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (affineSpan.nonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5)) (Set.preimage.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) P ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) x (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))))))) A)) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (affineSpan.nonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (affineSpan.nonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (AffineSubspace.completeLattice.{u1, u2, u3} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (affineSpan.nonempty.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (A : Set.{u3} P) [_inst_5 : Nonempty.{succ u3} (Set.Elem.{u3} P A)], Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (affineSpan.{u2, u1, u3} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5)) (Set.preimage.{u3, u3} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) P (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) A)) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5))) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k (Subtype.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3)) x (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A)))) _inst_1 (Submodule.addCommGroup.{u2, u1} k V _inst_1 _inst_2 _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (Submodule.module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3 (AffineSubspace.direction.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A))) (AffineSubspace.toAddTorsor.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A) (instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 A _inst_5)))))
Case conversion may be inaccurate. Consider using '#align affine_span_coe_preimage_eq_top affineSpan_coe_preimage_eq_topₓ'. -/
/-- A set, considered as a subset of its spanned affine subspace, spans the whole subspace. -/
@[simp]
theorem affineSpan_coe_preimage_eq_top (A : Set P) [Nonempty A] :
    affineSpan k ((coe : affineSpan k A → P) ⁻¹' A) = ⊤ :=
  by
  rw [eq_top_iff]
  rintro ⟨x, hx⟩ -
  refine' affineSpan_induction' (fun y hy => _) (fun c u hu v hv w hw => _) hx
  · exact subset_affineSpan _ _ hy
  · exact AffineSubspace.smul_vsub_vadd_mem _ _
#align affine_span_coe_preimage_eq_top affineSpan_coe_preimage_eq_top

end WithLocalInstance

/- warning: affine_span_singleton_union_vadd_eq_top_of_span_eq_top -> affineSpan_singleton_union_vadd_eq_top_of_span_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u2} V} (p : P), (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u2} V (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) x s)))))))) (Top.top.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p) s))) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {s : Set.{u3} V} (p : P), (Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.span.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u3} V (Subtype.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) x s)) (Subtype.val.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) x s)))) (Top.top.{u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))) -> (Eq.{succ u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Union.union.{u1} (Set.{u1} P) (Set.instUnionSet.{u1} P) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p) (Set.image.{u3, u1} V P (fun (v : V) => HVAdd.hVAdd.{u3, u1, u1} V P P (instHVAdd.{u3, u1} V P (AddAction.toVAdd.{u3, u1} V P (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2))) (AddTorsor.toAddAction.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4))) v p) s))) (Top.top.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u1} (AffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align affine_span_singleton_union_vadd_eq_top_of_span_eq_top affineSpan_singleton_union_vadd_eq_top_of_span_eq_topₓ'. -/
/-- Suppose a set of vectors spans `V`.  Then a point `p`, together
with those vectors added to `p`, spans `P`. -/
theorem affineSpan_singleton_union_vadd_eq_top_of_span_eq_top {s : Set V} (p : P)
    (h : Submodule.span k (Set.range (coe : s → V)) = ⊤) :
    affineSpan k ({p} ∪ (fun v => v +ᵥ p) '' s) = ⊤ :=
  by
  convert ext_of_direction_eq _
      ⟨p, mem_affineSpan k (Set.mem_union_left _ (Set.mem_singleton _)), mem_top k V p⟩
  rw [direction_affineSpan, direction_top,
    vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ (Set.mem_singleton _) : p ∈ _),
    eq_top_iff, ← h]
  apply Submodule.span_mono
  rintro v ⟨v', rfl⟩
  use (v' : V) +ᵥ p
  simp
#align affine_span_singleton_union_vadd_eq_top_of_span_eq_top affineSpan_singleton_union_vadd_eq_top_of_span_eq_top

variable (k)

/- warning: vector_span_pair -> vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (p₁ : P) (p₂ : P), Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))) (Submodule.span.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Singleton.singleton.{u3, u3} V (Set.{u3} V) (Set.instSingletonSet.{u3} V) (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₁ p₂)))
Case conversion may be inaccurate. Consider using '#align vector_span_pair vectorSpan_pairₓ'. -/
/-- The `vector_span` of two points is the span of their difference. -/
theorem vectorSpan_pair (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = k ∙ p₁ -ᵥ p₂ := by
  rw [vectorSpan_eq_span_vsub_set_left k (mem_insert p₁ _), image_pair, vsub_self,
    Submodule.span_insert_zero]
#align vector_span_pair vectorSpan_pair

/- warning: vector_span_pair_rev -> vectorSpan_pair_rev is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (p₁ : P) (p₂ : P), Eq.{succ u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))) (Submodule.span.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Singleton.singleton.{u3, u3} V (Set.{u3} V) (Set.instSingletonSet.{u3} V) (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₂ p₁)))
Case conversion may be inaccurate. Consider using '#align vector_span_pair_rev vectorSpan_pair_revₓ'. -/
/-- The `vector_span` of two points is the span of their difference (reversed). -/
theorem vectorSpan_pair_rev (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = k ∙ p₂ -ᵥ p₁ := by
  rw [pair_comm, vectorSpan_pair]
#align vector_span_pair_rev vectorSpan_pair_rev

/- warning: vsub_mem_vector_span_pair -> vsub_mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₁ p₂) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))
Case conversion may be inaccurate. Consider using '#align vsub_mem_vector_span_pair vsub_mem_vectorSpan_pairₓ'. -/
/-- The difference between two points lies in their `vector_span`. -/
theorem vsub_mem_vectorSpan_pair (p₁ p₂ : P) : p₁ -ᵥ p₂ ∈ vectorSpan k ({p₁, p₂} : Set P) :=
  vsub_mem_vectorSpan _ (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))
#align vsub_mem_vector_span_pair vsub_mem_vectorSpan_pair

/- warning: vsub_rev_mem_vector_span_pair -> vsub_rev_mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₂ p₁) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))
Case conversion may be inaccurate. Consider using '#align vsub_rev_mem_vector_span_pair vsub_rev_mem_vectorSpan_pairₓ'. -/
/-- The difference between two points (reversed) lies in their `vector_span`. -/
theorem vsub_rev_mem_vectorSpan_pair (p₁ p₂ : P) : p₂ -ᵥ p₁ ∈ vectorSpan k ({p₁, p₂} : Set P) :=
  vsub_mem_vectorSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _)) (Set.mem_insert _ _)
#align vsub_rev_mem_vector_span_pair vsub_rev_mem_vectorSpan_pair

variable {k}

/- warning: smul_vsub_mem_vector_span_pair -> smul_vsub_mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂)) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (HSMul.hSMul.{u2, u3, u3} k V V (instHSMul.{u2, u3} k V (SMulZeroClass.toSMul.{u2, u3} k V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) r (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₁ p₂)) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))
Case conversion may be inaccurate. Consider using '#align smul_vsub_mem_vector_span_pair smul_vsub_mem_vectorSpan_pairₓ'. -/
/-- A multiple of the difference between two points lies in their `vector_span`. -/
theorem smul_vsub_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :
    r • (p₁ -ᵥ p₂) ∈ vectorSpan k ({p₁, p₂} : Set P) :=
  Submodule.smul_mem _ _ (vsub_mem_vectorSpan_pair k p₁ p₂)
#align smul_vsub_mem_vector_span_pair smul_vsub_mem_vectorSpan_pair

/- warning: smul_vsub_rev_mem_vector_span_pair -> smul_vsub_rev_mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁)) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (HSMul.hSMul.{u2, u3, u3} k V V (instHSMul.{u2, u3} k V (SMulZeroClass.toSMul.{u2, u3} k V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) r (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₂ p₁)) (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))
Case conversion may be inaccurate. Consider using '#align smul_vsub_rev_mem_vector_span_pair smul_vsub_rev_mem_vectorSpan_pairₓ'. -/
/-- A multiple of the difference between two points (reversed) lies in their `vector_span`. -/
theorem smul_vsub_rev_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :
    r • (p₂ -ᵥ p₁) ∈ vectorSpan k ({p₁, p₂} : Set P) :=
  Submodule.smul_mem _ _ (vsub_rev_mem_vectorSpan_pair k p₁ p₂)
#align smul_vsub_rev_mem_vector_span_pair smul_vsub_rev_mem_vectorSpan_pair

/- warning: mem_vector_span_pair -> mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))) (Exists.{succ u1} k (fun (r : k) => Eq.{succ u2} V (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂)) v))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) v (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))) (Exists.{succ u2} k (fun (r : k) => Eq.{succ u3} V (HSMul.hSMul.{u2, u3, u3} k V V (instHSMul.{u2, u3} k V (SMulZeroClass.toSMul.{u2, u3} k V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) r (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₁ p₂)) v))
Case conversion may be inaccurate. Consider using '#align mem_vector_span_pair mem_vectorSpan_pairₓ'. -/
/-- A vector lies in the `vector_span` of two points if and only if it is a multiple of their
difference. -/
theorem mem_vectorSpan_pair {p₁ p₂ : P} {v : V} :
    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, r • (p₁ -ᵥ p₂) = v := by
  rw [vectorSpan_pair, Submodule.mem_span_singleton]
#align mem_vector_span_pair mem_vectorSpan_pair

/- warning: mem_vector_span_pair_rev -> mem_vectorSpan_pair_rev is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))) (Exists.{succ u1} k (fun (r : k) => Eq.{succ u2} V (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁)) v))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) v (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂)))) (Exists.{succ u2} k (fun (r : k) => Eq.{succ u3} V (HSMul.hSMul.{u2, u3, u3} k V V (instHSMul.{u2, u3} k V (SMulZeroClass.toSMul.{u2, u3} k V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))) r (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) p₂ p₁)) v))
Case conversion may be inaccurate. Consider using '#align mem_vector_span_pair_rev mem_vectorSpan_pair_revₓ'. -/
/-- A vector lies in the `vector_span` of two points if and only if it is a multiple of their
difference (reversed). -/
theorem mem_vectorSpan_pair_rev {p₁ p₂ : P} {v : V} :
    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, r • (p₂ -ᵥ p₁) = v := by
  rw [vectorSpan_pair_rev, Submodule.mem_span_singleton]
#align mem_vector_span_pair_rev mem_vectorSpan_pair_rev

variable (k)

-- mathport name: «exprline[ , , ]»
notation "line[" k ", " p₁ ", " p₂ "]" =>
  affineSpan k (insert p₁ (@singleton _ _ Set.hasSingleton p₂))

/- warning: left_mem_affine_span_pair -> left_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align left_mem_affine_span_pair left_mem_affineSpan_pairₓ'. -/
/-- The first of two points lies in their affine span. -/
theorem left_mem_affineSpan_pair (p₁ p₂ : P) : p₁ ∈ line[k, p₁, p₂] :=
  mem_affineSpan _ (Set.mem_insert _ _)
#align left_mem_affine_span_pair left_mem_affineSpan_pair

/- warning: right_mem_affine_span_pair -> right_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align right_mem_affine_span_pair right_mem_affineSpan_pairₓ'. -/
/-- The second of two points lies in their affine span. -/
theorem right_mem_affineSpan_pair (p₁ p₂ : P) : p₂ ∈ line[k, p₁, p₂] :=
  mem_affineSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))
#align right_mem_affine_span_pair right_mem_affineSpan_pair

variable {k}

/- warning: affine_map.line_map_mem_affine_span_pair -> AffineMap.lineMap_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) r) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) r) (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u2, succ u3} (AffineMap.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) _x) (AffineMap.funLike.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) r) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_mem_affine_span_pair AffineMap.lineMap_mem_affineSpan_pairₓ'. -/
/-- A combination of two points expressed with `line_map` lies in their affine span. -/
theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :
    AffineMap.lineMap p₁ p₂ r ∈ line[k, p₁, p₂] :=
  AffineMap.lineMap_mem _ (left_mem_affineSpan_pair _ _ _) (right_mem_affineSpan_pair _ _ _)
#align affine_map.line_map_mem_affine_span_pair AffineMap.lineMap_mem_affineSpan_pair

/- warning: affine_map.line_map_rev_mem_affine_span_pair -> AffineMap.lineMap_rev_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₂ p₁) r) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) r) (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u2, succ u3} (AffineMap.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) _x) (AffineMap.funLike.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p₂ p₁) r) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_rev_mem_affine_span_pair AffineMap.lineMap_rev_mem_affineSpan_pairₓ'. -/
/-- A combination of two points expressed with `line_map` (with the two points reversed) lies in
their affine span. -/
theorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :
    AffineMap.lineMap p₂ p₁ r ∈ line[k, p₁, p₂] :=
  AffineMap.lineMap_mem _ (right_mem_affineSpan_pair _ _ _) (left_mem_affineSpan_pair _ _ _)
#align affine_map.line_map_rev_mem_affine_span_pair AffineMap.lineMap_rev_mem_affineSpan_pair

/- warning: smul_vsub_vadd_mem_affine_span_pair -> smul_vsub_vadd_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁)) p₁) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p₂ p₁)) p₁) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align smul_vsub_vadd_mem_affine_span_pair smul_vsub_vadd_mem_affineSpan_pairₓ'. -/
/-- A multiple of the difference of two points added to the first point lies in their affine
span. -/
theorem smul_vsub_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :
    r • (p₂ -ᵥ p₁) +ᵥ p₁ ∈ line[k, p₁, p₂] :=
  AffineMap.lineMap_mem_affineSpan_pair _ _ _
#align smul_vsub_vadd_mem_affine_span_pair smul_vsub_vadd_mem_affineSpan_pair

/- warning: smul_vsub_rev_vadd_mem_affine_span_pair -> smul_vsub_rev_vadd_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂)) p₂) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (r : k) (p₁ : P) (p₂ : P), Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p₁ p₂)) p₂) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))
Case conversion may be inaccurate. Consider using '#align smul_vsub_rev_vadd_mem_affine_span_pair smul_vsub_rev_vadd_mem_affineSpan_pairₓ'. -/
/-- A multiple of the difference of two points added to the second point lies in their affine
span. -/
theorem smul_vsub_rev_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :
    r • (p₁ -ᵥ p₂) +ᵥ p₂ ∈ line[k, p₁, p₂] :=
  AffineMap.lineMap_rev_mem_affineSpan_pair _ _ _
#align smul_vsub_rev_vadd_mem_affine_span_pair smul_vsub_rev_vadd_mem_affineSpan_pair

/- warning: vadd_left_mem_affine_span_pair -> vadd_left_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))) (Exists.{succ u1} k (fun (r : k) => Eq.{succ u2} V (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₂ p₁)) v))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) v p₁) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))) (Exists.{succ u2} k (fun (r : k) => Eq.{succ u1} V (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p₂ p₁)) v))
Case conversion may be inaccurate. Consider using '#align vadd_left_mem_affine_span_pair vadd_left_mem_affineSpan_pairₓ'. -/
/-- A vector added to the first point lies in the affine span of two points if and only if it is
a multiple of their difference. -/
theorem vadd_left_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :
    v +ᵥ p₁ ∈ line[k, p₁, p₂] ↔ ∃ r : k, r • (p₂ -ᵥ p₁) = v := by
  rw [vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _), direction_affineSpan,
    mem_vectorSpan_pair_rev]
#align vadd_left_mem_affine_span_pair vadd_left_mem_affineSpan_pair

/- warning: vadd_right_mem_affine_span_pair -> vadd_right_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₂) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂)))) (Exists.{succ u1} k (fun (r : k) => Eq.{succ u2} V (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p₁ p₂)) v))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {v : V}, Iff (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (HVAdd.hVAdd.{u1, u3, u3} V P P (instHVAdd.{u1, u3} V P (AddAction.toVAdd.{u1, u3} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) v p₂) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₂)))) (Exists.{succ u2} k (fun (r : k) => Eq.{succ u1} V (HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) r (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p₁ p₂)) v))
Case conversion may be inaccurate. Consider using '#align vadd_right_mem_affine_span_pair vadd_right_mem_affineSpan_pairₓ'. -/
/-- A vector added to the second point lies in the affine span of two points if and only if it is
a multiple of their difference. -/
theorem vadd_right_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :
    v +ᵥ p₂ ∈ line[k, p₁, p₂] ↔ ∃ r : k, r • (p₁ -ᵥ p₂) = v := by
  rw [vadd_mem_iff_mem_direction _ (right_mem_affineSpan_pair _ _ _), direction_affineSpan,
    mem_vectorSpan_pair]
#align vadd_right_mem_affine_span_pair vadd_right_mem_affineSpan_pair

/- warning: affine_span_pair_le_of_mem_of_mem -> affineSpan_pair_le_of_mem_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ s) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) s)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ s) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₂ s) -> (LE.le.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))) s)
Case conversion may be inaccurate. Consider using '#align affine_span_pair_le_of_mem_of_mem affineSpan_pair_le_of_mem_of_memₓ'. -/
/-- The span of two points that lie in an affine subspace is contained in that subspace. -/
theorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s :=
  by
  rw [affineSpan_le, Set.insert_subset, Set.singleton_subset_iff]
  exact ⟨hp₁, hp₂⟩
#align affine_span_pair_le_of_mem_of_mem affineSpan_pair_le_of_mem_of_mem

/- warning: affine_span_pair_le_of_left_mem -> affineSpan_pair_le_of_left_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃)))) -> (LE.le.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))))
Case conversion may be inaccurate. Consider using '#align affine_span_pair_le_of_left_mem affineSpan_pair_le_of_left_memₓ'. -/
/-- One line is contained in another differing in the first point if the first point of the first
line is contained in the second line. -/
theorem affineSpan_pair_le_of_left_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :
    line[k, p₁, p₃] ≤ line[k, p₂, p₃] :=
  affineSpan_pair_le_of_mem_of_mem h (right_mem_affineSpan_pair _ _ _)
#align affine_span_pair_le_of_left_mem affineSpan_pair_le_of_left_mem

/- warning: affine_span_pair_le_of_right_mem -> affineSpan_pair_le_of_right_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃)))) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₃))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p₁ (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃)))) -> (LE.le.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₁))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p₂ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₃))))
Case conversion may be inaccurate. Consider using '#align affine_span_pair_le_of_right_mem affineSpan_pair_le_of_right_memₓ'. -/
/-- One line is contained in another differing in the second point if the second point of the
first line is contained in the second line. -/
theorem affineSpan_pair_le_of_right_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :
    line[k, p₂, p₁] ≤ line[k, p₂, p₃] :=
  affineSpan_pair_le_of_mem_of_mem (left_mem_affineSpan_pair _ _ _) h
#align affine_span_pair_le_of_right_mem affineSpan_pair_le_of_right_mem

variable (k)

/- warning: affine_span_mono -> affineSpan_mono is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s₁ s₂) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s₁ s₂) -> (LE.le.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
Case conversion may be inaccurate. Consider using '#align affine_span_mono affineSpan_monoₓ'. -/
/-- `affine_span` is monotone. -/
@[mono]
theorem affineSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : affineSpan k s₁ ≤ affineSpan k s₂ :=
  spanPoints_subset_coe_of_subset_coe (Set.Subset.trans h (subset_affineSpan k _))
#align affine_span_mono affineSpan_mono

/- warning: affine_span_insert_affine_span -> affineSpan_insert_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (ps : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ps))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P) (ps : Set.{u3} P), Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p (SetLike.coe.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)))) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p ps))
Case conversion may be inaccurate. Consider using '#align affine_span_insert_affine_span affineSpan_insert_affineSpanₓ'. -/
/-- Taking the affine span of a set, adding a point and taking the
span again produces the same results as adding the point to the set
and taking the span. -/
theorem affineSpan_insert_affineSpan (p : P) (ps : Set P) :
    affineSpan k (insert p (affineSpan k ps : Set P)) = affineSpan k (insert p ps) := by
  rw [Set.insert_eq, Set.insert_eq, span_union, span_union, affine_span_coe]
#align affine_span_insert_affine_span affineSpan_insert_affineSpan

/- warning: affine_span_insert_eq_affine_span -> affineSpan_insert_eq_affineSpan is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : P} {ps : Set.{u3} P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ps)) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p : P} {ps : Set.{u3} P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)) -> (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p ps)) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps))
Case conversion may be inaccurate. Consider using '#align affine_span_insert_eq_affine_span affineSpan_insert_eq_affineSpanₓ'. -/
/-- If a point is in the affine span of a set, adding it to that set
does not change the affine span. -/
theorem affineSpan_insert_eq_affineSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :
    affineSpan k (insert p ps) = affineSpan k ps :=
  by
  rw [← mem_coe] at h
  rw [← affineSpan_insert_affineSpan, Set.insert_eq_of_mem h, affine_span_coe]
#align affine_span_insert_eq_affine_span affineSpan_insert_eq_affineSpan

variable {k}

/- warning: vector_span_insert_eq_vector_span -> vectorSpan_insert_eq_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p : P} {ps : Set.{u3} P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p ps)) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p : P} {ps : Set.{u3} P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps)) -> (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.instInsertSet.{u3} P) p ps)) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ps))
Case conversion may be inaccurate. Consider using '#align vector_span_insert_eq_vector_span vectorSpan_insert_eq_vectorSpanₓ'. -/
/-- If a point is in the affine span of a set, adding it to that set
does not change the vector span. -/
theorem vectorSpan_insert_eq_vectorSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :
    vectorSpan k (insert p ps) = vectorSpan k ps := by
  simp_rw [← direction_affineSpan, affineSpan_insert_eq_affineSpan _ h]
#align vector_span_insert_eq_vector_span vectorSpan_insert_eq_vectorSpan

end AffineSpace'

namespace AffineSubspace

variable {k : Type _} {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]
  [affine_space V P]

include V

/- warning: affine_subspace.direction_sup -> AffineSubspace.direction_sup is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s2 : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s1) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s2) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Sup.sup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) s1 s2)) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s1) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s2)) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s1 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s2 : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s1) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p2 s2) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Sup.sup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SemilatticeSup.toSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))) s1 s2)) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s1) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s2)) (Submodule.span.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_sup AffineSubspace.direction_supₓ'. -/
/-- The direction of the sup of two nonempty affine subspaces is the
sup of the two directions and of any one difference between points in
the two subspaces. -/
theorem direction_sup {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s1) (hp2 : p2 ∈ s2) :
    (s1 ⊔ s2).direction = s1.direction ⊔ s2.direction ⊔ k ∙ p2 -ᵥ p1 :=
  by
  refine' le_antisymm _ _
  · change (affineSpan k ((s1 : Set P) ∪ s2)).direction ≤ _
    rw [← mem_coe] at hp1
    rw [direction_affineSpan, vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ hp1),
      Submodule.span_le]
    rintro v ⟨p3, hp3, rfl⟩
    cases hp3
    · rw [sup_assoc, sup_comm, SetLike.mem_coe, Submodule.mem_sup]
      use 0, Submodule.zero_mem _, p3 -ᵥ p1, vsub_mem_direction hp3 hp1
      rw [zero_add]
    · rw [sup_assoc, SetLike.mem_coe, Submodule.mem_sup]
      use 0, Submodule.zero_mem _, p3 -ᵥ p1
      rw [and_comm', zero_add]
      use rfl
      rw [← vsub_add_vsub_cancel p3 p2 p1, Submodule.mem_sup]
      use p3 -ᵥ p2, vsub_mem_direction hp3 hp2, p2 -ᵥ p1, Submodule.mem_span_singleton_self _
  · refine' sup_le (sup_direction_le _ _) _
    rw [direction_eq_vector_span, vectorSpan_def]
    exact
      sInf_le_sInf fun p hp =>
        Set.Subset.trans
          (Set.singleton_subset_iff.2
            (vsub_mem_vsub (mem_spanPoints k p2 _ (Set.mem_union_right _ hp2))
              (mem_spanPoints k p1 _ (Set.mem_union_left _ hp1))))
          hp
#align affine_subspace.direction_sup AffineSubspace.direction_sup

/- warning: affine_subspace.direction_affine_span_insert -> AffineSubspace.direction_affineSpan_insert is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p2 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)))) (Sup.sup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Submodule.span.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1))) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P} {p2 : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p2 (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))) (Sup.sup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Submodule.span.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1))) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.direction_affine_span_insert AffineSubspace.direction_affineSpan_insertₓ'. -/
/-- The direction of the span of the result of adding a point to a
nonempty affine subspace is the sup of the direction of that subspace
and of any one difference between that point and a point in the
subspace. -/
theorem direction_affineSpan_insert {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) :
    (affineSpan k (insert p2 (s : Set P))).direction = Submodule.span k {p2 -ᵥ p1} ⊔ s.direction :=
  by
  rw [sup_comm, ← Set.union_singleton, ← coe_affine_span_singleton k V p2]
  change (s ⊔ affineSpan k {p2}).direction = _
  rw [direction_sup hp1 (mem_affineSpan k (Set.mem_singleton _)), direction_affineSpan]
  simp
#align affine_subspace.direction_affine_span_insert AffineSubspace.direction_affineSpan_insert

/- warning: affine_subspace.mem_affine_span_insert_iff -> AffineSubspace.mem_affineSpan_insert_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (forall (p2 : P) (p : P), Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p2 ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) s)))) (Exists.{succ u1} k (fun (r : k) => Exists.{succ u3} P (fun (p0 : P) => Exists.{0} (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 s) (fun (hp0 : Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 s) => Eq.{succ u3} P p (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) r (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1)) p0))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {p1 : P}, (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 s) -> (forall (p2 : P) (p : P), Iff (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p2 (SetLike.coe.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s)))) (Exists.{succ u3} k (fun (r : k) => Exists.{succ u1} P (fun (p0 : P) => Exists.{0} (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 s) (fun (hp0 : Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 s) => Eq.{succ u1} P p (HVAdd.hVAdd.{u2, u1, u1} V P P (instHVAdd.{u2, u1} V P (AddAction.toVAdd.{u2, u1} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u2, u2} k V V (instHSMul.{u3, u2} k V (SMulZeroClass.toSMul.{u3, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k V (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k V (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) r (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p2 p1)) p0))))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_affine_span_insert_iff AffineSubspace.mem_affineSpan_insert_iffₓ'. -/
/-- Given a point `p1` in an affine subspace `s`, and a point `p2`, a
point `p` is in the span of `s` with `p2` added if and only if it is a
multiple of `p2 -ᵥ p1` added to a point in `s`. -/
theorem mem_affineSpan_insert_iff {s : AffineSubspace k P} {p1 : P} (hp1 : p1 ∈ s) (p2 p : P) :
    p ∈ affineSpan k (insert p2 (s : Set P)) ↔
      ∃ (r : k)(p0 : P)(hp0 : p0 ∈ s), p = r • (p2 -ᵥ p1 : V) +ᵥ p0 :=
  by
  rw [← mem_coe] at hp1
  rw [← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_insert_of_mem _ hp1)),
    direction_affine_span_insert hp1, Submodule.mem_sup]
  constructor
  · rintro ⟨v1, hv1, v2, hv2, hp⟩
    rw [Submodule.mem_span_singleton] at hv1
    rcases hv1 with ⟨r, rfl⟩
    use r, v2 +ᵥ p1, vadd_mem_of_mem_direction hv2 hp1
    symm at hp
    rw [← sub_eq_zero, ← vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp
    rw [hp, vadd_vadd]
  · rintro ⟨r, p3, hp3, rfl⟩
    use r • (p2 -ᵥ p1), Submodule.mem_span_singleton.2 ⟨r, rfl⟩, p3 -ᵥ p1,
      vsub_mem_direction hp3 hp1
    rw [vadd_vsub_assoc, add_comm]
#align affine_subspace.mem_affine_span_insert_iff AffineSubspace.mem_affineSpan_insert_iff

end AffineSubspace

section MapComap

variable {k V₁ P₁ V₂ P₂ V₃ P₃ : Type _} [Ring k]

variable [AddCommGroup V₁] [Module k V₁] [AddTorsor V₁ P₁]

variable [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂]

variable [AddCommGroup V₃] [Module k V₃] [AddTorsor V₃ P₃]

include V₁ V₂

section

variable (f : P₁ →ᵃ[k] P₂)

/- warning: affine_map.vector_span_image_eq_submodule_map -> AffineMap.vectorSpan_image_eq_submodule_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : Set.{u3} P₁}, Eq.{succ u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_6) (Submodule.map.{u1, u1, u2, u4, max u2 u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomSurjective.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (vectorSpan.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s)) (vectorSpan.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u3, u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s))
but is expected to have type
  forall {k : Type.{u3}} {V₁ : Type.{u2}} {P₁ : Type.{u5}} {V₂ : Type.{u4}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u3, u4} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u3, u2, u5, u4, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : Set.{u5} P₁}, Eq.{succ u4} (Submodule.{u3, u4} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_6) (Submodule.map.{u3, u3, u2, u4, max u2 u4} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomSurjective.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearMap.{u3, u3, u2, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u3, u3, u2, u4} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (AffineMap.linear.{u3, u2, u5, u4, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (vectorSpan.{u3, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s)) (vectorSpan.{u3, u4, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u5, u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u2) (succ u5)) (succ u4)) (succ u1), succ u5, succ u1} (AffineMap.{u3, u2, u5, u4, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u3, u2, u5, u4, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s))
Case conversion may be inaccurate. Consider using '#align affine_map.vector_span_image_eq_submodule_map AffineMap.vectorSpan_image_eq_submodule_mapₓ'. -/
@[simp]
theorem AffineMap.vectorSpan_image_eq_submodule_map {s : Set P₁} :
    Submodule.map f.linear (vectorSpan k s) = vectorSpan k (f '' s) := by
  simp [f.image_vsub_image, vectorSpan_def]
#align affine_map.vector_span_image_eq_submodule_map AffineMap.vectorSpan_image_eq_submodule_map

namespace AffineSubspace

#print AffineSubspace.map /-
/-- The image of an affine subspace under an affine map as an affine subspace. -/
def map (s : AffineSubspace k P₁) : AffineSubspace k P₂
    where
  carrier := f '' s
  smul_vsub_vadd_mem :=
    by
    rintro t - - - ⟨p₁, h₁, rfl⟩ ⟨p₂, h₂, rfl⟩ ⟨p₃, h₃, rfl⟩
    use t • (p₁ -ᵥ p₂) +ᵥ p₃
    suffices t • (p₁ -ᵥ p₂) +ᵥ p₃ ∈ s by simp [this]
    exact s.smul_vsub_vadd_mem t h₁ h₂ h₃
#align affine_subspace.map AffineSubspace.map
-/

/- warning: affine_subspace.coe_map -> AffineSubspace.coe_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u5} (Set.{u5} P₂) ((fun (a : Type.{u5}) (b : Type.{u5}) [self : HasLiftT.{succ u5, succ u5} a b] => self.0) (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (HasLiftT.mk.{succ u5, succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (CoeTCₓ.coe.{succ u5, succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (SetLike.Set.hasCoeT.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Set.image.{u3, u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u1}} {P₂ : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u2} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (Set.{u2} P₂) (SetLike.coe.{u2, u2} (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Set.image.{u3, u2} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u1)) (succ u2), succ u3, succ u2} (AffineMap.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) (SetLike.coe.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_map AffineSubspace.coe_mapₓ'. -/
@[simp]
theorem coe_map (s : AffineSubspace k P₁) : (s.map f : Set P₂) = f '' s :=
  rfl
#align affine_subspace.coe_map AffineSubspace.coe_map

/- warning: affine_subspace.mem_map -> AffineSubspace.mem_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₂} {s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Membership.Mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.hasMem.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) x (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Exists.{succ u3} P₁ (fun (y : P₁) => Exists.{0} (Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) y s) (fun (H : Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) y s) => Eq.{succ u5} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) x)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₂} {s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Exists.{succ u3} P₁ (fun (y : P₁) => And (Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) y s) (Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) y) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (a : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) a) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y) x)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_map AffineSubspace.mem_mapₓ'. -/
@[simp]
theorem mem_map {f : P₁ →ᵃ[k] P₂} {x : P₂} {s : AffineSubspace k P₁} :
    x ∈ s.map f ↔ ∃ y ∈ s, f y = x :=
  mem_image_iff_bex
#align affine_subspace.mem_map AffineSubspace.mem_map

/- warning: affine_subspace.mem_map_of_mem -> AffineSubspace.mem_map_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {x : P₁} {s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, (Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x s) -> (Membership.Mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.hasMem.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u1}} {P₂ : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u2} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {x : P₁} {s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, (Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x s) -> (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) x) (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u1)) (succ u2), succ u3, succ u2} (AffineMap.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (AffineSubspace.map.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_map_of_mem AffineSubspace.mem_map_of_memₓ'. -/
theorem mem_map_of_mem {x : P₁} {s : AffineSubspace k P₁} (h : x ∈ s) : f x ∈ s.map f :=
  Set.mem_image_of_mem _ h
#align affine_subspace.mem_map_of_mem AffineSubspace.mem_map_of_mem

/- warning: affine_subspace.mem_map_iff_mem_of_injective -> AffineSubspace.mem_map_iff_mem_of_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₁} {s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Injective.{succ u3, succ u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Membership.Mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.hasMem.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₁} {s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, (Function.Injective.{succ u3, succ u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) x) (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_map_iff_mem_of_injective AffineSubspace.mem_map_iff_mem_of_injectiveₓ'. -/
theorem mem_map_iff_mem_of_injective {f : P₁ →ᵃ[k] P₂} {x : P₁} {s : AffineSubspace k P₁}
    (hf : Function.Injective f) : f x ∈ s.map f ↔ x ∈ s :=
  hf.mem_set_image
#align affine_subspace.mem_map_iff_mem_of_injective AffineSubspace.mem_map_iff_mem_of_injective

/- warning: affine_subspace.map_bot -> AffineSubspace.map_bot is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Bot.bot.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasBot.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))
but is expected to have type
  forall {k : Type.{u4}} {V₁ : Type.{u2}} {P₁ : Type.{u1}} {V₂ : Type.{u3}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u4, u2} k V₁ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u4, u3} k V₂ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] (f : AffineMap.{u4, u2, u1, u3, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u5} (AffineSubspace.{u4, u3, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u4, u2, u1, u3, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Bot.bot.{u1} (AffineSubspace.{u4, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u4, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Bot.bot.{u5} (AffineSubspace.{u4, u3, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toBot.{u5} (AffineSubspace.{u4, u3, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u3, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_bot AffineSubspace.map_botₓ'. -/
@[simp]
theorem map_bot : (⊥ : AffineSubspace k P₁).map f = ⊥ :=
  coe_injective <| image_empty f
#align affine_subspace.map_bot AffineSubspace.map_bot

/- warning: affine_subspace.map_eq_bot_iff -> AffineSubspace.map_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (Bot.bot.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasBot.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u1}} {P₂ : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u2} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4}, Iff (Eq.{succ u2} (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u5, u4, u3, u1, u2} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (Bot.bot.{u2} (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toBot.{u2} (AffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u1, u2} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (Eq.{succ u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_eq_bot_iff AffineSubspace.map_eq_bot_iffₓ'. -/
@[simp]
theorem map_eq_bot_iff {s : AffineSubspace k P₁} : s.map f = ⊥ ↔ s = ⊥ :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · rwa [← coe_eq_bot_iff, coe_map, image_eq_empty, coe_eq_bot_iff] at h
  · rw [h, map_bot]
#align affine_subspace.map_eq_bot_iff AffineSubspace.map_eq_bot_iff

omit V₂

/- warning: affine_subspace.map_id -> AffineSubspace.map_id is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.map.{u1, u2, u3, u2, u3} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s) s
but is expected to have type
  forall {k : Type.{u3}} {V₁ : Type.{u2}} {P₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.map.{u3, u2, u1, u2, u1} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s) s
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_id AffineSubspace.map_idₓ'. -/
@[simp]
theorem map_id (s : AffineSubspace k P₁) : s.map (AffineMap.id k P₁) = s :=
  coe_injective <| image_id _
#align affine_subspace.map_id AffineSubspace.map_id

include V₂ V₃

/- warning: affine_subspace.map_map -> AffineSubspace.map_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} {V₃ : Type.{u6}} {P₃ : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u6} V₃] [_inst_9 : Module.{u1, u6} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₃ _inst_8)] [_inst_10 : AddTorsor.{u6, u7} V₃ P₃ (AddCommGroup.toAddGroup.{u6} V₃ _inst_8)] (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u1, u4, u5, u6, u7} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{succ u7} (AffineSubspace.{u1, u6, u7} k V₃ P₃ _inst_1 _inst_8 _inst_9 _inst_10) (AffineSubspace.map.{u1, u4, u5, u6, u7} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (AffineSubspace.map.{u1, u2, u3, u6, u7} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u1, u2, u3, u4, u5, u6, u7} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g f) s)
but is expected to have type
  forall {k : Type.{u7}} {V₁ : Type.{u6}} {P₁ : Type.{u5}} {V₂ : Type.{u4}} {P₂ : Type.{u3}} {V₃ : Type.{u2}} {P₃ : Type.{u1}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u6} V₁] [_inst_3 : Module.{u7, u6} k V₁ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₁ _inst_2)] [_inst_4 : AddTorsor.{u6, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u6} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u7, u4} k V₂ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u2} V₃] [_inst_9 : Module.{u7, u2} k V₃ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₃ _inst_8)] [_inst_10 : AddTorsor.{u2, u1} V₃ P₃ (AddCommGroup.toAddGroup.{u2} V₃ _inst_8)] (s : AffineSubspace.{u7, u6, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (f : AffineMap.{u7, u6, u5, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u7, u4, u3, u2, u1} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{succ u1} (AffineSubspace.{u7, u2, u1} k V₃ P₃ _inst_1 _inst_8 _inst_9 _inst_10) (AffineSubspace.map.{u7, u4, u3, u2, u1} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g (AffineSubspace.map.{u7, u6, u5, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (AffineSubspace.map.{u7, u6, u5, u2, u1} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u7, u6, u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g f) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_map AffineSubspace.map_mapₓ'. -/
theorem map_map (s : AffineSubspace k P₁) (f : P₁ →ᵃ[k] P₂) (g : P₂ →ᵃ[k] P₃) :
    (s.map f).map g = s.map (g.comp f) :=
  coe_injective <| image_image _ _ _
#align affine_subspace.map_map AffineSubspace.map_map

omit V₃

/- warning: affine_subspace.map_direction -> AffineSubspace.map_direction is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_6) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Submodule.map.{u1, u1, u2, u4, max u2 u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomSurjective.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5) _inst_6) (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Submodule.map.{u5, u5, u4, u2, max u4 u2} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomSurjective.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.semilinearMapClass.{u5, u5, u4, u2} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_direction AffineSubspace.map_directionₓ'. -/
@[simp]
theorem map_direction (s : AffineSubspace k P₁) : (s.map f).direction = s.direction.map f.linear :=
  by simp [direction_eq_vector_span]
#align affine_subspace.map_direction AffineSubspace.map_direction

/- warning: affine_subspace.map_span -> AffineSubspace.map_span is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u3} P₁), Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (affineSpan.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s)) (affineSpan.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u3, u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s))
but is expected to have type
  forall {k : Type.{u3}} {V₁ : Type.{u1}} {P₁ : Type.{u5}} {V₂ : Type.{u2}} {P₂ : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u3, u2} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u3, u1, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u5} P₁), Eq.{succ u4} (AffineSubspace.{u3, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u3, u1, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (affineSpan.{u3, u1, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s)) (affineSpan.{u3, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u5, u4} P₁ P₂ (FunLike.coe.{max (max (max (succ u1) (succ u5)) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u3, u1, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u3, u1, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_span AffineSubspace.map_spanₓ'. -/
theorem map_span (s : Set P₁) : (affineSpan k s).map f = affineSpan k (f '' s) :=
  by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p, hp⟩); · simp
  apply ext_of_direction_eq
  · simp [direction_affineSpan]
  ·
    exact
      ⟨f p, mem_image_of_mem f (subset_affineSpan k _ hp),
        subset_affineSpan k _ (mem_image_of_mem f hp)⟩
#align affine_subspace.map_span AffineSubspace.map_span

end AffineSubspace

namespace AffineMap

/- warning: affine_map.map_top_of_surjective -> AffineMap.map_top_of_surjective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Surjective.{succ u3, succ u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Top.top.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasTop.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
but is expected to have type
  forall {k : Type.{u1}} {V₁ : Type.{u3}} {P₁ : Type.{u5}} {V₂ : Type.{u2}} {P₂ : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Surjective.{succ u5, succ u4} P₁ P₂ (FunLike.coe.{max (max (max (succ u3) (succ u5)) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Eq.{succ u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Top.top.{u5} (AffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u5} (AffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Top.top.{u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toTop.{u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
Case conversion may be inaccurate. Consider using '#align affine_map.map_top_of_surjective AffineMap.map_top_of_surjectiveₓ'. -/
@[simp]
theorem map_top_of_surjective (hf : Function.Surjective f) : AffineSubspace.map f ⊤ = ⊤ :=
  by
  rw [← AffineSubspace.ext_iff]
  exact image_univ_of_surjective hf
#align affine_map.map_top_of_surjective AffineMap.map_top_of_surjective

/- warning: affine_map.span_eq_top_of_surjective -> AffineMap.span_eq_top_of_surjective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : Set.{u3} P₁}, (Function.Surjective.{succ u3, succ u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) -> (Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (affineSpan.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u3, u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s)) (Top.top.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasTop.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
but is expected to have type
  forall {k : Type.{u1}} {V₁ : Type.{u3}} {P₁ : Type.{u5}} {V₂ : Type.{u2}} {P₂ : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {s : Set.{u5} P₁}, (Function.Surjective.{succ u5, succ u4} P₁ P₂ (FunLike.coe.{max (max (max (succ u3) (succ u5)) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Eq.{succ u5} (AffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s) (Top.top.{u5} (AffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u5} (AffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u3, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) -> (Eq.{succ u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (affineSpan.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u5, u4} P₁ P₂ (FunLike.coe.{max (max (max (succ u3) (succ u5)) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s)) (Top.top.{u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toTop.{u4} (AffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u2, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
Case conversion may be inaccurate. Consider using '#align affine_map.span_eq_top_of_surjective AffineMap.span_eq_top_of_surjectiveₓ'. -/
theorem span_eq_top_of_surjective {s : Set P₁} (hf : Function.Surjective f)
    (h : affineSpan k s = ⊤) : affineSpan k (f '' s) = ⊤ := by
  rw [← AffineSubspace.map_span, h, map_top_of_surjective f hf]
#align affine_map.span_eq_top_of_surjective AffineMap.span_eq_top_of_surjective

end AffineMap

namespace AffineEquiv

/- warning: affine_equiv.span_eq_top_iff -> AffineEquiv.span_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {s : Set.{u3} P₁} (e : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (affineSpan.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u3, u5} P₁ P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) (Top.top.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasTop.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
but is expected to have type
  forall {k : Type.{u4}} {V₁ : Type.{u2}} {P₁ : Type.{u5}} {V₂ : Type.{u1}} {P₂ : Type.{u3}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u4, u2} k V₁ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u4, u1} k V₂ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {s : Set.{u5} P₁} (e : AffineEquiv.{u4, u5, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Eq.{succ u5} (AffineSubspace.{u4, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u4, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 s) (Top.top.{u5} (AffineSubspace.{u4, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u5} (AffineSubspace.{u4, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u2, u5} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u3} (AffineSubspace.{u4, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (affineSpan.{u4, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Set.image.{u5, u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u4, u5, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e) s)) (Top.top.{u3} (AffineSubspace.{u4, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toTop.{u3} (AffineSubspace.{u4, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u4, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))
Case conversion may be inaccurate. Consider using '#align affine_equiv.span_eq_top_iff AffineEquiv.span_eq_top_iffₓ'. -/
theorem span_eq_top_iff {s : Set P₁} (e : P₁ ≃ᵃ[k] P₂) :
    affineSpan k s = ⊤ ↔ affineSpan k (e '' s) = ⊤ :=
  by
  refine' ⟨(e : P₁ →ᵃ[k] P₂).span_eq_top_of_surjective e.surjective, _⟩
  intro h
  have : s = e.symm '' (e '' s) := by simp [← image_comp]
  rw [this]
  exact (e.symm : P₂ →ᵃ[k] P₁).span_eq_top_of_surjective e.symm.surjective h
#align affine_equiv.span_eq_top_iff AffineEquiv.span_eq_top_iff

end AffineEquiv

end

namespace AffineSubspace

#print AffineSubspace.comap /-
/-- The preimage of an affine subspace under an affine map as an affine subspace. -/
def comap (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₂) : AffineSubspace k P₁
    where
  carrier := f ⁻¹' s
  smul_vsub_vadd_mem t p₁ p₂ p₃ (hp₁ : f p₁ ∈ s) (hp₂ : f p₂ ∈ s) (hp₃ : f p₃ ∈ s) :=
    show f _ ∈ s by
      rw [AffineMap.map_vadd, LinearMap.map_smul, AffineMap.linearMap_vsub]
      apply s.smul_vsub_vadd_mem _ hp₁ hp₂ hp₃
#align affine_subspace.comap AffineSubspace.comap
-/

/- warning: affine_subspace.coe_comap -> AffineSubspace.coe_comap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (Set.{u3} P₁) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P₁) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Set.preimage.{u3, u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) ((fun (a : Type.{u5}) (b : Type.{u5}) [self : HasLiftT.{succ u5, succ u5} a b] => self.0) (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (HasLiftT.mk.{succ u5, succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (CoeTCₓ.coe.{succ u5, succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Set.{u5} P₂) (SetLike.Set.hasCoeT.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (Set.{u3} P₁) (SetLike.coe.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Set.preimage.{u3, u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) (SetLike.coe.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.coe_comap AffineSubspace.coe_comapₓ'. -/
@[simp]
theorem coe_comap (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₂) : (s.comap f : Set P₁) = f ⁻¹' ↑s :=
  rfl
#align affine_subspace.coe_comap AffineSubspace.coe_comap

/- warning: affine_subspace.mem_comap -> AffineSubspace.mem_comap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₁} {s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, Iff (Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Membership.Mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.hasMem.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) s)
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {x : P₁} {s : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, Iff (Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) x (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) (Membership.mem.{u1, u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) x) (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.mem_comap AffineSubspace.mem_comapₓ'. -/
@[simp]
theorem mem_comap {f : P₁ →ᵃ[k] P₂} {x : P₁} {s : AffineSubspace k P₂} : x ∈ s.comap f ↔ f x ∈ s :=
  Iff.rfl
#align affine_subspace.mem_comap AffineSubspace.mem_comap

/- warning: affine_subspace.comap_mono -> AffineSubspace.comap_mono is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7} {t : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, (LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toHasLe.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) s t) -> (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {s : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7} {t : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, (LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) s t) -> (LE.le.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_mono AffineSubspace.comap_monoₓ'. -/
theorem comap_mono {f : P₁ →ᵃ[k] P₂} {s t : AffineSubspace k P₂} : s ≤ t → s.comap f ≤ t.comap f :=
  preimage_mono
#align affine_subspace.comap_mono AffineSubspace.comap_mono

/- warning: affine_subspace.comap_top -> AffineSubspace.comap_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Top.top.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toHasTop.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Eq.{succ u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Top.top.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toTop.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (Top.top.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_top AffineSubspace.comap_topₓ'. -/
@[simp]
theorem comap_top {f : P₁ →ᵃ[k] P₂} : (⊤ : AffineSubspace k P₂).comap f = ⊤ :=
  by
  rw [← ext_iff]
  exact preimage_univ
#align affine_subspace.comap_top AffineSubspace.comap_top

omit V₂

/- warning: affine_subspace.comap_id -> AffineSubspace.comap_id is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u2, u3} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s) s
but is expected to have type
  forall {k : Type.{u3}} {V₁ : Type.{u2}} {P₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u3, u2, u1, u2, u1} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u3, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) s) s
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_id AffineSubspace.comap_idₓ'. -/
@[simp]
theorem comap_id (s : AffineSubspace k P₁) : s.comap (AffineMap.id k P₁) = s :=
  coe_injective rfl
#align affine_subspace.comap_id AffineSubspace.comap_id

include V₂ V₃

/- warning: affine_subspace.comap_comap -> AffineSubspace.comap_comap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} {V₃ : Type.{u6}} {P₃ : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u6} V₃] [_inst_9 : Module.{u1, u6} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₃ _inst_8)] [_inst_10 : AddTorsor.{u6, u7} V₃ P₃ (AddCommGroup.toAddGroup.{u6} V₃ _inst_8)] (s : AffineSubspace.{u1, u6, u7} k V₃ P₃ _inst_1 _inst_8 _inst_9 _inst_10) (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u1, u4, u5, u6, u7} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.comap.{u1, u4, u5, u6, u7} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g s)) (AffineSubspace.comap.{u1, u2, u3, u6, u7} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u1, u2, u3, u4, u5, u6, u7} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g f) s)
but is expected to have type
  forall {k : Type.{u7}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} {V₃ : Type.{u6}} {P₃ : Type.{u5}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u7, u4} k V₁ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u7, u2} k V₂ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u6} V₃] [_inst_9 : Module.{u7, u6} k V₃ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₃ _inst_8)] [_inst_10 : AddTorsor.{u6, u5} V₃ P₃ (AddCommGroup.toAddGroup.{u6} V₃ _inst_8)] (s : AffineSubspace.{u7, u6, u5} k V₃ P₃ _inst_1 _inst_8 _inst_9 _inst_10) (f : AffineMap.{u7, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u7, u2, u1, u6, u5} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{succ u3} (AffineSubspace.{u7, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u7, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.comap.{u7, u2, u1, u6, u5} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g s)) (AffineSubspace.comap.{u7, u4, u3, u6, u5} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u7, u4, u3, u2, u1, u6, u5} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 g f) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_comap AffineSubspace.comap_comapₓ'. -/
theorem comap_comap (s : AffineSubspace k P₃) (f : P₁ →ᵃ[k] P₂) (g : P₂ →ᵃ[k] P₃) :
    (s.comap g).comap f = s.comap (g.comp f) :=
  coe_injective rfl
#align affine_subspace.comap_comap AffineSubspace.comap_comap

omit V₃

/- warning: affine_subspace.map_le_iff_le_comap -> AffineSubspace.map_le_iff_le_comap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4} {t : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, Iff (LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toHasLe.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) t) (LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) s (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4} {t : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7}, Iff (LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) t) (LE.le.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) s (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_le_iff_le_comap AffineSubspace.map_le_iff_le_comapₓ'. -/
-- lemmas about map and comap derived from the galois connection
theorem map_le_iff_le_comap {f : P₁ →ᵃ[k] P₂} {s : AffineSubspace k P₁} {t : AffineSubspace k P₂} :
    s.map f ≤ t ↔ s ≤ t.comap f :=
  image_subset_iff
#align affine_subspace.map_le_iff_le_comap AffineSubspace.map_le_iff_le_comap

/- warning: affine_subspace.gc_map_comap -> AffineSubspace.gc_map_comap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), GaloisConnection.{u3, u5} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), GaloisConnection.{u3, u1} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)
Case conversion may be inaccurate. Consider using '#align affine_subspace.gc_map_comap AffineSubspace.gc_map_comapₓ'. -/
theorem gc_map_comap (f : P₁ →ᵃ[k] P₂) : GaloisConnection (map f) (comap f) := fun _ _ =>
  map_le_iff_le_comap
#align affine_subspace.gc_map_comap AffineSubspace.gc_map_comap

/- warning: affine_subspace.map_comap_le -> AffineSubspace.map_comap_le is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toHasLe.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) s
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s)) s
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_comap_le AffineSubspace.map_comap_leₓ'. -/
theorem map_comap_le (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₂) : (s.comap f).map f ≤ s :=
  (gc_map_comap f).l_u_le _
#align affine_subspace.map_comap_le AffineSubspace.map_comap_le

/- warning: affine_subspace.le_comap_map -> AffineSubspace.le_comap_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), LE.le.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toHasLe.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.partialOrder.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) s (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), LE.le.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Preorder.toLE.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (PartialOrder.toPreorder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) s (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.le_comap_map AffineSubspace.le_comap_mapₓ'. -/
theorem le_comap_map (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₁) : s ≤ (s.map f).comap f :=
  (gc_map_comap f).le_u_l _
#align affine_subspace.le_comap_map AffineSubspace.le_comap_map

/- warning: affine_subspace.map_sup -> AffineSubspace.map_sup is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (t : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Sup.sup.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SemilatticeSup.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) s t)) (Sup.sup.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SemilatticeSup.toHasSup.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Lattice.toSemilatticeSup.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] (s : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (t : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Sup.sup.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SemilatticeSup.toSup.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toSemilatticeSup.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) s t)) (Sup.sup.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SemilatticeSup.toSup.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Lattice.toSemilatticeSup.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_sup AffineSubspace.map_supₓ'. -/
theorem map_sup (s t : AffineSubspace k P₁) (f : P₁ →ᵃ[k] P₂) : (s ⊔ t).map f = s.map f ⊔ t.map f :=
  (gc_map_comap f).l_sup
#align affine_subspace.map_sup AffineSubspace.map_sup

/- warning: affine_subspace.map_supr -> AffineSubspace.map_iSup is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {ι : Sort.{u6}} (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : ι -> (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)), Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (iSup.{u3, u6} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toHasSup.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))) ι s)) (iSup.{u5, u6} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toHasSup.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))) ι (fun (i : ι) => AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (s i)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {ι : Sort.{u6}} (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : ι -> (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)), Eq.{succ u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (iSup.{u3, u6} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toSupSet.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))) ι s)) (iSup.{u1, u6} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toSupSet.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))) ι (fun (i : ι) => AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (s i)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_supr AffineSubspace.map_iSupₓ'. -/
theorem map_iSup {ι : Sort _} (f : P₁ →ᵃ[k] P₂) (s : ι → AffineSubspace k P₁) :
    (iSup s).map f = ⨆ i, (s i).map f :=
  (gc_map_comap f).l_iSup
#align affine_subspace.map_supr AffineSubspace.map_iSup

/- warning: affine_subspace.comap_inf -> AffineSubspace.comap_inf is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (t : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Inf.inf.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (SemilatticeInf.toHasInf.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Lattice.toSemilatticeInf.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))))) s t)) (Inf.inf.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (SemilatticeInf.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toSemilatticeInf.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u2}} {P₁ : Type.{u1}} {V₂ : Type.{u4}} {P₂ : Type.{u3}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u5, u4} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (s : AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (t : AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (f : AffineMap.{u5, u2, u1, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u1} (AffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u5, u2, u1, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (Inf.inf.{u3} (AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (Lattice.toInf.{u3} (AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)))) s t)) (Inf.inf.{u1} (AffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (Lattice.toInf.{u1} (AffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineSubspace.comap.{u5, u2, u1, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f s) (AffineSubspace.comap.{u5, u2, u1, u4, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f t))
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_inf AffineSubspace.comap_infₓ'. -/
theorem comap_inf (s t : AffineSubspace k P₂) (f : P₁ →ᵃ[k] P₂) :
    (s ⊓ t).comap f = s.comap f ⊓ t.comap f :=
  (gc_map_comap f).u_inf
#align affine_subspace.comap_inf AffineSubspace.comap_inf

/- warning: affine_subspace.comap_supr -> AffineSubspace.comap_supr is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {ι : Sort.{u6}} (f : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : ι -> (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (iInf.{u5, u6} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toHasInf.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.completeLattice.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))) ι s)) (iInf.{u3, u6} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toHasInf.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))) ι (fun (i : ι) => AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (s i)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {ι : Sort.{u6}} (f : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : ι -> (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7)), Eq.{succ u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (iInf.{u1, u6} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (ConditionallyCompleteLattice.toInfSet.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (CompleteLattice.toConditionallyCompleteLattice.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7))) ι s)) (iInf.{u3, u6} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (ConditionallyCompleteLattice.toInfSet.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4))) ι (fun (i : ι) => AffineSubspace.comap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (s i)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_supr AffineSubspace.comap_suprₓ'. -/
theorem comap_supr {ι : Sort _} (f : P₁ →ᵃ[k] P₂) (s : ι → AffineSubspace k P₂) :
    (iInf s).comap f = ⨅ i, (s i).comap f :=
  (gc_map_comap f).u_iInf
#align affine_subspace.comap_supr AffineSubspace.comap_supr

/- warning: affine_subspace.comap_symm -> AffineSubspace.comap_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (e : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.comap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 ((fun (a : Sort.{max (succ u5) (succ u3) (succ u4) (succ u2)}) (b : Sort.{max (succ u4) (succ u5) (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (HasLiftT.mk.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (CoeTCₓ.coe.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (coeBase.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.AffineMap.hasCoe.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4)))) (AffineEquiv.symm.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) s) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 ((fun (a : Sort.{max (succ u3) (succ u5) (succ u2) (succ u4)}) (b : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} a b] => self.0) (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e) s)
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u2}} {P₁ : Type.{u4}} {V₂ : Type.{u1}} {P₂ : Type.{u3}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4), Eq.{succ u3} (AffineSubspace.{u5, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7) (AffineSubspace.comap.{u5, u1, u3, u2, u4} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.toAffineMap.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) s) (AffineSubspace.map.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_symm AffineSubspace.comap_symmₓ'. -/
@[simp]
theorem comap_symm (e : P₁ ≃ᵃ[k] P₂) (s : AffineSubspace k P₁) :
    s.comap (e.symm : P₂ →ᵃ[k] P₁) = s.map e :=
  coe_injective <| e.preimage_symm _
#align affine_subspace.comap_symm AffineSubspace.comap_symm

/- warning: affine_subspace.map_symm -> AffineSubspace.map_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (e : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.map.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 ((fun (a : Sort.{max (succ u5) (succ u3) (succ u4) (succ u2)}) (b : Sort.{max (succ u4) (succ u5) (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (HasLiftT.mk.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (CoeTCₓ.coe.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (coeBase.{max (succ u5) (succ u3) (succ u4) (succ u2), max (succ u4) (succ u5) (succ u2) (succ u3)} (AffineEquiv.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u4, u5, u2, u3} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.AffineMap.hasCoe.{u1, u5, u3, u4, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4)))) (AffineEquiv.symm.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) s) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 ((fun (a : Sort.{max (succ u3) (succ u5) (succ u2) (succ u4)}) (b : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} a b] => self.0) (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e) s)
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u2}} {P₁ : Type.{u4}} {V₂ : Type.{u1}} {P₂ : Type.{u3}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : AffineSubspace.{u5, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7), Eq.{succ u4} (AffineSubspace.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.map.{u5, u1, u3, u2, u4} k V₂ P₂ V₁ P₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.toAffineMap.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) s) (AffineSubspace.comap.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) s)
Case conversion may be inaccurate. Consider using '#align affine_subspace.map_symm AffineSubspace.map_symmₓ'. -/
@[simp]
theorem map_symm (e : P₁ ≃ᵃ[k] P₂) (s : AffineSubspace k P₂) :
    s.map (e.symm : P₂ →ᵃ[k] P₁) = s.comap e :=
  coe_injective <| e.image_symm _
#align affine_subspace.map_symm AffineSubspace.map_symm

/- warning: affine_subspace.comap_span -> AffineSubspace.comap_span is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] (f : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u5} P₂), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 ((fun (a : Sort.{max (succ u3) (succ u5) (succ u2) (succ u4)}) (b : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} a b] => self.0) (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) f) (affineSpan.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 s)) (affineSpan.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (Set.preimage.{u3, u5} P₁ P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u2}} {P₁ : Type.{u4}} {V₂ : Type.{u1}} {P₂ : Type.{u3}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u3} P₂), Eq.{succ u4} (AffineSubspace.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.comap.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (affineSpan.{u5, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 s)) (affineSpan.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (Set.preimage.{u4, u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f) s))
Case conversion may be inaccurate. Consider using '#align affine_subspace.comap_span AffineSubspace.comap_spanₓ'. -/
theorem comap_span (f : P₁ ≃ᵃ[k] P₂) (s : Set P₂) :
    (affineSpan k s).comap (f : P₁ →ᵃ[k] P₂) = affineSpan k (f ⁻¹' s) := by
  rw [← map_symm, map_span, AffineEquiv.coe_coe, f.image_symm]
#align affine_subspace.comap_span AffineSubspace.comap_span

end AffineSubspace

end MapComap

namespace AffineSubspace

open AffineEquiv

variable {k : Type _} {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]

variable [affine_space V P]

include V

#print AffineSubspace.Parallel /-
/-- Two affine subspaces are parallel if one is related to the other by adding the same vector
to all points. -/
def Parallel (s₁ s₂ : AffineSubspace k P) : Prop :=
  ∃ v : V, s₂ = s₁.map (constVAdd k P v)
#align affine_subspace.parallel AffineSubspace.Parallel
-/

-- mathport name: affine_subspace.parallel
scoped[Affine] infixl:50 " ∥ " => AffineSubspace.Parallel

/- warning: affine_subspace.parallel.symm -> AffineSubspace.Parallel.symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₁)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₁)
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel.symm AffineSubspace.Parallel.symmₓ'. -/
@[symm]
theorem Parallel.symm {s₁ s₂ : AffineSubspace k P} (h : s₁ ∥ s₂) : s₂ ∥ s₁ :=
  by
  rcases h with ⟨v, rfl⟩
  refine' ⟨-v, _⟩
  rw [map_map, ← coe_trans_to_affine_map, ← const_vadd_add, neg_add_self, const_vadd_zero,
    coe_refl_to_affine_map, map_id]
#align affine_subspace.parallel.symm AffineSubspace.Parallel.symm

/- warning: affine_subspace.parallel_comm -> AffineSubspace.parallel_comm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₁)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₁)
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel_comm AffineSubspace.parallel_commₓ'. -/
theorem parallel_comm {s₁ s₂ : AffineSubspace k P} : s₁ ∥ s₂ ↔ s₂ ∥ s₁ :=
  ⟨Parallel.symm, Parallel.symm⟩
#align affine_subspace.parallel_comm AffineSubspace.parallel_comm

/- warning: affine_subspace.parallel.refl -> AffineSubspace.Parallel.refl is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4), AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s s
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4), AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s s
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel.refl AffineSubspace.Parallel.reflₓ'. -/
@[refl]
theorem Parallel.refl (s : AffineSubspace k P) : s ∥ s :=
  ⟨0, by simp⟩
#align affine_subspace.parallel.refl AffineSubspace.Parallel.refl

/- warning: affine_subspace.parallel.trans -> AffineSubspace.Parallel.trans is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₃ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₃) -> (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₃)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₃ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂ s₃) -> (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₃)
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel.trans AffineSubspace.Parallel.transₓ'. -/
@[trans]
theorem Parallel.trans {s₁ s₂ s₃ : AffineSubspace k P} (h₁₂ : s₁ ∥ s₂) (h₂₃ : s₂ ∥ s₃) : s₁ ∥ s₃ :=
  by
  rcases h₁₂ with ⟨v₁₂, rfl⟩
  rcases h₂₃ with ⟨v₂₃, rfl⟩
  refine' ⟨v₂₃ + v₁₂, _⟩
  rw [map_map, ← coe_trans_to_affine_map, ← const_vadd_add]
#align affine_subspace.parallel.trans AffineSubspace.Parallel.trans

/- warning: affine_subspace.parallel.direction_eq -> AffineSubspace.Parallel.direction_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) -> (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel.direction_eq AffineSubspace.Parallel.direction_eqₓ'. -/
theorem Parallel.direction_eq {s₁ s₂ : AffineSubspace k P} (h : s₁ ∥ s₂) :
    s₁.direction = s₂.direction := by
  rcases h with ⟨v, rfl⟩
  simp
#align affine_subspace.parallel.direction_eq AffineSubspace.Parallel.direction_eq

/- warning: affine_subspace.parallel_bot_iff_eq_bot -> AffineSubspace.parallel_bot_iff_eq_bot is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel_bot_iff_eq_bot AffineSubspace.parallel_bot_iff_eq_botₓ'. -/
@[simp]
theorem parallel_bot_iff_eq_bot {s : AffineSubspace k P} : s ∥ ⊥ ↔ s = ⊥ :=
  by
  refine' ⟨fun h => _, fun h => h ▸ parallel.refl _⟩
  rcases h with ⟨v, h⟩
  rwa [eq_comm, map_eq_bot_iff] at h
#align affine_subspace.parallel_bot_iff_eq_bot AffineSubspace.parallel_bot_iff_eq_bot

/- warning: affine_subspace.bot_parallel_iff_eq_bot -> AffineSubspace.bot_parallel_iff_eq_bot is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))) s) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))) s) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.bot_parallel_iff_eq_bot AffineSubspace.bot_parallel_iff_eq_botₓ'. -/
@[simp]
theorem bot_parallel_iff_eq_bot {s : AffineSubspace k P} : ⊥ ∥ s ↔ s = ⊥ := by
  rw [parallel_comm, parallel_bot_iff_eq_bot]
#align affine_subspace.bot_parallel_iff_eq_bot AffineSubspace.bot_parallel_iff_eq_bot

/- warning: affine_subspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot -> AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) (And (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (Iff (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₂ (Bot.bot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasBot.{u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4))))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4} {s₂ : AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4}, Iff (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁ s₂) (And (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (AffineSubspace.direction.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (Iff (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₁ (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (Eq.{succ u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) s₂ (Bot.bot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (CompleteLattice.toBot.{u1} (AffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4))))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_botₓ'. -/
theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s₁ s₂ : AffineSubspace k P} :
    s₁ ∥ s₂ ↔ s₁.direction = s₂.direction ∧ (s₁ = ⊥ ↔ s₂ = ⊥) :=
  by
  refine' ⟨fun h => ⟨h.direction_eq, _, _⟩, fun h => _⟩
  · rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  · rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  · rcases h with ⟨hd, hb⟩
    by_cases hs₁ : s₁ = ⊥
    · rw [hs₁, bot_parallel_iff_eq_bot]
      exact hb.1 hs₁
    · have hs₂ : s₂ ≠ ⊥ := hb.not.1 hs₁
      rcases(nonempty_iff_ne_bot s₁).2 hs₁ with ⟨p₁, hp₁⟩
      rcases(nonempty_iff_ne_bot s₂).2 hs₂ with ⟨p₂, hp₂⟩
      refine' ⟨p₂ -ᵥ p₁, (eq_iff_direction_eq_of_mem hp₂ _).2 _⟩
      · rw [mem_map]
        refine' ⟨p₁, hp₁, _⟩
        simp
      · simpa using hd.symm
#align affine_subspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot

/- warning: affine_subspace.parallel.vector_span_eq -> AffineSubspace.Parallel.vectorSpan_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) -> (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, (AffineSubspace.Parallel.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) -> (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂))
Case conversion may be inaccurate. Consider using '#align affine_subspace.parallel.vector_span_eq AffineSubspace.Parallel.vectorSpan_eqₓ'. -/
theorem Parallel.vectorSpan_eq {s₁ s₂ : Set P} (h : affineSpan k s₁ ∥ affineSpan k s₂) :
    vectorSpan k s₁ = vectorSpan k s₂ :=
  by
  simp_rw [← direction_affineSpan]
  exact h.direction_eq
#align affine_subspace.parallel.vector_span_eq AffineSubspace.Parallel.vectorSpan_eq

/- warning: affine_subspace.affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty -> AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (And (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (Iff (Eq.{succ u3} (Set.{u3} P) s₁ (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P))) (Eq.{succ u3} (Set.{u3} P) s₂ (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.hasEmptyc.{u3} P)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s₁ : Set.{u3} P} {s₂ : Set.{u3} P}, Iff (AffineSubspace.Parallel.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (And (Eq.{succ u1} (Submodule.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₁) (vectorSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s₂)) (Iff (Eq.{succ u3} (Set.{u3} P) s₁ (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.instEmptyCollectionSet.{u3} P))) (Eq.{succ u3} (Set.{u3} P) s₂ (EmptyCollection.emptyCollection.{u3} (Set.{u3} P) (Set.instEmptyCollectionSet.{u3} P)))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_emptyₓ'. -/
theorem affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty {s₁ s₂ : Set P} :
    affineSpan k s₁ ∥ affineSpan k s₂ ↔ vectorSpan k s₁ = vectorSpan k s₂ ∧ (s₁ = ∅ ↔ s₂ = ∅) :=
  by
  simp_rw [← direction_affineSpan, ← affineSpan_eq_bot k]
  exact parallel_iff_direction_eq_and_eq_bot_iff_eq_bot
#align affine_subspace.affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty

/- warning: affine_subspace.affine_span_pair_parallel_iff_vector_span_eq -> AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P}, Iff (AffineSubspace.Parallel.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄)))) (Eq.{succ u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₁ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₂))) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) p₃ (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₄))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P} {p₃ : P} {p₄ : P}, Iff (AffineSubspace.Parallel.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))) (affineSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₃ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₄)))) (Eq.{succ u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (vectorSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₁ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₂))) (vectorSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u1, u1} P (Set.{u1} P) (Set.instInsertSet.{u1} P) p₃ (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₄))))
Case conversion may be inaccurate. Consider using '#align affine_subspace.affine_span_pair_parallel_iff_vector_span_eq AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eqₓ'. -/
theorem affineSpan_pair_parallel_iff_vectorSpan_eq {p₁ p₂ p₃ p₄ : P} :
    line[k, p₁, p₂] ∥ line[k, p₃, p₄] ↔
      vectorSpan k ({p₁, p₂} : Set P) = vectorSpan k ({p₃, p₄} : Set P) :=
  by
  simp [affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty, ←
    not_nonempty_iff_eq_empty]
#align affine_subspace.affine_span_pair_parallel_iff_vector_span_eq AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eq

end AffineSubspace

