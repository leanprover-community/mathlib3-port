/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module linear_algebra.affine_space.midpoint
! leanprover-community/mathlib commit cb3ceec8485239a61ed51d944cb9a95b68c6bafc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Invertible
import Mathbin.LinearAlgebra.AffineSpace.AffineEquiv

/-!
# Midpoint of a segment

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

* `midpoint R x y`: midpoint of the segment `[x, y]`. We define it for `x` and `y`
  in a module over a ring `R` with invertible `2`.
* `add_monoid_hom.of_map_midpoint`: construct an `add_monoid_hom` given a map `f` such that
  `f` sends zero to zero and midpoints to midpoints.

## Main theorems

* `midpoint_eq_iff`: `z` is the midpoint of `[x, y]` if and only if `x + y = z + z`,
* `midpoint_unique`: `midpoint R x y` does not depend on `R`;
* `midpoint x y` is linear both in `x` and `y`;
* `point_reflection_midpoint_left`, `point_reflection_midpoint_right`:
  `equiv.point_reflection (midpoint R x y)` swaps `x` and `y`.

We do not mark most lemmas as `@[simp]` because it is hard to tell which side is simpler.

## Tags

midpoint, add_monoid_hom
-/


open AffineMap AffineEquiv

section

variable (R : Type _) {V V' P P' : Type _} [Ring R] [Invertible (2 : R)] [AddCommGroup V]
  [Module R V] [AddTorsor V P] [AddCommGroup V'] [Module R V'] [AddTorsor V' P']

include V

/- warning: midpoint -> midpoint is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)], P -> P -> P
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)], P -> P -> P
Case conversion may be inaccurate. Consider using '#align midpoint midpointₓ'. -/
/-- `midpoint x y` is the midpoint of the segment `[x, y]`. -/
def midpoint (x y : P) : P :=
  lineMap x y (⅟ 2 : R)
#align midpoint midpoint

variable {R} {x y z : P}

include V'

/- warning: affine_map.map_midpoint -> AffineMap.map_midpoint is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align affine_map.map_midpoint AffineMap.map_midpointₓ'. -/
@[simp]
theorem AffineMap.map_midpoint (f : P →ᵃ[R] P') (a b : P) :
    f (midpoint R a b) = midpoint R (f a) (f b) :=
  f.apply_lineMap a b _
#align affine_map.map_midpoint AffineMap.map_midpoint

/- warning: affine_equiv.map_midpoint -> AffineEquiv.map_midpoint is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align affine_equiv.map_midpoint AffineEquiv.map_midpointₓ'. -/
@[simp]
theorem AffineEquiv.map_midpoint (f : P ≃ᵃ[R] P') (a b : P) :
    f (midpoint R a b) = midpoint R (f a) (f b) :=
  f.apply_lineMap a b _
#align affine_equiv.map_midpoint AffineEquiv.map_midpoint

omit V'

/- warning: affine_equiv.point_reflection_midpoint_left -> AffineEquiv.pointReflection_midpoint_left is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_midpoint_left AffineEquiv.pointReflection_midpoint_leftₓ'. -/
@[simp]
theorem AffineEquiv.pointReflection_midpoint_left (x y : P) :
    pointReflection R (midpoint R x y) x = y := by
  rw [midpoint, point_reflection_apply, line_map_apply, vadd_vsub, vadd_vadd, ← add_smul, ← two_mul,
    mul_invOf_self, one_smul, vsub_vadd]
#align affine_equiv.point_reflection_midpoint_left AffineEquiv.pointReflection_midpoint_left

/- warning: midpoint_comm -> midpoint_comm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (x : P) (y : P), Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 y x)
but is expected to have type
  forall {R : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] (x : P) (y : P), Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 y x)
Case conversion may be inaccurate. Consider using '#align midpoint_comm midpoint_commₓ'. -/
theorem midpoint_comm (x y : P) : midpoint R x y = midpoint R y x := by
  rw [midpoint, ← line_map_apply_one_sub, one_sub_invOf_two, midpoint]
#align midpoint_comm midpoint_comm

/- warning: affine_equiv.point_reflection_midpoint_right -> AffineEquiv.pointReflection_midpoint_right is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_midpoint_right AffineEquiv.pointReflection_midpoint_rightₓ'. -/
@[simp]
theorem AffineEquiv.pointReflection_midpoint_right (x y : P) :
    pointReflection R (midpoint R x y) y = x := by
  rw [midpoint_comm, AffineEquiv.pointReflection_midpoint_left]
#align affine_equiv.point_reflection_midpoint_right AffineEquiv.pointReflection_midpoint_right

/- warning: midpoint_vsub_midpoint -> midpoint_vsub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P) (p₃ : P) (p₄ : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₃ p₄)) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₁ p₃) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₂ p₄))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P) (p₃ : P) (p₄ : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₃ p₄)) (midpoint.{u1, u3, u3} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_3)) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₁ p₃) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₂ p₄))
Case conversion may be inaccurate. Consider using '#align midpoint_vsub_midpoint midpoint_vsub_midpointₓ'. -/
theorem midpoint_vsub_midpoint (p₁ p₂ p₃ p₄ : P) :
    midpoint R p₁ p₂ -ᵥ midpoint R p₃ p₄ = midpoint R (p₁ -ᵥ p₃) (p₂ -ᵥ p₄) :=
  lineMap_vsub_lineMap _ _ _ _ _
#align midpoint_vsub_midpoint midpoint_vsub_midpoint

/- warning: midpoint_vadd_midpoint -> midpoint_vadd_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (v : V) (v' : V) (p : P) (p' : P), Eq.{succ u3} P (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5)) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v v') (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p p')) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5)) v p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5)) v' p'))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (v : V) (v' : V) (p : P) (p' : P), Eq.{succ u3} P (HVAdd.hVAdd.{u2, u3, u3} V P P (instHVAdd.{u2, u3} V P (AddAction.toVAdd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v v') (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p p')) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 (HVAdd.hVAdd.{u2, u3, u3} V P P (instHVAdd.{u2, u3} V P (AddAction.toVAdd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5))) v p) (HVAdd.hVAdd.{u2, u3, u3} V P P (instHVAdd.{u2, u3} V P (AddAction.toVAdd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5))) v' p'))
Case conversion may be inaccurate. Consider using '#align midpoint_vadd_midpoint midpoint_vadd_midpointₓ'. -/
theorem midpoint_vadd_midpoint (v v' : V) (p p' : P) :
    midpoint R v v' +ᵥ midpoint R p p' = midpoint R (v +ᵥ p) (v' +ᵥ p') :=
  lineMap_vadd_lineMap _ _ _ _ _
#align midpoint_vadd_midpoint midpoint_vadd_midpoint

/- warning: midpoint_eq_iff -> midpoint_eq_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align midpoint_eq_iff midpoint_eq_iffₓ'. -/
theorem midpoint_eq_iff {x y z : P} : midpoint R x y = z ↔ pointReflection R z x = y :=
  eq_comm.trans
    ((injective_pointReflection_left_of_module R x).eq_iff'
        (AffineEquiv.pointReflection_midpoint_left x y)).symm
#align midpoint_eq_iff midpoint_eq_iff

/- warning: midpoint_vsub_left -> midpoint_vsub_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p₁) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₂ p₁))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p₁) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₂ p₁))
Case conversion may be inaccurate. Consider using '#align midpoint_vsub_left midpoint_vsub_leftₓ'. -/
@[simp]
theorem midpoint_vsub_left (p₁ p₂ : P) : midpoint R p₁ p₂ -ᵥ p₁ = (⅟ 2 : R) • (p₂ -ᵥ p₁) :=
  lineMap_vsub_left _ _ _
#align midpoint_vsub_left midpoint_vsub_left

/- warning: midpoint_vsub_right -> midpoint_vsub_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p₂) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₁ p₂))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p₂) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₁ p₂))
Case conversion may be inaccurate. Consider using '#align midpoint_vsub_right midpoint_vsub_rightₓ'. -/
@[simp]
theorem midpoint_vsub_right (p₁ p₂ : P) : midpoint R p₁ p₂ -ᵥ p₂ = (⅟ 2 : R) • (p₁ -ᵥ p₂) := by
  rw [midpoint_comm, midpoint_vsub_left]
#align midpoint_vsub_right midpoint_vsub_right

/- warning: left_vsub_midpoint -> left_vsub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₁ (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₁ p₂))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₁ (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₁ p₂))
Case conversion may be inaccurate. Consider using '#align left_vsub_midpoint left_vsub_midpointₓ'. -/
@[simp]
theorem left_vsub_midpoint (p₁ p₂ : P) : p₁ -ᵥ midpoint R p₁ p₂ = (⅟ 2 : R) • (p₁ -ᵥ p₂) :=
  left_vsub_lineMap _ _ _
#align left_vsub_midpoint left_vsub_midpoint

/- warning: right_vsub_midpoint -> right_vsub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₂ (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₂ p₁))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₂ (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₂ p₁))
Case conversion may be inaccurate. Consider using '#align right_vsub_midpoint right_vsub_midpointₓ'. -/
@[simp]
theorem right_vsub_midpoint (p₁ p₂ : P) : p₂ -ᵥ midpoint R p₁ p₂ = (⅟ 2 : R) • (p₂ -ᵥ p₁) := by
  rw [midpoint_comm, left_vsub_midpoint]
#align right_vsub_midpoint right_vsub_midpoint

/- warning: midpoint_vsub -> midpoint_vsub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P) (p : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₁ p)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p₂ p)))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P) (p : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂) p) (HAdd.hAdd.{u3, u3, u3} V V V (instHAdd.{u3} V (AddZeroClass.toAdd.{u3} V (AddMonoid.toAddZeroClass.{u3} V (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_3)))))) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₁ p)) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p₂ p)))
Case conversion may be inaccurate. Consider using '#align midpoint_vsub midpoint_vsubₓ'. -/
theorem midpoint_vsub (p₁ p₂ p : P) :
    midpoint R p₁ p₂ -ᵥ p = (⅟ 2 : R) • (p₁ -ᵥ p) + (⅟ 2 : R) • (p₂ -ᵥ p) := by
  rw [← vsub_sub_vsub_cancel_right p₁ p p₂, smul_sub, sub_eq_add_neg, ← smul_neg,
    neg_vsub_eq_vsub_rev, add_assoc, invOf_two_smul_add_invOf_two_smul, ← vadd_vsub_assoc,
    midpoint_comm, midpoint, line_map_apply]
#align midpoint_vsub midpoint_vsub

/- warning: vsub_midpoint -> vsub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (p₁ : P) (p₂ : P) (p : P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p p₁)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) p p₂)))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (p₁ : P) (p₂ : P) (p : P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 p₁ p₂)) (HAdd.hAdd.{u3, u3, u3} V V V (instHAdd.{u3} V (AddZeroClass.toAdd.{u3} V (AddMonoid.toAddZeroClass.{u3} V (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_3)))))) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p p₁)) (HSMul.hSMul.{u1, u3, u3} R V V (instHSMul.{u1, u3} R V (SMulZeroClass.toSMul.{u1, u3} R V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_3))))) (Module.toMulActionWithZero.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3) _inst_5) p p₂)))
Case conversion may be inaccurate. Consider using '#align vsub_midpoint vsub_midpointₓ'. -/
theorem vsub_midpoint (p₁ p₂ p : P) :
    p -ᵥ midpoint R p₁ p₂ = (⅟ 2 : R) • (p -ᵥ p₁) + (⅟ 2 : R) • (p -ᵥ p₂) := by
  rw [← neg_vsub_eq_vsub_rev, midpoint_vsub, neg_add, ← smul_neg, ← smul_neg, neg_vsub_eq_vsub_rev,
    neg_vsub_eq_vsub_rev]
#align vsub_midpoint vsub_midpoint

/- warning: midpoint_sub_left -> midpoint_sub_left is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂) v₁) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ v₁))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂) v₁) (HSMul.hSMul.{u1, u2, u2} R V V (instHSMul.{u1, u2} R V (SMulZeroClass.toSMul.{u1, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ v₁))
Case conversion may be inaccurate. Consider using '#align midpoint_sub_left midpoint_sub_leftₓ'. -/
@[simp]
theorem midpoint_sub_left (v₁ v₂ : V) : midpoint R v₁ v₂ - v₁ = (⅟ 2 : R) • (v₂ - v₁) :=
  midpoint_vsub_left v₁ v₂
#align midpoint_sub_left midpoint_sub_left

/- warning: midpoint_sub_right -> midpoint_sub_right is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂) v₂) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ v₂))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂) v₂) (HSMul.hSMul.{u1, u2, u2} R V V (instHSMul.{u1, u2} R V (SMulZeroClass.toSMul.{u1, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ v₂))
Case conversion may be inaccurate. Consider using '#align midpoint_sub_right midpoint_sub_rightₓ'. -/
@[simp]
theorem midpoint_sub_right (v₁ v₂ : V) : midpoint R v₁ v₂ - v₂ = (⅟ 2 : R) • (v₁ - v₂) :=
  midpoint_vsub_right v₁ v₂
#align midpoint_sub_right midpoint_sub_right

/- warning: left_sub_midpoint -> left_sub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ v₂))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂)) (HSMul.hSMul.{u1, u2, u2} R V V (instHSMul.{u1, u2} R V (SMulZeroClass.toSMul.{u1, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₁ v₂))
Case conversion may be inaccurate. Consider using '#align left_sub_midpoint left_sub_midpointₓ'. -/
@[simp]
theorem left_sub_midpoint (v₁ v₂ : V) : v₁ - midpoint R v₁ v₂ = (⅟ 2 : R) • (v₁ - v₂) :=
  left_vsub_midpoint v₁ v₂
#align left_sub_midpoint left_sub_midpoint

/- warning: right_sub_midpoint -> right_sub_midpoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂)) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ v₁))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (v₁ : V) (v₂ : V), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) v₁ v₂)) (HSMul.hSMul.{u1, u2, u2} R V V (instHSMul.{u1, u2} R V (SMulZeroClass.toSMul.{u1, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) v₂ v₁))
Case conversion may be inaccurate. Consider using '#align right_sub_midpoint right_sub_midpointₓ'. -/
@[simp]
theorem right_sub_midpoint (v₁ v₂ : V) : v₂ - midpoint R v₁ v₂ = (⅟ 2 : R) • (v₂ - v₁) :=
  right_vsub_midpoint v₁ v₂
#align right_sub_midpoint right_sub_midpoint

variable (R)

/- warning: midpoint_eq_left_iff -> midpoint_eq_left_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) x) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) x) (Eq.{succ u3} P x y)
Case conversion may be inaccurate. Consider using '#align midpoint_eq_left_iff midpoint_eq_left_iffₓ'. -/
@[simp]
theorem midpoint_eq_left_iff {x y : P} : midpoint R x y = x ↔ x = y := by
  rw [midpoint_eq_iff, point_reflection_self]
#align midpoint_eq_left_iff midpoint_eq_left_iff

/- warning: left_eq_midpoint_iff -> left_eq_midpoint_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P x (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y)) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P x (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y)) (Eq.{succ u3} P x y)
Case conversion may be inaccurate. Consider using '#align left_eq_midpoint_iff left_eq_midpoint_iffₓ'. -/
@[simp]
theorem left_eq_midpoint_iff {x y : P} : x = midpoint R x y ↔ x = y := by
  rw [eq_comm, midpoint_eq_left_iff]
#align left_eq_midpoint_iff left_eq_midpoint_iff

/- warning: midpoint_eq_right_iff -> midpoint_eq_right_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) y) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) y) (Eq.{succ u3} P x y)
Case conversion may be inaccurate. Consider using '#align midpoint_eq_right_iff midpoint_eq_right_iffₓ'. -/
@[simp]
theorem midpoint_eq_right_iff {x y : P} : midpoint R x y = y ↔ x = y := by
  rw [midpoint_comm, midpoint_eq_left_iff, eq_comm]
#align midpoint_eq_right_iff midpoint_eq_right_iff

/- warning: right_eq_midpoint_iff -> right_eq_midpoint_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P y (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y)) (Eq.{succ u3} P x y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {y : P}, Iff (Eq.{succ u3} P y (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y)) (Eq.{succ u3} P x y)
Case conversion may be inaccurate. Consider using '#align right_eq_midpoint_iff right_eq_midpoint_iffₓ'. -/
@[simp]
theorem right_eq_midpoint_iff {x y : P} : y = midpoint R x y ↔ x = y := by
  rw [eq_comm, midpoint_eq_right_iff]
#align right_eq_midpoint_iff right_eq_midpoint_iff

/- warning: midpoint_eq_midpoint_iff_vsub_eq_vsub -> midpoint_eq_midpoint_iff_vsub_eq_vsub is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {x' : P} {y : P} {y' : P}, Iff (Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x' y')) (Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) x x') (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5) y' y))
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {x' : P} {y : P} {y' : P}, Iff (Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x' y')) (Eq.{succ u1} V (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3) _inst_5) x x') (VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3) _inst_5) y' y))
Case conversion may be inaccurate. Consider using '#align midpoint_eq_midpoint_iff_vsub_eq_vsub midpoint_eq_midpoint_iff_vsub_eq_vsubₓ'. -/
theorem midpoint_eq_midpoint_iff_vsub_eq_vsub {x x' y y' : P} :
    midpoint R x y = midpoint R x' y' ↔ x -ᵥ x' = y' -ᵥ y := by
  rw [← @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply,
    vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_eq_neg, neg_vsub_eq_vsub_rev]
#align midpoint_eq_midpoint_iff_vsub_eq_vsub midpoint_eq_midpoint_iff_vsub_eq_vsub

/- warning: midpoint_eq_iff' -> midpoint_eq_iff' is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] {x : P} {y : P} {z : P}, Iff (Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) z) (Eq.{succ u3} P (coeFn.{succ u3, succ u3} (Equiv.Perm.{succ u3} P) (fun (_x : Equiv.{succ u3, succ u3} P P) => P -> P) (Equiv.hasCoeToFun.{succ u3, succ u3} P P) (Equiv.pointReflection.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3) _inst_5 z) x) y)
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] {x : P} {y : P} {z : P}, Iff (Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) z) (Eq.{succ u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : P) => P) x) (FunLike.coe.{succ u3, succ u3, succ u3} (Equiv.Perm.{succ u3} P) P (fun (_x : P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : P) => P) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u3} P P) (Equiv.pointReflection.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3) _inst_5 z) x) y)
Case conversion may be inaccurate. Consider using '#align midpoint_eq_iff' midpoint_eq_iff'ₓ'. -/
theorem midpoint_eq_iff' {x y z : P} : midpoint R x y = z ↔ Equiv.pointReflection z x = y :=
  midpoint_eq_iff
#align midpoint_eq_iff' midpoint_eq_iff'

/- warning: midpoint_unique -> midpoint_unique is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (R' : Type.{u4}) [_inst_9 : Ring.{u4} R'] [_inst_10 : Invertible.{u4} R' (Distrib.toHasMul.{u4} R' (Ring.toDistrib.{u4} R' _inst_9)) (AddMonoidWithOne.toOne.{u4} R' (AddGroupWithOne.toAddMonoidWithOne.{u4} R' (AddCommGroupWithOne.toAddGroupWithOne.{u4} R' (Ring.toAddCommGroupWithOne.{u4} R' _inst_9)))) (OfNat.ofNat.{u4} R' 2 (OfNat.mk.{u4} R' 2 (bit0.{u4} R' (Distrib.toHasAdd.{u4} R' (Ring.toDistrib.{u4} R' _inst_9)) (One.one.{u4} R' (AddMonoidWithOne.toOne.{u4} R' (AddGroupWithOne.toAddMonoidWithOne.{u4} R' (AddCommGroupWithOne.toAddGroupWithOne.{u4} R' (Ring.toAddCommGroupWithOne.{u4} R' _inst_9))))))))] [_inst_11 : Module.{u4, u2} R' V (Ring.toSemiring.{u4} R' _inst_9) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : P) (y : P), Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u4, u2, u3} R' V P _inst_9 _inst_10 _inst_3 _inst_11 _inst_5 x y)
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} V] [_inst_4 : Module.{u1, u3} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] [_inst_5 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_3)] (R' : Type.{u4}) [_inst_9 : Ring.{u4} R'] [_inst_10 : Invertible.{u4} R' (NonUnitalNonAssocRing.toMul.{u4} R' (NonAssocRing.toNonUnitalNonAssocRing.{u4} R' (Ring.toNonAssocRing.{u4} R' _inst_9))) (Semiring.toOne.{u4} R' (Ring.toSemiring.{u4} R' _inst_9)) (OfNat.ofNat.{u4} R' 2 (instOfNat.{u4} R' 2 (Semiring.toNatCast.{u4} R' (Ring.toSemiring.{u4} R' _inst_9)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_11 : Module.{u4, u3} R' V (Ring.toSemiring.{u4} R' _inst_9) (AddCommGroup.toAddCommMonoid.{u3} V _inst_3)] (x : P) (y : P), Eq.{succ u2} P (midpoint.{u1, u3, u2} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x y) (midpoint.{u4, u3, u2} R' V P _inst_9 _inst_10 _inst_3 _inst_11 _inst_5 x y)
Case conversion may be inaccurate. Consider using '#align midpoint_unique midpoint_uniqueₓ'. -/
/-- `midpoint` does not depend on the ring `R`. -/
theorem midpoint_unique (R' : Type _) [Ring R'] [Invertible (2 : R')] [Module R' V] (x y : P) :
    midpoint R x y = midpoint R' x y :=
  (midpoint_eq_iff' R).2 <| (midpoint_eq_iff' R').1 rfl
#align midpoint_unique midpoint_unique

/- warning: midpoint_self -> midpoint_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] [_inst_5 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_3)] (x : P), Eq.{succ u3} P (midpoint.{u1, u2, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x x) x
but is expected to have type
  forall (R : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} R] [_inst_2 : Invertible.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R _inst_1))) (Semiring.toOne.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (OfNat.ofNat.{u2} R 2 (instOfNat.{u2} R 2 (Semiring.toNatCast.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u1} V] [_inst_4 : Module.{u2, u1} R V (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_3)] [_inst_5 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_3)] (x : P), Eq.{succ u3} P (midpoint.{u2, u1, u3} R V P _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 x x) x
Case conversion may be inaccurate. Consider using '#align midpoint_self midpoint_selfₓ'. -/
@[simp]
theorem midpoint_self (x : P) : midpoint R x x = x :=
  lineMap_same_apply _ _
#align midpoint_self midpoint_self

/- warning: midpoint_add_self -> midpoint_add_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y)) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y)) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)
Case conversion may be inaccurate. Consider using '#align midpoint_add_self midpoint_add_selfₓ'. -/
@[simp]
theorem midpoint_add_self (x y : V) : midpoint R x y + midpoint R x y = x + y :=
  calc
    midpoint R x y +ᵥ midpoint R x y = midpoint R x y +ᵥ midpoint R y x := by rw [midpoint_comm]
    _ = x + y := by rw [midpoint_vadd_midpoint, vadd_eq_add, vadd_eq_add, add_comm, midpoint_self]
    
#align midpoint_add_self midpoint_add_self

/- warning: midpoint_zero_add -> midpoint_zero_add is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))))) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y)
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))))) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)) (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y)
Case conversion may be inaccurate. Consider using '#align midpoint_zero_add midpoint_zero_addₓ'. -/
theorem midpoint_zero_add (x y : V) : midpoint R 0 (x + y) = midpoint R x y :=
  (midpoint_eq_midpoint_iff_vsub_eq_vsub R).2 <| by simp [sub_add_eq_sub_sub_swap]
#align midpoint_zero_add midpoint_zero_add

/- warning: midpoint_eq_smul_add -> midpoint_eq_smul_add is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y) (SMul.smul.{u1, u2} R V (SMulZeroClass.toHasSmul.{u1, u2} R V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R V (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4)))) (Invertible.invOf.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))))))) _inst_2) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y))
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x y) (HSMul.hSMul.{u1, u2, u2} R V V (instHSMul.{u1, u2} R V (SMulZeroClass.toSMul.{u1, u2} R V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R V (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R V (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) (Module.toMulActionWithZero.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3) _inst_4))))) (Invertible.invOf.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) _inst_2) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y))
Case conversion may be inaccurate. Consider using '#align midpoint_eq_smul_add midpoint_eq_smul_addₓ'. -/
theorem midpoint_eq_smul_add (x y : V) : midpoint R x y = (⅟ 2 : R) • (x + y) := by
  rw [midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, vadd_eq_add, sub_add_eq_add_sub, ←
    two_smul R, smul_smul, mul_invOf_self, one_smul, add_sub_cancel']
#align midpoint_eq_smul_add midpoint_eq_smul_add

/- warning: midpoint_self_neg -> midpoint_self_neg is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x (Neg.neg.{u2} V (SubNegMonoid.toHasNeg.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) x)) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))))))))
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) x (Neg.neg.{u2} V (NegZeroClass.toNeg.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) x)) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align midpoint_self_neg midpoint_self_negₓ'. -/
@[simp]
theorem midpoint_self_neg (x : V) : midpoint R x (-x) = 0 := by
  rw [midpoint_eq_smul_add, add_neg_self, smul_zero]
#align midpoint_self_neg midpoint_self_neg

/- warning: midpoint_neg_self -> midpoint_neg_self is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (Neg.neg.{u2} V (SubNegMonoid.toHasNeg.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))) x) x) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3))))))))
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (Neg.neg.{u2} V (NegZeroClass.toNeg.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3))))) x) x) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align midpoint_neg_self midpoint_neg_selfₓ'. -/
@[simp]
theorem midpoint_neg_self (x : V) : midpoint R (-x) x = 0 := by simpa using midpoint_self_neg R (-x)
#align midpoint_neg_self midpoint_neg_self

/- warning: midpoint_sub_add -> midpoint_sub_add is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) x y) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)) x
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) x y) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y)) x
Case conversion may be inaccurate. Consider using '#align midpoint_sub_add midpoint_sub_addₓ'. -/
@[simp]
theorem midpoint_sub_add (x y : V) : midpoint R (x - y) (x + y) = x := by
  rw [sub_eq_add_neg, ← vadd_eq_add, ← vadd_eq_add, ← midpoint_vadd_midpoint] <;> simp
#align midpoint_sub_add midpoint_sub_add

/- warning: midpoint_add_sub -> midpoint_add_sub is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) x y)) x
but is expected to have type
  forall (R : Type.{u1}) {V : Type.{u2}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u2} V] [_inst_4 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_3)] (x : V) (y : V), Eq.{succ u2} V (midpoint.{u1, u2, u2} R V V _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)) (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))))) x y) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_3)))) x y)) x
Case conversion may be inaccurate. Consider using '#align midpoint_add_sub midpoint_add_subₓ'. -/
@[simp]
theorem midpoint_add_sub (x y : V) : midpoint R (x + y) (x - y) = x := by
  rw [midpoint_comm] <;> simp
#align midpoint_add_sub midpoint_add_sub

end

namespace AddMonoidHom

variable (R R' : Type _) {E F : Type _} [Ring R] [Invertible (2 : R)] [AddCommGroup E] [Module R E]
  [Ring R'] [Invertible (2 : R')] [AddCommGroup F] [Module R' F]

/- warning: add_monoid_hom.of_map_midpoint -> AddMonoidHom.ofMapMidpoint is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (R' : Type.{u2}) {E : Type.{u3}} {F : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1)))) (OfNat.ofNat.{u1} R 2 (OfNat.mk.{u1} R 2 (bit0.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R _inst_1)) (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R _inst_1))))))))] [_inst_3 : AddCommGroup.{u3} E] [_inst_4 : Module.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_3)] [_inst_5 : Ring.{u2} R'] [_inst_6 : Invertible.{u2} R' (Distrib.toHasMul.{u2} R' (Ring.toDistrib.{u2} R' _inst_5)) (AddMonoidWithOne.toOne.{u2} R' (AddGroupWithOne.toAddMonoidWithOne.{u2} R' (AddCommGroupWithOne.toAddGroupWithOne.{u2} R' (Ring.toAddCommGroupWithOne.{u2} R' _inst_5)))) (OfNat.ofNat.{u2} R' 2 (OfNat.mk.{u2} R' 2 (bit0.{u2} R' (Distrib.toHasAdd.{u2} R' (Ring.toDistrib.{u2} R' _inst_5)) (One.one.{u2} R' (AddMonoidWithOne.toOne.{u2} R' (AddGroupWithOne.toAddMonoidWithOne.{u2} R' (AddCommGroupWithOne.toAddGroupWithOne.{u2} R' (Ring.toAddCommGroupWithOne.{u2} R' _inst_5))))))))] [_inst_7 : AddCommGroup.{u4} F] [_inst_8 : Module.{u2, u4} R' F (Ring.toSemiring.{u2} R' _inst_5) (AddCommGroup.toAddCommMonoid.{u4} F _inst_7)] (f : E -> F), (Eq.{succ u4} F (f (OfNat.ofNat.{u3} E 0 (OfNat.mk.{u3} E 0 (Zero.zero.{u3} E (AddZeroClass.toHasZero.{u3} E (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_3))))))))) (OfNat.ofNat.{u4} F 0 (OfNat.mk.{u4} F 0 (Zero.zero.{u4} F (AddZeroClass.toHasZero.{u4} F (AddMonoid.toAddZeroClass.{u4} F (SubNegMonoid.toAddMonoid.{u4} F (AddGroup.toSubNegMonoid.{u4} F (AddCommGroup.toAddGroup.{u4} F _inst_7))))))))) -> (forall (x : E) (y : E), Eq.{succ u4} F (f (midpoint.{u1, u3, u3} R E E _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_3)) x y)) (midpoint.{u2, u4, u4} R' F F _inst_5 _inst_6 _inst_7 _inst_8 (addGroupIsAddTorsor.{u4} F (AddCommGroup.toAddGroup.{u4} F _inst_7)) (f x) (f y))) -> (AddMonoidHom.{u3, u4} E F (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_3)))) (AddMonoid.toAddZeroClass.{u4} F (SubNegMonoid.toAddMonoid.{u4} F (AddGroup.toSubNegMonoid.{u4} F (AddCommGroup.toAddGroup.{u4} F _inst_7)))))
but is expected to have type
  forall (R : Type.{u1}) (R' : Type.{u2}) {E : Type.{u3}} {F : Type.{u4}} [_inst_1 : Ring.{u1} R] [_inst_2 : Invertible.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R _inst_1))) (Semiring.toOne.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (OfNat.ofNat.{u1} R 2 (instOfNat.{u1} R 2 (Semiring.toNatCast.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_3 : AddCommGroup.{u3} E] [_inst_4 : Module.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_3)] [_inst_5 : Ring.{u2} R'] [_inst_6 : Invertible.{u2} R' (NonUnitalNonAssocRing.toMul.{u2} R' (NonAssocRing.toNonUnitalNonAssocRing.{u2} R' (Ring.toNonAssocRing.{u2} R' _inst_5))) (Semiring.toOne.{u2} R' (Ring.toSemiring.{u2} R' _inst_5)) (OfNat.ofNat.{u2} R' 2 (instOfNat.{u2} R' 2 (Semiring.toNatCast.{u2} R' (Ring.toSemiring.{u2} R' _inst_5)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] [_inst_7 : AddCommGroup.{u4} F] [_inst_8 : Module.{u2, u4} R' F (Ring.toSemiring.{u2} R' _inst_5) (AddCommGroup.toAddCommMonoid.{u4} F _inst_7)] (f : E -> F), (Eq.{succ u4} F (f (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_3)))))))) (OfNat.ofNat.{u4} F 0 (Zero.toOfNat0.{u4} F (NegZeroClass.toZero.{u4} F (SubNegZeroMonoid.toNegZeroClass.{u4} F (SubtractionMonoid.toSubNegZeroMonoid.{u4} F (SubtractionCommMonoid.toSubtractionMonoid.{u4} F (AddCommGroup.toDivisionAddCommMonoid.{u4} F _inst_7)))))))) -> (forall (x : E) (y : E), Eq.{succ u4} F (f (midpoint.{u1, u3, u3} R E E _inst_1 _inst_2 _inst_3 _inst_4 (addGroupIsAddTorsor.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_3)) x y)) (midpoint.{u2, u4, u4} R' F F _inst_5 _inst_6 _inst_7 _inst_8 (addGroupIsAddTorsor.{u4} F (AddCommGroup.toAddGroup.{u4} F _inst_7)) (f x) (f y))) -> (AddMonoidHom.{u3, u4} E F (AddMonoid.toAddZeroClass.{u3} E (SubNegMonoid.toAddMonoid.{u3} E (AddGroup.toSubNegMonoid.{u3} E (AddCommGroup.toAddGroup.{u3} E _inst_3)))) (AddMonoid.toAddZeroClass.{u4} F (SubNegMonoid.toAddMonoid.{u4} F (AddGroup.toSubNegMonoid.{u4} F (AddCommGroup.toAddGroup.{u4} F _inst_7)))))
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.of_map_midpoint AddMonoidHom.ofMapMidpointₓ'. -/
/-- A map `f : E → F` sending zero to zero and midpoints to midpoints is an `add_monoid_hom`. -/
def ofMapMidpoint (f : E → F) (h0 : f 0 = 0)
    (hm : ∀ x y, f (midpoint R x y) = midpoint R' (f x) (f y)) : E →+ F
    where
  toFun := f
  map_zero' := h0
  map_add' x y :=
    calc
      f (x + y) = f 0 + f (x + y) := by rw [h0, zero_add]
      _ = midpoint R' (f 0) (f (x + y)) + midpoint R' (f 0) (f (x + y)) :=
        (midpoint_add_self _ _ _).symm
      _ = f (midpoint R x y) + f (midpoint R x y) := by rw [← hm, midpoint_zero_add]
      _ = f x + f y := by rw [hm, midpoint_add_self]
      
#align add_monoid_hom.of_map_midpoint AddMonoidHom.ofMapMidpoint

/- warning: add_monoid_hom.coe_of_map_midpoint -> AddMonoidHom.coe_ofMapMidpoint is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align add_monoid_hom.coe_of_map_midpoint AddMonoidHom.coe_ofMapMidpointₓ'. -/
@[simp]
theorem coe_ofMapMidpoint (f : E → F) (h0 : f 0 = 0)
    (hm : ∀ x y, f (midpoint R x y) = midpoint R' (f x) (f y)) :
    ⇑(ofMapMidpoint R R' f h0 hm) = f :=
  rfl
#align add_monoid_hom.coe_of_map_midpoint AddMonoidHom.coe_ofMapMidpoint

end AddMonoidHom

