/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module linear_algebra.affine_space.independent
! leanprover-community/mathlib commit 4f81bc21e32048db7344b7867946e992cf5f68cc
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Finset.Sort
import Mathbin.Data.Fin.VecNotation
import Mathbin.Data.Sign
import Mathbin.LinearAlgebra.AffineSpace.Combination
import Mathbin.LinearAlgebra.AffineSpace.AffineEquiv
import Mathbin.LinearAlgebra.Basis

/-!
# Affine independence

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines affinely independent families of points.

## Main definitions

* `affine_independent` defines affinely independent families of points
  as those where no nontrivial weighted subtraction is `0`.  This is
  proved equivalent to two other formulations: linear independence of
  the results of subtracting a base point in the family from the other
  points in the family, or any equal affine combinations having the
  same weights.  A bundled type `simplex` is provided for finite
  affinely independent families of points, with an abbreviation
  `triangle` for the case of three points.

## References

* https://en.wikipedia.org/wiki/Affine_space

-/


noncomputable section

open BigOperators Affine

open Function

section AffineIndependent

variable (k : Type _) {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]

variable [affine_space V P] {ι : Type _}

include V

#print AffineIndependent /-
/-- An indexed family is said to be affinely independent if no
nontrivial weighted subtractions (where the sum of weights is 0) are
0. -/
def AffineIndependent (p : ι → P) : Prop :=
  ∀ (s : Finset ι) (w : ι → k),
    (∑ i in s, w i) = 0 → s.weightedVSub p w = (0 : V) → ∀ i ∈ s, w i = 0
#align affine_independent AffineIndependent
-/

/- warning: affine_independent_def -> affineIndependent_def is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P), Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (s : Finset.{u4} ι) (w : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))))
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} (p : ι -> P), Iff (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (s : Finset.{u1} ι) (w : ι -> k), (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u4), max (succ u1) (succ u4), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u1 u4, u3} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u1, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) _inst_3 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (OfNat.ofNat.{u3} V 0 (Zero.toOfNat0.{u3} V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2)))))))) -> (forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u4} k (w i) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align affine_independent_def affineIndependent_defₓ'. -/
/-- The definition of `affine_independent`. -/
theorem affineIndependent_def (p : ι → P) :
    AffineIndependent k p ↔
      ∀ (s : Finset ι) (w : ι → k),
        (∑ i in s, w i) = 0 → s.weightedVSub p w = (0 : V) → ∀ i ∈ s, w i = 0 :=
  Iff.rfl
#align affine_independent_def affineIndependent_def

/- warning: affine_independent_of_subsingleton -> affineIndependent_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Subsingleton.{succ u4} ι] (p : ι -> P), AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Subsingleton.{succ u4} ι] (p : ι -> P), AffineIndependent.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p
Case conversion may be inaccurate. Consider using '#align affine_independent_of_subsingleton affineIndependent_of_subsingletonₓ'. -/
/-- A family with at most one point is affinely independent. -/
theorem affineIndependent_of_subsingleton [Subsingleton ι] (p : ι → P) : AffineIndependent k p :=
  fun s w h hs i hi => Fintype.eq_of_subsingleton_of_sum_eq h i hi
#align affine_independent_of_subsingleton affineIndependent_of_subsingleton

/- warning: affine_independent_iff_of_fintype -> affineIndependent_iff_of_fintype is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (w : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (forall (i : ι), Eq.{succ u1} k (w i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Iff (AffineIndependent.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (w : ι -> k), (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) _inst_3 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (forall (i : ι), Eq.{succ u3} k (w i) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_of_fintype affineIndependent_iff_of_fintypeₓ'. -/
/-- A family indexed by a `fintype` is affinely independent if and
only if no nontrivial weighted subtractions over `finset.univ` (where
the sum of the weights is 0) are 0. -/
theorem affineIndependent_iff_of_fintype [Fintype ι] (p : ι → P) :
    AffineIndependent k p ↔
      ∀ w : ι → k, (∑ i, w i) = 0 → Finset.univ.weightedVSub p w = (0 : V) → ∀ i, w i = 0 :=
  by
  constructor
  · exact fun h w hw hs i => h Finset.univ w hw hs i (Finset.mem_univ _)
  · intro h s w hw hs i hi
    rw [Finset.weightedVSub_indicator_subset _ _ (Finset.subset_univ s)] at hs
    rw [Set.sum_indicator_subset _ (Finset.subset_univ s)] at hw
    replace h := h ((↑s : Set ι).indicator w) hw hs i
    simpa [hi] using h
#align affine_independent_iff_of_fintype affineIndependent_iff_of_fintype

/- warning: affine_independent_iff_linear_independent_vsub -> affineIndependent_iff_linearIndependent_vsub is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i1 : ι), Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (LinearIndependent.{u4, u1, u2} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) k V (fun (i : Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1)) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Ne.{succ u4} ι x i1))))) i)) (p i1)) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i1 : ι), Iff (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (LinearIndependent.{u1, u4, u3} (Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i1)) k V (fun (i : Subtype.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i1)) => VSub.vsub.{u3, u2} V P (AddTorsor.toVSub.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4) (p (Subtype.val.{succ u1} ι (fun (x : ι) => Ne.{succ u1} ι x i1) i)) (p i1)) (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_linear_independent_vsub affineIndependent_iff_linearIndependent_vsubₓ'. -/
/-- A family is affinely independent if and only if the differences
from a base point in that family are linearly independent. -/
theorem affineIndependent_iff_linearIndependent_vsub (p : ι → P) (i1 : ι) :
    AffineIndependent k p ↔ LinearIndependent k fun i : { x // x ≠ i1 } => (p i -ᵥ p i1 : V) := by
  classical
    constructor
    · intro h
      rw [linearIndependent_iff']
      intro s g hg i hi
      set f : ι → k := fun x => if hx : x = i1 then -∑ y in s, g y else g ⟨x, hx⟩ with hfdef
      let s2 : Finset ι := insert i1 (s.map (embedding.subtype _))
      have hfg : ∀ x : { x // x ≠ i1 }, g x = f x :=
        by
        intro x
        rw [hfdef]
        dsimp only
        erw [dif_neg x.property, Subtype.coe_eta]
      rw [hfg]
      have hf : (∑ ι in s2, f ι) = 0 :=
        by
        rw [Finset.sum_insert
            (Finset.not_mem_map_subtype_of_not_property s (Classical.not_not.2 rfl)),
          Finset.sum_subtype_map_embedding fun x hx => (hfg x).symm]
        rw [hfdef]
        dsimp only
        rw [dif_pos rfl]
        exact neg_add_self _
      have hs2 : s2.weighted_vsub p f = (0 : V) :=
        by
        set f2 : ι → V := fun x => f x • (p x -ᵥ p i1) with hf2def
        set g2 : { x // x ≠ i1 } → V := fun x => g x • (p x -ᵥ p i1) with hg2def
        have hf2g2 : ∀ x : { x // x ≠ i1 }, f2 x = g2 x :=
          by
          simp_rw [hf2def, hg2def, hfg]
          exact fun x => rfl
        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s2 f p hf (p i1),
          Finset.weightedVSubOfPoint_insert, Finset.weightedVSubOfPoint_apply,
          Finset.sum_subtype_map_embedding fun x hx => hf2g2 x]
        exact hg
      exact h s2 f hf hs2 i (Finset.mem_insert_of_mem (Finset.mem_map.2 ⟨i, hi, rfl⟩))
    · intro h
      rw [linearIndependent_iff'] at h
      intro s w hw hs i hi
      rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p hw (p i1), ←
        s.weighted_vsub_of_point_erase w p i1, Finset.weightedVSubOfPoint_apply] at hs
      let f : ι → V := fun i => w i • (p i -ᵥ p i1)
      have hs2 : (∑ i in (s.erase i1).Subtype fun i => i ≠ i1, f i) = 0 :=
        by
        rw [← hs]
        convert Finset.sum_subtype_of_mem f fun x => Finset.ne_of_mem_erase
      have h2 := h ((s.erase i1).Subtype fun i => i ≠ i1) (fun x => w x) hs2
      simp_rw [Finset.mem_subtype] at h2
      have h2b : ∀ i ∈ s, i ≠ i1 → w i = 0 := fun i his hi =>
        h2 ⟨i, hi⟩ (Finset.mem_erase_of_ne_of_mem hi his)
      exact Finset.eq_zero_of_sum_eq_zero hw h2b i hi
#align affine_independent_iff_linear_independent_vsub affineIndependent_iff_linearIndependent_vsub

/- warning: affine_independent_set_iff_linear_independent_vsub -> affineIndependent_set_iff_linearIndependent_vsub is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {p₁ : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p₁ s) -> (Iff (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) (fun (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s))))) p)) (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) k V (fun (v : coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) x (Set.image.{u3, u2} P V (fun (p : P) => VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (BooleanAlgebra.toHasSdiff.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P)) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁)))))))) v) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {p₁ : P}, (Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) p₁ s) -> (Iff (AffineIndependent.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P s) (fun (p : Set.Elem.{u3} P s) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x s) p)) (LinearIndependent.{u1, u2, u1} (Set.Elem.{u1} V (Set.image.{u3, u1} P V (fun (p : P) => VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (Set.instSDiffSet.{u3} P) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₁)))) k V (fun (v : Set.Elem.{u1} V (Set.image.{u3, u1} P V (fun (p : P) => VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (Set.instSDiffSet.{u3} P) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₁)))) => Subtype.val.{succ u1} V (fun (x : V) => Membership.mem.{u1, u1} V (Set.{u1} V) (Set.instMembershipSet.{u1} V) x (Set.image.{u3, u1} P V (fun (p : P) => VSub.vsub.{u1, u3} V P (AddTorsor.toVSub.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) p p₁) (SDiff.sdiff.{u3} (Set.{u3} P) (Set.instSDiffSet.{u3} P) s (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.instSingletonSet.{u3} P) p₁)))) v) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align affine_independent_set_iff_linear_independent_vsub affineIndependent_set_iff_linearIndependent_vsubₓ'. -/
/-- A set is affinely independent if and only if the differences from
a base point in that set are linearly independent. -/
theorem affineIndependent_set_iff_linearIndependent_vsub {s : Set P} {p₁ : P} (hp₁ : p₁ ∈ s) :
    AffineIndependent k (fun p => p : s → P) ↔
      LinearIndependent k (fun v => v : (fun p => (p -ᵥ p₁ : V)) '' (s \ {p₁}) → V) :=
  by
  rw [affineIndependent_iff_linearIndependent_vsub k (fun p => p : s → P) ⟨p₁, hp₁⟩]
  constructor
  · intro h
    have hv : ∀ v : (fun p => (p -ᵥ p₁ : V)) '' (s \ {p₁}), (v : V) +ᵥ p₁ ∈ s \ {p₁} := fun v =>
      (vsub_left_injective p₁).mem_set_image.1 ((vadd_vsub (v : V) p₁).symm ▸ v.property)
    let f : (fun p : P => (p -ᵥ p₁ : V)) '' (s \ {p₁}) → { x : s // x ≠ ⟨p₁, hp₁⟩ } := fun x =>
      ⟨⟨(x : V) +ᵥ p₁, Set.mem_of_mem_diff (hv x)⟩, fun hx =>
        Set.not_mem_of_mem_diff (hv x) (Subtype.ext_iff.1 hx)⟩
    convert h.comp f fun x1 x2 hx =>
        Subtype.ext (vadd_right_cancel p₁ (Subtype.ext_iff.1 (Subtype.ext_iff.1 hx)))
    ext v
    exact (vadd_vsub (v : V) p₁).symm
  · intro h
    let f : { x : s // x ≠ ⟨p₁, hp₁⟩ } → (fun p : P => (p -ᵥ p₁ : V)) '' (s \ {p₁}) := fun x =>
      ⟨((x : s) : P) -ᵥ p₁, ⟨x, ⟨⟨(x : s).property, fun hx => x.property (Subtype.ext hx)⟩, rfl⟩⟩⟩
    convert h.comp f fun x1 x2 hx =>
        Subtype.ext (Subtype.ext (vsub_left_cancel (Subtype.ext_iff.1 hx)))
#align affine_independent_set_iff_linear_independent_vsub affineIndependent_set_iff_linearIndependent_vsub

/- warning: linear_independent_set_iff_affine_independent_vadd_union_singleton -> linearIndependent_set_iff_affineIndependent_vadd_union_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u2} V}, (forall (v : V), (Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) v s) -> (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))))))) -> (forall (p₁ : P), Iff (LinearIndependent.{u2, u1, u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) k V (fun (v : coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) => (fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Set.{u2} V) Type.{u2} (Set.hasCoeToSort.{u2} V) s) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Set.{u2} V) (Set.hasMem.{u2} V) x s))))) v) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) (fun (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Union.union.{u3} (Set.{u3} P) (Set.hasUnion.{u3} P) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) p₁) (Set.image.{u2, u3} V P (fun (v : V) => VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) v p₁) s))))))) p)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {s : Set.{u3} V}, (forall (v : V), (Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) v s) -> (Ne.{succ u3} V v (OfNat.ofNat.{u3} V 0 (Zero.toOfNat0.{u3} V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))))))) -> (forall (p₁ : P), Iff (LinearIndependent.{u3, u2, u3} (Set.Elem.{u3} V s) k V (fun (v : Set.Elem.{u3} V s) => Subtype.val.{succ u3} V (fun (x : V) => Membership.mem.{u3, u3} V (Set.{u3} V) (Set.instMembershipSet.{u3} V) x s) v) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (AffineIndependent.{u2, u3, u1, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u1} P (Union.union.{u1} (Set.{u1} P) (Set.instUnionSet.{u1} P) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₁) (Set.image.{u3, u1} V P (fun (v : V) => HVAdd.hVAdd.{u3, u1, u1} V P P (instHVAdd.{u3, u1} V P (AddAction.toVAdd.{u3, u1} V P (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2))) (AddTorsor.toAddAction.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4))) v p₁) s))) (fun (p : Set.Elem.{u1} P (Union.union.{u1} (Set.{u1} P) (Set.instUnionSet.{u1} P) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₁) (Set.image.{u3, u1} V P (fun (v : V) => HVAdd.hVAdd.{u3, u1, u1} V P P (instHVAdd.{u3, u1} V P (AddAction.toVAdd.{u3, u1} V P (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2))) (AddTorsor.toAddAction.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4))) v p₁) s))) => Subtype.val.{succ u1} P (fun (x : P) => Membership.mem.{u1, u1} P (Set.{u1} P) (Set.instMembershipSet.{u1} P) x (Union.union.{u1} (Set.{u1} P) (Set.instUnionSet.{u1} P) (Singleton.singleton.{u1, u1} P (Set.{u1} P) (Set.instSingletonSet.{u1} P) p₁) (Set.image.{u3, u1} V P (fun (v : V) => HVAdd.hVAdd.{u3, u1, u1} V P P (instHVAdd.{u3, u1} V P (AddAction.toVAdd.{u3, u1} V P (SubNegMonoid.toAddMonoid.{u3} V (AddGroup.toSubNegMonoid.{u3} V (AddCommGroup.toAddGroup.{u3} V _inst_2))) (AddTorsor.toAddAction.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) _inst_4))) v p₁) s))) p)))
Case conversion may be inaccurate. Consider using '#align linear_independent_set_iff_affine_independent_vadd_union_singleton linearIndependent_set_iff_affineIndependent_vadd_union_singletonₓ'. -/
/-- A set of nonzero vectors is linearly independent if and only if,
given a point `p₁`, the vectors added to `p₁` and `p₁` itself are
affinely independent. -/
theorem linearIndependent_set_iff_affineIndependent_vadd_union_singleton {s : Set V}
    (hs : ∀ v ∈ s, v ≠ (0 : V)) (p₁ : P) :
    LinearIndependent k (fun v => v : s → V) ↔
      AffineIndependent k (fun p => p : {p₁} ∪ (fun v => v +ᵥ p₁) '' s → P) :=
  by
  rw [affineIndependent_set_iff_linearIndependent_vsub k
      (Set.mem_union_left _ (Set.mem_singleton p₁))]
  have h : (fun p => (p -ᵥ p₁ : V)) '' (({p₁} ∪ (fun v => v +ᵥ p₁) '' s) \ {p₁}) = s :=
    by
    simp_rw [Set.union_diff_left, Set.image_diff (vsub_left_injective p₁), Set.image_image,
      Set.image_singleton, vsub_self, vadd_vsub, Set.image_id']
    exact Set.diff_singleton_eq_self fun h => hs 0 h rfl
  rw [h]
#align linear_independent_set_iff_affine_independent_vadd_union_singleton linearIndependent_set_iff_affineIndependent_vadd_union_singleton

/- warning: affine_independent_iff_indicator_eq_of_affine_combination_eq -> affineIndependent_iff_indicator_eq_of_affineCombination_eq is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P), Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (s1 : Finset.{u4} ι) (s2 : Finset.{u4} ι) (w1 : ι -> k) (w2 : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s1 (fun (i : ι) => w1 i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s2 (fun (i : ι) => w2 i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s1 p) w1) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s2 p) w2)) -> (Eq.{max (succ u4) (succ u1)} (ι -> k) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s1) w1) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s2) w2)))
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} (p : ι -> P), Iff (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (s1 : Finset.{u1} ι) (s2 : Finset.{u1} ι) (w1 : ι -> k) (w2 : ι -> k), (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s1 (fun (i : ι) => w1 i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s2 (fun (i : ι) => w2 i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w1) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s1 p) w1) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s2 p) w2)) -> (Eq.{max (succ u4) (succ u1)} (ι -> k) (Set.indicator.{u1, u4} ι k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.toSet.{u1} ι s1) w1) (Set.indicator.{u1, u4} ι k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.toSet.{u1} ι s2) w2)))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_indicator_eq_of_affine_combination_eq affineIndependent_iff_indicator_eq_of_affineCombination_eqₓ'. -/
/-- A family is affinely independent if and only if any affine
combinations (with sum of weights 1) that evaluate to the same point
have equal `set.indicator`. -/
theorem affineIndependent_iff_indicator_eq_of_affineCombination_eq (p : ι → P) :
    AffineIndependent k p ↔
      ∀ (s1 s2 : Finset ι) (w1 w2 : ι → k),
        (∑ i in s1, w1 i) = 1 →
          (∑ i in s2, w2 i) = 1 →
            s1.affineCombination k p w1 = s2.affineCombination k p w2 →
              Set.indicator (↑s1) w1 = Set.indicator (↑s2) w2 :=
  by
  classical
    constructor
    · intro ha s1 s2 w1 w2 hw1 hw2 heq
      ext i
      by_cases hi : i ∈ s1 ∪ s2
      · rw [← sub_eq_zero]
        rw [Set.sum_indicator_subset _ (Finset.subset_union_left s1 s2)] at hw1
        rw [Set.sum_indicator_subset _ (Finset.subset_union_right s1 s2)] at hw2
        have hws : (∑ i in s1 ∪ s2, (Set.indicator (↑s1) w1 - Set.indicator (↑s2) w2) i) = 0 := by
          simp [hw1, hw2]
        rw [Finset.affineCombination_indicator_subset _ _ (Finset.subset_union_left s1 s2),
          Finset.affineCombination_indicator_subset _ _ (Finset.subset_union_right s1 s2), ←
          @vsub_eq_zero_iff_eq V, Finset.affineCombination_vsub] at heq
        exact ha (s1 ∪ s2) (Set.indicator (↑s1) w1 - Set.indicator (↑s2) w2) hws HEq i hi
      · rw [← Finset.mem_coe, Finset.coe_union] at hi
        simp [mt (Set.mem_union_left ↑s2) hi, mt (Set.mem_union_right ↑s1) hi]
    · intro ha s w hw hs i0 hi0
      let w1 : ι → k := Function.update (Function.const ι 0) i0 1
      have hw1 : (∑ i in s, w1 i) = 1 := by
        rw [Finset.sum_update_of_mem hi0, Finset.sum_const_zero, add_zero]
      have hw1s : s.affine_combination k p w1 = p i0 :=
        s.affine_combination_of_eq_one_of_eq_zero w1 p hi0 (Function.update_same _ _ _)
          fun _ _ hne => Function.update_noteq hne _ _
      let w2 := w + w1
      have hw2 : (∑ i in s, w2 i) = 1 := by simp [w2, Finset.sum_add_distrib, hw, hw1]
      have hw2s : s.affine_combination k p w2 = p i0 := by
        simp [w2, ← Finset.weightedVSub_vadd_affineCombination, hs, hw1s]
      replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm ▸ hw2s)
      have hws : w2 i0 - w1 i0 = 0 := by
        rw [← Finset.mem_coe] at hi0
        rw [← Set.indicator_of_mem hi0 w2, ← Set.indicator_of_mem hi0 w1, ha, sub_self]
      simpa [w2] using hws
#align affine_independent_iff_indicator_eq_of_affine_combination_eq affineIndependent_iff_indicator_eq_of_affineCombination_eq

/- warning: affine_independent_iff_eq_of_fintype_affine_combination_eq -> affineIndependent_iff_eq_of_fintype_affineCombination_eq is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (w1 : ι -> k) (w2 : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w1 i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w2 i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w1) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w2)) -> (Eq.{max (succ u4) (succ u1)} (ι -> k) w1 w2))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Iff (AffineIndependent.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) (forall (w1 : ι -> k) (w2 : ι -> k), (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w1 i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1))))) -> (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w2 i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1))))) -> (Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w1) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u2)) (succ u1), succ (max u3 u4), succ u1} (AffineMap.{u3, max u3 u4, max u3 u4, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w1) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u2)) (succ u1), succ (max u3 u4), succ u1} (AffineMap.{u3, max u3 u4, max u3 u4, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w2)) -> (Eq.{max (succ u3) (succ u4)} (ι -> k) w1 w2))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff_eq_of_fintype_affine_combination_eq affineIndependent_iff_eq_of_fintype_affineCombination_eqₓ'. -/
/-- A finite family is affinely independent if and only if any affine
combinations (with sum of weights 1) that evaluate to the same point are equal. -/
theorem affineIndependent_iff_eq_of_fintype_affineCombination_eq [Fintype ι] (p : ι → P) :
    AffineIndependent k p ↔
      ∀ w1 w2 : ι → k,
        (∑ i, w1 i) = 1 →
          (∑ i, w2 i) = 1 →
            Finset.univ.affineCombination k p w1 = Finset.univ.affineCombination k p w2 → w1 = w2 :=
  by
  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq]
  constructor
  · intro h w1 w2 hw1 hw2 hweq
    simpa only [Set.indicator_univ, Finset.coe_univ] using h _ _ w1 w2 hw1 hw2 hweq
  · intro h s1 s2 w1 w2 hw1 hw2 hweq
    have hw1' : (∑ i, (s1 : Set ι).indicator w1 i) = 1 := by
      rwa [Set.sum_indicator_subset _ (Finset.subset_univ s1)] at hw1
    have hw2' : (∑ i, (s2 : Set ι).indicator w2 i) = 1 := by
      rwa [Set.sum_indicator_subset _ (Finset.subset_univ s2)] at hw2
    rw [Finset.affineCombination_indicator_subset w1 p (Finset.subset_univ s1),
      Finset.affineCombination_indicator_subset w2 p (Finset.subset_univ s2)] at hweq
    exact h _ _ hw1' hw2' hweq
#align affine_independent_iff_eq_of_fintype_affine_combination_eq affineIndependent_iff_eq_of_fintype_affineCombination_eq

variable {k}

/- warning: affine_independent.units_line_map -> AffineIndependent.units_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (j : ι) (w : ι -> (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1))), AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (fun (i : ι) => coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (p j) (p i)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (coeBase.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (Units.hasCoe.{u1} k (Ring.toMonoid.{u1} k _inst_1))))) (w i))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (j : ι) (w : ι -> (Units.{u4} k (MonoidWithZero.toMonoid.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))))), AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (fun (i : ι) => FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), succ u4, succ u2} (AffineMap.{u4, u4, u4, u3, u2} k k k V P _inst_1 (Ring.toAddCommGroup.{u4} k _inst_1) (Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (addGroupIsAddTorsor.{u4} k (AddGroupWithOne.toAddGroup.{u4} k (Ring.toAddGroupWithOne.{u4} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) _x) (AffineMap.funLike.{u4, u4, u4, u3, u2} k k k V P _inst_1 (Ring.toAddCommGroup.{u4} k _inst_1) (Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (addGroupIsAddTorsor.{u4} k (AddGroupWithOne.toAddGroup.{u4} k (Ring.toAddGroupWithOne.{u4} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (p j) (p i)) (Units.val.{u4} k (MonoidWithZero.toMonoid.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (w i))))
Case conversion may be inaccurate. Consider using '#align affine_independent.units_line_map AffineIndependent.units_lineMapₓ'. -/
/-- If we single out one member of an affine-independent family of points and affinely transport
all others along the line joining them to this member, the resulting new family of points is affine-
independent.

This is the affine version of `linear_independent.units_smul`. -/
theorem AffineIndependent.units_lineMap {p : ι → P} (hp : AffineIndependent k p) (j : ι)
    (w : ι → Units k) : AffineIndependent k fun i => AffineMap.lineMap (p j) (p i) (w i : k) :=
  by
  rw [affineIndependent_iff_linearIndependent_vsub k _ j] at hp⊢
  simp only [AffineMap.lineMap_vsub_left, AffineMap.coe_const, AffineMap.lineMap_same]
  exact hp.units_smul fun i => w i
#align affine_independent.units_line_map AffineIndependent.units_lineMap

/- warning: affine_independent.indicator_eq_of_affine_combination_eq -> AffineIndependent.indicator_eq_of_affineCombination_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (s₁ : Finset.{u4} ι) (s₂ : Finset.{u4} ι) (w₁ : ι -> k) (w₂ : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s₁ (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s₂ (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s₁ p) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s₂ p) w₂)) -> (Eq.{max (succ u4) (succ u1)} (ι -> k) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s₁) w₁) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s₂) w₂)))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (s₁ : Finset.{u1} ι) (s₂ : Finset.{u1} ι) (w₁ : ι -> k) (w₂ : ι -> k), (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s₁ (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s₂ (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₁) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s₁ p) w₁) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s₂ p) w₂)) -> (Eq.{max (succ u4) (succ u1)} (ι -> k) (Set.indicator.{u1, u4} ι k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.toSet.{u1} ι s₁) w₁) (Set.indicator.{u1, u4} ι k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.toSet.{u1} ι s₂) w₂)))
Case conversion may be inaccurate. Consider using '#align affine_independent.indicator_eq_of_affine_combination_eq AffineIndependent.indicator_eq_of_affineCombination_eqₓ'. -/
theorem AffineIndependent.indicator_eq_of_affineCombination_eq {p : ι → P}
    (ha : AffineIndependent k p) (s₁ s₂ : Finset ι) (w₁ w₂ : ι → k) (hw₁ : (∑ i in s₁, w₁ i) = 1)
    (hw₂ : (∑ i in s₂, w₂ i) = 1) (h : s₁.affineCombination k p w₁ = s₂.affineCombination k p w₂) :
    Set.indicator (↑s₁) w₁ = Set.indicator (↑s₂) w₂ :=
  (affineIndependent_iff_indicator_eq_of_affineCombination_eq k p).1 ha s₁ s₂ w₁ w₂ hw₁ hw₂ h
#align affine_independent.indicator_eq_of_affine_combination_eq AffineIndependent.indicator_eq_of_affineCombination_eq

/- warning: affine_independent.injective -> AffineIndependent.injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (Function.Injective.{succ u4, succ u3} ι P p)
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_5 : Nontrivial.{u4} k] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (Function.Injective.{succ u1, succ u2} ι P p)
Case conversion may be inaccurate. Consider using '#align affine_independent.injective AffineIndependent.injectiveₓ'. -/
/-- An affinely independent family is injective, if the underlying
ring is nontrivial. -/
protected theorem AffineIndependent.injective [Nontrivial k] {p : ι → P}
    (ha : AffineIndependent k p) : Function.Injective p :=
  by
  intro i j hij
  rw [affineIndependent_iff_linearIndependent_vsub _ _ j] at ha
  by_contra hij'
  exact ha.ne_zero ⟨i, hij'⟩ (vsub_eq_zero_iff_eq.mpr hij)
#align affine_independent.injective AffineIndependent.injective

/- warning: affine_independent.comp_embedding -> AffineIndependent.comp_embedding is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι2 : Type.{u5}} (f : Function.Embedding.{succ u5, succ u4} ι2 ι) {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (AffineIndependent.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι2 (Function.comp.{succ u5, succ u4, succ u3} ι2 ι P p (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι2 ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι2 ι) => ι2 -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι2 ι) f)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι2 : Type.{u5}} (f : Function.Embedding.{succ u5, succ u4} ι2 ι) {p : ι -> P}, (AffineIndependent.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (AffineIndependent.{u3, u2, u1, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι2 (Function.comp.{succ u5, succ u4, succ u1} ι2 ι P p (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι2 ι) ι2 (fun (_x : ι2) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι2) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι2 ι) ι2 ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι2 ι)) f)))
Case conversion may be inaccurate. Consider using '#align affine_independent.comp_embedding AffineIndependent.comp_embeddingₓ'. -/
/-- If a family is affinely independent, so is any subfamily given by
composition of an embedding into index type with the original
family. -/
theorem AffineIndependent.comp_embedding {ι2 : Type _} (f : ι2 ↪ ι) {p : ι → P}
    (ha : AffineIndependent k p) : AffineIndependent k (p ∘ f) := by
  classical
    intro fs w hw hs i0 hi0
    let fs' := fs.map f
    let w' i := if h : ∃ i2, f i2 = i then w h.some else 0
    have hw' : ∀ i2 : ι2, w' (f i2) = w i2 := by
      intro i2
      have h : ∃ i : ι2, f i = f i2 := ⟨i2, rfl⟩
      have hs : h.some = i2 := f.injective h.some_spec
      simp_rw [w', dif_pos h, hs]
    have hw's : (∑ i in fs', w' i) = 0 :=
      by
      rw [← hw, Finset.sum_map]
      simp [hw']
    have hs' : fs'.weighted_vsub p w' = (0 : V) :=
      by
      rw [← hs, Finset.weightedVSub_map]
      congr with i
      simp [hw']
    rw [← ha fs' w' hw's hs' (f i0) ((Finset.mem_map' _).2 hi0), hw']
#align affine_independent.comp_embedding AffineIndependent.comp_embedding

/- warning: affine_independent.subtype -> AffineIndependent.subtype is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (s : Set.{u4} ι), AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) x s))))) i)))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (s : Set.{u1} ι), AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u1} ι s) (fun (i : Set.Elem.{u1} ι s) => p (Subtype.val.{succ u1} ι (fun (x : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) x s) i)))
Case conversion may be inaccurate. Consider using '#align affine_independent.subtype AffineIndependent.subtypeₓ'. -/
/-- If a family is affinely independent, so is any subfamily indexed
by a subtype of the index type. -/
protected theorem AffineIndependent.subtype {p : ι → P} (ha : AffineIndependent k p) (s : Set ι) :
    AffineIndependent k fun i : s => p i :=
  ha.comp_embedding (Embedding.subtype _)
#align affine_independent.subtype AffineIndependent.subtype

/- warning: affine_independent.range -> AffineIndependent.range is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.range.{u3, succ u4} P ι p)))))) x))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (AffineIndependent.{u4, u3, u2, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u2} P (Set.range.{u2, succ u1} P ι p)) (fun (x : Set.Elem.{u2} P (Set.range.{u2, succ u1} P ι p)) => Subtype.val.{succ u2} P (fun (x : P) => Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) x (Set.range.{u2, succ u1} P ι p)) x))
Case conversion may be inaccurate. Consider using '#align affine_independent.range AffineIndependent.rangeₓ'. -/
/-- If an indexed family of points is affinely independent, so is the
corresponding set of points. -/
protected theorem AffineIndependent.range {p : ι → P} (ha : AffineIndependent k p) :
    AffineIndependent k (fun x => x : Set.range p → P) :=
  by
  let f : Set.range p → ι := fun x => x.property.some
  have hf : ∀ x, p (f x) = x := fun x => x.property.some_spec
  let fe : Set.range p ↪ ι := ⟨f, fun x₁ x₂ he => Subtype.ext (hf x₁ ▸ hf x₂ ▸ he ▸ rfl)⟩
  convert ha.comp_embedding fe
  ext
  simp [hf]
#align affine_independent.range AffineIndependent.range

/- warning: affine_independent_equiv -> affineIndependent_equiv is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι' : Type.{u5}} (e : Equiv.{succ u4, succ u5} ι ι') {p : ι' -> P}, Iff (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Function.comp.{succ u4, succ u5, succ u3} ι ι' P p (coeFn.{max 1 (max (succ u4) (succ u5)) (succ u5) (succ u4), max (succ u4) (succ u5)} (Equiv.{succ u4, succ u5} ι ι') (fun (_x : Equiv.{succ u4, succ u5} ι ι') => ι -> ι') (Equiv.hasCoeToFun.{succ u4, succ u5} ι ι') e))) (AffineIndependent.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι' p)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι' : Type.{u5}} (e : Equiv.{succ u4, succ u5} ι ι') {p : ι' -> P}, Iff (AffineIndependent.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Function.comp.{succ u4, succ u5, succ u1} ι ι' P p (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (Equiv.{succ u4, succ u5} ι ι') ι (fun (_x : ι) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : ι) => ι') _x) (Equiv.instFunLikeEquiv.{succ u4, succ u5} ι ι') e))) (AffineIndependent.{u3, u2, u1, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι' p)
Case conversion may be inaccurate. Consider using '#align affine_independent_equiv affineIndependent_equivₓ'. -/
theorem affineIndependent_equiv {ι' : Type _} (e : ι ≃ ι') {p : ι' → P} :
    AffineIndependent k (p ∘ e) ↔ AffineIndependent k p :=
  by
  refine' ⟨_, AffineIndependent.comp_embedding e.to_embedding⟩
  intro h
  have : p = p ∘ e ∘ e.symm.to_embedding := by
    ext
    simp
  rw [this]
  exact h.comp_embedding e.symm.to_embedding
#align affine_independent_equiv affineIndependent_equiv

/- warning: affine_independent.mono -> AffineIndependent.mono is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P} {t : Set.{u3} P}, (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x t))))) x)) -> (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s t) -> (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s))))) x))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P} {t : Set.{u3} P}, (AffineIndependent.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P t) (fun (x : Set.Elem.{u3} P t) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x t) x)) -> (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s t) -> (AffineIndependent.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P s) (fun (x : Set.Elem.{u3} P s) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x s) x))
Case conversion may be inaccurate. Consider using '#align affine_independent.mono AffineIndependent.monoₓ'. -/
/-- If a set of points is affinely independent, so is any subset. -/
protected theorem AffineIndependent.mono {s t : Set P}
    (ha : AffineIndependent k (fun x => x : t → P)) (hs : s ⊆ t) :
    AffineIndependent k (fun x => x : s → P) :=
  ha.comp_embedding (s.embeddingOfSubset t hs)
#align affine_independent.mono AffineIndependent.mono

/- warning: affine_independent.of_set_of_injective -> AffineIndependent.of_set_of_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) (Set.range.{u3, succ u4} P ι p)) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x (Set.range.{u3, succ u4} P ι p)))))) x)) -> (Function.Injective.{succ u4, succ u3} ι P p) -> (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u2} P (Set.range.{u2, succ u1} P ι p)) (fun (x : Set.Elem.{u2} P (Set.range.{u2, succ u1} P ι p)) => Subtype.val.{succ u2} P (fun (x : P) => Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) x (Set.range.{u2, succ u1} P ι p)) x)) -> (Function.Injective.{succ u1, succ u2} ι P p) -> (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
Case conversion may be inaccurate. Consider using '#align affine_independent.of_set_of_injective AffineIndependent.of_set_of_injectiveₓ'. -/
/-- If the range of an injective indexed family of points is affinely
independent, so is that family. -/
theorem AffineIndependent.of_set_of_injective {p : ι → P}
    (ha : AffineIndependent k (fun x => x : Set.range p → P)) (hi : Function.Injective p) :
    AffineIndependent k p :=
  ha.comp_embedding
    (⟨fun i => ⟨p i, Set.mem_range_self _⟩, fun x y h => hi (Subtype.mk_eq_mk.1 h)⟩ :
      ι ↪ Set.range p)
#align affine_independent.of_set_of_injective AffineIndependent.of_set_of_injective

section Composition

variable {V₂ P₂ : Type _} [AddCommGroup V₂] [Module k V₂] [affine_space V₂ P₂]

include V₂

/- warning: affine_independent.of_comp -> AffineIndependent.of_comp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {V₂ : Type.{u5}} {P₂ : Type.{u6}} [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u6} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {p : ι -> P} (f : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (AffineIndependent.{u1, u5, u6, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u4, succ u3, succ u6} ι P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)) -> (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
but is expected to have type
  forall {k : Type.{u6}} {V : Type.{u5}} {P : Type.{u4}} [_inst_1 : Ring.{u6} k] [_inst_2 : AddCommGroup.{u5} V] [_inst_3 : Module.{u6, u5} k V (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V _inst_2)] [_inst_4 : AddTorsor.{u5, u4} V P (AddCommGroup.toAddGroup.{u5} V _inst_2)] {ι : Type.{u1}} {V₂ : Type.{u3}} {P₂ : Type.{u2}} [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u6, u3} k V₂ (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u2} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] {p : ι -> P} (f : AffineMap.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (AffineIndependent.{u6, u3, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u1, succ u4, succ u2} ι P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u4, succ u2} (AffineMap.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P₂) _x) (AffineMap.funLike.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)) -> (AffineIndependent.{u6, u5, u4, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
Case conversion may be inaccurate. Consider using '#align affine_independent.of_comp AffineIndependent.of_compₓ'. -/
/-- If the image of a family of points in affine space under an affine transformation is affine-
independent, then the original family of points is also affine-independent. -/
theorem AffineIndependent.of_comp {p : ι → P} (f : P →ᵃ[k] P₂) (hai : AffineIndependent k (f ∘ p)) :
    AffineIndependent k p := by
  cases' isEmpty_or_nonempty ι with h h;
  · haveI := h
    apply affineIndependent_of_subsingleton
  obtain ⟨i⟩ := h
  rw [affineIndependent_iff_linearIndependent_vsub k p i]
  simp_rw [affineIndependent_iff_linearIndependent_vsub k (f ∘ p) i, Function.comp_apply, ←
    f.linear_map_vsub] at hai
  exact LinearIndependent.of_comp f.linear hai
#align affine_independent.of_comp AffineIndependent.of_comp

/- warning: affine_independent.map' -> AffineIndependent.map' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {V₂ : Type.{u5}} {P₂ : Type.{u6}} [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u6} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (f : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Injective.{succ u3, succ u6} P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (AffineIndependent.{u1, u5, u6, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u4, succ u3, succ u6} ι P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)))
but is expected to have type
  forall {k : Type.{u6}} {V : Type.{u5}} {P : Type.{u4}} [_inst_1 : Ring.{u6} k] [_inst_2 : AddCommGroup.{u5} V] [_inst_3 : Module.{u6, u5} k V (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V _inst_2)] [_inst_4 : AddTorsor.{u5, u4} V P (AddCommGroup.toAddGroup.{u5} V _inst_2)] {ι : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u6, u2} k V₂ (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {p : ι -> P}, (AffineIndependent.{u6, u5, u4, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (f : AffineMap.{u6, u5, u4, u2, u1} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Injective.{succ u4, succ u1} P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u4, succ u1} (AffineMap.{u6, u5, u4, u2, u1} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P₂) _x) (AffineMap.funLike.{u6, u5, u4, u2, u1} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (AffineIndependent.{u6, u2, u1, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u3, succ u4, succ u1} ι P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u4, succ u1} (AffineMap.{u6, u5, u4, u2, u1} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P₂) _x) (AffineMap.funLike.{u6, u5, u4, u2, u1} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)))
Case conversion may be inaccurate. Consider using '#align affine_independent.map' AffineIndependent.map'ₓ'. -/
/-- The image of a family of points in affine space, under an injective affine transformation, is
affine-independent. -/
theorem AffineIndependent.map' {p : ι → P} (hai : AffineIndependent k p) (f : P →ᵃ[k] P₂)
    (hf : Function.Injective f) : AffineIndependent k (f ∘ p) :=
  by
  cases' isEmpty_or_nonempty ι with h h
  · haveI := h
    apply affineIndependent_of_subsingleton
  obtain ⟨i⟩ := h
  rw [affineIndependent_iff_linearIndependent_vsub k p i] at hai
  simp_rw [affineIndependent_iff_linearIndependent_vsub k (f ∘ p) i, Function.comp_apply, ←
    f.linear_map_vsub]
  have hf' : f.linear.ker = ⊥ := by rwa [LinearMap.ker_eq_bot, f.linear_injective_iff]
  exact LinearIndependent.map' hai f.linear hf'
#align affine_independent.map' AffineIndependent.map'

/- warning: affine_map.affine_independent_iff -> AffineMap.affineIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {V₂ : Type.{u5}} {P₂ : Type.{u6}} [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u6} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {p : ι -> P} (f : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Injective.{succ u3, succ u6} P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (AffineIndependent.{u1, u5, u6, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u4, succ u3, succ u6} ι P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)) (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p))
but is expected to have type
  forall {k : Type.{u6}} {V : Type.{u5}} {P : Type.{u4}} [_inst_1 : Ring.{u6} k] [_inst_2 : AddCommGroup.{u5} V] [_inst_3 : Module.{u6, u5} k V (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V _inst_2)] [_inst_4 : AddTorsor.{u5, u4} V P (AddCommGroup.toAddGroup.{u5} V _inst_2)] {ι : Type.{u1}} {V₂ : Type.{u3}} {P₂ : Type.{u2}} [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u6, u3} k V₂ (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u2} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] {p : ι -> P} (f : AffineMap.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), (Function.Injective.{succ u4, succ u2} P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u4, succ u2} (AffineMap.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P₂) _x) (AffineMap.funLike.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f)) -> (Iff (AffineIndependent.{u6, u3, u2, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u1, succ u4, succ u2} ι P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u4, succ u2} (AffineMap.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => P₂) _x) (AffineMap.funLike.{u6, u5, u4, u3, u2} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) p)) (AffineIndependent.{u6, u5, u4, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p))
Case conversion may be inaccurate. Consider using '#align affine_map.affine_independent_iff AffineMap.affineIndependent_iffₓ'. -/
/-- Injective affine maps preserve affine independence. -/
theorem AffineMap.affineIndependent_iff {p : ι → P} (f : P →ᵃ[k] P₂) (hf : Function.Injective f) :
    AffineIndependent k (f ∘ p) ↔ AffineIndependent k p :=
  ⟨AffineIndependent.of_comp f, fun hai => AffineIndependent.map' hai f hf⟩
#align affine_map.affine_independent_iff AffineMap.affineIndependent_iff

/- warning: affine_equiv.affine_independent_iff -> AffineEquiv.affineIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {V₂ : Type.{u5}} {P₂ : Type.{u6}} [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u6} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {p : ι -> P} (e : AffineEquiv.{u1, u3, u6, u2, u5} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (AffineIndependent.{u1, u5, u6, u4} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u4, succ u3, succ u6} ι P P₂ (coeFn.{max (succ u3) (succ u6) (succ u2) (succ u5), max (succ u3) (succ u6)} (AffineEquiv.{u1, u3, u6, u2, u5} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u6, u2, u5} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u6, u2, u5} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) p)) (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
but is expected to have type
  forall {k : Type.{u6}} {V : Type.{u3}} {P : Type.{u5}} [_inst_1 : Ring.{u6} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u6, u3} k V (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {V₂ : Type.{u2}} {P₂ : Type.{u4}} [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u6, u2} k V₂ (Ring.toSemiring.{u6} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {p : ι -> P} (e : AffineEquiv.{u6, u5, u4, u3, u2} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (AffineIndependent.{u6, u2, u4, u1} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 ι (Function.comp.{succ u1, succ u5, succ u4} ι P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u5, succ u4} (AffineEquiv.{u6, u5, u4, u3, u2} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u5, succ u4} (AffineEquiv.{u6, u5, u4, u3, u2} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), succ u5, succ u4} (AffineEquiv.{u6, u5, u4, u3, u2} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (AffineEquiv.equivLike.{u6, u5, u4, u3, u2} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e) p)) (AffineIndependent.{u6, u3, u5, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p)
Case conversion may be inaccurate. Consider using '#align affine_equiv.affine_independent_iff AffineEquiv.affineIndependent_iffₓ'. -/
/-- Affine equivalences preserve affine independence of families of points. -/
theorem AffineEquiv.affineIndependent_iff {p : ι → P} (e : P ≃ᵃ[k] P₂) :
    AffineIndependent k (e ∘ p) ↔ AffineIndependent k p :=
  e.toAffineMap.affineIndependent_iff e.toEquiv.Injective
#align affine_equiv.affine_independent_iff AffineEquiv.affineIndependent_iff

/- warning: affine_equiv.affine_independent_set_of_eq_iff -> AffineEquiv.affineIndependent_set_of_eq_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_5 : AddCommGroup.{u4} V₂] [_inst_6 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_5)] {s : Set.{u3} P} (e : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (AffineIndependent.{u1, u4, u5, u5} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (coeSort.{succ u5, succ (succ u5)} (Set.{u5} P₂) Type.{u5} (Set.hasCoeToSort.{u5} P₂) (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) ((fun (a : Type.{u5}) (b : Type.{u5}) [self : HasLiftT.{succ u5, succ u5} a b] => self.0) (coeSort.{succ u5, succ (succ u5)} (Set.{u5} P₂) Type.{u5} (Set.hasCoeToSort.{u5} P₂) (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) P₂ (HasLiftT.mk.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (Set.{u5} P₂) Type.{u5} (Set.hasCoeToSort.{u5} P₂) (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) P₂ (CoeTCₓ.coe.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (Set.{u5} P₂) Type.{u5} (Set.hasCoeToSort.{u5} P₂) (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) P₂ (coeBase.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (Set.{u5} P₂) Type.{u5} (Set.hasCoeToSort.{u5} P₂) (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)) P₂ (coeSubtype.{succ u5} P₂ (fun (x : P₂) => Membership.Mem.{u5, u5} P₂ (Set.{u5} P₂) (Set.hasMem.{u5} P₂) x (Set.image.{u3, u5} P P₂ (coeFn.{max (succ u3) (succ u5) (succ u2) (succ u4), max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P -> P₂) (AffineEquiv.hasCoeToFun.{u1, u3, u5, u2, u4} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) s)))))))) (AffineIndependent.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s)))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u5}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {V₂ : Type.{u1}} {P₂ : Type.{u3}} [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u4, u1} k V₂ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {s : Set.{u5} P} (e : AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (AffineIndependent.{u4, u1, u3, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (Subtype.{succ u3} P₂ (fun (x : P₂) => Membership.mem.{u3, u3} P₂ (Set.{u3} P₂) (Set.instMembershipSet.{u3} P₂) x (Set.image.{u5, u3} P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (a : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P₂) a) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (AffineEquiv.equivLike.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e) s))) (Subtype.val.{succ u3} P₂ (fun (x : P₂) => Membership.mem.{u3, u3} P₂ (Set.{u3} P₂) (Set.instMembershipSet.{u3} P₂) x (Set.image.{u5, u3} P P₂ (FunLike.coe.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P (fun (a : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1470 : P) => P₂) a) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u3)) (succ u2)) (succ u1), succ u5, succ u3} (AffineEquiv.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P P₂ (AffineEquiv.equivLike.{u4, u5, u3, u2, u1} k P P₂ V V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e) s)))) (AffineIndependent.{u4, u2, u5, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Subtype.{succ u5} P (fun (x : P) => Membership.mem.{u5, u5} P (Set.{u5} P) (Set.instMembershipSet.{u5} P) x s)) (Subtype.val.{succ u5} P (fun (x : P) => Membership.mem.{u5, u5} P (Set.{u5} P) (Set.instMembershipSet.{u5} P) x s)))
Case conversion may be inaccurate. Consider using '#align affine_equiv.affine_independent_set_of_eq_iff AffineEquiv.affineIndependent_set_of_eq_iffₓ'. -/
/-- Affine equivalences preserve affine independence of subsets. -/
theorem AffineEquiv.affineIndependent_set_of_eq_iff {s : Set P} (e : P ≃ᵃ[k] P₂) :
    AffineIndependent k (coe : e '' s → P₂) ↔ AffineIndependent k (coe : s → P) :=
  by
  have : e ∘ (coe : s → P) = (coe : e '' s → P₂) ∘ (e : P ≃ P₂).image s := rfl
  rw [← e.affine_independent_iff, this, affineIndependent_equiv]
#align affine_equiv.affine_independent_set_of_eq_iff AffineEquiv.affineIndependent_set_of_eq_iff

end Composition

/- warning: affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span -> AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {s1 : Set.{u4} ι} {s2 : Set.{u4} ι} {p0 : P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s1))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s2))) -> (Exists.{succ u4} ι (fun (i : ι) => Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) i (Inter.inter.{u4} (Set.{u4} ι) (Set.hasInter.{u4} ι) s1 s2))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_5 : Nontrivial.{u4} k] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {s1 : Set.{u1} ι} {s2 : Set.{u1} ι} {p0 : P}, (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p s1))) -> (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p0 (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p s2))) -> (Exists.{succ u1} ι (fun (i : ι) => Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i (Inter.inter.{u1} (Set.{u1} ι) (Set.instInterSet.{u1} ι) s1 s2))))
Case conversion may be inaccurate. Consider using '#align affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpanₓ'. -/
/-- If a family is affinely independent, and the spans of points
indexed by two subsets of the index type have a point in common, those
subsets of the index type have an element in common, if the underlying
ring is nontrivial. -/
theorem AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan [Nontrivial k] {p : ι → P}
    (ha : AffineIndependent k p) {s1 s2 : Set ι} {p0 : P} (hp0s1 : p0 ∈ affineSpan k (p '' s1))
    (hp0s2 : p0 ∈ affineSpan k (p '' s2)) : ∃ i : ι, i ∈ s1 ∩ s2 :=
  by
  rw [Set.image_eq_range] at hp0s1 hp0s2
  rw [mem_affineSpan_iff_eq_affineCombination, ←
    Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype] at hp0s1 hp0s2
  rcases hp0s1 with ⟨fs1, hfs1, w1, hw1, hp0s1⟩
  rcases hp0s2 with ⟨fs2, hfs2, w2, hw2, hp0s2⟩
  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq] at ha
  replace ha := ha fs1 fs2 w1 w2 hw1 hw2 (hp0s1 ▸ hp0s2)
  have hnz : (∑ i in fs1, w1 i) ≠ 0 := hw1.symm ▸ one_ne_zero
  rcases Finset.exists_ne_zero_of_sum_ne_zero hnz with ⟨i, hifs1, hinz⟩
  simp_rw [← Set.indicator_of_mem (Finset.mem_coe.2 hifs1) w1, ha] at hinz
  use i, hfs1 hifs1, hfs2 (Set.mem_of_indicator_ne_zero hinz)
#align affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan

/- warning: affine_independent.affine_span_disjoint_of_disjoint -> AffineIndependent.affineSpan_disjoint_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {s1 : Set.{u4} ι} {s2 : Set.{u4} ι}, (Disjoint.{u4} (Set.{u4} ι) (CompleteSemilatticeInf.toPartialOrder.{u4} (Set.{u4} ι) (CompleteLattice.toCompleteSemilatticeInf.{u4} (Set.{u4} ι) (Order.Coframe.toCompleteLattice.{u4} (Set.{u4} ι) (CompleteDistribLattice.toCoframe.{u4} (Set.{u4} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u4} (Set.{u4} ι) (Set.completeBooleanAlgebra.{u4} ι)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u4} (Set.{u4} ι) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u4} (Set.{u4} ι) (Set.booleanAlgebra.{u4} ι))) s1 s2) -> (Disjoint.{u3} (Set.{u3} P) (CompleteSemilatticeInf.toPartialOrder.{u3} (Set.{u3} P) (CompleteLattice.toCompleteSemilatticeInf.{u3} (Set.{u3} P) (Order.Coframe.toCompleteLattice.{u3} (Set.{u3} P) (CompleteDistribLattice.toCoframe.{u3} (Set.{u3} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u3} (Set.{u3} P) (Set.completeBooleanAlgebra.{u3} P)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u3} (Set.{u3} P) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u3} (Set.{u3} P) (Set.booleanAlgebra.{u3} P))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s1))) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (HasLiftT.mk.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (CoeTCₓ.coe.{succ u3, succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (Set.{u3} P) (SetLike.Set.hasCoeT.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s2)))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_5 : Nontrivial.{u4} k] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {s1 : Set.{u1} ι} {s2 : Set.{u1} ι}, (Disjoint.{u1} (Set.{u1} ι) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} ι) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} ι) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} ι) (Set.instCompleteBooleanAlgebraSet.{u1} ι)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} ι) (Preorder.toLE.{u1} (Set.{u1} ι) (PartialOrder.toPreorder.{u1} (Set.{u1} ι) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Set.{u1} ι) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Set.{u1} ι) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} ι) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} ι) (Set.instCompleteBooleanAlgebraSet.{u1} ι)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} ι) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} ι) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} ι) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} ι) (Set.instCompleteBooleanAlgebraSet.{u1} ι)))))) s1 s2) -> (Disjoint.{u2} (Set.{u2} P) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} P) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} P) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} P) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} P) (Set.instCompleteBooleanAlgebraSet.{u2} P)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} P) (Preorder.toLE.{u2} (Set.{u2} P) (PartialOrder.toPreorder.{u2} (Set.{u2} P) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Set.{u2} P) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Set.{u2} P) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} P) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} P) (Set.instCompleteBooleanAlgebraSet.{u2} P)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} P) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} P) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} P) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} P) (Set.instCompleteBooleanAlgebraSet.{u2} P)))))) (SetLike.coe.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p s1))) (SetLike.coe.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p s2)))))
Case conversion may be inaccurate. Consider using '#align affine_independent.affine_span_disjoint_of_disjoint AffineIndependent.affineSpan_disjoint_of_disjointₓ'. -/
/-- If a family is affinely independent, the spans of points indexed
by disjoint subsets of the index type are disjoint, if the underlying
ring is nontrivial. -/
theorem AffineIndependent.affineSpan_disjoint_of_disjoint [Nontrivial k] {p : ι → P}
    (ha : AffineIndependent k p) {s1 s2 : Set ι} (hd : Disjoint s1 s2) :
    Disjoint (affineSpan k (p '' s1) : Set P) (affineSpan k (p '' s2)) :=
  by
  refine' Set.disjoint_left.2 fun p0 hp0s1 hp0s2 => _
  cases' ha.exists_mem_inter_of_exists_mem_inter_affine_span hp0s1 hp0s2 with i hi
  exact Set.disjoint_iff.1 hd hi
#align affine_independent.affine_span_disjoint_of_disjoint AffineIndependent.affineSpan_disjoint_of_disjoint

/- warning: affine_independent.mem_affine_span_iff -> AffineIndependent.mem_affineSpan_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (i : ι) (s : Set.{u4} ι), Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p s))) (Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) i s))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_5 : Nontrivial.{u4} k] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (i : ι) (s : Set.{u1} ι), Iff (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p s))) (Membership.mem.{u1, u1} ι (Set.{u1} ι) (Set.instMembershipSet.{u1} ι) i s))
Case conversion may be inaccurate. Consider using '#align affine_independent.mem_affine_span_iff AffineIndependent.mem_affineSpan_iffₓ'. -/
/-- If a family is affinely independent, a point in the family is in
the span of some of the points given by a subset of the index type if
and only if that point's index is in the subset, if the underlying
ring is nontrivial. -/
@[simp]
protected theorem AffineIndependent.mem_affineSpan_iff [Nontrivial k] {p : ι → P}
    (ha : AffineIndependent k p) (i : ι) (s : Set ι) : p i ∈ affineSpan k (p '' s) ↔ i ∈ s :=
  by
  constructor
  · intro hs
    have h :=
      AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan ha hs
        (mem_affineSpan k (Set.mem_image_of_mem _ (Set.mem_singleton _)))
    rwa [← Set.nonempty_def, Set.inter_singleton_nonempty] at h
  · exact fun h => mem_affineSpan k (Set.mem_image_of_mem p h)
#align affine_independent.mem_affine_span_iff AffineIndependent.mem_affineSpan_iff

/- warning: affine_independent.not_mem_affine_span_diff -> AffineIndependent.not_mem_affineSpan_diff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (i : ι) (s : Set.{u4} ι), Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p (SDiff.sdiff.{u4} (Set.{u4} ι) (BooleanAlgebra.toHasSdiff.{u4} (Set.{u4} ι) (Set.booleanAlgebra.{u4} ι)) s (Singleton.singleton.{u4, u4} ι (Set.{u4} ι) (Set.hasSingleton.{u4} ι) i))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_5 : Nontrivial.{u4} k] {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall (i : ι) (s : Set.{u1} ι), Not (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p (SDiff.sdiff.{u1} (Set.{u1} ι) (Set.instSDiffSet.{u1} ι) s (Singleton.singleton.{u1, u1} ι (Set.{u1} ι) (Set.instSingletonSet.{u1} ι) i))))))
Case conversion may be inaccurate. Consider using '#align affine_independent.not_mem_affine_span_diff AffineIndependent.not_mem_affineSpan_diffₓ'. -/
/-- If a family is affinely independent, a point in the family is not
in the affine span of the other points, if the underlying ring is
nontrivial. -/
theorem AffineIndependent.not_mem_affineSpan_diff [Nontrivial k] {p : ι → P}
    (ha : AffineIndependent k p) (i : ι) (s : Set ι) : p i ∉ affineSpan k (p '' (s \ {i})) := by
  simp [ha]
#align affine_independent.not_mem_affine_span_diff AffineIndependent.not_mem_affineSpan_diff

/- warning: exists_nontrivial_relation_sum_zero_of_not_affine_ind -> exists_nontrivial_relation_sum_zero_of_not_affine_ind is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {t : Finset.{u2} V}, (Not (AffineIndependent.{u1, u2, u2, u2} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} V) Type.{u2} (Finset.hasCoeToSort.{u2} V) t) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} V) Type.{u2} (Finset.hasCoeToSort.{u2} V) t) V (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} V) Type.{u2} (Finset.hasCoeToSort.{u2} V) t) V (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} V) Type.{u2} (Finset.hasCoeToSort.{u2} V) t) V (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Finset.{u2} V) Type.{u2} (Finset.hasCoeToSort.{u2} V) t) V (coeSubtype.{succ u2} V (fun (x : V) => Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t)))))))) -> (Exists.{max (succ u2) (succ u1)} (V -> k) (fun (f : V -> k) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (f e) e)) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) (And (Eq.{succ u1} k (Finset.sum.{u1, u2} k V (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) t (fun (e : V) => f e)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) (Exists.{succ u2} V (fun (x : V) => Exists.{0} (Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) (fun (H : Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) => Ne.{succ u1} k (f x) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))))))))
but is expected to have type
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {t : Finset.{u2} V}, (Not (AffineIndependent.{u1, u2, u2, u2} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Finset.{u2} V) (Finset.instMembershipFinset.{u2} V) x t)) (Subtype.val.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Finset.{u2} V) (Finset.instMembershipFinset.{u2} V) x t)))) -> (Exists.{max (succ u1) (succ u2)} (V -> k) (fun (f : V -> k) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => HSMul.hSMul.{u1, u2, u2} k V V (instHSMul.{u1, u2} k V (SMulZeroClass.toSMul.{u1, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k V (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (f e) e)) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) (And (Eq.{succ u1} k (Finset.sum.{u1, u2} k V (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) t (fun (e : V) => f e)) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))) (Exists.{succ u2} V (fun (x : V) => And (Membership.mem.{u2, u2} V (Finset.{u2} V) (Finset.instMembershipFinset.{u2} V) x t) (Ne.{succ u1} k (f x) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align exists_nontrivial_relation_sum_zero_of_not_affine_ind exists_nontrivial_relation_sum_zero_of_not_affine_indₓ'. -/
theorem exists_nontrivial_relation_sum_zero_of_not_affine_ind {t : Finset V}
    (h : ¬AffineIndependent k (coe : t → V)) :
    ∃ f : V → k, (∑ e in t, f e • e) = 0 ∧ (∑ e in t, f e) = 0 ∧ ∃ x ∈ t, f x ≠ 0 := by
  classical
    rw [affineIndependent_iff_of_fintype] at h
    simp only [exists_prop, not_forall] at h
    obtain ⟨w, hw, hwt, i, hi⟩ := h
    simp only [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w (coe : t → V) hw 0,
      vsub_eq_sub, Finset.weightedVSubOfPoint_apply, sub_zero] at hwt
    let f : ∀ x : V, x ∈ t → k := fun x hx => w ⟨x, hx⟩
    refine'
      ⟨fun x => if hx : x ∈ t then f x hx else (0 : k), _, _,
        by
        use i
        simp [hi, f]⟩
    suffices (∑ e : V in t, dite (e ∈ t) (fun hx => f e hx • e) fun hx => 0) = 0
      by
      convert this
      ext
      by_cases hx : x ∈ t <;> simp [hx]
    all_goals
      simp only [Finset.sum_dite_of_true fun x h => h, Subtype.val_eq_coe, Finset.mk_coe, f, hwt,
        hw]
#align exists_nontrivial_relation_sum_zero_of_not_affine_ind exists_nontrivial_relation_sum_zero_of_not_affine_ind

/- warning: affine_independent_iff -> affineIndependent_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} {p : ι -> V}, Iff (AffineIndependent.{u1, u2, u2, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) ι p) (forall (s : Finset.{u3} ι) (w : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u3} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s w) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (e : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w e) (p e))) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (forall (e : ι), (Membership.Mem.{u3, u3} ι (Finset.{u3} ι) (Finset.hasMem.{u3} ι) e s) -> (Eq.{succ u1} k (w e) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {ι : Type.{u3}} {p : ι -> V}, Iff (AffineIndependent.{u2, u1, u1, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) ι p) (forall (s : Finset.{u3} ι) (w : ι -> k), (Eq.{succ u2} k (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s w) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)))))) -> (Eq.{succ u1} V (Finset.sum.{u1, u3} V ι (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) s (fun (e : ι) => HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (w e) (p e))) (OfNat.ofNat.{u1} V 0 (Zero.toOfNat0.{u1} V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2)))))))) -> (forall (e : ι), (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) e s) -> (Eq.{succ u2} k (w e) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align affine_independent_iff affineIndependent_iffₓ'. -/
/-- Viewing a module as an affine space modelled on itself, we can characterise affine independence
in terms of linear combinations. -/
theorem affineIndependent_iff {ι} {p : ι → V} :
    AffineIndependent k p ↔
      ∀ (s : Finset ι) (w : ι → k), s.Sum w = 0 → (∑ e in s, w e • p e) = 0 → ∀ e ∈ s, w e = 0 :=
  forall₃_congr fun s w hw => by simp [s.weighted_vsub_eq_linear_combination hw]
#align affine_independent_iff affineIndependent_iff

/- warning: weighted_vsub_mem_vector_span_pair -> weightedVSub_mem_vectorSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u4} ι}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₂))))) (Exists.{succ u1} k (fun (r : k) => forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w i) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1))) r (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) (w₁ i) (w₂ i))))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u1} ι}, (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Iff (Membership.mem.{u3, u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) w) (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) (FunLike.coe.{max (max (succ u3) (succ u1)) (succ u4), max (succ u1) (succ u4), succ u3} (LinearMap.{u4, u4, max u4 u1, u3} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u1 u4, u3} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u1, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2389 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) _inst_3 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (vectorSpan.{u4, u3, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₁) (Set.{u2} P) (Set.instInsertSet.{u2} P) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (Set.{u2} P) (Set.instSingletonSet.{u2} P) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₂))))) (Exists.{succ u4} k (fun (r : k) => forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u4} k (w i) (HMul.hMul.{u4, u4, u4} k k k (instHMul.{u4} k (NonUnitalNonAssocRing.toMul.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) r (HSub.hSub.{u4, u4, u4} k k k (instHSub.{u4} k (Ring.toSub.{u4} k _inst_1)) (w₁ i) (w₂ i))))))))
Case conversion may be inaccurate. Consider using '#align weighted_vsub_mem_vector_span_pair weightedVSub_mem_vectorSpan_pairₓ'. -/
/-- Given an affinely independent family of points, a weighted subtraction lies in the
`vector_span` of two points given as affine combinations if and only if it is a weighted
subtraction with weights a multiple of the difference between the weights of the two points. -/
theorem weightedVSub_mem_vectorSpan_pair {p : ι → P} (h : AffineIndependent k p) {w w₁ w₂ : ι → k}
    {s : Finset ι} (hw : (∑ i in s, w i) = 0) (hw₁ : (∑ i in s, w₁ i) = 1)
    (hw₂ : (∑ i in s, w₂ i) = 1) :
    s.weightedVSub p w ∈
        vectorSpan k ({s.affineCombination k p w₁, s.affineCombination k p w₂} : Set P) ↔
      ∃ r : k, ∀ i ∈ s, w i = r * (w₁ i - w₂ i) :=
  by
  rw [mem_vectorSpan_pair]
  refine' ⟨fun h => _, fun h => _⟩
  · rcases h with ⟨r, hr⟩
    refine' ⟨r, fun i hi => _⟩
    rw [s.affine_combination_vsub, ← s.weighted_vsub_const_smul, ← sub_eq_zero, ← map_sub] at hr
    have hw' : (∑ j in s, (r • (w₁ - w₂) - w) j) = 0 := by
      simp_rw [Pi.sub_apply, Pi.smul_apply, Pi.sub_apply, smul_sub, Finset.sum_sub_distrib, ←
        Finset.smul_sum, hw, hw₁, hw₂, sub_self]
    have hr' := h s _ hw' hr i hi
    rw [eq_comm, ← sub_eq_zero, ← smul_eq_mul]
    exact hr'
  · rcases h with ⟨r, hr⟩
    refine' ⟨r, _⟩
    let w' i := r * (w₁ i - w₂ i)
    change ∀ i ∈ s, w i = w' i at hr
    rw [s.weighted_vsub_congr hr fun _ _ => rfl, s.affine_combination_vsub, ←
      s.weighted_vsub_const_smul]
    congr
#align weighted_vsub_mem_vector_span_pair weightedVSub_mem_vectorSpan_pair

/- warning: affine_combination_mem_affine_span_pair -> affineCombination_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u4} ι}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₂))))) (Exists.{succ u1} k (fun (r : k) => forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w i) (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1))) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1))) r (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) (w₂ i) (w₁ i))) (w₁ i)))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u1} ι}, (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) -> (Iff (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w) (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) _inst_1 _inst_2 _inst_3 _inst_4) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) _inst_1 _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) _inst_1 _inst_2 _inst_3 _inst_4 (Insert.insert.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₁) (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (Set.instInsertSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (Set.instSingletonSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w₂))))) (Exists.{succ u4} k (fun (r : k) => forall (i : ι), (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Eq.{succ u4} k (w i) (HAdd.hAdd.{u4, u4, u4} k k k (instHAdd.{u4} k (Distrib.toAdd.{u4} k (NonUnitalNonAssocSemiring.toDistrib.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))))) (HMul.hMul.{u4, u4, u4} k k k (instHMul.{u4} k (NonUnitalNonAssocRing.toMul.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) r (HSub.hSub.{u4, u4, u4} k k k (instHSub.{u4} k (Ring.toSub.{u4} k _inst_1)) (w₂ i) (w₁ i))) (w₁ i)))))))
Case conversion may be inaccurate. Consider using '#align affine_combination_mem_affine_span_pair affineCombination_mem_affineSpan_pairₓ'. -/
/-- Given an affinely independent family of points, an affine combination lies in the
span of two points given as affine combinations if and only if it is an affine combination
with weights those of one point plus a multiple of the difference between the weights of the
two points. -/
theorem affineCombination_mem_affineSpan_pair {p : ι → P} (h : AffineIndependent k p)
    {w w₁ w₂ : ι → k} {s : Finset ι} (hw : (∑ i in s, w i) = 1) (hw₁ : (∑ i in s, w₁ i) = 1)
    (hw₂ : (∑ i in s, w₂ i) = 1) :
    s.affineCombination k p w ∈ line[k, s.affineCombination k p w₁, s.affineCombination k p w₂] ↔
      ∃ r : k, ∀ i ∈ s, w i = r * (w₂ i - w₁ i) + w₁ i :=
  by
  rw [← vsub_vadd (s.affine_combination k p w) (s.affine_combination k p w₁),
    AffineSubspace.vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _),
    direction_affineSpan, s.affine_combination_vsub, Set.pair_comm,
    weightedVSub_mem_vectorSpan_pair h _ hw₂ hw₁]
  · simp only [Pi.sub_apply, sub_eq_iff_eq_add]
  · simp_rw [Pi.sub_apply, Finset.sum_sub_distrib, hw, hw₁, sub_self]
#align affine_combination_mem_affine_span_pair affineCombination_mem_affineSpan_pair

end AffineIndependent

section DivisionRing

variable {k : Type _} {V : Type _} {P : Type _} [DivisionRing k] [AddCommGroup V] [Module k V]

variable [affine_space V P] {ι : Type _}

include V

/- warning: exists_subset_affine_independent_affine_span_eq_top -> exists_subset_affineIndependent_affineSpan_eq_top is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : Set.{u3} P}, (AffineIndependent.{u1, u2, u3, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) (fun (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s))))) p)) -> (Exists.{succ u3} (Set.{u3} P) (fun (t : Set.{u3} P) => And (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) s t) (And (AffineIndependent.{u1, u2, u3, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) (fun (p : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x t))))) p)) (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 t) (Top.top.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.toHasTop.{u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.completeLattice.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {s : Set.{u3} P}, (AffineIndependent.{u2, u1, u3, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P s) (fun (p : Set.Elem.{u3} P s) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x s) p)) -> (Exists.{succ u3} (Set.{u3} P) (fun (t : Set.{u3} P) => And (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) s t) (And (AffineIndependent.{u2, u1, u3, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P t) (fun (p : Set.Elem.{u3} P t) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x t) p)) (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 t) (Top.top.{u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (CompleteLattice.toTop.{u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4)))))))
Case conversion may be inaccurate. Consider using '#align exists_subset_affine_independent_affine_span_eq_top exists_subset_affineIndependent_affineSpan_eq_topₓ'. -/
/-- An affinely independent set of points can be extended to such a
set that spans the whole space. -/
theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ :=
  by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)
  · have p₁ : P := add_torsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linear_independent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex _ _ → v ≠ 0 :=
      by
      intro v hv
      simpa using hsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    exact
      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linear_independent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : ∀ v : V, v ∈ h.extend _ → v ≠ 0 :=
      by
      intro v hv
      simpa using bsv.ne_zero ⟨v, hv⟩
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi
    refine' ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), _, _⟩
    · refine' Set.Subset.trans _ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    · use hsvi, affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt
#align exists_subset_affine_independent_affine_span_eq_top exists_subset_affineIndependent_affineSpan_eq_top

variable (k V)

/- warning: exists_affine_independent -> exists_affineIndependent is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Set.{u3} P), Exists.{succ u3} (Set.{u3} P) (fun (t : Set.{u3} P) => Exists.{0} (HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) t s) (fun (H : HasSubset.Subset.{u3} (Set.{u3} P) (Set.hasSubset.{u3} P) t s) => And (Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 t) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (AffineIndependent.{u1, u2, u3, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) t) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x t)))))))))
but is expected to have type
  forall (k : Type.{u2}) (V : Type.{u1}) {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Set.{u3} P), Exists.{succ u3} (Set.{u3} P) (fun (t : Set.{u3} P) => Exists.{0} (HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) t s) (fun (H : HasSubset.Subset.{u3} (Set.{u3} P) (Set.instHasSubsetSet.{u3} P) t s) => And (Eq.{succ u3} (AffineSubspace.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4) (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 t) (affineSpan.{u2, u1, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 s)) (AffineIndependent.{u2, u1, u3, u3} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x t)) (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x t)))))
Case conversion may be inaccurate. Consider using '#align exists_affine_independent exists_affineIndependentₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/
theorem exists_affineIndependent (s : Set P) :
    ∃ (t : _)(_ : t ⊆ s), affineSpan k t = affineSpan k s ∧ AffineIndependent k (coe : t → P) :=
  by
  rcases s.eq_empty_or_nonempty with (rfl | ⟨p, hp⟩)
  · exact ⟨∅, Set.empty_subset ∅, rfl, affineIndependent_of_subsingleton k _⟩
  obtain ⟨b, hb₁, hb₂, hb₃⟩ := exists_linearIndependent k ((Equiv.vaddConst p).symm '' s)
  have hb₀ : ∀ v : V, v ∈ b → v ≠ 0 := fun v hv => hb₃.ne_zero (⟨v, hv⟩ : b)
  rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k hb₀ p] at hb₃
  refine' ⟨{p} ∪ Equiv.vaddConst p '' b, _, _, hb₃⟩
  · apply Set.union_subset (set.singleton_subset_iff.mpr hp)
    rwa [← (Equiv.vaddConst p).subset_image' b s]
  · rw [Equiv.coe_vaddConst_symm, ← vectorSpan_eq_span_vsub_set_right k hp] at hb₂
    apply AffineSubspace.ext_of_direction_eq
    · have : Submodule.span k b = Submodule.span k (insert 0 b) := by simp
      simp only [direction_affineSpan, ← hb₂, Equiv.coe_vaddConst, Set.singleton_union,
        vectorSpan_eq_span_vsub_set_right k (Set.mem_insert p _), this]
      congr
      change (Equiv.vaddConst p).symm '' insert p (Equiv.vaddConst p '' b) = _
      rw [Set.image_insert_eq, ← Set.image_comp]
      simp
    · use p
      simp only [Equiv.coe_vaddConst, Set.singleton_union, Set.mem_inter_iff, coe_affineSpan]
      exact ⟨mem_spanPoints k _ _ (Set.mem_insert p _), mem_spanPoints k _ _ hp⟩
#align exists_affine_independent exists_affineIndependent

variable (k) {V P}

/- warning: affine_independent_of_ne -> affineIndependent_of_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {p₁ : P} {p₂ : P}, (Ne.{succ u3} P p₁ p₂) -> (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))))) (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₁ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₂ (Matrix.vecEmpty.{u3} P))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {p₁ : P} {p₂ : P}, (Ne.{succ u3} P p₁ p₂) -> (AffineIndependent.{u2, u1, u3, 0} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₁ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₂ (Matrix.vecEmpty.{u3} P))))
Case conversion may be inaccurate. Consider using '#align affine_independent_of_ne affineIndependent_of_neₓ'. -/
/-- Two different points are affinely independent. -/
theorem affineIndependent_of_ne {p₁ p₂ : P} (h : p₁ ≠ p₂) : AffineIndependent k ![p₁, p₂] :=
  by
  rw [affineIndependent_iff_linearIndependent_vsub k ![p₁, p₂] 0]
  let i₁ : { x // x ≠ (0 : Fin 2) } := ⟨1, by norm_num⟩
  have he' : ∀ i, i = i₁ := by
    rintro ⟨i, hi⟩
    ext
    fin_cases i
    · simpa using hi
  haveI : Unique { x // x ≠ (0 : Fin 2) } := ⟨⟨i₁⟩, he'⟩
  have hz : (![p₁, p₂] ↑default -ᵥ ![p₁, p₂] 0 : V) ≠ 0 :=
    by
    rw [he' default]
    simpa using h.symm
  exact linearIndependent_unique _ hz
#align affine_independent_of_ne affineIndependent_of_ne

variable {k V P}

/- warning: affine_independent.affine_independent_of_not_mem_span -> AffineIndependent.affineIndependent_of_not_mem_span is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P} {i : ι}, (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) (fun (x : Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i)) ι (coeSubtype.{succ u4} ι (fun (y : ι) => Ne.{succ u4} ι y i))))) x))) -> (Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.image.{u4, u3} ι P p (setOf.{u4} ι (fun (x : ι) => Ne.{succ u4} ι x i)))))) -> (AffineIndependent.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι p)
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P} {i : ι}, (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Subtype.{succ u1} ι (fun (y : ι) => Ne.{succ u1} ι y i)) (fun (x : Subtype.{succ u1} ι (fun (y : ι) => Ne.{succ u1} ι y i)) => p (Subtype.val.{succ u1} ι (fun (y : ι) => Ne.{succ u1} ι y i) x))) -> (Not (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4)) (p i) (affineSpan.{u4, u3, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.image.{u1, u2} ι P p (setOf.{u1} ι (fun (x : ι) => Ne.{succ u1} ι x i)))))) -> (AffineIndependent.{u4, u3, u2, u1} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 ι p)
Case conversion may be inaccurate. Consider using '#align affine_independent.affine_independent_of_not_mem_span AffineIndependent.affineIndependent_of_not_mem_spanₓ'. -/
/-- If all but one point of a family are affinely independent, and that point does not lie in
the affine span of that family, the family is affinely independent. -/
theorem AffineIndependent.affineIndependent_of_not_mem_span {p : ι → P} {i : ι}
    (ha : AffineIndependent k fun x : { y // y ≠ i } => p x)
    (hi : p i ∉ affineSpan k (p '' { x | x ≠ i })) : AffineIndependent k p := by
  classical
    intro s w hw hs
    let s' : Finset { y // y ≠ i } := s.subtype (· ≠ i)
    let p' : { y // y ≠ i } → P := fun x => p x
    by_cases his : i ∈ s ∧ w i ≠ 0
    · refine' False.elim (hi _)
      let wm : ι → k := -(w i)⁻¹ • w
      have hms : s.weighted_vsub p wm = (0 : V) := by simp [wm, hs]
      have hwm : (∑ i in s, wm i) = 0 := by simp [wm, ← Finset.mul_sum, hw]
      have hwmi : wm i = -1 := by simp [wm, his.2]
      let w' : { y // y ≠ i } → k := fun x => wm x
      have hw' : (∑ x in s', w' x) = 1 :=
        by
        simp_rw [w', Finset.sum_subtype_eq_sum_filter]
        rw [← s.sum_filter_add_sum_filter_not (· ≠ i)] at hwm
        simp_rw [Classical.not_not, Finset.filter_eq', if_pos his.1, Finset.sum_singleton, ← wm,
          hwmi, ← sub_eq_add_neg, sub_eq_zero] at hwm
        exact hwm
      rw [← s.affine_combination_eq_of_weighted_vsub_eq_zero_of_eq_neg_one hms his.1 hwmi, ←
        (Subtype.range_coe : _ = { x | x ≠ i }), ← Set.range_comp, ←
        s.affine_combination_subtype_eq_filter]
      exact affineCombination_mem_affineSpan hw' p'
    · rw [not_and_or, Classical.not_not] at his
      let w' : { y // y ≠ i } → k := fun x => w x
      have hw' : (∑ x in s', w' x) = 0 :=
        by
        simp_rw [Finset.sum_subtype_eq_sum_filter]
        rw [Finset.sum_filter_of_ne, hw]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      have hs' : s'.weighted_vsub p' w' = (0 : V) :=
        by
        simp_rw [Finset.weightedVSub_subtype_eq_filter]
        rw [Finset.weightedVSub_filter_of_ne, hs]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      intro j hj
      by_cases hji : j = i
      · rw [hji] at hj
        exact hji.symm ▸ his.neg_resolve_left hj
      · exact ha s' w' hw' hs' ⟨j, hji⟩ (Finset.mem_subtype.2 hj)
#align affine_independent.affine_independent_of_not_mem_span AffineIndependent.affineIndependent_of_not_mem_span

/- warning: affine_independent_of_ne_of_mem_of_mem_of_not_mem -> affineIndependent_of_ne_of_mem_of_mem_of_not_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u3} P p₁ p₂) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s) -> (Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s)) -> (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))) (Matrix.vecCons.{u3} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) p₁ (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₂ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₃ (Matrix.vecEmpty.{u3} P)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u1} P p₁ p₂) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s) -> (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s)) -> (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Matrix.vecCons.{u1} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) p₁ (Matrix.vecCons.{u1} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₂ (Matrix.vecCons.{u1} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₃ (Matrix.vecEmpty.{u1} P)))))
Case conversion may be inaccurate. Consider using '#align affine_independent_of_ne_of_mem_of_mem_of_not_mem affineIndependent_of_ne_of_mem_of_mem_of_not_memₓ'. -/
/-- If distinct points `p₁` and `p₂` lie in `s` but `p₃` does not, the three points are affinely
independent. -/
theorem affineIndependent_of_ne_of_mem_of_mem_of_not_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}
    (hp₁p₂ : p₁ ≠ p₂) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∉ s) :
    AffineIndependent k ![p₁, p₂, p₃] :=
  by
  have ha : AffineIndependent k fun x : { x : Fin 3 // x ≠ 2 } => ![p₁, p₂, p₃] x :=
    by
    rw [← affineIndependent_equiv (finSuccAboveEquiv (2 : Fin 3)).toEquiv]
    convert affineIndependent_of_ne k hp₁p₂
    ext x
    fin_cases x <;> rfl
  refine' ha.affine_independent_of_not_mem_span _
  intro h
  refine' hp₃ ((AffineSubspace.le_def' _ s).1 _ p₃ h)
  simp_rw [affineSpan_le, Set.image_subset_iff, Set.subset_def, Set.mem_preimage]
  intro x
  fin_cases x <;> simp [hp₁, hp₂]
#align affine_independent_of_ne_of_mem_of_mem_of_not_mem affineIndependent_of_ne_of_mem_of_mem_of_not_mem

/- warning: affine_independent_of_ne_of_mem_of_not_mem_of_mem -> affineIndependent_of_ne_of_mem_of_not_mem_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u3} P p₁ p₃) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s) -> (Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s)) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s) -> (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))) (Matrix.vecCons.{u3} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) p₁ (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₂ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₃ (Matrix.vecEmpty.{u3} P)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u1} P p₁ p₃) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s) -> (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s)) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s) -> (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Matrix.vecCons.{u1} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) p₁ (Matrix.vecCons.{u1} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₂ (Matrix.vecCons.{u1} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₃ (Matrix.vecEmpty.{u1} P)))))
Case conversion may be inaccurate. Consider using '#align affine_independent_of_ne_of_mem_of_not_mem_of_mem affineIndependent_of_ne_of_mem_of_not_mem_of_memₓ'. -/
/-- If distinct points `p₁` and `p₃` lie in `s` but `p₂` does not, the three points are affinely
independent. -/
theorem affineIndependent_of_ne_of_mem_of_not_mem_of_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}
    (hp₁p₃ : p₁ ≠ p₃) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∉ s) (hp₃ : p₃ ∈ s) :
    AffineIndependent k ![p₁, p₂, p₃] :=
  by
  rw [← affineIndependent_equiv (Equiv.swap (1 : Fin 3) 2)]
  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp₁p₃ hp₁ hp₃ hp₂ using 1
  ext x
  fin_cases x <;> rfl
#align affine_independent_of_ne_of_mem_of_not_mem_of_mem affineIndependent_of_ne_of_mem_of_not_mem_of_mem

/- warning: affine_independent_of_ne_of_not_mem_of_mem_of_mem -> affineIndependent_of_ne_of_not_mem_of_mem_of_mem is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u3} P p₂ p₃) -> (Not (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s)) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s) -> (AffineIndependent.{u1, u2, u3, 0} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))))) (Matrix.vecCons.{u3} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))))) p₁ (Matrix.vecCons.{u3} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) p₂ (Matrix.vecCons.{u3} P (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) p₃ (Matrix.vecEmpty.{u3} P)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {s : AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4} {p₁ : P} {p₂ : P} {p₃ : P}, (Ne.{succ u1} P p₂ p₃) -> (Not (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₁ s)) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₂ s) -> (Membership.mem.{u1, u1} P (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) p₃ s) -> (AffineIndependent.{u3, u2, u1, 0} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Fin (Nat.succ (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (Matrix.vecCons.{u1} P (Nat.succ (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))) p₁ (Matrix.vecCons.{u1} P (Nat.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) p₂ (Matrix.vecCons.{u1} P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) p₃ (Matrix.vecEmpty.{u1} P)))))
Case conversion may be inaccurate. Consider using '#align affine_independent_of_ne_of_not_mem_of_mem_of_mem affineIndependent_of_ne_of_not_mem_of_mem_of_memₓ'. -/
/-- If distinct points `p₂` and `p₃` lie in `s` but `p₁` does not, the three points are affinely
independent. -/
theorem affineIndependent_of_ne_of_not_mem_of_mem_of_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}
    (hp₂p₃ : p₂ ≠ p₃) (hp₁ : p₁ ∉ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) :
    AffineIndependent k ![p₁, p₂, p₃] :=
  by
  rw [← affineIndependent_equiv (Equiv.swap (0 : Fin 3) 2)]
  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp₂p₃.symm hp₃ hp₂ hp₁ using 1
  ext x
  fin_cases x <;> rfl
#align affine_independent_of_ne_of_not_mem_of_mem_of_mem affineIndependent_of_ne_of_not_mem_of_mem_of_mem

end DivisionRing

section Ordered

variable {k : Type _} {V : Type _} {P : Type _} [LinearOrderedRing k] [AddCommGroup V]

variable [Module k V] [affine_space V P] {ι : Type _}

include V

attribute [local instance] LinearOrderedRing.decidableLt

/- warning: sign_eq_of_affine_combination_mem_affine_span_pair -> sign_eq_of_affineCombination_mem_affineSpan_pair is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u4} ι}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w₂))))) -> (forall {i : ι} {j : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) j s) -> (Eq.{succ u1} k (w₁ i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))))))) -> (Eq.{succ u1} k (w₁ j) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))))))) -> (Eq.{1} SignType (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w₂ i)) (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w₂ j))) -> (Eq.{1} SignType (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w i)) (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w j)))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : LinearOrderedRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {w₁ : ι -> k} {w₂ : ι -> k} {s : Finset.{u1} ι}, (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) s (fun (i : ι) => w₁ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) -> (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) s (fun (i : ι) => w₂ i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) -> (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w) (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₁) (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (Set.instInsertSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w₁) (Singleton.singleton.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂) (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (Set.instSingletonSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w₂)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w₂))))) -> (forall {i : ι} {j : ι}, (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i s) -> (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) j s) -> (Eq.{succ u4} k (w₁ i) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1)))))))) -> (Eq.{succ u4} k (w₁ j) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1)))))))) -> (Eq.{1} SignType (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w₂ i)) (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w₂ j))) -> (Eq.{1} SignType (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w i)) (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w j)))))
Case conversion may be inaccurate. Consider using '#align sign_eq_of_affine_combination_mem_affine_span_pair sign_eq_of_affineCombination_mem_affineSpan_pairₓ'. -/
/-- Given an affinely independent family of points, suppose that an affine combination lies in
the span of two points given as affine combinations, and suppose that, for two indices, the
coefficients in the first point in the span are zero and those in the second point in the span
have the same sign. Then the coefficients in the combination lying in the span have the same
sign. -/
theorem sign_eq_of_affineCombination_mem_affineSpan_pair {p : ι → P} (h : AffineIndependent k p)
    {w w₁ w₂ : ι → k} {s : Finset ι} (hw : (∑ i in s, w i) = 1) (hw₁ : (∑ i in s, w₁ i) = 1)
    (hw₂ : (∑ i in s, w₂ i) = 1)
    (hs :
      s.affineCombination k p w ∈ line[k, s.affineCombination k p w₁, s.affineCombination k p w₂])
    {i j : ι} (hi : i ∈ s) (hj : j ∈ s) (hi0 : w₁ i = 0) (hj0 : w₁ j = 0)
    (hij : SignType.sign (w₂ i) = SignType.sign (w₂ j)) :
    SignType.sign (w i) = SignType.sign (w j) :=
  by
  rw [affineCombination_mem_affineSpan_pair h hw hw₁ hw₂] at hs
  rcases hs with ⟨r, hr⟩
  dsimp only at hr
  rw [hr i hi, hr j hj, hi0, hj0, add_zero, add_zero, sub_zero, sub_zero, sign_mul, sign_mul, hij]
#align sign_eq_of_affine_combination_mem_affine_span_pair sign_eq_of_affineCombination_mem_affineSpan_pair

/- warning: sign_eq_of_affine_combination_mem_affine_span_single_line_map -> sign_eq_of_affineCombination_mem_affineSpan_single_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : LinearOrderedRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p : ι -> P}, (AffineIndependent.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {s : Finset.{u4} ι}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) -> (forall {i₁ : ι} {i₂ : ι} {i₃ : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i₁ s) -> (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i₂ s) -> (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i₃ s) -> (Ne.{succ u4} ι i₁ i₂) -> (Ne.{succ u4} ι i₁ i₃) -> (Ne.{succ u4} ι i₂ i₃) -> (forall {c : k}, (LT.lt.{u1} k (Preorder.toHasLt.{u1} k (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) c) -> (LT.lt.{u1} k (Preorder.toHasLt.{u1} k (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) c (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))))))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u3, u3} P (Set.{u3} P) (Set.hasInsert.{u3} P) (p i₁) (Singleton.singleton.{u3, u3} P (Set.{u3} P) (Set.hasSingleton.{u3} P) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)) _inst_2 _inst_3 _inst_4 (p i₂) (p i₃)) c))))) -> (Eq.{1} SignType (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w i₂)) (coeFn.{succ u1, succ u1} (OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (fun (_x : OrderHom.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) => k -> SignType) (OrderHom.hasCoeToFun.{u1, 0} k SignType (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (LinearOrder.toLattice.{0} SignType SignType.linearOrder))))) (SignType.sign.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (StrictOrderedRing.toRing.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1))))))) (PartialOrder.toPreorder.{u1} k (OrderedAddCommGroup.toPartialOrder.{u1} k (StrictOrderedRing.toOrderedAddCommGroup.{u1} k (LinearOrderedRing.toStrictOrderedRing.{u1} k _inst_1)))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLt.{u1} k _inst_1 a b)) (w i₃))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : LinearOrderedRing.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u1}} {p : ι -> P}, (AffineIndependent.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι p) -> (forall {w : ι -> k} {s : Finset.{u1} ι}, (Eq.{succ u4} k (Finset.sum.{u4, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) -> (forall {i₁ : ι} {i₂ : ι} {i₃ : ι}, (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i₁ s) -> (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i₂ s) -> (Membership.mem.{u1, u1} ι (Finset.{u1} ι) (Finset.instMembershipFinset.{u1} ι) i₃ s) -> (Ne.{succ u1} ι i₁ i₂) -> (Ne.{succ u1} ι i₁ i₃) -> (Ne.{succ u1} ι i₂ i₃) -> (forall {c : k}, (LT.lt.{u4} k (Preorder.toLT.{u4} k (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) c) -> (LT.lt.{u4} k (Preorder.toLT.{u4} k (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) c (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (Semiring.toOne.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))))) -> (Membership.mem.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) w) (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (AffineSubspace.instSetLikeAffineSubspace.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ (max u4 u1)) (succ u3)) (succ u2), succ (max u4 u1), succ u2} (AffineMap.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u1, max u4 u1, u3, u2} k (ι -> k) (ι -> k) V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Pi.addCommGroup.{u1, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (Pi.module.{u1, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))))) (fun (i : ι) => Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u1} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u4, u3, u2, u1} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u4, u3, u2} k V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 (Insert.insert.{u2, u2} P (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c)) (Set.instInsertSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c)) (p i₁) (Singleton.singleton.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c) (Set.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c)) (Set.instSingletonSet.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) c)) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), succ u4, succ u2} (AffineMap.{u4, u4, u4, u3, u2} k k k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (addGroupIsAddTorsor.{u4} k (AddGroupWithOne.toAddGroup.{u4} k (Ring.toAddGroupWithOne.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : k) => P) _x) (AffineMap.funLike.{u4, u4, u4, u3, u2} k k k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) (Ring.toAddCommGroup.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (Semiring.toModule.{u4} k (Ring.toSemiring.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)))) (addGroupIsAddTorsor.{u4} k (AddGroupWithOne.toAddGroup.{u4} k (Ring.toAddGroupWithOne.{u4} k (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u4, u3, u2} k V P (StrictOrderedRing.toRing.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1)) _inst_2 _inst_3 _inst_4 (p i₂) (p i₃)) c))))) -> (Eq.{1} SignType (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w i₂)) (OrderHom.toFun.{u4, 0} k SignType (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (PartialOrder.toPreorder.{0} SignType (SemilatticeInf.toPartialOrder.{0} SignType (Lattice.toSemilatticeInf.{0} SignType (DistribLattice.toLattice.{0} SignType (instDistribLattice.{0} SignType SignType.instLinearOrderSignType))))) (SignType.sign.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (StrictOrderedSemiring.toSemiring.{u4} k (LinearOrderedSemiring.toStrictOrderedSemiring.{u4} k (LinearOrderedRing.toLinearOrderedSemiring.{u4} k _inst_1))))) (PartialOrder.toPreorder.{u4} k (StrictOrderedRing.toPartialOrder.{u4} k (LinearOrderedRing.toStrictOrderedRing.{u4} k _inst_1))) (fun (a : k) (b : k) => LinearOrderedRing.decidableLT.{u4} k _inst_1 a b)) (w i₃))))))
Case conversion may be inaccurate. Consider using '#align sign_eq_of_affine_combination_mem_affine_span_single_line_map sign_eq_of_affineCombination_mem_affineSpan_single_lineMapₓ'. -/
/-- Given an affinely independent family of points, suppose that an affine combination lies in
the span of one point of that family and a combination of another two points of that family given
by `line_map` with coefficient between 0 and 1. Then the coefficients of those two points in the
combination lying in the span have the same sign. -/
theorem sign_eq_of_affineCombination_mem_affineSpan_single_lineMap {p : ι → P}
    (h : AffineIndependent k p) {w : ι → k} {s : Finset ι} (hw : (∑ i in s, w i) = 1) {i₁ i₂ i₃ : ι}
    (h₁ : i₁ ∈ s) (h₂ : i₂ ∈ s) (h₃ : i₃ ∈ s) (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃)
    {c : k} (hc0 : 0 < c) (hc1 : c < 1)
    (hs : s.affineCombination k p w ∈ line[k, p i₁, AffineMap.lineMap (p i₂) (p i₃) c]) :
    SignType.sign (w i₂) = SignType.sign (w i₃) := by
  classical
    rw [← s.affine_combination_affine_combination_single_weights k p h₁, ←
      s.affine_combination_affine_combination_line_map_weights p h₂ h₃ c] at hs
    refine'
      sign_eq_of_affineCombination_mem_affineSpan_pair h hw
        (s.sum_affine_combination_single_weights k h₁)
        (s.sum_affine_combination_line_map_weights h₂ h₃ c) hs h₂ h₃
        (Finset.affineCombinationSingleWeights_apply_of_ne k h₁₂.symm)
        (Finset.affineCombinationSingleWeights_apply_of_ne k h₁₃.symm) _
    rw [Finset.affineCombinationLineMapWeights_apply_left h₂₃,
      Finset.affineCombinationLineMapWeights_apply_right h₂₃]
    simp [hc0, sub_pos.2 hc1]
#align sign_eq_of_affine_combination_mem_affine_span_single_line_map sign_eq_of_affineCombination_mem_affineSpan_single_lineMap

end Ordered

namespace Affine

variable (k : Type _) {V : Type _} (P : Type _) [Ring k] [AddCommGroup V] [Module k V]

variable [affine_space V P]

include V

#print Affine.Simplex /-
/-- A `simplex k P n` is a collection of `n + 1` affinely
independent points. -/
structure Simplex (n : ℕ) where
  points : Fin (n + 1) → P
  Independent : AffineIndependent k points
#align affine.simplex Affine.Simplex
-/

#print Affine.Triangle /-
/-- A `triangle k P` is a collection of three affinely independent points. -/
abbrev Triangle :=
  Simplex k P 2
#align affine.triangle Affine.Triangle
-/

namespace Simplex

variable {P}

#print Affine.Simplex.mkOfPoint /-
/-- Construct a 0-simplex from a point. -/
def mkOfPoint (p : P) : Simplex k P 0 :=
  ⟨fun _ => p, affineIndependent_of_subsingleton k _⟩
#align affine.simplex.mk_of_point Affine.Simplex.mkOfPoint
-/

/- warning: affine.simplex.mk_of_point_points -> Affine.Simplex.mkOfPoint_points is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (p : P) (i : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))), Eq.{succ u3} P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Affine.Simplex.mkOfPoint.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p) i) p
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (p : P) (i : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))), Eq.{succ u3} P (Affine.Simplex.points.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Affine.Simplex.mkOfPoint.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p) i) p
Case conversion may be inaccurate. Consider using '#align affine.simplex.mk_of_point_points Affine.Simplex.mkOfPoint_pointsₓ'. -/
/-- The point in a simplex constructed with `mk_of_point`. -/
@[simp]
theorem mkOfPoint_points (p : P) (i : Fin 1) : (mkOfPoint k p).points i = p :=
  rfl
#align affine.simplex.mk_of_point_points Affine.Simplex.mkOfPoint_points

instance [Inhabited P] : Inhabited (Simplex k P 0) :=
  ⟨mkOfPoint k default⟩

#print Affine.Simplex.nonempty /-
instance nonempty : Nonempty (Simplex k P 0) :=
  ⟨mkOfPoint k <| AddTorsor.nonempty.some⟩
#align affine.simplex.nonempty Affine.Simplex.nonempty
-/

variable {k V}

/- warning: affine.simplex.ext -> Affine.Simplex.ext is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} {s1 : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n} {s2 : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n}, (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s1 i) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s2 i)) -> (Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) s1 s2)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} {s1 : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n} {s2 : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n}, (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} P (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s1 i) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s2 i)) -> (Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) s1 s2)
Case conversion may be inaccurate. Consider using '#align affine.simplex.ext Affine.Simplex.extₓ'. -/
/-- Two simplices are equal if they have the same points. -/
@[ext]
theorem ext {n : ℕ} {s1 s2 : Simplex k P n} (h : ∀ i, s1.points i = s2.points i) : s1 = s2 :=
  by
  cases s1
  cases s2
  congr with i
  exact h i
#align affine.simplex.ext Affine.Simplex.ext

/- warning: affine.simplex.ext_iff -> Affine.Simplex.ext_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s1 : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (s2 : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n), Iff (Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) s1 s2) (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s1 i) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s2 i))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s1 : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (s2 : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n), Iff (Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) s1 s2) (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} P (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s1 i) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s2 i))
Case conversion may be inaccurate. Consider using '#align affine.simplex.ext_iff Affine.Simplex.ext_iffₓ'. -/
/-- Two simplices are equal if and only if they have the same points. -/
theorem ext_iff {n : ℕ} (s1 s2 : Simplex k P n) : s1 = s2 ↔ ∀ i, s1.points i = s2.points i :=
  ⟨fun h _ => h ▸ rfl, ext⟩
#align affine.simplex.ext_iff Affine.Simplex.ext_iff

#print Affine.Simplex.face /-
/-- A face of a simplex is a simplex with the given subset of
points. -/
def face {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) :
    Simplex k P m :=
  ⟨s.points ∘ fs.orderEmbOfFin h, s.Independent.comp_embedding (fs.orderEmbOfFin h).toEmbedding⟩
#align affine.simplex.face Affine.Simplex.face
-/

/- warning: affine.simplex.face_points -> Affine.Simplex.face_points is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h) i) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))))) (fun (_x : RelEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) => (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) (Finset.orderEmbOfFin.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) h) i))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} P (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h) i) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s (FunLike.coe.{1, 1, 1} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (_x : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (InfHomClass.toFunLike.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (LatticeHomClass.toInfHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (OrderHomClass.toLatticeHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (RelEmbedding.instRelHomClassRelEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.684 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.682 x._@.Mathlib.Order.Hom.Basic._hyg.684) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.699 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) x._@.Mathlib.Order.Hom.Basic._hyg.697 x._@.Mathlib.Order.Hom.Basic._hyg.699))))) (Finset.orderEmbOfFin.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) h) i))
Case conversion may be inaccurate. Consider using '#align affine.simplex.face_points Affine.Simplex.face_pointsₓ'. -/
/-- The points of a face of a simplex are given by `mono_of_fin`. -/
theorem face_points {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}
    (h : fs.card = m + 1) (i : Fin (m + 1)) :
    (s.face h).points i = s.points (fs.orderEmbOfFin h i) :=
  rfl
#align affine.simplex.face_points Affine.Simplex.face_points

/- warning: affine.simplex.face_points' -> Affine.Simplex.face_points' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} ((Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> P) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h)) (Function.comp.{1, 1, succ u3} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s) (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))))))) (fun (_x : RelEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) => (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Preorder.toHasLe.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LinearOrder.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))))))) (Finset.orderEmbOfFin.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.linearOrder (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) h)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} ((Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> P) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h)) (Function.comp.{1, 1, succ u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) P (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s) (FunLike.coe.{1, 1, 1} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (_x : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (InfHomClass.toFunLike.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (LatticeHomClass.toInfHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (OrderHomClass.toLatticeHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (RelEmbedding.instRelHomClassRelEmbedding.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.684 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.682 x._@.Mathlib.Order.Hom.Basic._hyg.684) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.699 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Preorder.toLE.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (PartialOrder.toPreorder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (SemilatticeInf.toPartialOrder.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toSemilatticeInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instDistribLattice.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))))) x._@.Mathlib.Order.Hom.Basic._hyg.697 x._@.Mathlib.Order.Hom.Basic._hyg.699))))) (Finset.orderEmbOfFin.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) h)))
Case conversion may be inaccurate. Consider using '#align affine.simplex.face_points' Affine.Simplex.face_points'ₓ'. -/
/-- The points of a face of a simplex are given by `mono_of_fin`. -/
theorem face_points' {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}
    (h : fs.card = m + 1) : (s.face h).points = s.points ∘ fs.orderEmbOfFin h :=
  rfl
#align affine.simplex.face_points' Affine.Simplex.face_points'

/- warning: affine.simplex.face_eq_mk_of_point -> Affine.Simplex.face_eq_mkOfPoint is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Affine.Simplex.face.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s (Singleton.singleton.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Finset.hasSingleton.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) i) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (Finset.card_singleton.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) i)) (Affine.Simplex.mkOfPoint.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s i))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Affine.Simplex.face.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s (Singleton.singleton.{0, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Finset.instSingletonFinset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) i) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (Finset.card_singleton.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) i)) (Affine.Simplex.mkOfPoint.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s i))
Case conversion may be inaccurate. Consider using '#align affine.simplex.face_eq_mk_of_point Affine.Simplex.face_eq_mkOfPointₓ'. -/
/-- A single-point face equals the 0-simplex constructed with
`mk_of_point`. -/
@[simp]
theorem face_eq_mkOfPoint {n : ℕ} (s : Simplex k P n) (i : Fin (n + 1)) :
    s.face (Finset.card_singleton i) = mkOfPoint k (s.points i) :=
  by
  ext
  simp [face_points]
#align affine.simplex.face_eq_mk_of_point Affine.Simplex.face_eq_mkOfPoint

/- warning: affine.simplex.range_face_points -> Affine.Simplex.range_face_points is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} (Set.{u3} P) (Set.range.{u3, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h))) (Set.image.{0, u3} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) P (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Set.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (HasLiftT.mk.{1, 1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Set.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (CoeTCₓ.coe.{1, 1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Set.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Finset.Set.hasCoeT.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))))) fs))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} (Set.{u1} P) (Set.range.{u1, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s fs m h))) (Set.image.{0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) P (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n s) (Finset.toSet.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs))
Case conversion may be inaccurate. Consider using '#align affine.simplex.range_face_points Affine.Simplex.range_face_pointsₓ'. -/
/-- The set of points of a face. -/
@[simp]
theorem range_face_points {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}
    (h : fs.card = m + 1) : Set.range (s.face h).points = s.points '' ↑fs := by
  rw [face_points', Set.range_comp, Finset.range_orderEmbOfFin]
#align affine.simplex.range_face_points Affine.Simplex.range_face_points

#print Affine.Simplex.reindex /-
/-- Remap a simplex along an `equiv` of index types. -/
@[simps]
def reindex {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) : Simplex k P n :=
  ⟨s.points ∘ e.symm, (affineIndependent_equiv e.symm).2 s.Independent⟩
#align affine.simplex.reindex Affine.Simplex.reindex
-/

/- warning: affine.simplex.reindex_refl -> Affine.Simplex.reindex_refl is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n), Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n n s (Equiv.refl.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) s
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n), Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n) (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n n s (Equiv.refl.{1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) s
Case conversion may be inaccurate. Consider using '#align affine.simplex.reindex_refl Affine.Simplex.reindex_reflₓ'. -/
/-- Reindexing by `equiv.refl` yields the original simplex. -/
@[simp]
theorem reindex_refl {n : ℕ} (s : Simplex k P n) : s.reindex (Equiv.refl (Fin (n + 1))) = s :=
  ext fun _ => rfl
#align affine.simplex.reindex_refl Affine.Simplex.reindex_refl

/- warning: affine.simplex.reindex_trans -> Affine.Simplex.reindex_trans is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n₁ : Nat} {n₂ : Nat} {n₃ : Nat} (e₁₂ : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (e₂₃ : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₃ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁), Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₃) (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁ n₃ s (Equiv.trans.{1, 1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n₃ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) e₁₂ e₂₃)) (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₂ n₃ (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁ n₂ s e₁₂) e₂₃)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n₁ : Nat} {n₂ : Nat} {n₃ : Nat} (e₁₂ : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (e₂₃ : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₃ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁), Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₃) (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁ n₃ s (Equiv.trans.{1, 1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n₃ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) e₁₂ e₂₃)) (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₂ n₃ (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n₁ n₂ s e₁₂) e₂₃)
Case conversion may be inaccurate. Consider using '#align affine.simplex.reindex_trans Affine.Simplex.reindex_transₓ'. -/
/-- Reindexing by the composition of two equivalences is the same as reindexing twice. -/
@[simp]
theorem reindex_trans {n₁ n₂ n₃ : ℕ} (e₁₂ : Fin (n₁ + 1) ≃ Fin (n₂ + 1))
    (e₂₃ : Fin (n₂ + 1) ≃ Fin (n₃ + 1)) (s : Simplex k P n₁) :
    s.reindex (e₁₂.trans e₂₃) = (s.reindex e₁₂).reindex e₂₃ :=
  rfl
#align affine.simplex.reindex_trans Affine.Simplex.reindex_trans

/- warning: affine.simplex.reindex_reindex_symm -> Affine.Simplex.reindex_reindex_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))), Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n m (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s e) (Equiv.symm.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) e)) s
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))), Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n m (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s e) (Equiv.symm.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) e)) s
Case conversion may be inaccurate. Consider using '#align affine.simplex.reindex_reindex_symm Affine.Simplex.reindex_reindex_symmₓ'. -/
/-- Reindexing by an equivalence and its inverse yields the original simplex. -/
@[simp]
theorem reindex_reindex_symm {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :
    (s.reindex e).reindex e.symm = s := by rw [← reindex_trans, Equiv.self_trans_symm, reindex_refl]
#align affine.simplex.reindex_reindex_symm Affine.Simplex.reindex_reindex_symm

/- warning: affine.simplex.reindex_symm_reindex -> Affine.Simplex.reindex_symm_reindex is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))), Eq.{succ u3} (Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n m (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s (Equiv.symm.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) e)) e) s
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))), Eq.{succ u1} (Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n m (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s (Equiv.symm.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) e)) e) s
Case conversion may be inaccurate. Consider using '#align affine.simplex.reindex_symm_reindex Affine.Simplex.reindex_symm_reindexₓ'. -/
/-- Reindexing by the inverse of an equivalence and that equivalence yields the original simplex. -/
@[simp]
theorem reindex_symm_reindex {m n : ℕ} (s : Simplex k P m) (e : Fin (n + 1) ≃ Fin (m + 1)) :
    (s.reindex e.symm).reindex e = s := by rw [← reindex_trans, Equiv.symm_trans_self, reindex_refl]
#align affine.simplex.reindex_symm_reindex Affine.Simplex.reindex_symm_reindex

/- warning: affine.simplex.reindex_range_points -> Affine.Simplex.reindex_range_points is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))), Eq.{succ u3} (Set.{u3} P) (Set.range.{u3, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 n (Affine.Simplex.reindex.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s e))) (Set.range.{u3, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 m s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {m : Nat} {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m) (e : Equiv.{1, 1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))), Eq.{succ u1} (Set.{u1} P) (Set.range.{u1, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 n (Affine.Simplex.reindex.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m n s e))) (Set.range.{u1, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 m s))
Case conversion may be inaccurate. Consider using '#align affine.simplex.reindex_range_points Affine.Simplex.reindex_range_pointsₓ'. -/
/-- Reindexing a simplex produces one with the same set of points. -/
@[simp]
theorem reindex_range_points {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :
    Set.range (s.reindex e).points = Set.range s.points := by
  rw [reindex, Set.range_comp, Equiv.range_eq_univ, Set.image_univ]
#align affine.simplex.reindex_range_points Affine.Simplex.reindex_range_points

end Simplex

end Affine

namespace Affine

namespace Simplex

variable {k : Type _} {V : Type _} {P : Type _} [DivisionRing k] [AddCommGroup V] [Module k V]
  [affine_space V P]

include V

/- warning: affine.simplex.face_centroid_eq_centroid -> Affine.Simplex.face_centroid_eq_centroid is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs m h))) (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m : Nat} (h : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} P (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 m (Affine.Simplex.face.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs m h))) (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s))
Case conversion may be inaccurate. Consider using '#align affine.simplex.face_centroid_eq_centroid Affine.Simplex.face_centroid_eq_centroidₓ'. -/
/-- The centroid of a face of a simplex as the centroid of a subset of
the points. -/
@[simp]
theorem face_centroid_eq_centroid {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}
    (h : fs.card = m + 1) : Finset.univ.centroid k (s.face h).points = fs.centroid k s.points :=
  by
  convert(finset.univ.centroid_map k (fs.order_emb_of_fin h).toEmbedding s.points).symm
  rw [← Finset.coe_inj, Finset.coe_map, Finset.coe_univ, Set.image_univ]
  simp
#align affine.simplex.face_centroid_eq_centroid Affine.Simplex.face_centroid_eq_centroid

/- warning: affine.simplex.centroid_eq_iff -> Affine.Simplex.centroid_eq_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs₁ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {fs₂ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m₁ : Nat} {m₂ : Nat}, (Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₁) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₂) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Iff (Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₁ (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s)) (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₂ (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s))) (Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) fs₁ fs₂))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : CharZero.{u3} k (AddGroupWithOne.toAddMonoidWithOne.{u3} k (Ring.toAddGroupWithOne.{u3} k (DivisionRing.toRing.{u3} k _inst_1)))] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs₁ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {fs₂ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m₁ : Nat} {m₂ : Nat}, (Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₁) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₂) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Iff (Eq.{succ u1} P (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₁ (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s)) (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₂ (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s))) (Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) fs₁ fs₂))
Case conversion may be inaccurate. Consider using '#align affine.simplex.centroid_eq_iff Affine.Simplex.centroid_eq_iffₓ'. -/
/-- Over a characteristic-zero division ring, the centroids given by
two subsets of the points of a simplex are equal if and only if those
faces are given by the same subset of points. -/
@[simp]
theorem centroid_eq_iff [CharZero k] {n : ℕ} (s : Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))}
    {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) :
    fs₁.centroid k s.points = fs₂.centroid k s.points ↔ fs₁ = fs₂ :=
  by
  refine' ⟨fun h => _, congr_arg _⟩
  rw [Finset.centroid_eq_affineCombination_fintype, Finset.centroid_eq_affineCombination_fintype] at
    h
  have ha :=
    (affineIndependent_iff_indicator_eq_of_affineCombination_eq k s.points).1 s.independent _ _ _ _
      (fs₁.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₁)
      (fs₂.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₂) h
  simp_rw [Finset.coe_univ, Set.indicator_univ, Function.funext_iff,
    Finset.centroidWeightsIndicator_def, Finset.centroidWeights, h₁, h₂] at ha
  ext i
  specialize ha i
  have key : ∀ n : ℕ, (n : k) + 1 ≠ 0 := fun n h => by norm_cast  at h
  -- we should be able to golf this to `refine ⟨λ hi, decidable.by_contradiction (λ hni, _), ...⟩`,
      -- but for some unknown reason it doesn't work.
      constructor <;>
      intro hi <;>
    by_contra hni
  · simpa [hni, hi, key] using ha
  · simpa [hni, hi, key] using ha.symm
#align affine.simplex.centroid_eq_iff Affine.Simplex.centroid_eq_iff

/- warning: affine.simplex.face_centroid_eq_iff -> Affine.Simplex.face_centroid_eq_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {n : Nat} (s : Affine.Simplex.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs₁ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {fs₂ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))} {m₁ : Nat} {m₂ : Nat} (h₁ : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₁) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (h₂ : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) fs₂) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Iff (Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₁ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 m₁ (Affine.Simplex.face.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs₁ m₁ h₁))) (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m₂ (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 m₂ (Affine.Simplex.face.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs₂ m₂ h₂)))) (Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) fs₁ fs₂)
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : CharZero.{u3} k (AddGroupWithOne.toAddMonoidWithOne.{u3} k (Ring.toAddGroupWithOne.{u3} k (DivisionRing.toRing.{u3} k _inst_1)))] {n : Nat} (s : Affine.Simplex.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n) {fs₁ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {fs₂ : Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))} {m₁ : Nat} {m₂ : Nat} (h₁ : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₁) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (h₂ : Eq.{1} Nat (Finset.card.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) fs₂) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Iff (Eq.{succ u1} P (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₁ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 m₁ (Affine.Simplex.face.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs₁ m₁ h₁))) (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) m₂ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 m₂ (Affine.Simplex.face.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s fs₂ m₂ h₂)))) (Eq.{1} (Finset.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) fs₁ fs₂)
Case conversion may be inaccurate. Consider using '#align affine.simplex.face_centroid_eq_iff Affine.Simplex.face_centroid_eq_iffₓ'. -/
/-- Over a characteristic-zero division ring, the centroids of two
faces of a simplex are equal if and only if those faces are given by
the same subset of points. -/
theorem face_centroid_eq_iff [CharZero k] {n : ℕ} (s : Simplex k P n)
    {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) :
    Finset.univ.centroid k (s.face h₁).points = Finset.univ.centroid k (s.face h₂).points ↔
      fs₁ = fs₂ :=
  by
  rw [face_centroid_eq_centroid, face_centroid_eq_centroid]
  exact s.centroid_eq_iff h₁ h₂
#align affine.simplex.face_centroid_eq_iff Affine.Simplex.face_centroid_eq_iff

/- warning: affine.simplex.centroid_eq_of_range_eq -> Affine.Simplex.centroid_eq_of_range_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} {s₁ : Affine.Simplex.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n} {s₂ : Affine.Simplex.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n}, (Eq.{succ u3} (Set.{u3} P) (Set.range.{u3, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s₁)) (Set.range.{u3, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s₂))) -> (Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s₁)) (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (Affine.Simplex.points.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 n s₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {n : Nat} {s₁ : Affine.Simplex.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n} {s₂ : Affine.Simplex.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n}, (Eq.{succ u1} (Set.{u1} P) (Set.range.{u1, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s₁)) (Set.range.{u1, 1} P (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s₂))) -> (Eq.{succ u1} P (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s₁)) (Finset.centroid.{u3, u2, u1, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Finset.univ.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Affine.Simplex.points.{u3, u2, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 n s₂)))
Case conversion may be inaccurate. Consider using '#align affine.simplex.centroid_eq_of_range_eq Affine.Simplex.centroid_eq_of_range_eqₓ'. -/
/-- Two simplices with the same points have the same centroid. -/
theorem centroid_eq_of_range_eq {n : ℕ} {s₁ s₂ : Simplex k P n}
    (h : Set.range s₁.points = Set.range s₂.points) :
    Finset.univ.centroid k s₁.points = Finset.univ.centroid k s₂.points :=
  by
  rw [← Set.image_univ, ← Set.image_univ, ← Finset.coe_univ] at h
  exact
    finset.univ.centroid_eq_of_inj_on_of_image_eq k _
      (fun _ _ _ _ he => AffineIndependent.injective s₁.independent he)
      (fun _ _ _ _ he => AffineIndependent.injective s₂.independent he) h
#align affine.simplex.centroid_eq_of_range_eq Affine.Simplex.centroid_eq_of_range_eq

end Simplex

end Affine

