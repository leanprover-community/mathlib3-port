/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module linear_algebra.affine_space.affine_map
! leanprover-community/mathlib commit f47581155c818e6361af4e4fda60d27d020c226b
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Set.Pointwise.Interval
import Mathbin.LinearAlgebra.AffineSpace.Basic
import Mathbin.LinearAlgebra.BilinearMap
import Mathbin.LinearAlgebra.Pi
import Mathbin.LinearAlgebra.Prod

/-!
# Affine maps

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines affine maps.

## Main definitions

* `affine_map` is the type of affine maps between two affine spaces with the same ring `k`.  Various
  basic examples of affine maps are defined, including `const`, `id`, `line_map` and `homothety`.

## Notations

* `P1 →ᵃ[k] P2` is a notation for `affine_map k P1 P2`;
* `affine_space V P`: a localized notation for `add_torsor V P` defined in
  `linear_algebra.affine_space.basic`.

## Implementation notes

`out_param` is used in the definition of `[add_torsor V P]` to make `V` an implicit argument
(deduced from `P`) in most cases; `include V` is needed in many cases for `V`, and type classes
using it, to be added as implicit arguments to individual lemmas.  As for modules, `k` is an
explicit argument rather than implied by `P` or `V`.

This file only provides purely algebraic definitions and results. Those depending on analysis or
topology are defined elsewhere; see `analysis.normed_space.add_torsor` and
`topology.algebra.affine`.

## References

* https://en.wikipedia.org/wiki/Affine_space
* https://en.wikipedia.org/wiki/Principal_homogeneous_space
-/


open Affine

#print AffineMap /-
/-- An `affine_map k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that
induces a corresponding linear map from `V1` to `V2`. -/
structure AffineMap (k : Type _) {V1 : Type _} (P1 : Type _) {V2 : Type _} (P2 : Type _) [Ring k]
  [AddCommGroup V1] [Module k V1] [affine_space V1 P1] [AddCommGroup V2] [Module k V2]
  [affine_space V2 P2] where
  toFun : P1 → P2
  linear : V1 →ₗ[k] V2
  map_vadd' : ∀ (p : P1) (v : V1), to_fun (v +ᵥ p) = linear v +ᵥ to_fun p
#align affine_map AffineMap
-/

-- mathport name: «expr →ᵃ[ ] »
notation:25 P1 " →ᵃ[" k:25 "] " P2:0 => AffineMap k P1 P2

instance (k : Type _) {V1 : Type _} (P1 : Type _) {V2 : Type _} (P2 : Type _) [Ring k]
    [AddCommGroup V1] [Module k V1] [affine_space V1 P1] [AddCommGroup V2] [Module k V2]
    [affine_space V2 P2] : CoeFun (P1 →ᵃ[k] P2) fun _ => P1 → P2 :=
  ⟨AffineMap.toFun⟩

namespace LinearMap

variable {k : Type _} {V₁ : Type _} {V₂ : Type _} [Ring k] [AddCommGroup V₁] [Module k V₁]
  [AddCommGroup V₂] [Module k V₂] (f : V₁ →ₗ[k] V₂)

#print LinearMap.toAffineMap /-
/-- Reinterpret a linear map as an affine map. -/
def toAffineMap : V₁ →ᵃ[k] V₂ where
  toFun := f
  linear := f
  map_vadd' p v := f.map_add v p
#align linear_map.to_affine_map LinearMap.toAffineMap
-/

/- warning: linear_map.coe_to_affine_map -> LinearMap.coe_toAffineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {V₂ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), Eq.{max (succ u2) (succ u3)} (V₁ -> V₂) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_4))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_4))) => V₁ -> V₂) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_4))) (LinearMap.toAffineMap.{u1, u2, u3} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V₁ -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f)
but is expected to have type
  forall {k : Type.{u1}} {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddCommGroup.{u2} V₂] [_inst_5 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4)] (f : LinearMap.{u1, u1, u3, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4) _inst_3 _inst_5), Eq.{max (succ u3) (succ u2)} (V₁ -> V₂) (AffineMap.toFun.{u1, u3, u3, u2, u2} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u2} V₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_4)) (LinearMap.toAffineMap.{u1, u3, u2} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f)) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u1, u1, u3, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4) _inst_3 _inst_5) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V₁) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u2} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f)
Case conversion may be inaccurate. Consider using '#align linear_map.coe_to_affine_map LinearMap.coe_toAffineMapₓ'. -/
@[simp]
theorem coe_toAffineMap : ⇑f.toAffineMap = f :=
  rfl
#align linear_map.coe_to_affine_map LinearMap.coe_toAffineMap

/- warning: linear_map.to_affine_map_linear -> LinearMap.toAffineMap_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {V₂ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (AffineMap.linear.{u1, u2, u2, u3, u3} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_4)) (LinearMap.toAffineMap.{u1, u2, u3} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f)) f
but is expected to have type
  forall {k : Type.{u1}} {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddCommGroup.{u2} V₂] [_inst_5 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4)] (f : LinearMap.{u1, u1, u3, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4) _inst_3 _inst_5), Eq.{max (succ u3) (succ u2)} (LinearMap.{u1, u1, u3, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_4) _inst_3 _inst_5) (AffineMap.linear.{u1, u3, u3, u2, u2} k V₁ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) _inst_4 _inst_5 (addGroupIsAddTorsor.{u2} V₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_4)) (LinearMap.toAffineMap.{u1, u3, u2} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f)) f
Case conversion may be inaccurate. Consider using '#align linear_map.to_affine_map_linear LinearMap.toAffineMap_linearₓ'. -/
@[simp]
theorem toAffineMap_linear : f.toAffineMap.linear = f :=
  rfl
#align linear_map.to_affine_map_linear LinearMap.toAffineMap_linear

end LinearMap

namespace AffineMap

variable {k : Type _} {V1 : Type _} {P1 : Type _} {V2 : Type _} {P2 : Type _} {V3 : Type _}
  {P3 : Type _} {V4 : Type _} {P4 : Type _} [Ring k] [AddCommGroup V1] [Module k V1]
  [affine_space V1 P1] [AddCommGroup V2] [Module k V2] [affine_space V2 P2] [AddCommGroup V3]
  [Module k V3] [affine_space V3 P3] [AddCommGroup V4] [Module k V4] [affine_space V4 P4]

include V1 V2

/- warning: affine_map.coe_mk -> AffineMap.coe_mk is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : P1 -> P2) (linear : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (add : forall (p : P1) (v : V1), Eq.{succ u5} P2 (f (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) v p)) (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) linear v) (f p))), Eq.{max (succ u3) (succ u5)} ((fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.mk.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f linear add)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.mk.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f linear add)) f
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u1}} {V2 : Type.{u3}} {P2 : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u5, u3} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)] [_inst_7 : AddTorsor.{u3, u2} V2 P2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)] (f : P1 -> P2) (linear : LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (add : forall (p : P1) (v : V1), Eq.{succ u2} P2 (f (HVAdd.hVAdd.{u4, u1, u1} V1 P1 P1 (instHVAdd.{u4, u1} V1 P1 (AddAction.toVAdd.{u4, u1} V1 P1 (SubNegMonoid.toAddMonoid.{u4} V1 (AddGroup.toSubNegMonoid.{u4} V1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2))) (AddTorsor.toAddAction.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4))) v p)) (HVAdd.hVAdd.{u3, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 P2 (instHVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (AddAction.toVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) _inst_5))) (AddTorsor.toAddAction.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) _inst_5) _inst_7))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) linear v) (f p))), Eq.{max (succ u1) (succ u2)} (P1 -> P2) (AffineMap.toFun.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.mk.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f linear add)) f
Case conversion may be inaccurate. Consider using '#align affine_map.coe_mk AffineMap.coe_mkₓ'. -/
/-- Constructing an affine map and coercing back to a function
produces the same map. -/
@[simp]
theorem coe_mk (f : P1 → P2) (linear add) : ((mk f linear add : P1 →ᵃ[k] P2) : P1 → P2) = f :=
  rfl
#align affine_map.coe_mk AffineMap.coe_mk

/-- `to_fun` is the same as the result of coercing to a function. -/
@[simp]
theorem toFun_eq_coe (f : P1 →ᵃ[k] P2) : f.toFun = ⇑f :=
  rfl
#align affine_map.to_fun_eq_coe AffineMap.toFun_eq_coe

/- warning: affine_map.map_vadd -> AffineMap.map_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1) (v : V1), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) v p)) (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) v) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1) (v : V1), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (HVAdd.hVAdd.{u4, u3, u3} V1 P1 P1 (instHVAdd.{u4, u3} V1 P1 (AddAction.toVAdd.{u4, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u4} V1 (AddGroup.toSubNegMonoid.{u4} V1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2))) (AddTorsor.toAddAction.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4))) v p)) (HVAdd.hVAdd.{u2, u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 P2 (instHVAdd.{u2, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (AddAction.toVAdd.{u2, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (SubNegMonoid.toAddMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) (AddGroup.toSubNegMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) (AddCommGroup.toAddGroup.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) _inst_5))) (AddTorsor.toAddAction.{u2, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) P2 (AddCommGroup.toAddGroup.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) v) _inst_5) _inst_7))) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) v) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p))
Case conversion may be inaccurate. Consider using '#align affine_map.map_vadd AffineMap.map_vaddₓ'. -/
/-- An affine map on the result of adding a vector to a point produces
the same result as the linear map applied to that vector, added to the
affine map applied to that point. -/
@[simp]
theorem map_vadd (f : P1 →ᵃ[k] P2) (p : P1) (v : V1) : f (v +ᵥ p) = f.linear v +ᵥ f p :=
  f.map_vadd' p v
#align affine_map.map_vadd AffineMap.map_vadd

/- warning: affine_map.linear_map_vsub -> AffineMap.linearMap_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p1 : P1) (p2 : P1), Eq.{succ u4} V2 (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p1 p2)) (VSub.vsub.{u4, u5} V2 P2 (AddTorsor.toHasVsub.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p1) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p2))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p1 : P1) (p2 : P1), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u3} V1 P1 (AddTorsor.toVSub.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p1 p2)) (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (VSub.vsub.{u4, u3} V1 P1 (AddTorsor.toVSub.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p1 p2)) (VSub.vsub.{u2, u1} V2 P2 (AddTorsor.toVSub.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5) _inst_7) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p1) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p2))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_map_vsub AffineMap.linearMap_vsubₓ'. -/
/-- The linear map on the result of subtracting two points is the
result of subtracting the result of the affine map on those two
points. -/
@[simp]
theorem linearMap_vsub (f : P1 →ᵃ[k] P2) (p1 p2 : P1) : f.linear (p1 -ᵥ p2) = f p1 -ᵥ f p2 := by
  conv_rhs => rw [← vsub_vadd p1 p2, map_vadd, vadd_vsub]
#align affine_map.linear_map_vsub AffineMap.linearMap_vsub

/- warning: affine_map.ext -> AffineMap.ext is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (forall (p : P1), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g p)) -> (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g)
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (forall (p : P1), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g p)) -> (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g)
Case conversion may be inaccurate. Consider using '#align affine_map.ext AffineMap.extₓ'. -/
/-- Two affine maps are equal if they coerce to the same function. -/
@[ext]
theorem ext {f g : P1 →ᵃ[k] P2} (h : ∀ p, f p = g p) : f = g :=
  by
  rcases f with ⟨f, f_linear, f_add⟩
  rcases g with ⟨g, g_linear, g_add⟩
  obtain rfl : f = g := funext h
  congr with v
  cases' (AddTorsor.nonempty : Nonempty P1) with p
  apply vadd_right_cancel (f p)
  erw [← f_add, ← g_add]
#align affine_map.ext AffineMap.ext

/- warning: affine_map.ext_iff -> AffineMap.ext_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g) (forall (p : P1), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g p))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g) (forall (p : P1), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g p))
Case conversion may be inaccurate. Consider using '#align affine_map.ext_iff AffineMap.ext_iffₓ'. -/
theorem ext_iff {f g : P1 →ᵃ[k] P2} : f = g ↔ ∀ p, f p = g p :=
  ⟨fun h p => h ▸ rfl, ext⟩
#align affine_map.ext_iff AffineMap.ext_iff

#print AffineMap.coeFn_injective /-
theorem coeFn_injective : @Function.Injective (P1 →ᵃ[k] P2) (P1 → P2) coeFn := fun f g H =>
  ext <| congr_fun H
#align affine_map.coe_fn_injective AffineMap.coeFn_injective
-/

/- warning: affine_map.congr_arg -> AffineMap.congr_arg is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {x : P1} {y : P1}, (Eq.{succ u3} P1 x y) -> (Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f y))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {x : P1} {y : P1}, (Eq.{succ u3} P1 x y) -> (Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f x) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f y))
Case conversion may be inaccurate. Consider using '#align affine_map.congr_arg AffineMap.congr_argₓ'. -/
protected theorem congr_arg (f : P1 →ᵃ[k] P2) {x y : P1} (h : x = y) : f x = f y :=
  congr_arg _ h
#align affine_map.congr_arg AffineMap.congr_arg

/- warning: affine_map.congr_fun -> AffineMap.congr_fun is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] {f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g) -> (forall (x : P1), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f x) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g x))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] {f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {g : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f g) -> (forall (x : P1), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f x) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g x))
Case conversion may be inaccurate. Consider using '#align affine_map.congr_fun AffineMap.congr_funₓ'. -/
protected theorem congr_fun {f g : P1 →ᵃ[k] P2} (h : f = g) (x : P1) : f x = g x :=
  h ▸ rfl
#align affine_map.congr_fun AffineMap.congr_fun

variable (k P1)

#print AffineMap.const /-
/-- Constant function as an `affine_map`. -/
def const (p : P2) : P1 →ᵃ[k] P2
    where
  toFun := Function.const P1 p
  linear := 0
  map_vadd' p v := by simp
#align affine_map.const AffineMap.const
-/

/- warning: affine_map.coe_const -> AffineMap.coe_const is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} (P1 : Type.{u3}) {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (p : P2), Eq.{max (succ u3) (succ u5)} (P1 -> P2) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.const.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (Function.const.{succ u5, succ u3} P2 P1 p)
but is expected to have type
  forall (k : Type.{u3}) {V1 : Type.{u2}} (P1 : Type.{u5}) {V2 : Type.{u1}} {P2 : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V2 P2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)] (p : P2), Eq.{max (succ u5) (succ u4)} (P1 -> P2) (AffineMap.toFun.{u3, u2, u5, u1, u4} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.const.{u3, u2, u5, u1, u4} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (Function.const.{succ u4, succ u5} P2 P1 p)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_const AffineMap.coe_constₓ'. -/
@[simp]
theorem coe_const (p : P2) : ⇑(const k P1 p) = Function.const P1 p :=
  rfl
#align affine_map.coe_const AffineMap.coe_const

/- warning: affine_map.const_linear -> AffineMap.const_linear is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} (P1 : Type.{u3}) {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (p : P2), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.const.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (OfNat.ofNat.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (OfNat.mk.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.zero.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasZero.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))))
but is expected to have type
  forall (k : Type.{u3}) {V1 : Type.{u5}} (P1 : Type.{u2}) {V2 : Type.{u4}} {P2 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u5} V1] [_inst_3 : Module.{u3, u5} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V1 P1 (AddCommGroup.toAddGroup.{u5} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u3, u4} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u1} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (p : P2), Eq.{max (succ u5) (succ u4)} (LinearMap.{u3, u3, u5, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u3, u5, u2, u4, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.const.{u3, u5, u2, u4, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 p)) (OfNat.ofNat.{max u5 u4} (LinearMap.{u3, u3, u5, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.toOfNat0.{max u5 u4} (LinearMap.{u3, u3, u5, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instZeroLinearMap.{u3, u3, u5, u4} k k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align affine_map.const_linear AffineMap.const_linearₓ'. -/
@[simp]
theorem const_linear (p : P2) : (const k P1 p).linear = 0 :=
  rfl
#align affine_map.const_linear AffineMap.const_linear

variable {k P1}

/- warning: affine_map.linear_eq_zero_iff_exists_const -> AffineMap.linear_eq_zero_iff_exists_const is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (OfNat.ofNat.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (OfNat.mk.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.zero.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasZero.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))))) (Exists.{succ u5} P2 (fun (q : P2) => Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f (AffineMap.const.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 q)))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Eq.{max (succ u4) (succ u2)} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) (OfNat.ofNat.{max u4 u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.toOfNat0.{max u4 u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instZeroLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))))))) (Exists.{succ u1} P2 (fun (q : P2) => Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f (AffineMap.const.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 q)))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_eq_zero_iff_exists_const AffineMap.linear_eq_zero_iff_exists_constₓ'. -/
theorem linear_eq_zero_iff_exists_const (f : P1 →ᵃ[k] P2) : f.linear = 0 ↔ ∃ q, f = const k P1 q :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · use f (Classical.arbitrary P1)
    ext
    rw [coe_const, Function.const_apply, ← @vsub_eq_zero_iff_eq V2, ← f.linear_map_vsub, h,
      LinearMap.zero_apply]
  · rcases h with ⟨q, rfl⟩
    exact const_linear k P1 q
#align affine_map.linear_eq_zero_iff_exists_const AffineMap.linear_eq_zero_iff_exists_const

#print AffineMap.nonempty /-
instance nonempty : Nonempty (P1 →ᵃ[k] P2) :=
  (AddTorsor.nonempty : Nonempty P2).elim fun p => ⟨const k P1 p⟩
#align affine_map.nonempty AffineMap.nonempty
-/

/- warning: affine_map.mk' -> AffineMap.mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (p : P1), (forall (p' : P1), Eq.{succ u5} P2 (f p') (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f' (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (f p))) -> (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (p : P1), (forall (p' : P1), Eq.{succ u5} P2 (f p') (HVAdd.hVAdd.{u4, u5, u5} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) P2 P2 (instHVAdd.{u4, u5} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) P2 (AddAction.toVAdd.{u4, u5} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) P2 (SubNegMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u4, u5} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) P2 (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f' (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toVSub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (f p))) -> (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align affine_map.mk' AffineMap.mk'ₓ'. -/
/-- Construct an affine map by verifying the relation between the map and its linear part at one
base point. Namely, this function takes a map `f : P₁ → P₂`, a linear map `f' : V₁ →ₗ[k] V₂`, and
a point `p` such that for any other point `p'` we have `f p' = f' (p' -ᵥ p) +ᵥ f p`. -/
def mk' (f : P1 → P2) (f' : V1 →ₗ[k] V2) (p : P1) (h : ∀ p' : P1, f p' = f' (p' -ᵥ p) +ᵥ f p) :
    P1 →ᵃ[k] P2 where
  toFun := f
  linear := f'
  map_vadd' p' v := by rw [h, h p', vadd_vsub_assoc, f'.map_add, vadd_vadd]
#align affine_map.mk' AffineMap.mk'

/- warning: affine_map.coe_mk' -> AffineMap.coe_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (p : P1) (h : forall (p' : P1), Eq.{succ u5} P2 (f p') (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f' (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (f p))), Eq.{max (succ u3) (succ u5)} (P1 -> P2) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.mk'.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' p h)) f
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u1}} {V2 : Type.{u3}} {P2 : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u5, u3} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)] [_inst_7 : AddTorsor.{u3, u2} V2 P2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (p : P1) (h : forall (p' : P1), Eq.{succ u2} P2 (f p') (HVAdd.hVAdd.{u3, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 P2 (instHVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (AddAction.toVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) f' (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (f p))), Eq.{max (succ u1) (succ u2)} (P1 -> P2) (AffineMap.toFun.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.mk'.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' p h)) f
Case conversion may be inaccurate. Consider using '#align affine_map.coe_mk' AffineMap.coe_mk'ₓ'. -/
@[simp]
theorem coe_mk' (f : P1 → P2) (f' : V1 →ₗ[k] V2) (p h) : ⇑(mk' f f' p h) = f :=
  rfl
#align affine_map.coe_mk' AffineMap.coe_mk'

/- warning: affine_map.mk'_linear -> AffineMap.mk'_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (p : P1) (h : forall (p' : P1), Eq.{succ u5} P2 (f p') (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) f' (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p' p)) (f p))), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.mk'.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' p h)) f'
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u1}} {V2 : Type.{u3}} {P2 : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u5, u3} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)] [_inst_7 : AddTorsor.{u3, u2} V2 P2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)] (f : P1 -> P2) (f' : LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (p : P1) (h : forall (p' : P1), Eq.{succ u2} P2 (f p') (HVAdd.hVAdd.{u3, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 P2 (instHVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (AddAction.toVAdd.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u3, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) P2 (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u3} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) f' (VSub.vsub.{u4, u1} V1 P1 (AddTorsor.toVSub.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2) _inst_4) p' p)) (f p))), Eq.{max (succ u4) (succ u3)} (LinearMap.{u5, u5, u4, u3} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineMap.mk'.{u5, u4, u1, u3, u2} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' p h)) f'
Case conversion may be inaccurate. Consider using '#align affine_map.mk'_linear AffineMap.mk'_linearₓ'. -/
@[simp]
theorem mk'_linear (f : P1 → P2) (f' : V1 →ₗ[k] V2) (p h) : (mk' f f' p h).linear = f' :=
  rfl
#align affine_map.mk'_linear AffineMap.mk'_linear

section SMul

variable {R : Type _} [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]

/-- The space of affine maps to a module inherits an `R`-action from the action on its codomain. -/
instance : MulAction R (P1 →ᵃ[k] V2)
    where
  smul c f := ⟨c • f, c • f.linear, fun p v => by simp [smul_add]⟩
  one_smul f := ext fun p => one_smul _ _
  mul_smul c₁ c₂ f := ext fun p => mul_smul _ _ _

/- warning: affine_map.coe_smul -> AffineMap.coe_smul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] {R : Type.{u5}} [_inst_14 : Monoid.{u5} R] [_inst_15 : DistribMulAction.{u5, u4} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))] [_inst_16 : SMulCommClass.{u1, u5, u4} k R V2 (SMulZeroClass.toHasSmul.{u1, u4} k V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (SMulWithZero.toSmulZeroClass.{u1, u4} k V2 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (MulActionWithZero.toSMulWithZero.{u1, u4} k V2 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (Module.toMulActionWithZero.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u4} R V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))))) (DistribSMul.toSmulZeroClass.{u5, u4} R V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u5, u4} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) _inst_15)))] (c : R) (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{succ (max u3 u4)} (P1 -> V2) (coeFn.{succ (max u2 u3 u4), succ (max u3 u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (SMul.smul.{u5, max u2 u3 u4} R (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (MulAction.toHasSmul.{u5, max u2 u3 u4} R (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) _inst_14 (AffineMap.mulAction.{u1, u2, u3, u4, u5} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 R _inst_14 _inst_15 _inst_16)) c f)) (SMul.smul.{u5, max u3 u4} R (P1 -> V2) (Function.hasSMul.{u3, u5, u4} P1 R V2 (SMulZeroClass.toHasSmul.{u5, u4} R V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))))) (DistribSMul.toSmulZeroClass.{u5, u4} R V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u5, u4} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) _inst_15)))) c (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) f))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] {R : Type.{u1}} [_inst_14 : Monoid.{u1} R] [_inst_15 : DistribMulAction.{u1, u2} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)))] [_inst_16 : SMulCommClass.{u5, u1, u2} k R V2 (SMulZeroClass.toSMul.{u5, u2} k V2 (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (SMulWithZero.toSMulZeroClass.{u5, u2} k V2 (MonoidWithZero.toZero.{u5} k (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (MulActionWithZero.toSMulWithZero.{u5, u2} k V2 (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (Module.toMulActionWithZero.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_6)))) (SMulZeroClass.toSMul.{u1, u2} R V2 (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V2 (AddMonoid.toAddZeroClass.{u2} V2 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u1, u2} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) _inst_15)))] (c : R) (f : AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))), Eq.{max (succ u3) (succ u2)} (P1 -> V2) (AffineMap.toFun.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) (HSMul.hSMul.{u1, max (max u4 u3) u2, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (instHSMul.{u1, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (MulAction.toSMul.{u1, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) _inst_14 (AffineMap.mulAction.{u5, u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 R _inst_14 _inst_15 _inst_16))) c f)) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} R (P1 -> V2) (P1 -> V2) (instHSMul.{u1, max u3 u2} R (P1 -> V2) (Pi.instSMul.{u3, u2, u1} P1 R (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.93 : P1) => V2) (fun (i : P1) => SMulZeroClass.toSMul.{u1, u2} R V2 (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V2 (AddMonoid.toAddZeroClass.{u2} V2 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u1, u2} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) _inst_15))))) c (AffineMap.toFun.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) f))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_smul AffineMap.coe_smulₓ'. -/
@[simp, norm_cast]
theorem coe_smul (c : R) (f : P1 →ᵃ[k] V2) : ⇑(c • f) = c • f :=
  rfl
#align affine_map.coe_smul AffineMap.coe_smul

/- warning: affine_map.smul_linear -> AffineMap.smul_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] {R : Type.{u5}} [_inst_14 : Monoid.{u5} R] [_inst_15 : DistribMulAction.{u5, u4} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))] [_inst_16 : SMulCommClass.{u1, u5, u4} k R V2 (SMulZeroClass.toHasSmul.{u1, u4} k V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (SMulWithZero.toSmulZeroClass.{u1, u4} k V2 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (MulActionWithZero.toSMulWithZero.{u1, u4} k V2 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)))) (Module.toMulActionWithZero.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_6)))) (SMulZeroClass.toHasSmul.{u5, u4} R V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))))) (DistribSMul.toSmulZeroClass.{u5, u4} R V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u5, u4} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) _inst_15)))] (t : R) (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) (SMul.smul.{u5, max u2 u3 u4} R (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (MulAction.toHasSmul.{u5, max u2 u3 u4} R (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) _inst_14 (AffineMap.mulAction.{u1, u2, u3, u4, u5} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 R _inst_14 _inst_15 _inst_16)) t f)) (SMul.smul.{u5, max u2 u4} R (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasSmul.{u1, u1, u5, u2, u4} k k R V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_14 _inst_15 _inst_16) t (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) f))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] {R : Type.{u1}} [_inst_14 : Monoid.{u1} R] [_inst_15 : DistribMulAction.{u1, u2} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)))] [_inst_16 : SMulCommClass.{u5, u1, u2} k R V2 (SMulZeroClass.toSMul.{u5, u2} k V2 (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (SMulWithZero.toSMulZeroClass.{u5, u2} k V2 (MonoidWithZero.toZero.{u5} k (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (MulActionWithZero.toSMulWithZero.{u5, u2} k V2 (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (Module.toMulActionWithZero.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_6)))) (SMulZeroClass.toSMul.{u1, u2} R V2 (NegZeroClass.toZero.{u2} V2 (SubNegZeroMonoid.toNegZeroClass.{u2} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V2 (AddCommGroup.toDivisionAddCommMonoid.{u2} V2 _inst_5))))) (DistribSMul.toSMulZeroClass.{u1, u2} R V2 (AddMonoid.toAddZeroClass.{u2} V2 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)))) (DistribMulAction.toDistribSMul.{u1, u2} R V2 _inst_14 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) _inst_15)))] (t : R) (f : AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))), Eq.{max (succ u4) (succ u2)} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) (HSMul.hSMul.{u1, max (max u4 u3) u2, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (instHSMul.{u1, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (MulAction.toSMul.{u1, max (max u4 u3) u2} R (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) _inst_14 (AffineMap.mulAction.{u5, u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 R _inst_14 _inst_15 _inst_16))) t f)) (HSMul.hSMul.{u1, max u4 u2, max u4 u2} R (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (instHSMul.{u1, max u4 u2} R (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instSMulLinearMap.{u5, u5, u1, u4, u2} k k R V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) _inst_14 _inst_15 _inst_16)) t (AffineMap.linear.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) f))
Case conversion may be inaccurate. Consider using '#align affine_map.smul_linear AffineMap.smul_linearₓ'. -/
@[simp]
theorem smul_linear (t : R) (f : P1 →ᵃ[k] V2) : (t • f).linear = t • f.linear :=
  rfl
#align affine_map.smul_linear AffineMap.smul_linear

instance [DistribMulAction Rᵐᵒᵖ V2] [IsCentralScalar R V2] : IsCentralScalar R (P1 →ᵃ[k] V2)
    where op_smul_eq_smul r x := ext fun _ => op_smul_eq_smul _ _

end SMul

instance : Zero (P1 →ᵃ[k] V2) where zero := ⟨0, 0, fun p v => (zero_vadd _ _).symm⟩

instance : Add (P1 →ᵃ[k] V2)
    where add f g := ⟨f + g, f.linear + g.linear, fun p v => by simp [add_add_add_comm]⟩

instance : Sub (P1 →ᵃ[k] V2)
    where sub f g := ⟨f - g, f.linear - g.linear, fun p v => by simp [sub_add_sub_comm]⟩

instance : Neg (P1 →ᵃ[k] V2) where neg f := ⟨-f, -f.linear, fun p v => by simp [add_comm]⟩

/- warning: affine_map.coe_zero -> AffineMap.coe_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)], Eq.{succ (max u3 u4)} (P1 -> V2) (coeFn.{max (succ u2) (succ u3) (succ u4), succ (max u3 u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (OfNat.ofNat.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) 0 (OfNat.mk.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) 0 (Zero.zero.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasZero.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) (OfNat.ofNat.{max u3 u4} (P1 -> V2) 0 (OfNat.mk.{max u3 u4} (P1 -> V2) 0 (Zero.zero.{max u3 u4} (P1 -> V2) (Pi.instZero.{u3, u4} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))))))))
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u4}} {V2 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u4} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u2, u3} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)], Eq.{max (succ u4) (succ u3)} (P1 -> V2) (AffineMap.toFun.{u2, u1, u4, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) (OfNat.ofNat.{max (max u1 u4) u3} (AffineMap.{u2, u1, u4, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) 0 (Zero.toOfNat0.{max (max u1 u4) u3} (AffineMap.{u2, u1, u4, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u2, u1, u4, u3} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (OfNat.ofNat.{max u4 u3} (P1 -> V2) 0 (Zero.toOfNat0.{max u4 u3} (P1 -> V2) (Pi.instZero.{u4, u3} P1 (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.93 : P1) => V2) (fun (i : P1) => NegZeroClass.toZero.{u3} V2 (SubNegZeroMonoid.toNegZeroClass.{u3} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V2 (AddCommGroup.toDivisionAddCommMonoid.{u3} V2 _inst_5))))))))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_zero AffineMap.coe_zeroₓ'. -/
@[simp, norm_cast]
theorem coe_zero : ⇑(0 : P1 →ᵃ[k] V2) = 0 :=
  rfl
#align affine_map.coe_zero AffineMap.coe_zero

/- warning: affine_map.coe_add -> AffineMap.coe_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (g : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{succ (max u3 u4)} (P1 -> V2) (coeFn.{succ (max u2 u3 u4), succ (max u3 u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (HAdd.hAdd.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (instHAdd.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasAdd.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HAdd.hAdd.{max u3 u4, max u3 u4, max u3 u4} (P1 -> V2) (P1 -> V2) (P1 -> V2) (instHAdd.{max u3 u4} (P1 -> V2) (Pi.instAdd.{u3, u4} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => AddZeroClass.toHasAdd.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))))))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) f) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) g))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (g : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u2) (succ u1)} (P1 -> V2) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (HAdd.hAdd.{max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (instHAdd.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instAddAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (P1 -> V2) (P1 -> V2) (P1 -> V2) (instHAdd.{max u2 u1} (P1 -> V2) (Pi.instAdd.{u2, u1} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => AddZeroClass.toAdd.{u1} V2 (AddMonoid.toAddZeroClass.{u1} V2 (SubNegMonoid.toAddMonoid.{u1} V2 (AddGroup.toSubNegMonoid.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))))))) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) g))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_add AffineMap.coe_addₓ'. -/
@[simp, norm_cast]
theorem coe_add (f g : P1 →ᵃ[k] V2) : ⇑(f + g) = f + g :=
  rfl
#align affine_map.coe_add AffineMap.coe_add

/- warning: affine_map.coe_neg -> AffineMap.coe_neg is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{succ (max u3 u4)} (P1 -> V2) (coeFn.{succ (max u2 u3 u4), succ (max u3 u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (Neg.neg.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasNeg.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)) (Neg.neg.{max u3 u4} (P1 -> V2) (Pi.instNeg.{u3, u4} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => SubNegMonoid.toHasNeg.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) f))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u2) (succ u1)} (P1 -> V2) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (Neg.neg.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instNegAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)) (Neg.neg.{max u2 u1} (P1 -> V2) (Pi.instNeg.{u2, u1} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => NegZeroClass.toNeg.{u1} V2 (SubNegZeroMonoid.toNegZeroClass.{u1} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V2 (AddCommGroup.toDivisionAddCommMonoid.{u1} V2 _inst_5)))))) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_neg AffineMap.coe_negₓ'. -/
@[simp, norm_cast]
theorem coe_neg (f : P1 →ᵃ[k] V2) : ⇑(-f) = -f :=
  rfl
#align affine_map.coe_neg AffineMap.coe_neg

/- warning: affine_map.coe_sub -> AffineMap.coe_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (g : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{succ (max u3 u4)} (P1 -> V2) (coeFn.{succ (max u2 u3 u4), succ (max u3 u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (HSub.hSub.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (instHSub.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasSub.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HSub.hSub.{max u3 u4, max u3 u4, max u3 u4} (P1 -> V2) (P1 -> V2) (P1 -> V2) (instHSub.{max u3 u4} (P1 -> V2) (Pi.instSub.{u3, u4} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => SubNegMonoid.toHasSub.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))))) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) f) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) g))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (g : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u2) (succ u1)} (P1 -> V2) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (HSub.hSub.{max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (instHSub.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instSubAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (P1 -> V2) (P1 -> V2) (P1 -> V2) (instHSub.{max u2 u1} (P1 -> V2) (Pi.instSub.{u2, u1} P1 (fun (ᾰ : P1) => V2) (fun (i : P1) => SubNegMonoid.toSub.{u1} V2 (AddGroup.toSubNegMonoid.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))))) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (AffineMap.toFun.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) g))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_sub AffineMap.coe_subₓ'. -/
@[simp, norm_cast]
theorem coe_sub (f g : P1 →ᵃ[k] V2) : ⇑(f - g) = f - g :=
  rfl
#align affine_map.coe_sub AffineMap.coe_sub

/- warning: affine_map.zero_linear -> AffineMap.zero_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)], Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) (OfNat.ofNat.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) 0 (OfNat.mk.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) 0 (Zero.zero.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasZero.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6))))) (OfNat.ofNat.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (OfNat.mk.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.zero.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasZero.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))))
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u4}} {P1 : Type.{u1}} {V2 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u2, u4} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u1} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u2, u3} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)], Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u2, u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u2, u4, u1, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) (OfNat.ofNat.{max (max u4 u1) u3} (AffineMap.{u2, u4, u1, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) 0 (Zero.toOfNat0.{max (max u4 u1) u3} (AffineMap.{u2, u4, u1, u3, u3} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u2, u4, u1, u3} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (OfNat.ofNat.{max u4 u3} (LinearMap.{u2, u2, u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) 0 (Zero.toOfNat0.{max u4 u3} (LinearMap.{u2, u2, u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instZeroLinearMap.{u2, u2, u4, u3} k k V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align affine_map.zero_linear AffineMap.zero_linearₓ'. -/
@[simp]
theorem zero_linear : (0 : P1 →ᵃ[k] V2).linear = 0 :=
  rfl
#align affine_map.zero_linear AffineMap.zero_linear

/- warning: affine_map.add_linear -> AffineMap.add_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (g : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) (HAdd.hAdd.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (instHAdd.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasAdd.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HAdd.hAdd.{max u2 u4, max u2 u4, max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (instHAdd.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasAdd.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) f) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) g))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (g : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (HAdd.hAdd.{max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (instHAdd.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instAddAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (instHAdd.{max u3 u1} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instAddLinearMap.{u4, u4, u3, u1} k k V1 V2 (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) g))
Case conversion may be inaccurate. Consider using '#align affine_map.add_linear AffineMap.add_linearₓ'. -/
@[simp]
theorem add_linear (f g : P1 →ᵃ[k] V2) : (f + g).linear = f.linear + g.linear :=
  rfl
#align affine_map.add_linear AffineMap.add_linear

/- warning: affine_map.sub_linear -> AffineMap.sub_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (g : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) (HSub.hSub.{max u2 u3 u4, max u2 u3 u4, max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (instHSub.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasSub.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HSub.hSub.{max u2 u4, max u2 u4, max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (instHSub.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasSub.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5 _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) f) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) g))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (g : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (HSub.hSub.{max (max u3 u2) u1, max (max u3 u2) u1, max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (instHSub.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instSubAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) f g)) (HSub.hSub.{max u3 u1, max u3 u1, max u3 u1} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (instHSub.{max u3 u1} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instSubLinearMapToAddCommMonoid.{u4, u4, u3, u1} k k V1 V2 (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_5 _inst_3 _inst_6 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))))) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) g))
Case conversion may be inaccurate. Consider using '#align affine_map.sub_linear AffineMap.sub_linearₓ'. -/
@[simp]
theorem sub_linear (f g : P1 →ᵃ[k] V2) : (f - g).linear = f.linear - g.linear :=
  rfl
#align affine_map.sub_linear AffineMap.sub_linear

/- warning: affine_map.neg_linear -> AffineMap.neg_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) (Neg.neg.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.hasNeg.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)) (Neg.neg.{max u2 u4} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (LinearMap.hasNeg.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5 _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)) f))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u4, u1} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u3) (succ u1)} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) (Neg.neg.{max (max u3 u2) u1} (AffineMap.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))) (AffineMap.instNegAffineMapAddGroupIsAddTorsorToAddGroup.{u4, u3, u2, u1} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6) f)) (Neg.neg.{max u3 u1} (LinearMap.{u4, u4, u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (LinearMap.instNegLinearMapToAddCommMonoid.{u4, u4, u3, u1} k k V1 V2 (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_5 _inst_3 _inst_6 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1)))) (AffineMap.linear.{u4, u3, u2, u1, u1} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f))
Case conversion may be inaccurate. Consider using '#align affine_map.neg_linear AffineMap.neg_linearₓ'. -/
@[simp]
theorem neg_linear (f : P1 →ᵃ[k] V2) : (-f).linear = -f.linear :=
  rfl
#align affine_map.neg_linear AffineMap.neg_linear

/-- The set of affine maps to a vector space is an additive commutative group. -/
instance : AddCommGroup (P1 →ᵃ[k] V2) :=
  coeFn_injective.AddCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_smul _ _)
    fun _ _ => coe_smul _ _

/-- The space of affine maps from `P1` to `P2` is an affine space over the space of affine maps
from `P1` to the vector space `V2` corresponding to `P2`. -/
instance : affine_space (P1 →ᵃ[k] V2) (P1 →ᵃ[k] P2)
    where
  vadd f g :=
    ⟨fun p => f p +ᵥ g p, f.linear + g.linear, fun p v => by simp [vadd_vadd, add_right_comm]⟩
  zero_vadd f := ext fun p => zero_vadd _ (f p)
  add_vadd f₁ f₂ f₃ := ext fun p => add_vadd (f₁ p) (f₂ p) (f₃ p)
  vsub f g :=
    ⟨fun p => f p -ᵥ g p, f.linear - g.linear, fun p v => by
      simp [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub, sub_add_eq_add_sub]⟩
  vsub_vadd' f g := ext fun p => vsub_vadd (f p) (g p)
  vadd_vsub' f g := ext fun p => vadd_vsub (f p) (g p)

/- warning: affine_map.vadd_apply -> AffineMap.vadd_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (VAdd.vadd.{max u2 u3 u4, max u2 u3 u4 u5} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddAction.toHasVadd.{max u2 u3 u4, max u2 u3 u4 u5} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (SubNegMonoid.toAddMonoid.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddGroup.toSubNegMonoid.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddCommGroup.toAddGroup.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.addCommGroup.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (AddTorsor.toAddAction.{max u2 u3 u4, max u2 u3 u4 u5} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddCommGroup.toAddGroup.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.addCommGroup.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) (AffineMap.addTorsor.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f g) p) (VAdd.vadd.{u4, u5} V2 P2 (AddAction.toHasVadd.{u4, u5} V2 P2 (SubNegMonoid.toAddMonoid.{u4} V2 (AddGroup.toSubNegMonoid.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AddTorsor.toAddAction.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) f p) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g p))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (g : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (HVAdd.hVAdd.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (instHVAdd.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddAction.toVAdd.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (SubNegMonoid.toAddMonoid.{max (max u4 u3) u2} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AddGroup.toSubNegMonoid.{max (max u4 u3) u2} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AddCommGroup.toAddGroup.{max (max u4 u3) u2} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u5, u4, u3, u2} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)))) (AddTorsor.toAddAction.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddCommGroup.toAddGroup.{max (max u4 u3) u2} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u5, u4, u3, u2} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) f g) p) (HVAdd.hVAdd.{u2, u1, u1} V2 P2 P2 (instHVAdd.{u2, u1} V2 P2 (AddAction.toVAdd.{u2, u1} V2 P2 (SubNegMonoid.toAddMonoid.{u2} V2 (AddGroup.toSubNegMonoid.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AddTorsor.toAddAction.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5) _inst_7))) (AffineMap.toFun.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) f p) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g p))
Case conversion may be inaccurate. Consider using '#align affine_map.vadd_apply AffineMap.vadd_applyₓ'. -/
@[simp]
theorem vadd_apply (f : P1 →ᵃ[k] V2) (g : P1 →ᵃ[k] P2) (p : P1) : (f +ᵥ g) p = f p +ᵥ g p :=
  rfl
#align affine_map.vadd_apply AffineMap.vadd_apply

/- warning: affine_map.vsub_apply -> AffineMap.vsub_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u4} V2 (coeFn.{max (succ u2) (succ u3) (succ u4), max (succ u3) (succ u4)} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) => P1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (VSub.vsub.{max u2 u3 u4, max u2 u3 u4 u5} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddTorsor.toHasVsub.{max u2 u3 u4, max u2 u3 u4 u5} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddCommGroup.toAddGroup.{max u2 u3 u4} (AffineMap.{u1, u2, u3, u4, u4} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5))) (AffineMap.addCommGroup.{u1, u2, u3, u4} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) (AffineMap.addTorsor.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) f g) p) (VSub.vsub.{u4, u5} V2 P2 (AddTorsor.toHasVsub.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g p))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (g : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u2} V2 (AffineMap.toFun.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)) (VSub.vsub.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddTorsor.toVSub.{max (max u4 u3) u2, max (max (max u4 u3) u2) u1} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AddCommGroup.toAddGroup.{max (max u4 u3) u2} (AffineMap.{u5, u4, u3, u2, u2} k V1 P1 V2 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 (addGroupIsAddTorsor.{u2} V2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u5, u4, u3, u2} k V1 P1 V2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) f g) p) (VSub.vsub.{u2, u1} V2 P2 (AddTorsor.toVSub.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5) _inst_7) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g p))
Case conversion may be inaccurate. Consider using '#align affine_map.vsub_apply AffineMap.vsub_applyₓ'. -/
@[simp]
theorem vsub_apply (f g : P1 →ᵃ[k] P2) (p : P1) : (f -ᵥ g : P1 →ᵃ[k] V2) p = f p -ᵥ g p :=
  rfl
#align affine_map.vsub_apply AffineMap.vsub_apply

/- warning: affine_map.fst -> AffineMap.fst is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], AffineMap.{u1, max u2 u4, max u3 u5, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], AffineMap.{u1, max u2 u4, max u5 u3, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.instAddCommGroupSum.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4
Case conversion may be inaccurate. Consider using '#align affine_map.fst AffineMap.fstₓ'. -/
/-- `prod.fst` as an `affine_map`. -/
def fst : P1 × P2 →ᵃ[k] P1 where
  toFun := Prod.fst
  linear := LinearMap.fst k V1 V2
  map_vadd' _ _ := rfl
#align affine_map.fst AffineMap.fst

/- warning: affine_map.coe_fst -> AffineMap.coe_fst is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ (max u3 u5)) (succ u3)} ((Prod.{u3, u5} P1 P2) -> P1) (coeFn.{max (succ (max u2 u4)) (succ (max u3 u5)) (succ u2) (succ u3), max (succ (max u3 u5)) (succ u3)} (AffineMap.{u1, max u2 u4, max u3 u5, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u2 u4, max u3 u5, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4) => (Prod.{u3, u5} P1 P2) -> P1) (AffineMap.hasCoeToFun.{u1, max u2 u4, max u3 u5, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4) (AffineMap.fst.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Prod.fst.{u3, u5} P1 P2)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u5}} {V2 : Type.{u1}} {P2 : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V2 P2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)], Eq.{max (succ u5) (succ u4)} ((Prod.{u5, u4} P1 P2) -> P1) (AffineMap.toFun.{u3, max u2 u1, max u5 u4, u2, u5} k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) V1 P1 _inst_1 (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4 (AffineMap.fst.{u3, u2, u5, u1, u4} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Prod.fst.{u5, u4} P1 P2)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_fst AffineMap.coe_fstₓ'. -/
@[simp]
theorem coe_fst : ⇑(fst : P1 × P2 →ᵃ[k] P1) = Prod.fst :=
  rfl
#align affine_map.coe_fst AffineMap.coe_fst

/- warning: affine_map.fst_linear -> AffineMap.fst_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ (max u2 u4)) (succ u2)} (LinearMap.{u1, u1, max u2 u4, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Prod.{u2, u4} V1 V2) V1 (AddCommGroup.toAddCommMonoid.{max u2 u4} (Prod.{u2, u4} V1 V2) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) _inst_3) (AffineMap.linear.{u1, max u2 u4, max u3 u5, u2, u3} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V1 P1 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4 (AffineMap.fst.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (LinearMap.fst.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u5}} {P1 : Type.{u2}} {V2 : Type.{u4}} {P2 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u5} V1] [_inst_3 : Module.{u3, u5} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V1 P1 (AddCommGroup.toAddGroup.{u5} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u3, u4} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u1} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ u5) (succ u4)} (LinearMap.{u3, u3, max u5 u4, u5} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Prod.{u5, u4} V1 V2) V1 (AddCommGroup.toAddCommMonoid.{max u5 u4} (Prod.{u5, u4} V1 V2) (Prod.instAddCommGroupSum.{u5, u4} V1 V2 _inst_2 _inst_5)) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (Prod.module.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) _inst_3) (AffineMap.linear.{u3, max u5 u4, max u2 u1, u5, u2} k (Prod.{u5, u4} V1 V2) (Prod.{u2, u1} P1 P2) V1 P1 _inst_1 (Prod.instAddCommGroupSum.{u5, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u5, u2, u4, u1} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u5} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_2 _inst_3 _inst_4 (AffineMap.fst.{u3, u5, u2, u4, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (LinearMap.fst.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align affine_map.fst_linear AffineMap.fst_linearₓ'. -/
@[simp]
theorem fst_linear : (fst : P1 × P2 →ᵃ[k] P1).linear = LinearMap.fst k V1 V2 :=
  rfl
#align affine_map.fst_linear AffineMap.fst_linear

/- warning: affine_map.snd -> AffineMap.snd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], AffineMap.{u1, max u2 u4, max u3 u5, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], AffineMap.{u1, max u2 u4, max u5 u3, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.instAddCommGroupSum.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7
Case conversion may be inaccurate. Consider using '#align affine_map.snd AffineMap.sndₓ'. -/
/-- `prod.snd` as an `affine_map`. -/
def snd : P1 × P2 →ᵃ[k] P2 where
  toFun := Prod.snd
  linear := LinearMap.snd k V1 V2
  map_vadd' _ _ := rfl
#align affine_map.snd AffineMap.snd

/- warning: affine_map.coe_snd -> AffineMap.coe_snd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ (max u3 u5)) (succ u5)} ((Prod.{u3, u5} P1 P2) -> P2) (coeFn.{max (succ (max u2 u4)) (succ (max u3 u5)) (succ u4) (succ u5), max (succ (max u3 u5)) (succ u5)} (AffineMap.{u1, max u2 u4, max u3 u5, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, max u2 u4, max u3 u5, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7) => (Prod.{u3, u5} P1 P2) -> P2) (AffineMap.hasCoeToFun.{u1, max u2 u4, max u3 u5, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7) (AffineMap.snd.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Prod.snd.{u3, u5} P1 P2)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u5}} {V2 : Type.{u1}} {P2 : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V2 P2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)], Eq.{max (succ u5) (succ u4)} ((Prod.{u5, u4} P1 P2) -> P2) (AffineMap.toFun.{u3, max u2 u1, max u5 u4, u1, u4} k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) V2 P2 _inst_1 (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7 (AffineMap.snd.{u3, u2, u5, u1, u4} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (Prod.snd.{u5, u4} P1 P2)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_snd AffineMap.coe_sndₓ'. -/
@[simp]
theorem coe_snd : ⇑(snd : P1 × P2 →ᵃ[k] P2) = Prod.snd :=
  rfl
#align affine_map.coe_snd AffineMap.coe_snd

/- warning: affine_map.snd_linear -> AffineMap.snd_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ (max u2 u4)) (succ u4)} (LinearMap.{u1, u1, max u2 u4, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Prod.{u2, u4} V1 V2) V2 (AddCommGroup.toAddCommMonoid.{max u2 u4} (Prod.{u2, u4} V1 V2) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) _inst_6) (AffineMap.linear.{u1, max u2 u4, max u3 u5, u4, u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) V2 P2 _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7 (AffineMap.snd.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (LinearMap.snd.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u5}} {P1 : Type.{u2}} {V2 : Type.{u4}} {P2 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u5} V1] [_inst_3 : Module.{u3, u5} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V1 P1 (AddCommGroup.toAddGroup.{u5} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u3, u4} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u1} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)], Eq.{max (succ u5) (succ u4)} (LinearMap.{u3, u3, max u5 u4, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (Prod.{u5, u4} V1 V2) V2 (AddCommGroup.toAddCommMonoid.{max u5 u4} (Prod.{u5, u4} V1 V2) (Prod.instAddCommGroupSum.{u5, u4} V1 V2 _inst_2 _inst_5)) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) (Prod.module.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) _inst_6) (AffineMap.linear.{u3, max u5 u4, max u2 u1, u4, u1} k (Prod.{u5, u4} V1 V2) (Prod.{u2, u1} P1 P2) V2 P2 _inst_1 (Prod.instAddCommGroupSum.{u5, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u5, u2, u4, u1} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u5} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) _inst_5 _inst_6 _inst_7 (AffineMap.snd.{u3, u5, u2, u4, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)) (LinearMap.snd.{u3, u5, u4} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6)
Case conversion may be inaccurate. Consider using '#align affine_map.snd_linear AffineMap.snd_linearₓ'. -/
@[simp]
theorem snd_linear : (snd : P1 × P2 →ᵃ[k] P2).linear = LinearMap.snd k V1 V2 :=
  rfl
#align affine_map.snd_linear AffineMap.snd_linear

variable (k P1)

omit V2

#print AffineMap.id /-
/-- Identity map as an affine map. -/
def id : P1 →ᵃ[k] P1 where
  toFun := id
  linear := LinearMap.id
  map_vadd' p v := rfl
#align affine_map.id AffineMap.id
-/

/- warning: affine_map.coe_id -> AffineMap.coe_id is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} (P1 : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)], Eq.{succ u3} (P1 -> P1) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.id.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (id.{succ u3} P1)
but is expected to have type
  forall (k : Type.{u2}) {V1 : Type.{u1}} (P1 : Type.{u3}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)], Eq.{succ u3} (P1 -> P1) (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (id.{succ u3} P1)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_id AffineMap.coe_idₓ'. -/
/-- The identity affine map acts as the identity. -/
@[simp]
theorem coe_id : ⇑(id k P1) = id :=
  rfl
#align affine_map.coe_id AffineMap.coe_id

/- warning: affine_map.id_linear -> AffineMap.id_linear is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} (P1 : Type.{u3}) [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)], Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (AffineMap.linear.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (LinearMap.id.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)
but is expected to have type
  forall (k : Type.{u2}) {V1 : Type.{u3}} (P1 : Type.{u1}) [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u2, u3} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)], Eq.{succ u3} (LinearMap.{u2, u2, u3, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3 _inst_3) (AffineMap.linear.{u2, u3, u1, u3, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u2, u3, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (LinearMap.id.{u2, u3} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align affine_map.id_linear AffineMap.id_linearₓ'. -/
@[simp]
theorem id_linear : (id k P1).linear = LinearMap.id :=
  rfl
#align affine_map.id_linear AffineMap.id_linear

variable {P1}

/- warning: affine_map.id_apply -> AffineMap.id_apply is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p : P1), Eq.{succ u3} P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.id.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4) p) p
but is expected to have type
  forall (k : Type.{u2}) {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4) p) p
Case conversion may be inaccurate. Consider using '#align affine_map.id_apply AffineMap.id_applyₓ'. -/
/-- The identity affine map acts as the identity. -/
theorem id_apply (p : P1) : id k P1 p = p :=
  rfl
#align affine_map.id_apply AffineMap.id_apply

variable {k P1}

instance : Inhabited (P1 →ᵃ[k] P1) :=
  ⟨id k P1⟩

include V2 V3

#print AffineMap.comp /-
/-- Composition of affine maps. -/
def comp (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : P1 →ᵃ[k] P3
    where
  toFun := f ∘ g
  linear := f.linear.comp g.linear
  map_vadd' := by
    intro p v
    rw [Function.comp_apply, g.map_vadd, f.map_vadd]
    rfl
#align affine_map.comp AffineMap.comp
-/

/- warning: affine_map.coe_comp -> AffineMap.coe_comp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} {V3 : Type.{u6}} {P3 : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] [_inst_8 : AddCommGroup.{u6} V3] [_inst_9 : Module.{u1, u6} k V3 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V3 _inst_8)] [_inst_10 : AddTorsor.{u6, u7} V3 P3 (AddCommGroup.toAddGroup.{u6} V3 _inst_8)] (f : AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u3) (succ u7)} (P1 -> P3) (coeFn.{max (succ u2) (succ u3) (succ u6) (succ u7), max (succ u3) (succ u7)} (AffineMap.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (fun (_x : AffineMap.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) => P1 -> P3) (AffineMap.hasCoeToFun.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.comp.{u1, u2, u3, u4, u5, u6, u7} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f g)) (Function.comp.{succ u3, succ u5, succ u7} P1 P2 P3 (coeFn.{max (succ u4) (succ u5) (succ u6) (succ u7), max (succ u5) (succ u7)} (AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (fun (_x : AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) => P2 -> P3) (AffineMap.hasCoeToFun.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) f) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g))
but is expected to have type
  forall {k : Type.{u7}} {V1 : Type.{u2}} {P1 : Type.{u1}} {V2 : Type.{u6}} {P2 : Type.{u5}} {V3 : Type.{u4}} {P3 : Type.{u3}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u7, u2} k V1 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u6} V2] [_inst_6 : Module.{u7, u6} k V2 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V2 _inst_5)] [_inst_7 : AddTorsor.{u6, u5} V2 P2 (AddCommGroup.toAddGroup.{u6} V2 _inst_5)] [_inst_8 : AddCommGroup.{u4} V3] [_inst_9 : Module.{u7, u4} k V3 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V3 _inst_8)] [_inst_10 : AddTorsor.{u4, u3} V3 P3 (AddCommGroup.toAddGroup.{u4} V3 _inst_8)] (f : AffineMap.{u7, u6, u5, u4, u3} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (g : AffineMap.{u7, u2, u1, u6, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u1) (succ u3)} (P1 -> P3) (AffineMap.toFun.{u7, u2, u1, u4, u3} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u7, u2, u1, u6, u5, u4, u3} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f g)) (Function.comp.{succ u1, succ u5, succ u3} P1 P2 P3 (AffineMap.toFun.{u7, u6, u5, u4, u3} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f) (AffineMap.toFun.{u7, u2, u1, u6, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_comp AffineMap.coe_compₓ'. -/
/-- Composition of affine maps acts as applying the two functions. -/
@[simp]
theorem coe_comp (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : ⇑(f.comp g) = f ∘ g :=
  rfl
#align affine_map.coe_comp AffineMap.coe_comp

/- warning: affine_map.comp_apply -> AffineMap.comp_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} {V3 : Type.{u6}} {P3 : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] [_inst_8 : AddCommGroup.{u6} V3] [_inst_9 : Module.{u1, u6} k V3 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V3 _inst_8)] [_inst_10 : AddTorsor.{u6, u7} V3 P3 (AddCommGroup.toAddGroup.{u6} V3 _inst_8)] (f : AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (g : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u7} P3 (coeFn.{max (succ u2) (succ u3) (succ u6) (succ u7), max (succ u3) (succ u7)} (AffineMap.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (fun (_x : AffineMap.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) => P1 -> P3) (AffineMap.hasCoeToFun.{u1, u2, u3, u6, u7} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.comp.{u1, u2, u3, u4, u5, u6, u7} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f g) p) (coeFn.{max (succ u4) (succ u5) (succ u6) (succ u7), max (succ u5) (succ u7)} (AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (fun (_x : AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) => P2 -> P3) (AffineMap.hasCoeToFun.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) f (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) g p))
but is expected to have type
  forall {k : Type.{u7}} {V1 : Type.{u2}} {P1 : Type.{u1}} {V2 : Type.{u6}} {P2 : Type.{u5}} {V3 : Type.{u4}} {P3 : Type.{u3}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u7, u2} k V1 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u6} V2] [_inst_6 : Module.{u7, u6} k V2 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V2 _inst_5)] [_inst_7 : AddTorsor.{u6, u5} V2 P2 (AddCommGroup.toAddGroup.{u6} V2 _inst_5)] [_inst_8 : AddCommGroup.{u4} V3] [_inst_9 : Module.{u7, u4} k V3 (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V3 _inst_8)] [_inst_10 : AddTorsor.{u4, u3} V3 P3 (AddCommGroup.toAddGroup.{u4} V3 _inst_8)] (f : AffineMap.{u7, u6, u5, u4, u3} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (g : AffineMap.{u7, u2, u1, u6, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P1), Eq.{succ u3} P3 (AffineMap.toFun.{u7, u2, u1, u4, u3} k V1 P1 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineMap.comp.{u7, u2, u1, u6, u5, u4, u3} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f g) p) (AffineMap.toFun.{u7, u6, u5, u4, u3} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f (AffineMap.toFun.{u7, u2, u1, u6, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g p))
Case conversion may be inaccurate. Consider using '#align affine_map.comp_apply AffineMap.comp_applyₓ'. -/
/-- Composition of affine maps acts as applying the two functions. -/
theorem comp_apply (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) (p : P1) : f.comp g p = f (g p) :=
  rfl
#align affine_map.comp_apply AffineMap.comp_apply

omit V3

/- warning: affine_map.comp_id -> AffineMap.comp_id is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u1, u2, u3, u2, u3, u4, u5} k V1 P1 V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineMap.id.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) f
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u5, u4, u3, u4, u3, u2, u1} k V1 P1 V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineMap.id.{u5, u4, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) f
Case conversion may be inaccurate. Consider using '#align affine_map.comp_id AffineMap.comp_idₓ'. -/
@[simp]
theorem comp_id (f : P1 →ᵃ[k] P2) : f.comp (id k P1) = f :=
  ext fun p => rfl
#align affine_map.comp_id AffineMap.comp_id

/- warning: affine_map.id_comp -> AffineMap.id_comp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u1, u2, u3, u4, u5, u4, u5} k V1 P1 V2 P2 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7 (AffineMap.id.{u1, u4, u5} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7) f) f
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u5, u4, u3, u2, u1, u2, u1} k V1 P1 V2 P2 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7 (AffineMap.id.{u5, u2, u1} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7) f) f
Case conversion may be inaccurate. Consider using '#align affine_map.id_comp AffineMap.id_compₓ'. -/
@[simp]
theorem id_comp (f : P1 →ᵃ[k] P2) : (id k P2).comp f = f :=
  ext fun p => rfl
#align affine_map.id_comp AffineMap.id_comp

include V3 V4

/- warning: affine_map.comp_assoc -> AffineMap.comp_assoc is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} {V3 : Type.{u6}} {P3 : Type.{u7}} {V4 : Type.{u8}} {P4 : Type.{u9}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] [_inst_8 : AddCommGroup.{u6} V3] [_inst_9 : Module.{u1, u6} k V3 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V3 _inst_8)] [_inst_10 : AddTorsor.{u6, u7} V3 P3 (AddCommGroup.toAddGroup.{u6} V3 _inst_8)] [_inst_11 : AddCommGroup.{u8} V4] [_inst_12 : Module.{u1, u8} k V4 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u8} V4 _inst_11)] [_inst_13 : AddTorsor.{u8, u9} V4 P4 (AddCommGroup.toAddGroup.{u8} V4 _inst_11)] (f₃₄ : AffineMap.{u1, u6, u7, u8, u9} k V3 P3 V4 P4 _inst_1 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13) (f₂₃ : AffineMap.{u1, u4, u5, u6, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (f₁₂ : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3) (succ u8) (succ u9)} (AffineMap.{u1, u2, u3, u8, u9} k V1 P1 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_11 _inst_12 _inst_13) (AffineMap.comp.{u1, u2, u3, u4, u5, u8, u9} k V1 P1 V2 P2 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_11 _inst_12 _inst_13 (AffineMap.comp.{u1, u4, u5, u6, u7, u8, u9} k V2 P2 V3 P3 V4 P4 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f₃₄ f₂₃) f₁₂) (AffineMap.comp.{u1, u2, u3, u6, u7, u8, u9} k V1 P1 V3 P3 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f₃₄ (AffineMap.comp.{u1, u2, u3, u4, u5, u6, u7} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f₂₃ f₁₂))
but is expected to have type
  forall {k : Type.{u9}} {V1 : Type.{u2}} {P1 : Type.{u1}} {V2 : Type.{u4}} {P2 : Type.{u3}} {V3 : Type.{u8}} {P3 : Type.{u7}} {V4 : Type.{u6}} {P4 : Type.{u5}} [_inst_1 : Ring.{u9} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u9, u2} k V1 (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u9, u4} k V2 (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u3} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] [_inst_8 : AddCommGroup.{u8} V3] [_inst_9 : Module.{u9, u8} k V3 (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u8} V3 _inst_8)] [_inst_10 : AddTorsor.{u8, u7} V3 P3 (AddCommGroup.toAddGroup.{u8} V3 _inst_8)] [_inst_11 : AddCommGroup.{u6} V4] [_inst_12 : Module.{u9, u6} k V4 (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V4 _inst_11)] [_inst_13 : AddTorsor.{u6, u5} V4 P4 (AddCommGroup.toAddGroup.{u6} V4 _inst_11)] (f₃₄ : AffineMap.{u9, u8, u7, u6, u5} k V3 P3 V4 P4 _inst_1 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13) (f₂₃ : AffineMap.{u9, u4, u3, u8, u7} k V2 P2 V3 P3 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (f₁₂ : AffineMap.{u9, u2, u1, u4, u3} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (max (max (succ u2) (succ u1)) (succ u6)) (succ u5)} (AffineMap.{u9, u2, u1, u6, u5} k V1 P1 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_11 _inst_12 _inst_13) (AffineMap.comp.{u9, u2, u1, u4, u3, u6, u5} k V1 P1 V2 P2 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_11 _inst_12 _inst_13 (AffineMap.comp.{u9, u4, u3, u8, u7, u6, u5} k V2 P2 V3 P3 V4 P4 _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f₃₄ f₂₃) f₁₂) (AffineMap.comp.{u9, u2, u1, u8, u7, u6, u5} k V1 P1 V3 P3 V4 P4 _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 f₃₄ (AffineMap.comp.{u9, u2, u1, u4, u3, u8, u7} k V1 P1 V2 P2 V3 P3 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 f₂₃ f₁₂))
Case conversion may be inaccurate. Consider using '#align affine_map.comp_assoc AffineMap.comp_assocₓ'. -/
theorem comp_assoc (f₃₄ : P3 →ᵃ[k] P4) (f₂₃ : P2 →ᵃ[k] P3) (f₁₂ : P1 →ᵃ[k] P2) :
    (f₃₄.comp f₂₃).comp f₁₂ = f₃₄.comp (f₂₃.comp f₁₂) :=
  rfl
#align affine_map.comp_assoc AffineMap.comp_assoc

omit V2 V3 V4

instance : Monoid (P1 →ᵃ[k] P1) where
  one := id k P1
  mul := comp
  one_mul := id_comp
  mul_one := comp_id
  mul_assoc := comp_assoc

/- warning: affine_map.coe_mul -> AffineMap.coe_mul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (f : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (g : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ u3} (P1 -> P1) (coeFn.{succ (max u2 u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasMul.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)))) f g)) (Function.comp.{succ u3, succ u3, succ u3} P1 P1 P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) f) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) g))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (f : AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (g : AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ u1} (P1 -> P1) (AffineMap.toFun.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toMul.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)))) f g)) (Function.comp.{succ u1, succ u1, succ u1} P1 P1 P1 (AffineMap.toFun.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 f) (AffineMap.toFun.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 g))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_mul AffineMap.coe_mulₓ'. -/
@[simp]
theorem coe_mul (f g : P1 →ᵃ[k] P1) : ⇑(f * g) = f ∘ g :=
  rfl
#align affine_map.coe_mul AffineMap.coe_mul

/- warning: affine_map.coe_one -> AffineMap.coe_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)], Eq.{succ u3} (P1 -> P1) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (OfNat.mk.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.one.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasOne.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4))))))) (id.{succ u3} P1)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)], Eq.{succ u3} (P1 -> P1) (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{max u1 u3} (AffineMap.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.toOfNat1.{max u1 u3} (AffineMap.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toOne.{max u1 u3} (AffineMap.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4))))) (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineMap.id.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4))
Case conversion may be inaccurate. Consider using '#align affine_map.coe_one AffineMap.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : P1 →ᵃ[k] P1) = id :=
  rfl
#align affine_map.coe_one AffineMap.coe_one

/- warning: affine_map.linear_hom -> AffineMap.linearHom is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)], MonoidHom.{max u2 u3, u2} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (MulZeroOneClass.toMulOneClass.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (NonAssocRing.toNonAssocSemiring.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Ring.toNonAssocRing.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Module.End.ring.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) _inst_2 _inst_3)))))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)], MonoidHom.{max u3 u2, u2} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4)) (MulZeroOneClass.toMulOneClass.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (NonAssocSemiring.toMulZeroOneClass.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Semiring.toNonAssocSemiring.{u2} (LinearMap.{u1, u1, u2, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3 _inst_3) (Module.End.semiring.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_hom AffineMap.linearHomₓ'. -/
/-- `affine_map.linear` on endomorphisms is a `monoid_hom`. -/
@[simps]
def linearHom : (P1 →ᵃ[k] P1) →* V1 →ₗ[k] V1
    where
  toFun := linear
  map_one' := rfl
  map_mul' _ _ := rfl
#align affine_map.linear_hom AffineMap.linearHom

include V2

/- warning: affine_map.linear_injective_iff -> AffineMap.linear_injective_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Injective.{succ u2, succ u4} V1 V2 (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Injective.{succ u3, succ u5} P1 P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Injective.{succ u4, succ u2} V1 V2 (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Injective.{succ u3, succ u1} P1 P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_injective_iff AffineMap.linear_injective_iffₓ'. -/
@[simp]
theorem linear_injective_iff (f : P1 →ᵃ[k] P2) :
    Function.Injective f.linear ↔ Function.Injective f :=
  by
  obtain ⟨p⟩ := (inferInstance : Nonempty P1)
  have h : ⇑f.linear = (Equiv.vaddConst (f p)).symm ∘ f ∘ Equiv.vaddConst p :=
    by
    ext v
    simp [f.map_vadd, vadd_vsub_assoc]
  rw [h, Equiv.comp_injective, Equiv.injective_comp]
#align affine_map.linear_injective_iff AffineMap.linear_injective_iff

/- warning: affine_map.linear_surjective_iff -> AffineMap.linear_surjective_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Surjective.{succ u2, succ u4} V1 V2 (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Surjective.{succ u3, succ u5} P1 P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Surjective.{succ u4, succ u2} V1 V2 (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Surjective.{succ u3, succ u1} P1 P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_surjective_iff AffineMap.linear_surjective_iffₓ'. -/
@[simp]
theorem linear_surjective_iff (f : P1 →ᵃ[k] P2) :
    Function.Surjective f.linear ↔ Function.Surjective f :=
  by
  obtain ⟨p⟩ := (inferInstance : Nonempty P1)
  have h : ⇑f.linear = (Equiv.vaddConst (f p)).symm ∘ f ∘ Equiv.vaddConst p :=
    by
    ext v
    simp [f.map_vadd, vadd_vsub_assoc]
  rw [h, Equiv.comp_surjective, Equiv.surjective_comp]
#align affine_map.linear_surjective_iff AffineMap.linear_surjective_iff

/- warning: affine_map.linear_bijective_iff -> AffineMap.linear_bijective_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Bijective.{succ u2, succ u4} V1 V2 (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Bijective.{succ u3, succ u5} P1 P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Iff (Function.Bijective.{succ u4, succ u2} V1 V2 (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u5, u5, u4, u2} k k V1 V2 (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))) (Function.Bijective.{succ u3, succ u1} P1 P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f))
Case conversion may be inaccurate. Consider using '#align affine_map.linear_bijective_iff AffineMap.linear_bijective_iffₓ'. -/
@[simp]
theorem linear_bijective_iff (f : P1 →ᵃ[k] P2) :
    Function.Bijective f.linear ↔ Function.Bijective f :=
  and_congr f.linear_injective_iff f.linear_surjective_iff
#align affine_map.linear_bijective_iff AffineMap.linear_bijective_iff

/- warning: affine_map.image_vsub_image -> AffineMap.image_vsub_image is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] {s : Set.{u3} P1} {t : Set.{u3} P1} (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u4} (Set.{u4} V2) (VSub.vsub.{u4, u5} (Set.{u4} V2) (Set.{u5} P2) (Set.vsub.{u4, u5} V2 P2 (AddTorsor.toHasVsub.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_7)) (Set.image.{u3, u5} P1 P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s) (Set.image.{u3, u5} P1 P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) t)) (Set.image.{u2, u4} V1 V2 (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) (VSub.vsub.{u2, u3} (Set.{u2} V1) (Set.{u3} P1) (Set.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) s t))
but is expected to have type
  forall {k : Type.{u4}} {V1 : Type.{u3}} {P1 : Type.{u5}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u4, u3} k V1 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u4, u2} k V2 (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] {s : Set.{u5} P1} {t : Set.{u5} P1} (f : AffineMap.{u4, u3, u5, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u2} (Set.{u2} V2) (VSub.vsub.{u2, u1} (Set.{u2} V2) (Set.{u1} P2) (Set.vsub.{u2, u1} V2 P2 (AddTorsor.toVSub.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5) _inst_7)) (Set.image.{u5, u1} P1 P2 (AffineMap.toFun.{u4, u3, u5, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) s) (Set.image.{u5, u1} P1 P2 (AffineMap.toFun.{u4, u3, u5, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f) t)) (Set.image.{u3, u2} V1 V2 (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} k k V1 V2 (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1)))) (AffineMap.linear.{u4, u3, u5, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) (VSub.vsub.{u3, u5} (Set.{u3} V1) (Set.{u5} P1) (Set.vsub.{u3, u5} V1 P1 (AddTorsor.toVSub.{u3, u5} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4)) s t))
Case conversion may be inaccurate. Consider using '#align affine_map.image_vsub_image AffineMap.image_vsub_imageₓ'. -/
theorem image_vsub_image {s t : Set P1} (f : P1 →ᵃ[k] P2) :
    f '' s -ᵥ f '' t = f.linear '' (s -ᵥ t) := by
  ext v
  simp only [Set.mem_vsub, Set.mem_image, exists_exists_and_eq_and, exists_and_left, ←
    f.linear_map_vsub]
  constructor
  · rintro ⟨x, hx, y, hy, hv⟩
    exact ⟨x -ᵥ y, ⟨x, hx, y, hy, rfl⟩, hv⟩
  · rintro ⟨-, ⟨x, hx, y, hy, rfl⟩, rfl⟩
    exact ⟨x, hx, y, hy, rfl⟩
#align affine_map.image_vsub_image AffineMap.image_vsub_image

omit V2

/-! ### Definition of `affine_map.line_map` and lemmas about it -/


#print AffineMap.lineMap /-
/-- The affine map from `k` to `P1` sending `0` to `p₀` and `1` to `p₁`. -/
def lineMap (p₀ p₁ : P1) : k →ᵃ[k] P1 :=
  ((LinearMap.id : k →ₗ[k] k).smul_right (p₁ -ᵥ p₀)).toAffineMap +ᵥ const k k p₀
#align affine_map.line_map AffineMap.lineMap
-/

/- warning: affine_map.coe_line_map -> AffineMap.coe_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (succ u1) (succ u3)} ((fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (fun (c : k) => VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀)) p₀)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u1}} {P1 : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u3, u1} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (succ u3) (succ u2)} (k -> P1) (AffineMap.toFun.{u3, u3, u3, u1, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u1, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (fun (c : k) => HVAdd.hVAdd.{u1, u2, u2} V1 P1 P1 (instHVAdd.{u1, u2} V1 P1 (AddAction.toVAdd.{u1, u2} V1 P1 (SubNegMonoid.toAddMonoid.{u1} V1 (AddGroup.toSubNegMonoid.{u1} V1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2))) (AddTorsor.toAddAction.{u1, u2} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4))) (HSMul.hSMul.{u3, u1, u1} k V1 V1 (instHSMul.{u3, u1} k V1 (SMulZeroClass.toSMul.{u3, u1} k V1 (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u1} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u1} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u1} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2) _inst_3))))) c (VSub.vsub.{u1, u2} V1 P1 (AddTorsor.toVSub.{u1, u2} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4) p₁ p₀)) p₀)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_line_map AffineMap.coe_lineMapₓ'. -/
theorem coe_lineMap (p₀ p₁ : P1) : (lineMap p₀ p₁ : k → P1) = fun c => c • (p₁ -ᵥ p₀) +ᵥ p₀ :=
  rfl
#align affine_map.coe_line_map AffineMap.coe_lineMap

/- warning: affine_map.line_map_apply -> AffineMap.lineMap_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀)) p₀)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) (HVAdd.hVAdd.{u1, u3, u3} V1 P1 P1 (instHVAdd.{u1, u3} V1 P1 (AddAction.toVAdd.{u1, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u1} V1 (AddGroup.toSubNegMonoid.{u1} V1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2))) (AddTorsor.toAddAction.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V1 V1 (instHSMul.{u2, u1} k V1 (SMulZeroClass.toSMul.{u2, u1} k V1 (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V1 (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V1 (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2) _inst_3))))) c (VSub.vsub.{u1, u3} V1 P1 (AddTorsor.toVSub.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4) p₁ p₀)) p₀)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply AffineMap.lineMap_applyₓ'. -/
theorem lineMap_apply (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c = c • (p₁ -ᵥ p₀) +ᵥ p₀ :=
  rfl
#align affine_map.line_map_apply AffineMap.lineMap_apply

/- warning: affine_map.line_map_apply_module' -> AffineMap.lineMap_apply_module' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (p₀ : V1) (p₁ : V1) (c : k), Eq.{succ u2} V1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) => k -> V1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) p₀ p₁) c) (HAdd.hAdd.{u2, u2, u2} V1 V1 V1 (instHAdd.{u2} V1 (AddZeroClass.toHasAdd.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))))) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c (HSub.hSub.{u2, u2, u2} V1 V1 V1 (instHSub.{u2} V1 (SubNegMonoid.toHasSub.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))) p₁ p₀)) p₀)
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (p₀ : V1) (p₁ : V1) (c : k), Eq.{succ u2} V1 (AffineMap.toFun.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) (AffineMap.lineMap.{u1, u2, u2} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) p₀ p₁) c) (HAdd.hAdd.{u2, u2, u2} V1 V1 V1 (instHAdd.{u2} V1 (AddZeroClass.toAdd.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} k V1 V1 (instHSMul.{u1, u2} k V1 (SMulZeroClass.toSMul.{u1, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))) c (HSub.hSub.{u2, u2, u2} V1 V1 V1 (instHSub.{u2} V1 (SubNegMonoid.toSub.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))) p₁ p₀)) p₀)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_module' AffineMap.lineMap_apply_module'ₓ'. -/
theorem lineMap_apply_module' (p₀ p₁ : V1) (c : k) : lineMap p₀ p₁ c = c • (p₁ - p₀) + p₀ :=
  rfl
#align affine_map.line_map_apply_module' AffineMap.lineMap_apply_module'

/- warning: affine_map.line_map_apply_module -> AffineMap.lineMap_apply_module is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (p₀ : V1) (p₁ : V1) (c : k), Eq.{succ u2} V1 (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) => k -> V1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) p₀ p₁) c) (HAdd.hAdd.{u2, u2, u2} V1 V1 V1 (instHAdd.{u2} V1 (AddZeroClass.toHasAdd.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))))) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) c) p₀) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c p₁))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (p₀ : V1) (p₁ : V1) (c : k), Eq.{succ u2} V1 (AffineMap.toFun.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) (AffineMap.lineMap.{u1, u2, u2} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) p₀ p₁) c) (HAdd.hAdd.{u2, u2, u2} V1 V1 V1 (instHAdd.{u2} V1 (AddZeroClass.toAdd.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)))))) (HSMul.hSMul.{u1, u2, u2} k V1 V1 (instHSMul.{u1, u2} k V1 (SMulZeroClass.toSMul.{u1, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (Semiring.toOne.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) c) p₀) (HSMul.hSMul.{u1, u2, u2} k V1 V1 (instHSMul.{u1, u2} k V1 (SMulZeroClass.toSMul.{u1, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))) c p₁))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_module AffineMap.lineMap_apply_moduleₓ'. -/
theorem lineMap_apply_module (p₀ p₁ : V1) (c : k) : lineMap p₀ p₁ c = (1 - c) • p₀ + c • p₁ := by
  simp [line_map_apply_module', smul_sub, sub_smul] <;> abel
#align affine_map.line_map_apply_module AffineMap.lineMap_apply_module

omit V1

/- warning: affine_map.line_map_apply_ring' -> AffineMap.lineMap_apply_ring' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] (a : k) (b : k) (c : k), Eq.{succ u1} k (coeFn.{succ u1, succ u1} (AffineMap.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (fun (_x : AffineMap.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) => k -> k) (AffineMap.hasCoeToFun.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AffineMap.lineMap.{u1, u1, u1} k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) a b) c) (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1))) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1))) c (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) b a)) a)
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] (a : k) (b : k) (c : k), Eq.{succ u1} k (AffineMap.toFun.{u1, u1, u1, u1, u1} k k k k k _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) (AffineMap.lineMap.{u1, u1, u1} k k k _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toAdd.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonUnitalRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonUnitalRing.{u1} k _inst_1)))))) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocRing.toMul.{u1} k (NonUnitalRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonUnitalRing.{u1} k _inst_1)))) c (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) b a)) a)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_ring' AffineMap.lineMap_apply_ring'ₓ'. -/
theorem lineMap_apply_ring' (a b c : k) : lineMap a b c = c * (b - a) + a :=
  rfl
#align affine_map.line_map_apply_ring' AffineMap.lineMap_apply_ring'

/- warning: affine_map.line_map_apply_ring -> AffineMap.lineMap_apply_ring is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] (a : k) (b : k) (c : k), Eq.{succ u1} k (coeFn.{succ u1, succ u1} (AffineMap.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (fun (_x : AffineMap.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) => k -> k) (AffineMap.hasCoeToFun.{u1, u1, u1, u1, u1} k k k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AffineMap.lineMap.{u1, u1, u1} k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) a b) c) (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1))) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) c) a) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1))) c b))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] (a : k) (b : k) (c : k), Eq.{succ u1} k (AffineMap.toFun.{u1, u1, u1, u1, u1} k k k k k _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) (AffineMap.lineMap.{u1, u1, u1} k k k _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) a b) c) (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toAdd.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonUnitalRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonUnitalRing.{u1} k _inst_1)))))) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocRing.toMul.{u1} k (NonUnitalRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonUnitalRing.{u1} k _inst_1)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (Semiring.toOne.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) c) a) (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocRing.toMul.{u1} k (NonUnitalRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonUnitalRing.{u1} k _inst_1)))) c b))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_ring AffineMap.lineMap_apply_ringₓ'. -/
theorem lineMap_apply_ring (a b c : k) : lineMap a b c = (1 - c) * a + c * b :=
  lineMap_apply_module a b c
#align affine_map.line_map_apply_ring AffineMap.lineMap_apply_ring

include V1

/- warning: affine_map.line_map_vadd_apply -> AffineMap.lineMap_vadd_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p : P1) (v : V1) (c : k), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) v p)) c) (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c v) p)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p : P1) (v : V1) (c : k), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p (HVAdd.hVAdd.{u1, u3, u3} V1 P1 P1 (instHVAdd.{u1, u3} V1 P1 (AddAction.toVAdd.{u1, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u1} V1 (AddGroup.toSubNegMonoid.{u1} V1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2))) (AddTorsor.toAddAction.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4))) v p)) c) (HVAdd.hVAdd.{u1, u3, u3} V1 P1 P1 (instHVAdd.{u1, u3} V1 P1 (AddAction.toVAdd.{u1, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u1} V1 (AddGroup.toSubNegMonoid.{u1} V1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2))) (AddTorsor.toAddAction.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_4))) (HSMul.hSMul.{u2, u1, u1} k V1 V1 (instHSMul.{u2, u1} k V1 (SMulZeroClass.toSMul.{u2, u1} k V1 (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V1 (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V1 (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2) _inst_3))))) c v) p)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_vadd_apply AffineMap.lineMap_vadd_applyₓ'. -/
theorem lineMap_vadd_apply (p : P1) (v : V1) (c : k) : lineMap p (v +ᵥ p) c = c • v +ᵥ p := by
  rw [line_map_apply, vadd_vsub]
#align affine_map.line_map_vadd_apply AffineMap.lineMap_vadd_apply

/- warning: affine_map.line_map_linear -> AffineMap.lineMap_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (succ u1) (succ u2)} (LinearMap.{u1, u1, u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) k V1 (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) _inst_3) (AffineMap.linear.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (LinearMap.smulRight.{u1, u1, u2, u1} k k V1 k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) _inst_3 (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (Ring.toSemiring.{u1} k _inst_1) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) _inst_3 (IsScalarTower.left.{u1, u2} k V1 (Ring.toMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))) (LinearMap.id.{u1, u1} k k (Ring.toSemiring.{u1} k _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (succ u3) (succ u2)} (LinearMap.{u3, u3, u3, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) k V1 (AddCommGroup.toAddCommMonoid.{u3} k (Ring.toAddCommGroup.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) _inst_3) (AffineMap.linear.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (LinearMap.smulRight.{u3, u3, u2, u3} k k V1 k (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) _inst_3 (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) _inst_3 (IsScalarTower.left.{u3, u2} k V1 (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MulActionWithZero.toMulAction.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))) (LinearMap.id.{u3, u3} k k (Ring.toSemiring.{u3} k _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (VSub.vsub.{u2, u1} V1 P1 (AddTorsor.toVSub.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_linear AffineMap.lineMap_linearₓ'. -/
@[simp]
theorem lineMap_linear (p₀ p₁ : P1) :
    (lineMap p₀ p₁ : k →ᵃ[k] P1).linear = LinearMap.id.smul_right (p₁ -ᵥ p₀) :=
  add_zero _
#align affine_map.line_map_linear AffineMap.lineMap_linear

/- warning: affine_map.line_map_same_apply -> AffineMap.lineMap_same_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p : P1) (c : k), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p p) c) p
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p : P1) (c : k), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p p) c) p
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_same_apply AffineMap.lineMap_same_applyₓ'. -/
theorem lineMap_same_apply (p : P1) (c : k) : lineMap p p c = p := by simp [line_map_apply]
#align affine_map.line_map_same_apply AffineMap.lineMap_same_apply

/- warning: affine_map.line_map_same -> AffineMap.lineMap_same is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p : P1), Eq.{max (succ u1) (succ u2) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p p) (AffineMap.const.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4 p)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p : P1), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (AffineMap.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p p) (AffineMap.const.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 p)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_same AffineMap.lineMap_sameₓ'. -/
@[simp]
theorem lineMap_same (p : P1) : lineMap p p = const k k p :=
  ext <| lineMap_same_apply p
#align affine_map.line_map_same AffineMap.lineMap_same

/- warning: affine_map.line_map_apply_zero -> AffineMap.lineMap_apply_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) p₀
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)))))) p₀
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_zero AffineMap.lineMap_apply_zeroₓ'. -/
@[simp]
theorem lineMap_apply_zero (p₀ p₁ : P1) : lineMap p₀ p₁ (0 : k) = p₀ := by simp [line_map_apply]
#align affine_map.line_map_apply_zero AffineMap.lineMap_apply_zero

/- warning: affine_map.line_map_apply_one -> AffineMap.lineMap_apply_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))) p₁
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (Semiring.toOne.{u2} k (Ring.toSemiring.{u2} k _inst_1))))) p₁
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_one AffineMap.lineMap_apply_oneₓ'. -/
@[simp]
theorem lineMap_apply_one (p₀ p₁ : P1) : lineMap p₀ p₁ (1 : k) = p₁ := by simp [line_map_apply]
#align affine_map.line_map_apply_one AffineMap.lineMap_apply_one

/- warning: affine_map.line_map_eq_line_map_iff -> AffineMap.lineMap_eq_lineMap_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c₁ : k} {c₂ : k}, Iff (Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c₁) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c₂)) (Or (Eq.{succ u3} P1 p₀ p₁) (Eq.{succ u1} k c₁ c₂))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c₁ : k} {c₂ : k}, Iff (Eq.{succ u1} P1 (AffineMap.toFun.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c₁) (AffineMap.toFun.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c₂)) (Or (Eq.{succ u1} P1 p₀ p₁) (Eq.{succ u3} k c₁ c₂))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_eq_line_map_iff AffineMap.lineMap_eq_lineMap_iffₓ'. -/
@[simp]
theorem lineMap_eq_lineMap_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c₁ c₂ : k} :
    lineMap p₀ p₁ c₁ = lineMap p₀ p₁ c₂ ↔ p₀ = p₁ ∨ c₁ = c₂ := by
  rw [line_map_apply, line_map_apply, ← @vsub_eq_zero_iff_eq V1, vadd_vsub_vadd_cancel_right, ←
    sub_smul, smul_eq_zero, sub_eq_zero, vsub_eq_zero_iff_eq, or_comm', eq_comm]
#align affine_map.line_map_eq_line_map_iff AffineMap.lineMap_eq_lineMap_iff

/- warning: affine_map.line_map_eq_left_iff -> AffineMap.lineMap_eq_left_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c : k}, Iff (Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₀) (Or (Eq.{succ u3} P1 p₀ p₁) (Eq.{succ u1} k c (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c : k}, Iff (Eq.{succ u1} P1 (AffineMap.toFun.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₀) (Or (Eq.{succ u1} P1 p₀ p₁) (Eq.{succ u3} k c (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_eq_left_iff AffineMap.lineMap_eq_left_iffₓ'. -/
@[simp]
theorem lineMap_eq_left_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c : k} :
    lineMap p₀ p₁ c = p₀ ↔ p₀ = p₁ ∨ c = 0 := by
  rw [← @line_map_eq_line_map_iff k V1, line_map_apply_zero]
#align affine_map.line_map_eq_left_iff AffineMap.lineMap_eq_left_iff

/- warning: affine_map.line_map_eq_right_iff -> AffineMap.lineMap_eq_right_iff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c : k}, Iff (Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₁) (Or (Eq.{succ u3} P1 p₀ p₁) (Eq.{succ u1} k c (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1} {c : k}, Iff (Eq.{succ u1} P1 (AffineMap.toFun.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₁) (Or (Eq.{succ u1} P1 p₀ p₁) (Eq.{succ u3} k c (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_eq_right_iff AffineMap.lineMap_eq_right_iffₓ'. -/
@[simp]
theorem lineMap_eq_right_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c : k} :
    lineMap p₀ p₁ c = p₁ ↔ p₀ = p₁ ∨ c = 1 := by
  rw [← @line_map_eq_line_map_iff k V1, line_map_apply_one]
#align affine_map.line_map_eq_right_iff AffineMap.lineMap_eq_right_iff

variable (k)

/- warning: affine_map.line_map_injective -> AffineMap.lineMap_injective is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))) (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1}, (Ne.{succ u3} P1 p₀ p₁) -> (Function.Injective.{succ u1, succ u3} k P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)))
but is expected to have type
  forall (k : Type.{u3}) {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_14 : NoZeroSMulDivisors.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulZeroClass.toSMul.{u3, u2} k V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} k V1 (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3))))] {p₀ : P1} {p₁ : P1}, (Ne.{succ u1} P1 p₀ p₁) -> (Function.Injective.{succ u3, succ u1} k P1 (AffineMap.toFun.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_injective AffineMap.lineMap_injectiveₓ'. -/
theorem lineMap_injective [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} (h : p₀ ≠ p₁) :
    Function.Injective (lineMap p₀ p₁ : k → P1) := fun c₁ c₂ hc =>
  (lineMap_eq_lineMap_iff.mp hc).resolve_left h
#align affine_map.line_map_injective AffineMap.lineMap_injective

variable {k}

include V2

/- warning: affine_map.apply_line_map -> AffineMap.apply_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u5} P2 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (coeFn.{max (succ u1) (succ u4) (succ u5), max (succ u1) (succ u5)} (AffineMap.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) => k -> P2) (AffineMap.hasCoeToFun.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (AffineMap.lineMap.{u1, u4, u5} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p₀) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p₁)) c)
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u1} P2 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineMap.toFun.{u5, u5, u5, u4, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u5, u4, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (AffineMap.toFun.{u5, u5, u5, u2, u1} k k k V2 P2 _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_5 _inst_6 _inst_7 (AffineMap.lineMap.{u5, u2, u1} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p₀) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p₁)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.apply_line_map AffineMap.apply_lineMapₓ'. -/
@[simp]
theorem apply_lineMap (f : P1 →ᵃ[k] P2) (p₀ p₁ : P1) (c : k) :
    f (lineMap p₀ p₁ c) = lineMap (f p₀) (f p₁) c := by simp [line_map_apply]
#align affine_map.apply_line_map AffineMap.apply_lineMap

/- warning: affine_map.comp_line_map -> AffineMap.comp_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (f : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p₀ : P1) (p₁ : P1), Eq.{max (succ u1) (succ u4) (succ u5)} (AffineMap.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u1, u1, u1, u2, u3, u4, u5} k k k V1 P1 V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (AffineMap.lineMap.{u1, u4, u5} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p₀) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P1 -> P2) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f p₁))
but is expected to have type
  forall {k : Type.{u5}} {V1 : Type.{u4}} {P1 : Type.{u3}} {V2 : Type.{u2}} {P2 : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V1] [_inst_3 : Module.{u5, u4} k V1 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V1 _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V1 P1 (AddCommGroup.toAddGroup.{u4} V1 _inst_2)] [_inst_5 : AddCommGroup.{u2} V2] [_inst_6 : Module.{u5, u2} k V2 (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V2 _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V2 P2 (AddCommGroup.toAddGroup.{u2} V2 _inst_5)] (f : AffineMap.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p₀ : P1) (p₁ : P1), Eq.{max (max (succ u5) (succ u2)) (succ u1)} (AffineMap.{u5, u5, u5, u2, u1} k k k V2 P2 _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_5 _inst_6 _inst_7) (AffineMap.comp.{u5, u5, u5, u4, u3, u2, u1} k k k V1 P1 V2 P2 _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f (AffineMap.lineMap.{u5, u4, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁)) (AffineMap.lineMap.{u5, u2, u1} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p₀) (AffineMap.toFun.{u5, u4, u3, u2, u1} k V1 P1 V2 P2 _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f p₁))
Case conversion may be inaccurate. Consider using '#align affine_map.comp_line_map AffineMap.comp_lineMapₓ'. -/
@[simp]
theorem comp_lineMap (f : P1 →ᵃ[k] P2) (p₀ p₁ : P1) :
    f.comp (lineMap p₀ p₁) = lineMap (f p₀) (f p₁) :=
  ext <| f.apply_lineMap p₀ p₁
#align affine_map.comp_line_map AffineMap.comp_lineMap

/- warning: affine_map.fst_line_map -> AffineMap.fst_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (p₀ : Prod.{u3, u5} P1 P2) (p₁ : Prod.{u3, u5} P1 P2) (c : k), Eq.{succ u3} P1 (Prod.fst.{u3, u5} P1 P2 (coeFn.{max (succ u1) (succ (max u2 u4)) (succ (max u3 u5)), max (succ u1) (succ (max u3 u5))} (AffineMap.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) (fun (_x : AffineMap.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) => k -> (Prod.{u3, u5} P1 P2)) (AffineMap.hasCoeToFun.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) (AffineMap.lineMap.{u1, max u2 u4, max u3 u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) p₀ p₁) c)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 (Prod.fst.{u3, u5} P1 P2 p₀) (Prod.fst.{u3, u5} P1 P2 p₁)) c)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u5}} {V2 : Type.{u1}} {P2 : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V2 P2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)] (p₀ : Prod.{u5, u4} P1 P2) (p₁ : Prod.{u5, u4} P1 P2) (c : k), Eq.{succ u5} P1 (Prod.fst.{u5, u4} P1 P2 (AffineMap.toFun.{u3, u3, u3, max u2 u1, max u5 u4} k k k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) (AffineMap.lineMap.{u3, max u2 u1, max u5 u4} k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) _inst_1 (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) p₀ p₁) c)) (AffineMap.toFun.{u3, u3, u3, u2, u5} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u5} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 (Prod.fst.{u5, u4} P1 P2 p₀) (Prod.fst.{u5, u4} P1 P2 p₁)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.fst_line_map AffineMap.fst_lineMapₓ'. -/
@[simp]
theorem fst_lineMap (p₀ p₁ : P1 × P2) (c : k) : (lineMap p₀ p₁ c).1 = lineMap p₀.1 p₁.1 c :=
  fst.apply_lineMap p₀ p₁ c
#align affine_map.fst_line_map AffineMap.fst_lineMap

/- warning: affine_map.snd_line_map -> AffineMap.snd_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} {V2 : Type.{u4}} {P2 : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u4} V2] [_inst_6 : Module.{u1, u4} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5)] [_inst_7 : AddTorsor.{u4, u5} V2 P2 (AddCommGroup.toAddGroup.{u4} V2 _inst_5)] (p₀ : Prod.{u3, u5} P1 P2) (p₁ : Prod.{u3, u5} P1 P2) (c : k), Eq.{succ u5} P2 (Prod.snd.{u3, u5} P1 P2 (coeFn.{max (succ u1) (succ (max u2 u4)) (succ (max u3 u5)), max (succ u1) (succ (max u3 u5))} (AffineMap.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) (fun (_x : AffineMap.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) => k -> (Prod.{u3, u5} P1 P2)) (AffineMap.hasCoeToFun.{u1, u1, u1, max u2 u4, max u3 u5} k k k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7)) (AffineMap.lineMap.{u1, max u2 u4, max u3 u5} k (Prod.{u2, u4} V1 V2) (Prod.{u3, u5} P1 P2) _inst_1 (Prod.addCommGroup.{u2, u4} V1 V2 _inst_2 _inst_5) (Prod.module.{u1, u2, u4} k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_5) _inst_3 _inst_6) (Prod.addTorsor.{u2, u3, u4, u5} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u4} V2 _inst_5) _inst_4 _inst_7) p₀ p₁) c)) (coeFn.{max (succ u1) (succ u4) (succ u5), max (succ u1) (succ u5)} (AffineMap.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) => k -> P2) (AffineMap.hasCoeToFun.{u1, u1, u1, u4, u5} k k k V2 P2 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (AffineMap.lineMap.{u1, u4, u5} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (Prod.snd.{u3, u5} P1 P2 p₀) (Prod.snd.{u3, u5} P1 P2 p₁)) c)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u5}} {V2 : Type.{u1}} {P2 : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V2 P2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)] (p₀ : Prod.{u5, u4} P1 P2) (p₁ : Prod.{u5, u4} P1 P2) (c : k), Eq.{succ u4} P2 (Prod.snd.{u5, u4} P1 P2 (AffineMap.toFun.{u3, u3, u3, max u2 u1, max u5 u4} k k k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) (AffineMap.lineMap.{u3, max u2 u1, max u5 u4} k (Prod.{u2, u1} V1 V2) (Prod.{u5, u4} P1 P2) _inst_1 (Prod.instAddCommGroupSum.{u2, u1} V1 V2 _inst_2 _inst_5) (Prod.module.{u3, u2, u1} k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, u5, u1, u4} V1 P1 V2 P2 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) (AddCommGroup.toAddGroup.{u1} V2 _inst_5) _inst_4 _inst_7) p₀ p₁) c)) (AffineMap.toFun.{u3, u3, u3, u1, u4} k k k V2 P2 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_5 _inst_6 _inst_7 (AffineMap.lineMap.{u3, u1, u4} k V2 P2 _inst_1 _inst_5 _inst_6 _inst_7 (Prod.snd.{u5, u4} P1 P2 p₀) (Prod.snd.{u5, u4} P1 P2 p₁)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.snd_line_map AffineMap.snd_lineMapₓ'. -/
@[simp]
theorem snd_lineMap (p₀ p₁ : P1 × P2) (c : k) : (lineMap p₀ p₁ c).2 = lineMap p₀.2 p₁.2 c :=
  snd.apply_lineMap p₀ p₁ c
#align affine_map.snd_line_map AffineMap.snd_lineMap

omit V2

/- warning: affine_map.line_map_symm -> AffineMap.lineMap_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (succ u1) (succ u2) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (AffineMap.comp.{u1, u1, u1, u1, u1, u2, u3} k k k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₀) (AffineMap.lineMap.{u1, u1, u1} k k k _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (AffineMap.{u3, u3, u3, u2, u1} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (AffineMap.comp.{u3, u3, u3, u3, u3, u2, u1} k k k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₀) (AffineMap.lineMap.{u3, u3, u3} k k k _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_symm AffineMap.lineMap_symmₓ'. -/
theorem lineMap_symm (p₀ p₁ : P1) :
    lineMap p₀ p₁ = (lineMap p₁ p₀).comp (lineMap (1 : k) (0 : k)) :=
  by
  rw [comp_line_map]
  simp
#align affine_map.line_map_symm AffineMap.lineMap_symm

/- warning: affine_map.line_map_apply_one_sub -> AffineMap.lineMap_apply_one_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} P1 (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) c)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₀) c)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) (HSub.hSub.{u2, u2, u2} k k k (instHSub.{u2} k (Ring.toSub.{u2} k _inst_1)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (Semiring.toOne.{u2} k (Ring.toSemiring.{u2} k _inst_1)))) c)) (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₀) c)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_apply_one_sub AffineMap.lineMap_apply_one_subₓ'. -/
theorem lineMap_apply_one_sub (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ (1 - c) = lineMap p₁ p₀ c :=
  by
  rw [line_map_symm p₀, comp_apply]
  congr
  simp [line_map_apply]
#align affine_map.line_map_apply_one_sub AffineMap.lineMap_apply_one_sub

/- warning: affine_map.line_map_vsub_left -> AffineMap.lineMap_vsub_left is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u2} V1 (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₀) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} V1 (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₀) (HSMul.hSMul.{u1, u3, u3} k V1 V1 (instHSMul.{u1, u3} k V1 (SMulZeroClass.toSMul.{u1, u3} k V1 (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3))))) c (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₁ p₀))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_vsub_left AffineMap.lineMap_vsub_leftₓ'. -/
@[simp]
theorem lineMap_vsub_left (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c -ᵥ p₀ = c • (p₁ -ᵥ p₀) :=
  vadd_vsub _ _
#align affine_map.line_map_vsub_left AffineMap.lineMap_vsub_left

/- warning: affine_map.left_vsub_line_map -> AffineMap.left_vsub_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u2} V1 (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₀ (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) c (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₀ p₁))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} V1 (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₀ (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (HSMul.hSMul.{u1, u3, u3} k V1 V1 (instHSMul.{u1, u3} k V1 (SMulZeroClass.toSMul.{u1, u3} k V1 (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3))))) c (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₀ p₁))
Case conversion may be inaccurate. Consider using '#align affine_map.left_vsub_line_map AffineMap.left_vsub_lineMapₓ'. -/
@[simp]
theorem left_vsub_lineMap (p₀ p₁ : P1) (c : k) : p₀ -ᵥ lineMap p₀ p₁ c = c • (p₀ -ᵥ p₁) := by
  rw [← neg_vsub_eq_vsub_rev, line_map_vsub_left, ← smul_neg, neg_vsub_eq_vsub_rev]
#align affine_map.left_vsub_line_map AffineMap.left_vsub_lineMap

/- warning: affine_map.line_map_vsub_right -> AffineMap.lineMap_vsub_right is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u2} V1 (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₁) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) c) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₀ p₁))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} V1 (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c) p₁) (HSMul.hSMul.{u1, u3, u3} k V1 V1 (instHSMul.{u1, u3} k V1 (SMulZeroClass.toSMul.{u1, u3} k V1 (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3))))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (Semiring.toOne.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) c) (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₀ p₁))
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_vsub_right AffineMap.lineMap_vsub_rightₓ'. -/
@[simp]
theorem lineMap_vsub_right (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c -ᵥ p₁ = (1 - c) • (p₀ -ᵥ p₁) := by
  rw [← line_map_apply_one_sub, line_map_vsub_left]
#align affine_map.line_map_vsub_right AffineMap.lineMap_vsub_right

/- warning: affine_map.right_vsub_line_map -> AffineMap.right_vsub_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u2} V1 (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_3)))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) c) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₀))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] (p₀ : P1) (p₁ : P1) (c : k), Eq.{succ u3} V1 (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₁ (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₀ p₁) c)) (HSMul.hSMul.{u1, u3, u3} k V1 V1 (instHSMul.{u1, u3} k V1 (SMulZeroClass.toSMul.{u1, u3} k V1 (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} k V1 (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_3))))) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (Semiring.toOne.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) c) (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₁ p₀))
Case conversion may be inaccurate. Consider using '#align affine_map.right_vsub_line_map AffineMap.right_vsub_lineMapₓ'. -/
@[simp]
theorem right_vsub_lineMap (p₀ p₁ : P1) (c : k) : p₁ -ᵥ lineMap p₀ p₁ c = (1 - c) • (p₁ -ᵥ p₀) := by
  rw [← line_map_apply_one_sub, left_vsub_line_map]
#align affine_map.right_vsub_line_map AffineMap.right_vsub_lineMap

#print AffineMap.lineMap_vadd_lineMap /-
theorem lineMap_vadd_lineMap (v₁ v₂ : V1) (p₁ p₂ : P1) (c : k) :
    lineMap v₁ v₂ c +ᵥ lineMap p₁ p₂ c = lineMap (v₁ +ᵥ p₁) (v₂ +ᵥ p₂) c :=
  ((fst : V1 × P1 →ᵃ[k] V1) +ᵥ snd).apply_lineMap (v₁, p₁) (v₂, p₂) c
#align affine_map.line_map_vadd_line_map AffineMap.lineMap_vadd_lineMap
-/

/- warning: affine_map.line_map_vsub_line_map -> AffineMap.lineMap_vsub_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] (p₁ : P1) (p₂ : P1) (p₃ : P1) (p₄ : P1) (c : k), Eq.{succ u2} V1 (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) c) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₃ p₄) c)) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) => k -> V1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u2} k k k V1 V1 _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₁ p₃) (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_4) p₂ p₄)) c)
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] (p₁ : P1) (p₂ : P1) (p₃ : P1) (p₄ : P1) (c : k), Eq.{succ u3} V1 (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) c) (AffineMap.toFun.{u1, u1, u1, u3, u2} k k k V1 P1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4 (AffineMap.lineMap.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_4 p₃ p₄) c)) (AffineMap.toFun.{u1, u1, u1, u3, u3} k k k V1 V1 _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) (AffineMap.lineMap.{u1, u3, u3} k V1 V1 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₁ p₃) (VSub.vsub.{u3, u2} V1 P1 (AddTorsor.toVSub.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2) _inst_4) p₂ p₄)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_vsub_line_map AffineMap.lineMap_vsub_lineMapₓ'. -/
theorem lineMap_vsub_lineMap (p₁ p₂ p₃ p₄ : P1) (c : k) :
    lineMap p₁ p₂ c -ᵥ lineMap p₃ p₄ c = lineMap (p₁ -ᵥ p₃) (p₂ -ᵥ p₄) c :=
  letI-- Why Lean fails to find this instance without a hint?
   : affine_space (V1 × V1) (P1 × P1) := Prod.addTorsor
  ((fst : P1 × P1 →ᵃ[k] P1) -ᵥ (snd : P1 × P1 →ᵃ[k] P1)).apply_lineMap (_, _) (_, _) c
#align affine_map.line_map_vsub_line_map AffineMap.lineMap_vsub_lineMap

/- warning: affine_map.decomp -> AffineMap.decomp is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {V2 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u1, u3} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)] (f : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))), Eq.{max (succ u2) (succ u3)} ((fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) f) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) f) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} ((fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) f) ((fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) f) ((fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) f) (instHAdd.{max u2 u3} ((fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) f) (Pi.instAdd.{u2, u3} V1 (fun (ᾰ : V1) => V2) (fun (i : V1) => AddZeroClass.toHasAdd.{u3} V2 (AddMonoid.toAddZeroClass.{u3} V2 (SubNegMonoid.toAddMonoid.{u3} V2 (AddGroup.toSubNegMonoid.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) (fun (z : V1) => coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) f (OfNat.ofNat.{u2} V1 0 (OfNat.mk.{u2} V1 0 (Zero.zero.{u2} V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))))))))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u2) (succ u1)} (V1 -> V2) (AffineMap.toFun.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (forall (a : V1), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) a) (V1 -> V2) (V1 -> V2) (instHAdd.{max u2 u1} (forall (a : V1), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) a) (Pi.instAdd.{u2, u1} V1 (fun (ᾰ : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) ᾰ) (fun (i : V1) => AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) i) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) i) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) i) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) i) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) i) _inst_5))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} k k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (AffineMap.linear.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f)) (fun (z : V1) => AffineMap.toFun.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f (OfNat.ofNat.{u2} V1 0 (Zero.toOfNat0.{u2} V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align affine_map.decomp AffineMap.decompₓ'. -/
/-- Decomposition of an affine map in the special case when the point space and vector space
are the same. -/
theorem decomp (f : V1 →ᵃ[k] V2) : (f : V1 → V2) = f.linear + fun z => f 0 :=
  by
  ext x
  calc
    f x = f.linear x +ᵥ f 0 := by simp [← f.map_vadd]
    _ = (f.linear.to_fun + fun z : V1 => f 0) x := by simp
    
#align affine_map.decomp AffineMap.decomp

/- warning: affine_map.decomp' -> AffineMap.decomp' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {V2 : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u3} V2] [_inst_6 : Module.{u1, u3} k V2 (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5)] (f : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))), Eq.{max (succ u2) (succ u3)} ((fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) (fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} k k V1 V2 (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) (HSub.hSub.{max u2 u3, max u2 u3, max u2 u3} ((fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) ((fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) ((fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) (instHSub.{max u2 u3} ((fun (_x : LinearMap.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V2 _inst_5) _inst_3 _inst_6) => V1 -> V2) (AffineMap.linear.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5)) f)) (Pi.instSub.{u2, u3} V1 (fun (ᾰ : V1) => V2) (fun (i : V1) => SubNegMonoid.toHasSub.{u3} V2 (AddGroup.toSubNegMonoid.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) f) (fun (z : V1) => coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) => V1 -> V2) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V2 (AddCommGroup.toAddGroup.{u3} V2 _inst_5))) f (OfNat.ofNat.{u2} V1 0 (OfNat.mk.{u2} V1 0 (Zero.zero.{u2} V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))))))))))
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {V2 : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] [_inst_5 : AddCommGroup.{u1} V2] [_inst_6 : Module.{u3, u1} k V2 (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5)] (f : AffineMap.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))), Eq.{max (succ u2) (succ u1)} (forall (a : V1), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6) V1 (fun (_x : V1) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} k k V1 V2 (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V2 _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1)))) (AffineMap.linear.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f)) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (V1 -> V2) (V1 -> V2) (forall (a : V1), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : V1) => V2) a) (instHSub.{max u2 u1} (V1 -> V2) (Pi.instSub.{u2, u1} V1 (fun (ᾰ : V1) => V2) (fun (i : V1) => SubNegMonoid.toSub.{u1} V2 (AddGroup.toSubNegMonoid.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5))))) (AffineMap.toFun.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f) (fun (z : V1) => AffineMap.toFun.{u3, u2, u2, u1, u1} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V2 (AddCommGroup.toAddGroup.{u1} V2 _inst_5)) f (OfNat.ofNat.{u2} V1 0 (Zero.toOfNat0.{u2} V1 (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align affine_map.decomp' AffineMap.decomp'ₓ'. -/
/-- Decomposition of an affine map in the special case when the point space and vector space
are the same. -/
theorem decomp' (f : V1 →ᵃ[k] V2) : (f.linear : V1 → V2) = f - fun z => f 0 := by
  rw [decomp] <;> simp only [LinearMap.map_zero, Pi.add_apply, add_sub_cancel, zero_add]
#align affine_map.decomp' AffineMap.decomp'

omit V1

#print AffineMap.image_uIcc /-
theorem image_uIcc {k : Type _} [LinearOrderedField k] (f : k →ᵃ[k] k) (a b : k) :
    f '' Set.uIcc a b = Set.uIcc (f a) (f b) :=
  by
  have : ⇑f = (fun x => x + f 0) ∘ fun x => x * (f 1 - f 0) :=
    by
    ext x
    change f x = x • (f 1 -ᵥ f 0) +ᵥ f 0
    rw [← f.linear_map_vsub, ← f.linear.map_smul, ← f.map_vadd]
    simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul]
  rw [this, Set.image_comp]
  simp only [Set.image_add_const_uIcc, Set.image_mul_const_uIcc]
#align affine_map.image_uIcc AffineMap.image_uIcc
-/

section

variable {ι : Type _} {V : ∀ i : ι, Type _} {P : ∀ i : ι, Type _} [∀ i, AddCommGroup (V i)]
  [∀ i, Module k (V i)] [∀ i, AddTorsor (V i) (P i)]

include V

/- warning: affine_map.proj -> AffineMap.proj is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} {V : ι -> Type.{u3}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u1, u3} k (V i) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (i : ι), AffineMap.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i)) (fun (i : ι) => P i) (fun (i : ι) => _inst_16 i)) (_inst_14 i) (_inst_15 i) (_inst_16 i)
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} {V : ι -> Type.{u3}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u1, u3} k (V i) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (i : ι), AffineMap.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => P i) (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_16 i)) (_inst_14 i) (_inst_15 i) (_inst_16 i)
Case conversion may be inaccurate. Consider using '#align affine_map.proj AffineMap.projₓ'. -/
/-- Evaluation at a point as an affine map. -/
def proj (i : ι) : (∀ i : ι, P i) →ᵃ[k] P i
    where
  toFun f := f i
  linear := @LinearMap.proj k ι _ V _ _ i
  map_vadd' p v := rfl
#align affine_map.proj AffineMap.proj

/- warning: affine_map.proj_apply -> AffineMap.proj_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} {V : ι -> Type.{u3}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u1, u3} k (V i) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (i : ι) (f : forall (i : ι), P i), Eq.{succ u4} (P i) (coeFn.{max (succ (max u2 u3)) (succ (max u2 u4)) (succ u3) (succ u4), max (succ (max u2 u4)) (succ u4)} (AffineMap.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => (fun (i : ι) => _inst_14 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => P i) (fun (i : ι) => (fun (i : ι) => _inst_16 i) i)) ((fun (i : ι) => _inst_14 i) i) ((fun (i : ι) => _inst_15 i) i) ((fun (i : ι) => _inst_16 i) i)) (fun (_x : AffineMap.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => (fun (i : ι) => _inst_14 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => P i) (fun (i : ι) => (fun (i : ι) => _inst_16 i) i)) ((fun (i : ι) => _inst_14 i) i) ((fun (i : ι) => _inst_15 i) i) ((fun (i : ι) => _inst_16 i) i)) => (forall (i : ι), P i) -> (P i)) (AffineMap.hasCoeToFun.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => (fun (i : ι) => _inst_14 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => P i) (fun (i : ι) => (fun (i : ι) => _inst_16 i) i)) ((fun (i : ι) => _inst_14 i) i) ((fun (i : ι) => _inst_15 i) i) ((fun (i : ι) => _inst_16 i) i)) (AffineMap.proj.{u1, u2, u3, u4} k _inst_1 ι V P (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) i) f) (f i)
but is expected to have type
  forall {k : Type.{u3}} [_inst_1 : Ring.{u3} k] {ι : Type.{u2}} {V : ι -> Type.{u1}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u1} (V i)] [_inst_15 : forall (i : ι), Module.{u3, u1} k (V i) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u1, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u1} (V i) (_inst_14 i))] (i : ι) (f : forall (i : ι), P i), Eq.{succ u4} (P i) (AffineMap.toFun.{u3, max u2 u1, max u2 u4, u1, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u1, u3} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u2, u1, u4} ι (fun (i : ι) => V i) (fun (i : ι) => P i) (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_16 i)) (_inst_14 i) (_inst_15 i) (_inst_16 i) (AffineMap.proj.{u3, u2, u1, u4} k _inst_1 ι V P (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) i) f) (f i)
Case conversion may be inaccurate. Consider using '#align affine_map.proj_apply AffineMap.proj_applyₓ'. -/
@[simp]
theorem proj_apply (i : ι) (f : ∀ i, P i) : @proj k _ ι V P _ _ _ i f = f i :=
  rfl
#align affine_map.proj_apply AffineMap.proj_apply

/- warning: affine_map.proj_linear -> AffineMap.proj_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} {V : ι -> Type.{u3}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u1, u3} k (V i) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (i : ι), Eq.{max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (forall (i : ι), V i) (V i) (AddCommGroup.toAddCommMonoid.{max u2 u3} (forall (i : ι), V i) (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => (fun (i : ι) => _inst_14 i) i))) (AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) ((fun (i : ι) => _inst_15 i) i)) (AffineMap.linear.{u1, max u2 u3, max u2 u4, u3, u4} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => (fun (i : ι) => _inst_14 i) i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => (fun (i : ι) => _inst_15 i) i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) ((fun (i : ι) => _inst_14 i) i)) (fun (i : ι) => P i) (fun (i : ι) => (fun (i : ι) => _inst_16 i) i)) ((fun (i : ι) => _inst_14 i) i) ((fun (i : ι) => _inst_15 i) i) ((fun (i : ι) => _inst_16 i) i) (AffineMap.proj.{u1, u2, u3, u4} k _inst_1 ι V P (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) i)) (LinearMap.proj.{u1, u2, u3} k ι (Ring.toSemiring.{u1} k _inst_1) V (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i) i)
but is expected to have type
  forall {k : Type.{u2}} [_inst_1 : Ring.{u2} k] {ι : Type.{u4}} {V : ι -> Type.{u3}} {P : ι -> Type.{u1}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u2, u3} k (V i) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u1} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (i : ι), Eq.{max (succ u4) (succ u3)} (LinearMap.{u2, u2, max u4 u3, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (forall (i : ι), V i) (V i) (AddCommGroup.toAddCommMonoid.{max u4 u3} (forall (i : ι), V i) (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i))) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (Pi.module.{u4, u3, u2} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (_inst_15 i)) (AffineMap.linear.{u2, max u4 u3, max u4 u1, u3, u1} k (forall (i : ι), V i) (forall (i : ι), P i) (V i) (P i) _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u4, u3, u2} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u4, u3, u1} ι (fun (i : ι) => V i) (fun (i : ι) => P i) (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_16 i)) (_inst_14 i) (_inst_15 i) (_inst_16 i) (AffineMap.proj.{u2, u4, u3, u1} k _inst_1 ι V P (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_15 i) (fun (i : ι) => _inst_16 i) i)) (LinearMap.proj.{u2, u4, u3} k ι (Ring.toSemiring.{u2} k _inst_1) V (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i) i)
Case conversion may be inaccurate. Consider using '#align affine_map.proj_linear AffineMap.proj_linearₓ'. -/
@[simp]
theorem proj_linear (i : ι) : (@proj k _ ι V P _ _ _ i).linear = @LinearMap.proj k ι _ V _ _ i :=
  rfl
#align affine_map.proj_linear AffineMap.proj_linear

/- warning: affine_map.pi_line_map_apply -> AffineMap.pi_lineMap_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} {V : ι -> Type.{u3}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u3} (V i)] [_inst_15 : forall (i : ι), Module.{u1, u3} k (V i) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u3, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i))] (f : forall (i : ι), P i) (g : forall (i : ι), P i) (c : k) (i : ι), Eq.{succ u4} (P i) (coeFn.{max (succ u1) (succ (max u2 u3)) (succ (max u2 u4)), max (succ u1) (succ (max u2 u4))} (AffineMap.{u1, u1, u1, max u2 u3, max u2 u4} k k k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i)) (fun (i : ι) => P i) (fun (i : ι) => _inst_16 i))) (fun (_x : AffineMap.{u1, u1, u1, max u2 u3, max u2 u4} k k k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i)) (fun (i : ι) => P i) (fun (i : ι) => _inst_16 i))) => k -> (forall (i : ι), P i)) (AffineMap.hasCoeToFun.{u1, u1, u1, max u2 u3, max u2 u4} k k k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i)) (fun (i : ι) => P i) (fun (i : ι) => _inst_16 i))) (AffineMap.lineMap.{u1, max u2 u3, max u2 u4} k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u3, u1} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u3} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (Pi.addTorsor.{u2, u3, u4} ι (fun (i : ι) => V i) (fun (i : ι) => AddCommGroup.toAddGroup.{u3} (V i) (_inst_14 i)) (fun (i : ι) => P i) (fun (i : ι) => _inst_16 i)) f g) c i) (coeFn.{max (succ u1) (succ u3) (succ u4), max (succ u1) (succ u4)} (AffineMap.{u1, u1, u1, u3, u4} k k k (V i) (P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (_inst_14 i) (_inst_15 i) (_inst_16 i)) (fun (_x : AffineMap.{u1, u1, u1, u3, u4} k k k (V i) (P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (_inst_14 i) (_inst_15 i) (_inst_16 i)) => k -> (P i)) (AffineMap.hasCoeToFun.{u1, u1, u1, u3, u4} k k k (V i) (P i) _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (_inst_14 i) (_inst_15 i) (_inst_16 i)) (AffineMap.lineMap.{u1, u3, u4} k (V i) (P i) _inst_1 (_inst_14 i) (_inst_15 i) (_inst_16 i) (f i) (g i)) c)
but is expected to have type
  forall {k : Type.{u3}} [_inst_1 : Ring.{u3} k] {ι : Type.{u2}} {V : ι -> Type.{u1}} {P : ι -> Type.{u4}} [_inst_14 : forall (i : ι), AddCommGroup.{u1} (V i)] [_inst_15 : forall (i : ι), Module.{u3, u1} k (V i) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} (V i) (_inst_14 i))] [_inst_16 : forall (i : ι), AddTorsor.{u1, u4} (V i) (P i) (AddCommGroup.toAddGroup.{u1} (V i) (_inst_14 i))] (f : forall (i : ι), P i) (g : forall (i : ι), P i) (c : k) (i : ι), Eq.{succ u4} (P i) (AffineMap.toFun.{u3, u3, u3, max u2 u1, max u2 u4} k k k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (Pi.addCommGroup.{u2, u1} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u1, u3} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u2, u1, u4} ι (fun (i : ι) => V i) (fun (i : ι) => P i) (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_16 i)) (AffineMap.lineMap.{u3, max u2 u1, max u2 u4} k (forall (i : ι), V i) (forall (i : ι), P i) _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (i : ι) => V i) (fun (i : ι) => _inst_14 i)) (Pi.module.{u2, u1, u3} ι (fun (i : ι) => V i) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} (V i) (_inst_14 i)) (fun (i : ι) => _inst_15 i)) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u2, u1, u4} ι (fun (i : ι) => V i) (fun (i : ι) => P i) (fun (i : ι) => _inst_14 i) (fun (i : ι) => _inst_16 i)) f g) c i) (AffineMap.toFun.{u3, u3, u3, u1, u4} k k k (V i) (P i) _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) (_inst_14 i) (_inst_15 i) (_inst_16 i) (AffineMap.lineMap.{u3, u1, u4} k (V i) (P i) _inst_1 (_inst_14 i) (_inst_15 i) (_inst_16 i) (f i) (g i)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.pi_line_map_apply AffineMap.pi_lineMap_applyₓ'. -/
theorem pi_lineMap_apply (f g : ∀ i, P i) (c : k) (i : ι) :
    lineMap f g c i = lineMap (f i) (g i) c :=
  (proj i : (∀ i, P i) →ᵃ[k] P i).apply_lineMap f g c
#align affine_map.pi_line_map_apply AffineMap.pi_lineMap_apply

end

end AffineMap

namespace AffineMap

variable {R k V1 P1 V2 : Type _}

section Ring

variable [Ring k] [AddCommGroup V1] [affine_space V1 P1] [AddCommGroup V2]

variable [Module k V1] [Module k V2]

include V1

section DistribMulAction

variable [Monoid R] [DistribMulAction R V2] [SMulCommClass k R V2]

/-- The space of affine maps to a module inherits an `R`-action from the action on its codomain. -/
instance : DistribMulAction R (P1 →ᵃ[k] V2)
    where
  smul_add c f g := ext fun p => smul_add _ _ _
  smul_zero c := ext fun p => smul_zero _

end DistribMulAction

section Module

variable [Semiring R] [Module R V2] [SMulCommClass k R V2]

/-- The space of affine maps taking values in an `R`-module is an `R`-module. -/
instance : Module R (P1 →ᵃ[k] V2) :=
  { AffineMap.distribMulAction with
    smul := (· • ·)
    add_smul := fun c₁ c₂ f => ext fun p => add_smul _ _ _
    zero_smul := fun f => ext fun p => zero_smul _ _ }

variable (R)

/- warning: affine_map.to_const_prod_linear_map -> AffineMap.toConstProdLinearMap is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) {k : Type.{u2}} {V1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_4 : AddCommGroup.{u4} V2] [_inst_5 : Module.{u2, u3} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_6 : Module.{u2, u4} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)] [_inst_7 : Semiring.{u1} R] [_inst_8 : Module.{u1, u4} R V2 _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)] [_inst_9 : SMulCommClass.{u2, u1, u4} k R V2 (SMulZeroClass.toHasSmul.{u2, u4} k V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (SMulWithZero.toSmulZeroClass.{u2, u4} k V2 (MulZeroClass.toHasZero.{u2} k (MulZeroOneClass.toMulZeroClass.{u2} k (MonoidWithZero.toMulZeroOneClass.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))))) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V2 (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (Module.toMulActionWithZero.{u2, u4} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_6)))) (SMulZeroClass.toHasSmul.{u1, u4} R V2 (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u4} R V2 (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_7)))) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u4} R V2 (Semiring.toMonoidWithZero.{u1} R _inst_7) (AddZeroClass.toHasZero.{u4} V2 (AddMonoid.toAddZeroClass.{u4} V2 (AddCommMonoid.toAddMonoid.{u4} V2 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)))) (Module.toMulActionWithZero.{u1, u4} R V2 _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_8))))], LinearEquiv.{u1, u1, max u3 u4, max u3 u4} R R _inst_7 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_7)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_7)) (RingHomInvPair.ids.{u1} R _inst_7) (RingHomInvPair.ids.{u1} R _inst_7) (AffineMap.{u2, u3, u3, u4, u4} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_4))) (Prod.{u4, max u3 u4} V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6)) (AddCommGroup.toAddCommMonoid.{max u3 u4} (AffineMap.{u2, u3, u3, u4, u4} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_4))) (AffineMap.addCommGroup.{u2, u3, u3, u4} k V1 V1 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6)) (Prod.addCommMonoid.{u4, max u3 u4} V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) (LinearMap.addCommMonoid.{u2, u2, u3, u4} k k V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))))) (AffineMap.module.{u1, u2, u3, u3, u4} R k V1 V1 V2 _inst_1 _inst_2 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) (Prod.module.{u1, u4, max u3 u4} R V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6) _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) (LinearMap.addCommMonoid.{u2, u2, u3, u4} k k V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1)))) _inst_8 (LinearMap.module.{u2, u2, u1, u3, u4} k k R V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) _inst_7 _inst_8 _inst_9))
but is expected to have type
  forall (R : Type.{u1}) {k : Type.{u2}} {V1 : Type.{u3}} {V2 : Type.{u4}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_4 : AddCommGroup.{u4} V2] [_inst_5 : Module.{u2, u3} k V1 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] [_inst_6 : Module.{u2, u4} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)] [_inst_7 : Semiring.{u1} R] [_inst_8 : Module.{u1, u4} R V2 _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4)] [_inst_9 : SMulCommClass.{u2, u1, u4} k R V2 (SMulZeroClass.toSMul.{u2, u4} k V2 (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V2 (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V2 (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (Module.toMulActionWithZero.{u2, u4} k V2 (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_6)))) (SMulZeroClass.toSMul.{u1, u4} R V2 (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u4} R V2 (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_7)) (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u4} R V2 (Semiring.toMonoidWithZero.{u1} R _inst_7) (NegZeroClass.toZero.{u4} V2 (SubNegZeroMonoid.toNegZeroClass.{u4} V2 (SubtractionMonoid.toSubNegZeroMonoid.{u4} V2 (SubtractionCommMonoid.toSubtractionMonoid.{u4} V2 (AddCommGroup.toDivisionAddCommMonoid.{u4} V2 _inst_4))))) (Module.toMulActionWithZero.{u1, u4} R V2 _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_8))))], LinearEquiv.{u1, u1, max u4 u3, max u4 u3} R R _inst_7 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_7)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_7)) (RingHomInvPair.ids.{u1} R _inst_7) (RingHomInvPair.ids.{u1} R _inst_7) (AffineMap.{u2, u3, u3, u4, u4} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_4))) (Prod.{u4, max u4 u3} V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6)) (AddCommGroup.toAddCommMonoid.{max u3 u4} (AffineMap.{u2, u3, u3, u4, u4} k V1 V1 V2 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6 (addGroupIsAddTorsor.{u4} V2 (AddCommGroup.toAddGroup.{u4} V2 _inst_4))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u2, u3, u3, u4} k V1 V1 V2 _inst_1 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_6)) (Prod.instAddCommMonoidSum.{u4, max u3 u4} V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) (LinearMap.addCommMonoid.{u2, u2, u3, u4} k k V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))))) (AffineMap.instModuleAffineMapAddGroupIsAddTorsorToAddGroupToAddCommMonoidInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u2, u3, u3, u4} R k V1 V1 V2 _inst_1 _inst_2 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)) _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9) (Prod.module.{u1, u4, max u3 u4} R V2 (LinearMap.{u2, u2, u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) V1 V2 (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6) _inst_7 (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) (LinearMap.addCommMonoid.{u2, u2, u3, u4} k k V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1)))) _inst_8 (LinearMap.instModuleLinearMapAddCommMonoid.{u2, u2, u1, u3, u4} k k R V1 V2 (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V2 _inst_4) _inst_5 _inst_6 (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) _inst_7 _inst_8 _inst_9))
Case conversion may be inaccurate. Consider using '#align affine_map.to_const_prod_linear_map AffineMap.toConstProdLinearMapₓ'. -/
/-- The space of affine maps between two modules is linearly equivalent to the product of the
domain with the space of linear maps, by taking the value of the affine map at `(0 : V1)` and the
linear part.

See note [bundled maps over different rings]-/
@[simps]
def toConstProdLinearMap : (V1 →ᵃ[k] V2) ≃ₗ[R] V2 × (V1 →ₗ[k] V2)
    where
  toFun f := ⟨f 0, f.linear⟩
  invFun p := p.2.toAffineMap + const k V1 p.1
  left_inv f := by
    ext
    rw [f.decomp]
    simp
  right_inv := by
    rintro ⟨v, f⟩
    ext <;> simp
  map_add' := by simp
  map_smul' := by simp
#align affine_map.to_const_prod_linear_map AffineMap.toConstProdLinearMap

end Module

end Ring

section CommRing

variable [CommRing k] [AddCommGroup V1] [affine_space V1 P1] [AddCommGroup V2]

variable [Module k V1] [Module k V2]

include V1

#print AffineMap.homothety /-
/-- `homothety c r` is the homothety (also known as dilation) about `c` with scale factor `r`. -/
def homothety (c : P1) (r : k) : P1 →ᵃ[k] P1 :=
  r • (id k P1 -ᵥ const k P1 c) +ᵥ const k P1 c
#align affine_map.homothety AffineMap.homothety
-/

/- warning: affine_map.homothety_def -> AffineMap.homothety_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r : k), Eq.{max (succ u2) (succ u3)} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) (VAdd.vadd.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddAction.toHasVadd.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (SubNegMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddGroup.toSubNegMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)))) (AddTorsor.toAddAction.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3))) (SMul.smul.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (SMulZeroClass.toHasSmul.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (SMulWithZero.toSmulZeroClass.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (MulActionWithZero.toSMulWithZero.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (Module.toMulActionWithZero.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (smulCommClass_self.{u1, u2} k V1 (CommRing.toCommMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5)))))))) r (VSub.vsub.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddTorsor.toHasVsub.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.id.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3) (AffineMap.const.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))) (AffineMap.const.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] (c : P1) (r : k), Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) (HVAdd.hVAdd.{max u3 u2, max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (instHVAdd.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddAction.toVAdd.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (SubNegMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AddGroup.toSubNegMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)))) (AddTorsor.toAddAction.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (instHSMul.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (SMulZeroClass.toSMul.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (SMulWithZero.toSMulZeroClass.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (CommMonoidWithZero.toZero.{u1} k (CommSemiring.toCommMonoidWithZero.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (MulActionWithZero.toSMulWithZero.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (Module.toMulActionWithZero.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instModuleAffineMapAddGroupIsAddTorsorToAddGroupToAddCommMonoidInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u1, u3, u2, u3} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (smulCommClass_self.{u1, u3} k V1 (CommRing.toCommMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_5))))))))) r (VSub.vsub.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddTorsor.toVSub.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.id.{u1, u3, u2} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3) (AffineMap.const.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))) (AffineMap.const.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_def AffineMap.homothety_defₓ'. -/
theorem homothety_def (c : P1) (r : k) :
    homothety c r = r • (id k P1 -ᵥ const k P1 c) +ᵥ const k P1 c :=
  rfl
#align affine_map.homothety_def AffineMap.homothety_def

/- warning: affine_map.homothety_apply -> AffineMap.homothety_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r : k) (p : P1), Eq.{succ u3} P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) p) (VAdd.vadd.{u2, u3} V1 P1 (AddAction.toHasVadd.{u2, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u2} V1 (AddGroup.toSubNegMonoid.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddTorsor.toAddAction.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_3)) (SMul.smul.{u1, u2} k V1 (SMulZeroClass.toHasSmul.{u1, u2} k V1 (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V1 (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5)))) r (VSub.vsub.{u2, u3} V1 P1 (AddTorsor.toHasVsub.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2) _inst_3) p c)) c)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] [_inst_5 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] (c : P1) (r : k) (p : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) p) (HVAdd.hVAdd.{u1, u3, u3} V1 P1 P1 (instHVAdd.{u1, u3} V1 P1 (AddAction.toVAdd.{u1, u3} V1 P1 (SubNegMonoid.toAddMonoid.{u1} V1 (AddGroup.toSubNegMonoid.{u1} V1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2))) (AddTorsor.toAddAction.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_3))) (HSMul.hSMul.{u2, u1, u1} k V1 V1 (instHSMul.{u2, u1} k V1 (SMulZeroClass.toSMul.{u2, u1} k V1 (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V1 (CommMonoidWithZero.toZero.{u2} k (CommSemiring.toCommMonoidWithZero.{u2} k (CommRing.toCommSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V1 (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V1 (SubNegZeroMonoid.toNegZeroClass.{u1} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u1} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u1} V1 (AddCommGroup.toDivisionAddCommMonoid.{u1} V1 _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V1 (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2) _inst_5))))) r (VSub.vsub.{u1, u3} V1 P1 (AddTorsor.toVSub.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2) _inst_3) p c)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_apply AffineMap.homothety_applyₓ'. -/
theorem homothety_apply (c : P1) (r : k) (p : P1) : homothety c r p = r • (p -ᵥ c : V1) +ᵥ c :=
  rfl
#align affine_map.homothety_apply AffineMap.homothety_apply

/- warning: affine_map.homothety_eq_line_map -> AffineMap.homothety_eq_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r : k) (p : P1), Eq.{succ u3} P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) p) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V1 P1 (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) _inst_2 _inst_5 _inst_3) => k -> P1) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V1 P1 (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) _inst_2 _inst_5 _inst_3) (AffineMap.lineMap.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 c p) r)
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] [_inst_5 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] (c : P1) (r : k) (p : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) p) (AffineMap.toFun.{u2, u2, u2, u1, u3} k k k V1 P1 (CommRing.toRing.{u2} k _inst_1) (Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k (CommRing.toRing.{u2} k _inst_1)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_1)))) _inst_2 _inst_5 _inst_3 (AffineMap.lineMap.{u2, u1, u3} k V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 c p) r)
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_eq_line_map AffineMap.homothety_eq_lineMapₓ'. -/
theorem homothety_eq_lineMap (c : P1) (r : k) (p : P1) : homothety c r p = lineMap c p r :=
  rfl
#align affine_map.homothety_eq_line_map AffineMap.homothety_eq_lineMap

/- warning: affine_map.homothety_one -> AffineMap.homothety_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (succ u2) (succ u3)} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))))))) (AffineMap.id.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3)
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] (c : P1), Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))))) (AffineMap.id.{u1, u3, u2} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3)
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_one AffineMap.homothety_oneₓ'. -/
@[simp]
theorem homothety_one (c : P1) : homothety c (1 : k) = id k P1 :=
  by
  ext p
  simp [homothety_apply]
#align affine_map.homothety_one AffineMap.homothety_one

/- warning: affine_map.homothety_apply_same -> AffineMap.homothety_apply_same is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r : k), Eq.{succ u3} P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) c) c
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] [_inst_5 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] (c : P1) (r : k), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r) c) c
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_apply_same AffineMap.homothety_apply_sameₓ'. -/
@[simp]
theorem homothety_apply_same (c : P1) (r : k) : homothety c r c = c :=
  lineMap_same_apply c r
#align affine_map.homothety_apply_same AffineMap.homothety_apply_same

/- warning: affine_map.homothety_mul_apply -> AffineMap.homothety_mul_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k) (p : P1), Eq.{succ u3} P1 (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k (CommRing.toRing.{u1} k _inst_1)))) r₁ r₂)) p) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₁) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) => P1 -> P1) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂) p))
but is expected to have type
  forall {k : Type.{u2}} {V1 : Type.{u1}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V1] [_inst_3 : AddTorsor.{u1, u3} V1 P1 (AddCommGroup.toAddGroup.{u1} V1 _inst_2)] [_inst_5 : Module.{u2, u1} k V1 (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k) (p : P1), Eq.{succ u3} P1 (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HMul.hMul.{u2, u2, u2} k k k (instHMul.{u2} k (NonUnitalNonAssocRing.toMul.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_1))))) r₁ r₂)) p) (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₁) (AffineMap.toFun.{u2, u1, u3, u1, u3} k V1 P1 V1 P1 (CommRing.toRing.{u2} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u2, u1, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂) p))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_mul_apply AffineMap.homothety_mul_applyₓ'. -/
theorem homothety_mul_apply (c : P1) (r₁ r₂ : k) (p : P1) :
    homothety c (r₁ * r₂) p = homothety c r₁ (homothety c r₂ p) := by
  simp [homothety_apply, mul_smul]
#align affine_map.homothety_mul_apply AffineMap.homothety_mul_apply

/- warning: affine_map.homothety_mul -> AffineMap.homothety_mul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k), Eq.{max (succ u2) (succ u3)} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k (CommRing.toRing.{u1} k _inst_1)))) r₁ r₂)) (AffineMap.comp.{u1, u2, u3, u2, u3, u2, u3} k V1 P1 V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₁) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k), Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HMul.hMul.{u1, u1, u1} k k k (instHMul.{u1} k (NonUnitalNonAssocRing.toMul.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) r₁ r₂)) (AffineMap.comp.{u1, u3, u2, u3, u2, u3, u2} k V1 P1 V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₁) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_mul AffineMap.homothety_mulₓ'. -/
theorem homothety_mul (c : P1) (r₁ r₂ : k) :
    homothety c (r₁ * r₂) = (homothety c r₁).comp (homothety c r₂) :=
  ext <| homothety_mul_apply c r₁ r₂
#align affine_map.homothety_mul AffineMap.homothety_mul

/- warning: affine_map.homothety_zero -> AffineMap.homothety_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (succ u2) (succ u3)} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))))))))) (AffineMap.const.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c)
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] (c : P1), Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (CommMonoidWithZero.toZero.{u1} k (CommSemiring.toCommMonoidWithZero.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1)))))) (AffineMap.const.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c)
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_zero AffineMap.homothety_zeroₓ'. -/
@[simp]
theorem homothety_zero (c : P1) : homothety c (0 : k) = const k P1 c :=
  by
  ext p
  simp [homothety_apply]
#align affine_map.homothety_zero AffineMap.homothety_zero

/- warning: affine_map.homothety_add -> AffineMap.homothety_add is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k), Eq.{max (succ u2) (succ u3)} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k (CommRing.toRing.{u1} k _inst_1)))) r₁ r₂)) (VAdd.vadd.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddAction.toHasVadd.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (SubNegMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddGroup.toSubNegMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)))) (AddTorsor.toAddAction.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3))) (SMul.smul.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (SMulZeroClass.toHasSmul.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (SMulWithZero.toSmulZeroClass.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (MulActionWithZero.toSMulWithZero.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddMonoid.toAddZeroClass.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5))))) (Module.toMulActionWithZero.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (smulCommClass_self.{u1, u2} k V1 (CommRing.toCommMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V1 (AddMonoid.toAddZeroClass.{u2} V1 (AddCommMonoid.toAddMonoid.{u2} V1 (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5)))))))) r₁ (VSub.vsub.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddTorsor.toHasVsub.{max u3 u2, max u2 u3} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.id.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3) (AffineMap.const.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u3}} {P1 : Type.{u2}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u3} V1] [_inst_3 : AddTorsor.{u3, u2} V1 P1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2)] [_inst_5 : Module.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2)] (c : P1) (r₁ : k) (r₂ : k), Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c (HAdd.hAdd.{u1, u1, u1} k k k (instHAdd.{u1} k (Distrib.toAdd.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))))) r₁ r₂)) (HVAdd.hVAdd.{max u3 u2, max u2 u3, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (instHVAdd.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddAction.toVAdd.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (SubNegMonoid.toAddMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AddGroup.toSubNegMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)))) (AddTorsor.toAddAction.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)))) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (instHSMul.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (SMulZeroClass.toSMul.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (SMulWithZero.toSMulZeroClass.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (CommMonoidWithZero.toZero.{u1} k (CommSemiring.toCommMonoidWithZero.{u1} k (CommRing.toCommSemiring.{u1} k _inst_1))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (MulActionWithZero.toSMulWithZero.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (AffineMap.instZeroAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (Module.toMulActionWithZero.{u1, max u3 u2} k (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instModuleAffineMapAddGroupIsAddTorsorToAddGroupToAddCommMonoidInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u1, u3, u2, u3} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (smulCommClass_self.{u1, u3} k V1 (CommRing.toCommMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u3} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (NegZeroClass.toZero.{u3} V1 (SubNegZeroMonoid.toNegZeroClass.{u3} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u3} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u3} V1 (AddCommGroup.toDivisionAddCommMonoid.{u3} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u3} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V1 _inst_2) _inst_5))))))))) r₁ (VSub.vsub.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddTorsor.toVSub.{max u3 u2, max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AddCommGroup.toAddGroup.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u3} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u3} V1 (AddCommGroup.toAddGroup.{u3} V1 _inst_2))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5)) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.id.{u1, u3, u2} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3) (AffineMap.const.{u1, u3, u2, u3, u2} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3 c))) (AffineMap.homothety.{u1, u3, u2} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c r₂))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_add AffineMap.homothety_addₓ'. -/
@[simp]
theorem homothety_add (c : P1) (r₁ r₂ : k) :
    homothety c (r₁ + r₂) = r₁ • (id k P1 -ᵥ const k P1 c) +ᵥ homothety c r₂ := by
  simp only [homothety_def, add_smul, vadd_vadd]
#align affine_map.homothety_add AffineMap.homothety_add

/- warning: affine_map.homothety_hom -> AffineMap.homothetyHom is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)], P1 -> (MonoidHom.{u1, max u2 u3} k (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} k (NonAssocSemiring.toMulZeroOneClass.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.monoid.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3)))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)], P1 -> (MonoidHom.{u1, max u3 u2} k (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} k (NonAssocSemiring.toMulZeroOneClass.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3)))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_hom AffineMap.homothetyHomₓ'. -/
/-- `homothety` as a multiplicative monoid homomorphism. -/
def homothetyHom (c : P1) : k →* P1 →ᵃ[k] P1 :=
  ⟨homothety c, homothety_one c, homothety_mul c⟩
#align affine_map.homothety_hom AffineMap.homothetyHom

/- warning: affine_map.coe_homothety_hom -> AffineMap.coe_homothetyHom is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (succ u1) (succ (max u2 u3))} (k -> (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ u1) (succ (max u2 u3))} (MonoidHom.{u1, max u2 u3} k (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} k (NonAssocSemiring.toMulZeroOneClass.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.monoid.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3))) (fun (_x : MonoidHom.{u1, max u2 u3} k (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} k (NonAssocSemiring.toMulZeroOneClass.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.monoid.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3))) => k -> (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (MonoidHom.hasCoeToFun.{u1, max u2 u3} k (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u1} k (NonAssocSemiring.toMulZeroOneClass.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.monoid.{u1, u2, u3} k V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3))) (AffineMap.homothetyHom.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : CommRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k (CommRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (forall (ᾰ : k), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : k) => AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) ᾰ) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), succ u3, max (succ u2) (succ u1)} (MonoidHom.{u3, max u1 u2} k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3))) k (fun (_x : k) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : k) => AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) _x) (MulHomClass.toFunLike.{max (max u3 u2) u1, u3, max u2 u1} (MonoidHom.{u3, max u1 u2} k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3))) k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulOneClass.toMul.{u3} k (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1)))))) (MulOneClass.toMul.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3))) (MonoidHomClass.toMulHomClass.{max (max u3 u2) u1, u3, max u2 u1} (MonoidHom.{u3, max u1 u2} k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3))) k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3)) (MonoidHom.monoidHomClass.{u3, max u2 u1} k (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (MulZeroOneClass.toMulOneClass.{u3} k (NonAssocSemiring.toMulZeroOneClass.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k (CommRing.toRing.{u3} k _inst_1))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.instMonoidAffineMap.{u3, u2, u1} k V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3))))) (AffineMap.homothetyHom.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)) (AffineMap.homothety.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_homothety_hom AffineMap.coe_homothetyHomₓ'. -/
@[simp]
theorem coe_homothetyHom (c : P1) : ⇑(homothetyHom c : k →* _) = homothety c :=
  rfl
#align affine_map.coe_homothety_hom AffineMap.coe_homothetyHom

/- warning: affine_map.homothety_affine -> AffineMap.homothetyAffine is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)], P1 -> (AffineMap.{u1, u1, u1, max u3 u2, max u2 u3} k k k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (AffineMap.homothetyAffine._proof_1.{u1, u2} k V1 _inst_1 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3))
but is expected to have type
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)], P1 -> (AffineMap.{u1, u1, u1, max u2 u3, max u3 u2} k k k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u1} k _inst_1) (Ring.toAddCommGroup.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k (CommRing.toRing.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.instModuleAffineMapAddGroupIsAddTorsorToAddGroupToAddCommMonoidInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (smulCommClass_self.{u1, u2} k V1 (CommRing.toCommMonoid.{u1} k _inst_1) (MulActionWithZero.toMulAction.{u1, u2} k V1 (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5)))) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3))
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_affine AffineMap.homothetyAffineₓ'. -/
/-- `homothety` as an affine map. -/
def homothetyAffine (c : P1) : k →ᵃ[k] P1 →ᵃ[k] P1 :=
  ⟨homothety c, (LinearMap.lsmul k _).flip (id k P1 -ᵥ const k P1 c),
    Function.swap (homothety_add c)⟩
#align affine_map.homothety_affine AffineMap.homothetyAffine

/- warning: affine_map.coe_homothety_affine -> AffineMap.coe_homothetyAffine is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V1 : Type.{u2}} {P1 : Type.{u3}} [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u3} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u1, u2} k V1 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (succ u1) (succ (max u2 u3))} (k -> (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (coeFn.{max (succ u1) (succ (max u3 u2)) (succ (max u2 u3)), max (succ u1) (succ (max u2 u3))} (AffineMap.{u1, u1, u1, max u3 u2, max u2 u3} k k k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (AffineMap.homothetyAffine._proof_1.{u1, u2} k V1 _inst_1 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (fun (_x : AffineMap.{u1, u1, u1, max u3 u2, max u2 u3} k k k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (AffineMap.homothetyAffine._proof_1.{u1, u2} k V1 _inst_1 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) => k -> (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.hasCoeToFun.{u1, u1, u1, max u3 u2, max u2 u3} k k k (AffineMap.{u1, u2, u3, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u1} k _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1))) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (NonAssocRing.toAddGroupWithOne.{u1} k (Ring.toNonAssocRing.{u1} k (CommRing.toRing.{u1} k _inst_1))))) (AffineMap.addCommGroup.{u1, u2, u3, u2} k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.module.{u1, u1, u2, u3, u2} k k V1 P1 V1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) _inst_5 (AffineMap.homothetyAffine._proof_1.{u1, u2} k V1 _inst_1 _inst_2 _inst_5)) (AffineMap.addTorsor.{u1, u2, u3, u2, u3} k V1 P1 V1 P1 (CommRing.toRing.{u1} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.homothetyAffine.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)) (AffineMap.homothety.{u1, u2, u3} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)
but is expected to have type
  forall {k : Type.{u3}} {V1 : Type.{u2}} {P1 : Type.{u1}} [_inst_1 : CommRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V1] [_inst_3 : AddTorsor.{u2, u1} V1 P1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2)] [_inst_5 : Module.{u3, u2} k V1 (Ring.toSemiring.{u3} k (CommRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2)] (c : P1), Eq.{max (max (succ u3) (succ u2)) (succ u1)} (k -> (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3)) (AffineMap.toFun.{u3, u3, u3, max u2 u1, max u2 u1} k k k (AffineMap.{u3, u2, u1, u2, u2} k V1 P1 V1 V1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 (addGroupIsAddTorsor.{u2} V1 (AddCommGroup.toAddGroup.{u2} V1 _inst_2))) (AffineMap.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (CommRing.toRing.{u3} k _inst_1) (Ring.toAddCommGroup.{u3} k (CommRing.toRing.{u3} k _inst_1)) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k (CommRing.toRing.{u3} k _inst_1)) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k (CommRing.toRing.{u3} k _inst_1)))) (AffineMap.instAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u3, u2, u1, u2} k V1 P1 V1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5) (AffineMap.instModuleAffineMapAddGroupIsAddTorsorToAddGroupToAddCommMonoidInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u3, u3, u2, u1, u2} k k V1 P1 V1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_2 _inst_5 _inst_5 (Ring.toSemiring.{u3} k (CommRing.toRing.{u3} k _inst_1)) _inst_5 (smulCommClass_self.{u3, u2} k V1 (CommRing.toCommMonoid.{u3} k _inst_1) (MulActionWithZero.toMulAction.{u3, u2} k V1 (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k (CommRing.toRing.{u3} k _inst_1))) (NegZeroClass.toZero.{u2} V1 (SubNegZeroMonoid.toNegZeroClass.{u2} V1 (SubtractionMonoid.toSubNegZeroMonoid.{u2} V1 (SubtractionCommMonoid.toSubtractionMonoid.{u2} V1 (AddCommGroup.toDivisionAddCommMonoid.{u2} V1 _inst_2))))) (Module.toMulActionWithZero.{u3, u2} k V1 (Ring.toSemiring.{u3} k (CommRing.toRing.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V1 _inst_2) _inst_5)))) (AffineMap.instAddTorsorAffineMapAddGroupIsAddTorsorToAddGroupAffineMapToAddGroupInstAddCommGroupAffineMapAddGroupIsAddTorsorToAddGroup.{u3, u2, u1, u2, u1} k V1 P1 V1 P1 (CommRing.toRing.{u3} k _inst_1) _inst_2 _inst_5 _inst_3 _inst_2 _inst_5 _inst_3) (AffineMap.homothetyAffine.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)) (AffineMap.homothety.{u3, u2, u1} k V1 P1 _inst_1 _inst_2 _inst_3 _inst_5 c)
Case conversion may be inaccurate. Consider using '#align affine_map.coe_homothety_affine AffineMap.coe_homothetyAffineₓ'. -/
@[simp]
theorem coe_homothetyAffine (c : P1) : ⇑(homothetyAffine c : k →ᵃ[k] _) = homothety c :=
  rfl
#align affine_map.coe_homothety_affine AffineMap.coe_homothetyAffine

end CommRing

end AffineMap

section

variable {𝕜 E F : Type _} [Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F]

/- warning: convex.combo_affine_apply -> Convex.combo_affine_apply is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_1 : Ring.{u1} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u3} F] [_inst_4 : Module.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u1, u3} 𝕜 F (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)] {x : E} {y : E} {a : 𝕜} {b : 𝕜} {f : AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))}, (Eq.{succ u1} 𝕜 (HAdd.hAdd.{u1, u1, u1} 𝕜 𝕜 𝕜 (instHAdd.{u1} 𝕜 (Distrib.toHasAdd.{u1} 𝕜 (Ring.toDistrib.{u1} 𝕜 _inst_1))) a b) (OfNat.ofNat.{u1} 𝕜 1 (OfNat.mk.{u1} 𝕜 1 (One.one.{u1} 𝕜 (AddMonoidWithOne.toOne.{u1} 𝕜 (AddGroupWithOne.toAddMonoidWithOne.{u1} 𝕜 (NonAssocRing.toAddGroupWithOne.{u1} 𝕜 (Ring.toNonAssocRing.{u1} 𝕜 _inst_1)))))))) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (SMul.smul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) a x) (SMul.smul.{u1, u2} 𝕜 E (SMulZeroClass.toHasSmul.{u1, u2} 𝕜 E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} 𝕜 E (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} 𝕜 E (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} 𝕜 E (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4)))) b y))) (HAdd.hAdd.{u3, u3, u3} F F F (instHAdd.{u3} F (AddZeroClass.toHasAdd.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3)))))) (SMul.smul.{u1, u3} 𝕜 F (SMulZeroClass.toHasSmul.{u1, u3} 𝕜 F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} 𝕜 F (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} 𝕜 F (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} 𝕜 F (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) a (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f x)) (SMul.smul.{u1, u3} 𝕜 F (SMulZeroClass.toHasSmul.{u1, u3} 𝕜 F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (SMulWithZero.toSmulZeroClass.{u1, u3} 𝕜 F (MulZeroClass.toHasZero.{u1} 𝕜 (MulZeroOneClass.toMulZeroClass.{u1} 𝕜 (MonoidWithZero.toMulZeroOneClass.{u1} 𝕜 (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (MulActionWithZero.toSMulWithZero.{u1, u3} 𝕜 F (Semiring.toMonoidWithZero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_3)))) (Module.toMulActionWithZero.{u1, u3} 𝕜 F (Ring.toSemiring.{u1} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_3) _inst_5)))) b (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) (fun (_x : AffineMap.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) => E -> F) (AffineMap.hasCoeToFun.{u1, u2, u2, u3, u3} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_3))) f y))))
but is expected to have type
  forall {𝕜 : Type.{u3}} {E : Type.{u2}} {F : Type.{u1}} [_inst_1 : Ring.{u3} 𝕜] [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : AddCommGroup.{u1} F] [_inst_4 : Module.{u3, u2} 𝕜 E (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_5 : Module.{u3, u1} 𝕜 F (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3)] {x : E} {y : E} {a : 𝕜} {b : 𝕜} {f : AffineMap.{u3, u2, u2, u1, u1} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3))}, (Eq.{succ u3} 𝕜 (HAdd.hAdd.{u3, u3, u3} 𝕜 𝕜 𝕜 (instHAdd.{u3} 𝕜 (Distrib.toAdd.{u3} 𝕜 (NonUnitalNonAssocSemiring.toDistrib.{u3} 𝕜 (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} 𝕜 (NonAssocRing.toNonUnitalNonAssocRing.{u3} 𝕜 (Ring.toNonAssocRing.{u3} 𝕜 _inst_1)))))) a b) (OfNat.ofNat.{u3} 𝕜 1 (One.toOfNat1.{u3} 𝕜 (NonAssocRing.toOne.{u3} 𝕜 (Ring.toNonAssocRing.{u3} 𝕜 _inst_1))))) -> (Eq.{succ u1} F (AffineMap.toFun.{u3, u2, u2, u1, u1} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3)) f (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (HSMul.hSMul.{u3, u2, u2} 𝕜 E E (instHSMul.{u3, u2} 𝕜 E (SMulZeroClass.toSMul.{u3, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 E (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 E (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} 𝕜 E (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) a x) (HSMul.hSMul.{u3, u2, u2} 𝕜 E E (instHSMul.{u3, u2} 𝕜 E (SMulZeroClass.toSMul.{u3, u2} 𝕜 E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} 𝕜 E (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} 𝕜 E (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} 𝕜 E (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_4))))) b y))) (HAdd.hAdd.{u1, u1, u1} F F F (instHAdd.{u1} F (AddZeroClass.toAdd.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3)))))) (HSMul.hSMul.{u3, u1, u1} 𝕜 F F (instHSMul.{u3, u1} 𝕜 F (SMulZeroClass.toSMul.{u3, u1} 𝕜 F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} 𝕜 F (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕜 F (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (Module.toMulActionWithZero.{u3, u1} 𝕜 F (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) _inst_5))))) a (AffineMap.toFun.{u3, u2, u2, u1, u1} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3)) f x)) (HSMul.hSMul.{u3, u1, u1} 𝕜 F F (instHSMul.{u3, u1} 𝕜 F (SMulZeroClass.toSMul.{u3, u1} 𝕜 F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (SMulWithZero.toSMulZeroClass.{u3, u1} 𝕜 F (MonoidWithZero.toZero.{u3} 𝕜 (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (MulActionWithZero.toSMulWithZero.{u3, u1} 𝕜 F (Semiring.toMonoidWithZero.{u3} 𝕜 (Ring.toSemiring.{u3} 𝕜 _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_3))))) (Module.toMulActionWithZero.{u3, u1} 𝕜 F (Ring.toSemiring.{u3} 𝕜 _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_3) _inst_5))))) b (AffineMap.toFun.{u3, u2, u2, u1, u1} 𝕜 E E F F _inst_1 _inst_2 _inst_4 (addGroupIsAddTorsor.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) _inst_3 _inst_5 (addGroupIsAddTorsor.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_3)) f y))))
Case conversion may be inaccurate. Consider using '#align convex.combo_affine_apply Convex.combo_affine_applyₓ'. -/
/-- Applying an affine map to an affine combination of two points yields an affine combination of
the images. -/
theorem Convex.combo_affine_apply {x y : E} {a b : 𝕜} {f : E →ᵃ[𝕜] F} (h : a + b = 1) :
    f (a • x + b • y) = a • f x + b • f y :=
  by
  simp only [Convex.combo_eq_smul_sub_add h, ← vsub_eq_sub]
  exact f.apply_line_map _ _ _
#align convex.combo_affine_apply Convex.combo_affine_apply

end

