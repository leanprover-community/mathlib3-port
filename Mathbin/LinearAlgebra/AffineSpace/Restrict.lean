/-
Copyright (c) 2022 Paul Reichert. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Reichert

! This file was ported from Lean 3 source module linear_algebra.affine_space.restrict
! leanprover-community/mathlib commit 09258fb7f75d741b7eda9fa18d5c869e2135d9f1
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.AffineSubspace

/-!
# Affine map restrictions

This file defines restrictions of affine maps.

## Main definitions

* The domain and codomain of an affine map can be restricted using
  `affine_map.restrict`.

## Main theorems

* The associated linear map of the restriction is the restriction of the
  linear map associated to the original affine map.
* The restriction is injective if the original map is injective.
* The restriction in surjective if the codomain is the image of the domain.
-/


variable {k V₁ P₁ V₂ P₂ : Type _} [Ring k] [AddCommGroup V₁] [AddCommGroup V₂] [Module k V₁]
  [Module k V₂] [AddTorsor V₁ P₁] [AddTorsor V₂ P₂]

include V₁ V₂

/- warning: affine_subspace.nonempty_map -> AffineSubspace.nonempty_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} [Ene : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] {φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} [Ene : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] {φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, Nonempty.{succ u1} (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)))
Case conversion may be inaccurate. Consider using '#align affine_subspace.nonempty_map AffineSubspace.nonempty_mapₓ'. -/
-- not an instance because it loops with `nonempty`
theorem AffineSubspace.nonempty_map {E : AffineSubspace k P₁} [Ene : Nonempty E] {φ : P₁ →ᵃ[k] P₂} :
    Nonempty (E.map φ) := by
  obtain ⟨x, hx⟩ := id Ene
  refine' ⟨⟨φ x, affine_subspace.mem_map.mpr ⟨x, hx, rfl⟩⟩⟩
#align affine_subspace.nonempty_map AffineSubspace.nonempty_map

attribute [local instance, local nolint fails_quickly] AffineSubspace.nonempty_map

attribute [local instance, local nolint fails_quickly] AffineSubspace.toAddTorsor

/- warning: affine_map.restrict -> AffineMap.restrict is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] (φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] [_inst_9 : Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)], (LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) -> (AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9))
but is expected to have type
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] (φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] [_inst_9 : Nonempty.{succ u5} (Subtype.{succ u5} P₂ (fun (x : P₂) => Membership.mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))], (LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) -> (AffineMap.{u1, u2, u3, u4, u5} k (Subtype.{succ u2} V₁ (fun (x : V₁) => Membership.mem.{u2, u2} V₁ (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u4} V₂ (fun (x : V₂) => Membership.mem.{u4, u4} V₂ (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u5} P₂ (fun (x : P₂) => Membership.mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict AffineMap.restrictₓ'. -/
/-- Restrict domain and codomain of an affine map to the given subspaces. -/
def AffineMap.restrict (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁} {F : AffineSubspace k P₂}
    [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) : E →ᵃ[k] F :=
  by
  refine' ⟨_, _, _⟩
  · exact fun x => ⟨φ x, hEF <| affine_subspace.mem_map.mpr ⟨x, x.property, rfl⟩⟩
  · refine' φ.linear.restrict (_ : E.direction ≤ F.direction.comap φ.linear)
    rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]
    exact AffineSubspace.direction_le hEF
  · intro p v
    simp only [Subtype.ext_iff, Subtype.coe_mk, AffineSubspace.coe_vadd]
    apply AffineMap.map_vadd
#align affine_map.restrict AffineMap.restrict

/- warning: affine_map.restrict.coe_apply -> AffineMap.restrict.coe_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] (φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] [_inst_9 : Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)] (hEF : LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) (x : coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E), Eq.{succ u5} P₂ ((fun (a : Type.{u5}) (b : Type.{u5}) [self : HasLiftT.{succ u5, succ u5} a b] => self.0) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) P₂ (HasLiftT.mk.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) P₂ (CoeTCₓ.coe.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) P₂ (coeBase.{succ u5, succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) P₂ (coeSubtype.{succ u5} P₂ (fun (x : P₂) => Membership.Mem.{u5, u5} P₂ (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.hasMem.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))))) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) -> (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF) x)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) P₁ (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) P₁ (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) P₁ (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) P₁ (coeSubtype.{succ u3} P₁ (fun (x : P₁) => Membership.Mem.{u3, u3} P₁ (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))))) x))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] (φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] [_inst_9 : Nonempty.{succ u1} (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))] (hEF : LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) (x : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)), Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) (Subtype.val.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (Set.{u3} P₁) (Set.instMembershipSet.{u3} P₁) x (SetLike.coe.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) E)) x)) (Subtype.val.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (Set.{u1} P₂) (Set.instMembershipSet.{u1} P₂) x (SetLike.coe.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) F)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (fun (_x : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF) x)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ (Subtype.val.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (Set.{u3} P₁) (Set.instMembershipSet.{u3} P₁) x (SetLike.coe.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) E)) x))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.coe_apply AffineMap.restrict.coe_applyₓ'. -/
theorem AffineMap.restrict.coe_apply (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}
    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) (x : E) :
    ↑(φ.restrict hEF x) = φ x :=
  rfl
#align affine_map.restrict.coe_apply AffineMap.restrict.coe_apply

/- warning: affine_map.restrict.linear_aux -> AffineMap.restrict.linear_aux is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] {φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7} {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7}, (LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) -> (LE.le.{u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) (Preorder.toLE.{u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)))) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E) (Submodule.comap.{u1, u1, u2, u4, max u2 u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_4 _inst_5 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_4 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_4 _inst_5 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (AffineMap.linear.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] {φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7} {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7}, (LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F) -> (LE.le.{u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (Preorder.toLE.{u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (PartialOrder.toPreorder.{u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (Submodule.completeLattice.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4))))) (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E) (Submodule.comap.{u5, u5, u4, u2, max u4 u2} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_4 _inst_5 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_4 _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u5, u5, u4, u2} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_4 _inst_5 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1)))) (AffineMap.linear.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ) (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.linear_aux AffineMap.restrict.linear_auxₓ'. -/
theorem AffineMap.restrict.linear_aux {φ : P₁ →ᵃ[k] P₂} {E : AffineSubspace k P₁}
    {F : AffineSubspace k P₂} (hEF : E.map φ ≤ F) : E.direction ≤ F.direction.comap φ.linear :=
  by
  rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]
  exact AffineSubspace.direction_le hEF
#align affine_map.restrict.linear_aux AffineMap.restrict.linear_aux

/- warning: affine_map.restrict.linear -> AffineMap.restrict.linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] (φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] [_inst_9 : Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)] (hEF : LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (AddCommGroup.toAddCommMonoid.{u4} (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (AffineMap.linear.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9) (AffineMap.restrict.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF)) (LinearMap.restrict.{u1, u2, u4} k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_4 _inst_5 (AffineMap.linear.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F) (AffineMap.restrict.linear_aux.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F hEF))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] (φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] [_inst_9 : Nonempty.{succ u1} (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))] (hEF : LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Eq.{max (succ u4) (succ u2)} (LinearMap.{u5, u5, u4, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (AddCommGroup.toAddCommMonoid.{u4} (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (AddCommGroup.toAddCommMonoid.{u2} (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (AffineMap.linear.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9) (AffineMap.restrict.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF)) (LinearMap.restrict.{u5, u4, u2} k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_4 _inst_5 (AffineMap.linear.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ) (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E) (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F) (AffineMap.restrict.linear_aux.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F hEF))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.linear AffineMap.restrict.linearₓ'. -/
theorem AffineMap.restrict.linear (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}
    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) :
    (φ.restrict hEF).linear = φ.linear.restrict (AffineMap.restrict.linear_aux hEF) :=
  rfl
#align affine_map.restrict.linear AffineMap.restrict.linear

/- warning: affine_map.restrict.injective -> AffineMap.restrict.injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] {φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, (Function.Injective.{succ u3, succ u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ)) -> (forall {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] [_inst_9 : Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)] (hEF : LE.le.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Function.Injective.{succ u3, succ u5} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) -> (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] {φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, (Function.Injective.{succ u3, succ u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ)) -> (forall {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] [_inst_9 : Nonempty.{succ u1} (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))] (hEF : LE.le.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (Preorder.toLE.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Function.Injective.{succ u3, succ u1} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (fun (_x : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 hEF)))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.injective AffineMap.restrict.injectiveₓ'. -/
theorem AffineMap.restrict.injective {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Injective φ)
    {E : AffineSubspace k P₁} {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F]
    (hEF : E.map φ ≤ F) : Function.Injective (AffineMap.restrict φ hEF) :=
  by
  intro x y h
  simp only [Subtype.ext_iff, Subtype.coe_mk, AffineMap.restrict.coe_apply] at h⊢
  exact hφ h
#align affine_map.restrict.injective AffineMap.restrict.injective

/- warning: affine_map.restrict.surjective -> AffineMap.restrict.surjective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] (φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] [_inst_9 : Nonempty.{succ u5} (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)] (h : Eq.{succ u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Function.Surjective.{succ u3, succ u5} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) -> (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F)) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) F) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 (le_of_eq.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F h)))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] (φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} {F : AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] [_inst_9 : Nonempty.{succ u1} (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F))] (h : Eq.{succ u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F), Function.Surjective.{succ u3, succ u1} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (fun (_x : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x F)) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F)) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 F _inst_9)) (AffineMap.restrict.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E F _inst_8 _inst_9 (le_of_eq.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) F h)))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.surjective AffineMap.restrict.surjectiveₓ'. -/
theorem AffineMap.restrict.surjective (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}
    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (h : E.map φ = F) :
    Function.Surjective (AffineMap.restrict φ (le_of_eq h)) :=
  by
  rintro ⟨x, hx : x ∈ F⟩
  rw [← h, AffineSubspace.mem_map] at hx
  obtain ⟨y, hy, rfl⟩ := hx
  exact ⟨⟨y, hy⟩, rfl⟩
#align affine_map.restrict.surjective AffineMap.restrict.surjective

/- warning: affine_map.restrict.bijective -> AffineMap.restrict.bijective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {P₁ : Type.{u3}} {V₂ : Type.{u4}} {P₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : AddCommGroup.{u4} V₂] [_inst_4 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : Module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3)] [_inst_6 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_7 : AddTorsor.{u4, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u4} V₂ _inst_3)] {E : AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} [_inst_8 : Nonempty.{succ u3} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E)] {φ : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, (Function.Injective.{succ u3, succ u5} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ)) -> (Function.Bijective.{succ u3, succ u5} (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u3) (succ u5)} (AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ))) (fun (_x : AffineMap.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ))) => (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) -> (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineMap.hasCoeToFun.{u1, u2, u3, u4, u5} k (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4)) (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (coeSort.{succ u3, succ (succ u3)} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (AffineSubspace.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.setLike.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) E) (coeSort.{succ u4, succ (succ u4)} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) Type.{u4} (SetLike.hasCoeToSort.{u4, u4} (Submodule.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5)) (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (coeSort.{succ u5, succ (succ u5)} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) Type.{u5} (SetLike.hasCoeToSort.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)) _inst_1 (Submodule.addCommGroup.{u1, u2} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u1, u4} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (Submodule.module.{u1, u4} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineSubspace.toAddTorsor.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ))) (AffineMap.restrict.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) _inst_8 (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ) (le_refl.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.partialOrder.{u5, u5} (AffineSubspace.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.setLike.{u1, u4, u5} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7))) (AffineSubspace.map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)))))
but is expected to have type
  forall {k : Type.{u5}} {V₁ : Type.{u4}} {P₁ : Type.{u3}} {V₂ : Type.{u2}} {P₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : AddCommGroup.{u2} V₂] [_inst_4 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_5 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3)] [_inst_6 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_3)] {E : AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6} [_inst_8 : Nonempty.{succ u3} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E))] {φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7}, (Function.Injective.{succ u3, succ u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7) φ)) -> (Function.Bijective.{succ u3, succ u1} (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (fun (_x : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) => Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k (Subtype.{succ u4} V₁ (fun (x : V₁) => Membership.mem.{u4, u4} V₁ (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) (SetLike.instMembership.{u4, u4} (Submodule.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4) V₁ (Submodule.setLike.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4)) x (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E))) (Subtype.{succ u3} P₁ (fun (x : P₁) => Membership.mem.{u3, u3} P₁ (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6) P₁ (AffineSubspace.instSetLikeAffineSubspace.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6)) x E)) (Subtype.{succ u2} V₂ (fun (x : V₂) => Membership.mem.{u2, u2} V₂ (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) (SetLike.instMembership.{u2, u2} (Submodule.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5) V₂ (Submodule.setLike.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5)) x (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)))) (Subtype.{succ u1} P₂ (fun (x : P₂) => Membership.mem.{u1, u1} P₂ (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (SetLike.instMembership.{u1, u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) P₂ (AffineSubspace.instSetLikeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)) x (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) _inst_1 (Submodule.addCommGroup.{u5, u4} k V₁ _inst_1 _inst_2 _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (Submodule.module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_4 (AffineSubspace.direction.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E)) (AffineSubspace.toAddTorsor.{u5, u4, u3} k V₁ P₁ _inst_1 _inst_2 _inst_4 _inst_6 E _inst_8) (Submodule.addCommGroup.{u5, u2} k V₂ _inst_1 _inst_3 _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (Submodule.module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_3) _inst_5 (AffineSubspace.direction.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E))) (AffineSubspace.toAddTorsor.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7 (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ))) (AffineMap.restrict.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ E (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E) _inst_8 (AffineSubspace.nonempty_map.{u1, u2, u3, u4, u5} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 E _inst_8 φ) (le_refl.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (PartialOrder.toPreorder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (OmegaCompletePartialOrder.toPartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (AffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7) (AffineSubspace.instCompleteLatticeAffineSubspace.{u5, u2, u1} k V₂ P₂ _inst_1 _inst_3 _inst_5 _inst_7)))) (AffineSubspace.map.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_4 _inst_6 _inst_3 _inst_5 _inst_7 φ E)))))
Case conversion may be inaccurate. Consider using '#align affine_map.restrict.bijective AffineMap.restrict.bijectiveₓ'. -/
theorem AffineMap.restrict.bijective {E : AffineSubspace k P₁} [Nonempty E] {φ : P₁ →ᵃ[k] P₂}
    (hφ : Function.Injective φ) : Function.Bijective (φ.restrict (le_refl (E.map φ))) :=
  ⟨AffineMap.restrict.injective hφ _, AffineMap.restrict.surjective _ rfl⟩
#align affine_map.restrict.bijective AffineMap.restrict.bijective

