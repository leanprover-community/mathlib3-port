/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers

! This file was ported from Lean 3 source module linear_algebra.affine_space.combination
! leanprover-community/mathlib commit 19cb3751e5e9b3d97adb51023949c50c13b5fdfd
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Invertible
import Mathbin.Algebra.IndicatorFunction
import Mathbin.Algebra.Module.BigOperators
import Mathbin.Data.Fintype.BigOperators
import Mathbin.LinearAlgebra.AffineSpace.AffineMap
import Mathbin.LinearAlgebra.AffineSpace.AffineSubspace
import Mathbin.LinearAlgebra.Finsupp
import Mathbin.Tactic.FinCases

/-!
# Affine combinations of points

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines affine combinations of points.

## Main definitions

* `weighted_vsub_of_point` is a general weighted combination of
  subtractions with an explicit base point, yielding a vector.

* `weighted_vsub` uses an arbitrary choice of base point and is intended
  to be used when the sum of weights is 0, in which case the result is
  independent of the choice of base point.

* `affine_combination` adds the weighted combination to the arbitrary
  base point, yielding a point rather than a vector, and is intended
  to be used when the sum of weights is 1, in which case the result is
  independent of the choice of base point.

These definitions are for sums over a `finset`; versions for a
`fintype` may be obtained using `finset.univ`, while versions for a
`finsupp` may be obtained using `finsupp.support`.

## References

* https://en.wikipedia.org/wiki/Affine_space

-/


noncomputable section

open BigOperators Affine

namespace Finset

/- warning: finset.univ_fin2 -> Finset.univ_fin2 is a dubious translation:
lean 3 declaration is
  Eq.{1} (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Finset.univ.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Insert.insert.{0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Finset.hasInsert.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (b : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) a b)) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (Singleton.singleton.{0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (Finset.hasSingleton.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))))
but is expected to have type
  Eq.{1} (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (Finset.univ.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (Insert.insert.{0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (Finset.instInsertFinset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (b : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) a b)) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Singleton.singleton.{0, 0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Finset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (Finset.instSingletonFinset.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))
Case conversion may be inaccurate. Consider using '#align finset.univ_fin2 Finset.univ_fin2ₓ'. -/
theorem univ_fin2 : (univ : Finset (Fin 2)) = {0, 1} :=
  by
  ext x
  fin_cases x <;> simp
#align finset.univ_fin2 Finset.univ_fin2

variable {k : Type _} {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]

variable [S : affine_space V P]

include S

variable {ι : Type _} (s : Finset ι)

variable {ι₂ : Type _} (s₂ : Finset ι₂)

#print Finset.weightedVSubOfPoint /-
/-- A weighted sum of the results of subtracting a base point from the
given points, as a linear map on the weights.  The main cases of
interest are where the sum of the weights is 0, in which case the sum
is independent of the choice of base point, and where the sum of the
weights is 1, in which case the sum added to the base point is
independent of the choice of base point. -/
def weightedVSubOfPoint (p : ι → P) (b : P) : (ι → k) →ₗ[k] V :=
  ∑ i in s, (LinearMap.proj i : (ι → k) →ₗ[k] k).smul_right (p i -ᵥ b)
#align finset.weighted_vsub_of_point Finset.weightedVSubOfPoint
-/

/- warning: finset.weighted_vsub_of_point_apply -> Finset.weightedVSubOfPoint_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w) (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p i) b)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w) (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p i) b)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_apply Finset.weightedVSubOfPoint_applyₓ'. -/
@[simp]
theorem weightedVSubOfPoint_apply (w : ι → k) (p : ι → P) (b : P) :
    s.weightedVSubOfPoint p b w = ∑ i in s, w i • (p i -ᵥ b) := by
  simp [weighted_vsub_of_point, LinearMap.sum_apply]
#align finset.weighted_vsub_of_point_apply Finset.weightedVSubOfPoint_apply

/- warning: finset.weighted_vsub_of_point_apply_const -> Finset.weightedVSubOfPoint_apply_const is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : P) (b : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p) b) w) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p b))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : P) (b : P), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p) b) w) (HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) p b))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_apply_const Finset.weightedVSubOfPoint_apply_constₓ'. -/
/-- The value of `weighted_vsub_of_point`, where the given points are equal. -/
@[simp]
theorem weightedVSubOfPoint_apply_const (w : ι → k) (p : P) (b : P) :
    s.weightedVSubOfPoint (fun _ => p) b w = (∑ i in s, w i) • (p -ᵥ b) := by
  rw [weighted_vsub_of_point_apply, sum_smul]
#align finset.weighted_vsub_of_point_apply_const Finset.weightedVSubOfPoint_apply_const

/- warning: finset.weighted_vsub_of_point_congr -> Finset.weightedVSubOfPoint_congr is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u3} P (p₁ i) (p₂ i))) -> (forall (b : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u3} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u2} P (p₁ i) (p₂ i))) -> (forall (b : P), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u4, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w₁) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u4, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w₂)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_congr Finset.weightedVSubOfPoint_congrₓ'. -/
/-- `weighted_vsub_of_point` gives equal results for two families of weights and two families of
points that are equal on `s`. -/
theorem weightedVSubOfPoint_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}
    (hp : ∀ i ∈ s, p₁ i = p₂ i) (b : P) :
    s.weightedVSubOfPoint p₁ b w₁ = s.weightedVSubOfPoint p₂ b w₂ :=
  by
  simp_rw [weighted_vsub_of_point_apply]
  convert sum_congr rfl fun i hi => _
  rw [hw i hi, hp i hi]
#align finset.weighted_vsub_of_point_congr Finset.weightedVSubOfPoint_congr

/- warning: finset.weighted_vsub_of_point_eq_of_weights_eq -> Finset.weightedVSubOfPoint_eq_of_weights_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (p : ι -> P) (j : ι) (w₁ : ι -> k) (w₂ : ι -> k), (forall (i : ι), (Ne.{succ u4} ι i j) -> (Eq.{succ u1} k (w₁ i) (w₂ i))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p j)) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p j)) w₂))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (p : ι -> P) (j : ι) (w₁ : ι -> k) (w₂ : ι -> k), (forall (i : ι), (Ne.{succ u4} ι i j) -> (Eq.{succ u3} k (w₁ i) (w₂ i))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p j)) w₁) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p j)) w₂))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_eq_of_weights_eq Finset.weightedVSubOfPoint_eq_of_weights_eqₓ'. -/
/-- Given a family of points, if we use a member of the family as a base point, the
`weighted_vsub_of_point` does not depend on the value of the weights at this point. -/
theorem weightedVSubOfPoint_eq_of_weights_eq (p : ι → P) (j : ι) (w₁ w₂ : ι → k)
    (hw : ∀ i, i ≠ j → w₁ i = w₂ i) :
    s.weightedVSubOfPoint p (p j) w₁ = s.weightedVSubOfPoint p (p j) w₂ :=
  by
  simp only [Finset.weightedVSubOfPoint_apply]
  congr
  ext i
  cases' eq_or_ne i j with h h
  · simp [h]
  · simp [hw i h]
#align finset.weighted_vsub_of_point_eq_of_weights_eq Finset.weightedVSubOfPoint_eq_of_weights_eq

/- warning: finset.weighted_vsub_of_point_eq_of_sum_eq_zero -> Finset.weightedVSubOfPoint_eq_of_sum_eq_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (forall (b₁ : P) (b₂ : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b₁) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b₂) w))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (forall (b₁ : P) (b₂ : P), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b₁) w) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b₂) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_eq_of_sum_eq_zero Finset.weightedVSubOfPoint_eq_of_sum_eq_zeroₓ'. -/
/-- The weighted sum is independent of the base point when the sum of
the weights is 0. -/
theorem weightedVSubOfPoint_eq_of_sum_eq_zero (w : ι → k) (p : ι → P) (h : (∑ i in s, w i) = 0)
    (b₁ b₂ : P) : s.weightedVSubOfPoint p b₁ w = s.weightedVSubOfPoint p b₂ w :=
  by
  apply eq_of_sub_eq_zero
  rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ← sum_sub_distrib]
  conv_lhs =>
    congr
    skip
    ext
    rw [← smul_sub, vsub_sub_vsub_cancel_left]
  rw [← sum_smul, h, zero_smul]
#align finset.weighted_vsub_of_point_eq_of_sum_eq_zero Finset.weightedVSubOfPoint_eq_of_sum_eq_zero

/- warning: finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one -> Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (forall (b₁ : P) (b₂ : P), Eq.{succ u3} P (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b₁) w) b₁) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b₂) w) b₂))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (forall (b₁ : P) (b₂ : P), Eq.{succ u2} P (HVAdd.hVAdd.{u1, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P P (instHVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddAction.toVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))) (AddTorsor.toAddAction.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) S))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u1} (LinearMap.{u4, u4, max u4 u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u1} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b₁) w) b₁) (HVAdd.hVAdd.{u1, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P P (instHVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddAction.toVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))) (AddTorsor.toAddAction.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) S))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u1} (LinearMap.{u4, u4, max u4 u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u1} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b₂) w) b₂))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_oneₓ'. -/
/-- The weighted sum, added to the base point, is independent of the
base point when the sum of the weights is 1. -/
theorem weightedVSubOfPoint_vadd_eq_of_sum_eq_one (w : ι → k) (p : ι → P) (h : (∑ i in s, w i) = 1)
    (b₁ b₂ : P) : s.weightedVSubOfPoint p b₁ w +ᵥ b₁ = s.weightedVSubOfPoint p b₂ w +ᵥ b₂ :=
  by
  erw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ← @vsub_eq_zero_iff_eq V,
    vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ← add_sub_assoc, add_comm, add_sub_assoc, ←
    sum_sub_distrib]
  conv_lhs =>
    congr
    skip
    congr
    skip
    ext
    rw [← smul_sub, vsub_sub_vsub_cancel_left]
  rw [← sum_smul, h, one_smul, vsub_add_vsub_cancel, vsub_self]
#align finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_one

/- warning: finset.weighted_vsub_of_point_erase -> Finset.weightedVSubOfPoint_erase is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (w : ι -> k) (p : ι -> P) (i : ι), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.erase.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b) s i) p (p i)) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p i)) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (w : ι -> k) (p : ι -> P) (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.erase.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b) s i) p (p i)) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p i)) w)
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_erase Finset.weightedVSubOfPoint_eraseₓ'. -/
/-- The weighted sum is unaffected by removing the base point, if
present, from the set of points. -/
@[simp]
theorem weightedVSubOfPoint_erase [DecidableEq ι] (w : ι → k) (p : ι → P) (i : ι) :
    (s.eraseₓ i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w :=
  by
  rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
  apply sum_erase
  rw [vsub_self, smul_zero]
#align finset.weighted_vsub_of_point_erase Finset.weightedVSubOfPoint_erase

/- warning: finset.weighted_vsub_of_point_insert -> Finset.weightedVSubOfPoint_insert is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (w : ι -> k) (p : ι -> P) (i : ι), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Insert.insert.{u4, u4} ι (Finset.{u4} ι) (Finset.hasInsert.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) i s) p (p i)) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p i)) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (w : ι -> k) (p : ι -> P) (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Insert.insert.{u4, u4} ι (Finset.{u4} ι) (Finset.instInsertFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) i s) p (p i)) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (p i)) w)
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_insert Finset.weightedVSubOfPoint_insertₓ'. -/
/-- The weighted sum is unaffected by adding the base point, whether
or not present, to the set of points. -/
@[simp]
theorem weightedVSubOfPoint_insert [DecidableEq ι] (w : ι → k) (p : ι → P) (i : ι) :
    (insert i s).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w :=
  by
  rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
  apply sum_insert_zero
  rw [vsub_self, smul_zero]
#align finset.weighted_vsub_of_point_insert Finset.weightedVSubOfPoint_insert

/- warning: finset.weighted_vsub_of_point_indicator_subset -> Finset.weightedVSubOfPoint_indicator_subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) (b : P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₁ s₂) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p b) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s₁) w)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) (b : P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₁ s₂) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p b) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) (Set.indicator.{u4, u2} ι k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (Finset.toSet.{u4} ι s₁) w)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_indicator_subset Finset.weightedVSubOfPoint_indicator_subsetₓ'. -/
/-- The weighted sum is unaffected by changing the weights to the
corresponding indicator function and adding points to the set. -/
theorem weightedVSubOfPoint_indicator_subset (w : ι → k) (p : ι → P) (b : P) {s₁ s₂ : Finset ι}
    (h : s₁ ⊆ s₂) :
    s₁.weightedVSubOfPoint p b w = s₂.weightedVSubOfPoint p b (Set.indicator (↑s₁) w) :=
  by
  rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
  exact
    Set.sum_indicator_subset_of_eq_zero w (fun i wi => wi • (p i -ᵥ b : V)) h fun i => zero_smul k _
#align finset.weighted_vsub_of_point_indicator_subset Finset.weightedVSubOfPoint_indicator_subset

/- warning: finset.weighted_vsub_of_point_map -> Finset.weightedVSubOfPoint_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p b) w) (coeFn.{max (succ (max u5 u1)) (succ u2), max (succ (max u5 u1)) (succ u2)} (LinearMap.{u1, u1, max u5 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u5 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι₂ -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u5 u1, u2} k k (ι₂ -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e)) b) (Function.comp.{succ u5, succ u4, succ u1} ι₂ ι k w (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p b) w) (FunLike.coe.{max (max (succ u3) (succ u5)) (succ u2), max (succ u5) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u5, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u5, u2, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι₂ -> k) (fun (_x : ι₂ -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι₂ -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u5 u2, u3} k k (ι₂ -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u5, u2} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u5, u2, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u1} ι₂ ι P p (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e)) b) (Function.comp.{succ u5, succ u4, succ u2} ι₂ ι k w (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_map Finset.weightedVSubOfPoint_mapₓ'. -/
/-- A weighted sum, over the image of an embedding, equals a weighted
sum with the same points and weights over the original
`finset`. -/
theorem weightedVSubOfPoint_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) (b : P) :
    (s₂.map e).weightedVSubOfPoint p b w = s₂.weightedVSubOfPoint (p ∘ e) b (w ∘ e) :=
  by
  simp_rw [weighted_vsub_of_point_apply]
  exact Finset.sum_map _ _ _
#align finset.weighted_vsub_of_point_map Finset.weightedVSubOfPoint_map

/- warning: finset.sum_smul_vsub_eq_weighted_vsub_of_point_sub -> Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P) (b : P), Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) (p₂ i)))) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P) (b : P), Eq.{succ u4} V (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p₁ i) (p₂ i)))) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_eq_weighted_vsub_of_point_sub Finset.sum_smul_vsub_eq_weightedVSubOfPoint_subₓ'. -/
/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two
`weighted_vsub_of_point` expressions. -/
theorem sum_smul_vsub_eq_weightedVSubOfPoint_sub (w : ι → k) (p₁ p₂ : ι → P) (b : P) :
    (∑ i in s, w i • (p₁ i -ᵥ p₂ i)) =
      s.weightedVSubOfPoint p₁ b w - s.weightedVSubOfPoint p₂ b w :=
  by
  simp_rw [weighted_vsub_of_point_apply, ← sum_sub_distrib, ← smul_sub, vsub_sub_vsub_cancel_right]
#align finset.sum_smul_vsub_eq_weighted_vsub_of_point_sub Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub

/- warning: finset.sum_smul_vsub_const_eq_weighted_vsub_of_point_sub -> Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P) (b : P), Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) p₂))) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₂ b)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P) (b : P), Eq.{succ u4} V (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p₁ i) p₂))) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) V ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁ b) w) (HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) p₂ b)))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_const_eq_weighted_vsub_of_point_sub Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_subₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the right is constant,
expressed as a subtraction involving a `weighted_vsub_of_point` expression. -/
theorem sum_smul_vsub_const_eq_weightedVSubOfPoint_sub (w : ι → k) (p₁ : ι → P) (p₂ b : P) :
    (∑ i in s, w i • (p₁ i -ᵥ p₂)) = s.weightedVSubOfPoint p₁ b w - (∑ i in s, w i) • (p₂ -ᵥ b) :=
  by rw [sum_smul_vsub_eq_weighted_vsub_of_point_sub, weighted_vsub_of_point_apply_const]
#align finset.sum_smul_vsub_const_eq_weighted_vsub_of_point_sub Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_sub

/- warning: finset.sum_smul_const_vsub_eq_sub_weighted_vsub_of_point -> Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P) (b : P), Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (p₂ i)))) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ b)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P) (b : P), Eq.{succ u4} V (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) p₁ (p₂ i)))) (HSub.hSub.{u4, u4, u4} V ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) V (instHSub.{u4} V (SubNegMonoid.toSub.{u4} V (AddGroup.toSubNegMonoid.{u4} V (AddCommGroup.toAddGroup.{u4} V _inst_2)))) (HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) p₁ b)) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂ b) w))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_const_vsub_eq_sub_weighted_vsub_of_point Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPointₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the left is constant,
expressed as a subtraction involving a `weighted_vsub_of_point` expression. -/
theorem sum_smul_const_vsub_eq_sub_weightedVSubOfPoint (w : ι → k) (p₂ : ι → P) (p₁ b : P) :
    (∑ i in s, w i • (p₁ -ᵥ p₂ i)) = (∑ i in s, w i) • (p₁ -ᵥ b) - s.weightedVSubOfPoint p₂ b w :=
  by rw [sum_smul_vsub_eq_weighted_vsub_of_point_sub, weighted_vsub_of_point_apply_const]
#align finset.sum_smul_const_vsub_eq_sub_weighted_vsub_of_point Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint

/- warning: finset.weighted_vsub_of_point_sdiff -> Finset.weightedVSubOfPoint_sdiff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u2} V (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.hasSdiff.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p b) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) w)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (HAdd.hAdd.{u3, u3, u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHAdd.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddZeroClass.toAdd.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddMonoid.toAddZeroClass.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.instSDiffFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p b) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) w)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_sdiff Finset.weightedVSubOfPoint_sdiffₓ'. -/
/-- A weighted sum may be split into such sums over two subsets. -/
theorem weightedVSubOfPoint_sdiff [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)
    (p : ι → P) (b : P) :
    (s \ s₂).weightedVSubOfPoint p b w + s₂.weightedVSubOfPoint p b w =
      s.weightedVSubOfPoint p b w :=
  by simp_rw [weighted_vsub_of_point_apply, sum_sdiff h]
#align finset.weighted_vsub_of_point_sdiff Finset.weightedVSubOfPoint_sdiff

/- warning: finset.weighted_vsub_of_point_sdiff_sub -> Finset.weightedVSubOfPoint_sdiff_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.hasSdiff.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p b) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) (Neg.neg.{max u4 u1} (ι -> k) (Pi.instNeg.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => SubNegMonoid.toHasNeg.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) w))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P) (b : P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (HSub.hSub.{u3, u3, u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) (Neg.neg.{max u2 u4} (ι -> k) (Pi.instNeg.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.1988 : ι) => k) (fun (i : ι) => Ring.toNeg.{u2} k _inst_1)) w)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSub.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toSub.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.instSDiffFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p b) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p b) (Neg.neg.{max u2 u4} (ι -> k) (Pi.instNeg.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Ring.toNeg.{u2} k _inst_1)) w))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_sdiff_sub Finset.weightedVSubOfPoint_sdiff_subₓ'. -/
/-- A weighted sum may be split into a subtraction of such sums over two subsets. -/
theorem weightedVSubOfPoint_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)
    (p : ι → P) (b : P) :
    (s \ s₂).weightedVSubOfPoint p b w - s₂.weightedVSubOfPoint p b (-w) =
      s.weightedVSubOfPoint p b w :=
  by rw [map_neg, sub_neg_eq_add, s.weighted_vsub_of_point_sdiff h]
#align finset.weighted_vsub_of_point_sdiff_sub Finset.weightedVSubOfPoint_sdiff_sub

/- warning: finset.weighted_vsub_of_point_subtype_eq_filter -> Finset.weightedVSubOfPoint_subtype_eq_filter is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => ((Subtype.{succ u4} ι pred) -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k ((Subtype.{succ u4} ι pred) -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i)) b) (fun (i : Subtype.{succ u4} ι pred) => w ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p b) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Subtype.{succ u4} ι pred) -> k) => V) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) ((Subtype.{succ u4} ι pred) -> k) (fun (_x : (Subtype.{succ u4} ι pred) -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Subtype.{succ u4} ι pred) -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k ((Subtype.{succ u4} ι pred) -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p (Subtype.val.{succ u4} ι pred i)) b) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSubOfPoint.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p b) w)
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_subtype_eq_filter Finset.weightedVSubOfPoint_subtype_eq_filterₓ'. -/
/-- A weighted sum over `s.subtype pred` equals one over `s.filter pred`. -/
theorem weightedVSubOfPoint_subtype_eq_filter (w : ι → k) (p : ι → P) (b : P) (pred : ι → Prop)
    [DecidablePred pred] :
    ((s.Subtype pred).weightedVSubOfPoint (fun i => p i) b fun i => w i) =
      (s.filterₓ pred).weightedVSubOfPoint p b w :=
  by rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ← sum_subtype_eq_sum_filter]
#align finset.weighted_vsub_of_point_subtype_eq_filter Finset.weightedVSubOfPoint_subtype_eq_filter

/- warning: finset.weighted_vsub_of_point_filter_of_ne -> Finset.weightedVSubOfPoint_filter_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Ne.{succ u1} k (w i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (pred i)) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p b) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Ne.{succ u3} k (w i) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) -> (pred i)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p b) w) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_filter_of_ne Finset.weightedVSubOfPoint_filter_of_neₓ'. -/
/-- A weighted sum over `s.filter pred` equals one over `s` if all the weights at indices in `s`
not satisfying `pred` are zero. -/
theorem weightedVSubOfPoint_filter_of_ne (w : ι → k) (p : ι → P) (b : P) {pred : ι → Prop}
    [DecidablePred pred] (h : ∀ i ∈ s, w i ≠ 0 → pred i) :
    (s.filterₓ pred).weightedVSubOfPoint p b w = s.weightedVSubOfPoint p b w :=
  by
  rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, sum_filter_of_ne]
  intro i hi hne
  refine' h i hi _
  intro hw
  simpa [hw] using hne
#align finset.weighted_vsub_of_point_filter_of_ne Finset.weightedVSubOfPoint_filter_of_ne

/- warning: finset.weighted_vsub_of_point_const_smul -> Finset.weightedVSubOfPoint_const_smul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (b : P) (c : k), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) (SMul.smul.{u1, max u4 u1} k (ι -> k) (Function.hasSMul.{u4, u1, u1} ι k k (Mul.toSMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1)))) c w)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u2}} (s : Finset.{u2} ι) (w : ι -> k) (p : ι -> P) (b : P) (c : k), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) (HSMul.hSMul.{u3, max u3 u2, max u3 u2} k (ι -> k) (ι -> k) (instHSMul.{u3, max u3 u2} k (ι -> k) (Pi.instSMul.{u2, u3, u3} ι k (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2311 : ι) => k) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MulZeroClass.toSMulWithZero.{u3} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))))))) c w)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u3, u3, max u3 u2, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u4} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u2, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u4, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p b) (HSMul.hSMul.{u3, max u3 u2, max u3 u2} k (ι -> k) (ι -> k) (instHSMul.{u3, max u3 u2} k (ι -> k) (Pi.instSMul.{u2, u3, u3} ι k (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2311 : ι) => k) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MulZeroClass.toSMulWithZero.{u3} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))))))) c w)) (HSMul.hSMul.{u3, u4, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSMul.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SMulZeroClass.toSMul.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (Module.toMulActionWithZero.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) _inst_3))))) c (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u3, u3, max u3 u2, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u4} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u2, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u4, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_of_point_const_smul Finset.weightedVSubOfPoint_const_smulₓ'. -/
/-- A constant multiplier of the weights in `weighted_vsub_of_point` may be moved outside the
sum. -/
theorem weightedVSubOfPoint_const_smul (w : ι → k) (p : ι → P) (b : P) (c : k) :
    s.weightedVSubOfPoint p b (c • w) = c • s.weightedVSubOfPoint p b w := by
  simp_rw [weighted_vsub_of_point_apply, smul_sum, Pi.smul_apply, smul_smul, smul_eq_mul]
#align finset.weighted_vsub_of_point_const_smul Finset.weightedVSubOfPoint_const_smul

#print Finset.weightedVSub /-
/-- A weighted sum of the results of subtracting a default base point
from the given points, as a linear map on the weights.  This is
intended to be used when the sum of the weights is 0; that condition
is specified as a hypothesis on those lemmas that require it. -/
def weightedVSub (p : ι → P) : (ι → k) →ₗ[k] V :=
  s.weightedVSubOfPoint p (Classical.choice S.Nonempty)
#align finset.weighted_vsub Finset.weightedVSub
-/

/- warning: finset.weighted_vsub_apply -> Finset.weightedVSub_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p i) (Classical.choice.{succ u3} P (AddTorsor.nonempty.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p i) (Classical.choice.{succ u1} P (AddTorsor.Nonempty.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S)))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_apply Finset.weightedVSub_applyₓ'. -/
/-- Applying `weighted_vsub` with given weights.  This is for the case
where a result involving a default base point is OK (for example, when
that base point will cancel out later); a more typical use case for
`weighted_vsub` would involve selecting a preferred base point with
`weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero` and then
using `weighted_vsub_of_point_apply`. -/
theorem weightedVSub_apply (w : ι → k) (p : ι → P) :
    s.weightedVSub p w = ∑ i in s, w i • (p i -ᵥ Classical.choice S.Nonempty) := by
  simp [weighted_vsub, LinearMap.sum_apply]
#align finset.weighted_vsub_apply Finset.weightedVSub_apply

/- warning: finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero -> Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (forall (b : P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (forall (b : P), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zeroₓ'. -/
/-- `weighted_vsub` gives the sum of the results of subtracting any
base point, when the sum of the weights is 0. -/
theorem weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero (w : ι → k) (p : ι → P)
    (h : (∑ i in s, w i) = 0) (b : P) : s.weightedVSub p w = s.weightedVSubOfPoint p b w :=
  s.weightedVSubOfPoint_eq_of_sum_eq_zero w p h _ _
#align finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero

/- warning: finset.weighted_vsub_apply_const -> Finset.weightedVSub_apply_const is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p)) w) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))))))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p)) w) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (NegZeroClass.toZero.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_apply_const Finset.weightedVSub_apply_constₓ'. -/
/-- The value of `weighted_vsub`, where the given points are equal and the sum of the weights
is 0. -/
@[simp]
theorem weightedVSub_apply_const (w : ι → k) (p : P) (h : (∑ i in s, w i) = 0) :
    s.weightedVSub (fun _ => p) w = 0 := by
  rw [weighted_vsub, weighted_vsub_of_point_apply_const, h, zero_smul]
#align finset.weighted_vsub_apply_const Finset.weightedVSub_apply_const

/- warning: finset.weighted_vsub_empty -> Finset.weightedVSub_empty is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (EmptyCollection.emptyCollection.{u4} (Finset.{u4} ι) (Finset.hasEmptyc.{u4} ι)) p) w) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (w : ι -> k) (p : ι -> P), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι (EmptyCollection.emptyCollection.{u3} (Finset.{u3} ι) (Finset.instEmptyCollectionFinset.{u3} ι)) p) w) (OfNat.ofNat.{u4} V 0 (Zero.toOfNat0.{u4} V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2)))))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_empty Finset.weightedVSub_emptyₓ'. -/
/-- The `weighted_vsub` for an empty set is 0. -/
@[simp]
theorem weightedVSub_empty (w : ι → k) (p : ι → P) : (∅ : Finset ι).weightedVSub p w = (0 : V) := by
  simp [weighted_vsub_apply]
#align finset.weighted_vsub_empty Finset.weightedVSub_empty

/- warning: finset.weighted_vsub_congr -> Finset.weightedVSub_congr is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u3} P (p₁ i) (p₂ i))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u3} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u2} P (p₁ i) (p₂ i))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u4, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w₁) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u4, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w₂)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_congr Finset.weightedVSub_congrₓ'. -/
/-- `weighted_vsub` gives equal results for two families of weights and two families of points
that are equal on `s`. -/
theorem weightedVSub_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}
    (hp : ∀ i ∈ s, p₁ i = p₂ i) : s.weightedVSub p₁ w₁ = s.weightedVSub p₂ w₂ :=
  s.weightedVSubOfPoint_congr hw hp _
#align finset.weighted_vsub_congr Finset.weightedVSub_congr

/- warning: finset.weighted_vsub_indicator_subset -> Finset.weightedVSub_indicator_subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₁ s₂) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s₁) w)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₁ s₂) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Set.indicator.{u4, u2} ι k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (Finset.toSet.{u4} ι s₁) w)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_indicator_subset Finset.weightedVSub_indicator_subsetₓ'. -/
/-- The weighted sum is unaffected by changing the weights to the
corresponding indicator function and adding points to the set. -/
theorem weightedVSub_indicator_subset (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι} (h : s₁ ⊆ s₂) :
    s₁.weightedVSub p w = s₂.weightedVSub p (Set.indicator (↑s₁) w) :=
  weightedVSubOfPoint_indicator_subset _ _ _ h
#align finset.weighted_vsub_indicator_subset Finset.weightedVSub_indicator_subset

/- warning: finset.weighted_vsub_map -> Finset.weightedVSub_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) w) (coeFn.{max (succ (max u5 u1)) (succ u2), max (succ (max u5 u1)) (succ u2)} (LinearMap.{u1, u1, max u5 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u5 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι₂ -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u5 u1, u2} k k (ι₂ -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u5, u1} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u5, u1, u1} ι₂ k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e))) (Function.comp.{succ u5, succ u4, succ u1} ι₂ ι k w (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) w) (FunLike.coe.{max (max (succ u3) (succ u5)) (succ u2), max (succ u5) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u5, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι₂ -> k) V (Pi.addCommMonoid.{u5, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u5, u2, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι₂ -> k) (fun (_x : ι₂ -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι₂ -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u5 u2, u3} k k (ι₂ -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u5, u2} ι₂ (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u5, u2, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u1} ι₂ ι P p (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e))) (Function.comp.{succ u5, succ u4, succ u2} ι₂ ι k w (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_map Finset.weightedVSub_mapₓ'. -/
/-- A weighted subtraction, over the image of an embedding, equals a
weighted subtraction with the same points and weights over the
original `finset`. -/
theorem weightedVSub_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) :
    (s₂.map e).weightedVSub p w = s₂.weightedVSub (p ∘ e) (w ∘ e) :=
  s₂.weightedVSubOfPoint_map _ _ _ _
#align finset.weighted_vsub_map Finset.weightedVSub_map

/- warning: finset.sum_smul_vsub_eq_weighted_vsub_sub -> Finset.sum_smul_vsub_eq_weightedVSub_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P), Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) (p₂ i)))) (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P), Eq.{succ u4} V (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p₁ i) (p₂ i)))) (HSub.hSub.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toSub.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_eq_weighted_vsub_sub Finset.sum_smul_vsub_eq_weightedVSub_subₓ'. -/
/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two `weighted_vsub`
expressions. -/
theorem sum_smul_vsub_eq_weightedVSub_sub (w : ι → k) (p₁ p₂ : ι → P) :
    (∑ i in s, w i • (p₁ i -ᵥ p₂ i)) = s.weightedVSub p₁ w - s.weightedVSub p₂ w :=
  s.sum_smul_vsub_eq_weightedVSubOfPoint_sub _ _ _ _
#align finset.sum_smul_vsub_eq_weighted_vsub_sub Finset.sum_smul_vsub_eq_weightedVSub_sub

/- warning: finset.sum_smul_vsub_const_eq_weighted_vsub -> Finset.sum_smul_vsub_const_eq_weightedVSub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) p₂))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u4, u2, u2} k V V (instHSMul.{u4, u2} k V (SMulZeroClass.toSMul.{u4, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u4, u2} k V (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u4, u2} k V (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) p₂))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_const_eq_weighted_vsub Finset.sum_smul_vsub_const_eq_weightedVSubₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the right is constant and the
sum of the weights is 0. -/
theorem sum_smul_vsub_const_eq_weightedVSub (w : ι → k) (p₁ : ι → P) (p₂ : P)
    (h : (∑ i in s, w i) = 0) : (∑ i in s, w i • (p₁ i -ᵥ p₂)) = s.weightedVSub p₁ w := by
  rw [sum_smul_vsub_eq_weighted_vsub_sub, s.weighted_vsub_apply_const _ _ h, sub_zero]
#align finset.sum_smul_vsub_const_eq_weighted_vsub Finset.sum_smul_vsub_const_eq_weightedVSub

/- warning: finset.sum_smul_const_vsub_eq_neg_weighted_vsub -> Finset.sum_smul_const_vsub_eq_neg_weightedVSub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (p₂ i)))) (Neg.neg.{u2} V (SubNegMonoid.toHasNeg.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w)))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 0 (Zero.toOfNat0.{u4} k (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u4, u2, u2} k V V (instHSMul.{u4, u2} k V (SMulZeroClass.toSMul.{u4, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u4, u2} k V (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u4, u2} k V (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (p₂ i)))) (Neg.neg.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (NegZeroClass.toNeg.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u2} (LinearMap.{u4, u4, max u4 u3, u2} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u2} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSub.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w)))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_const_vsub_eq_neg_weighted_vsub Finset.sum_smul_const_vsub_eq_neg_weightedVSubₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the left is constant and the
sum of the weights is 0. -/
theorem sum_smul_const_vsub_eq_neg_weightedVSub (w : ι → k) (p₂ : ι → P) (p₁ : P)
    (h : (∑ i in s, w i) = 0) : (∑ i in s, w i • (p₁ -ᵥ p₂ i)) = -s.weightedVSub p₂ w := by
  rw [sum_smul_vsub_eq_weighted_vsub_sub, s.weighted_vsub_apply_const _ _ h, zero_sub]
#align finset.sum_smul_const_vsub_eq_neg_weighted_vsub Finset.sum_smul_const_vsub_eq_neg_weightedVSub

/- warning: finset.weighted_vsub_sdiff -> Finset.weightedVSub_sdiff is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (HAdd.hAdd.{u2, u2, u2} V V V (instHAdd.{u2} V (AddZeroClass.toHasAdd.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.hasSdiff.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) w)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (HAdd.hAdd.{u3, u3, u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHAdd.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddZeroClass.toAdd.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddMonoid.toAddZeroClass.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.instSDiffFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) w)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_sdiff Finset.weightedVSub_sdiffₓ'. -/
/-- A weighted sum may be split into such sums over two subsets. -/
theorem weightedVSub_sdiff [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k) (p : ι → P) :
    (s \ s₂).weightedVSub p w + s₂.weightedVSub p w = s.weightedVSub p w :=
  s.weightedVSubOfPoint_sdiff h _ _ _
#align finset.weighted_vsub_sdiff Finset.weightedVSub_sdiff

/- warning: finset.weighted_vsub_sdiff_sub -> Finset.weightedVSub_sdiff_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (HSub.hSub.{u2, u2, u2} V V V (instHSub.{u2} V (SubNegMonoid.toHasSub.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.hasSdiff.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Neg.neg.{max u4 u1} (ι -> k) (Pi.instNeg.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => SubNegMonoid.toHasNeg.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) w))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (HSub.hSub.{u3, u3, u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) (Neg.neg.{max u2 u4} (ι -> k) (Pi.instNeg.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3314 : ι) => k) (fun (i : ι) => Ring.toNeg.{u2} k _inst_1)) w)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSub.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegMonoid.toSub.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2)))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.instSDiffFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Neg.neg.{max u2 u4} (ι -> k) (Pi.instNeg.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Ring.toNeg.{u2} k _inst_1)) w))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_sdiff_sub Finset.weightedVSub_sdiff_subₓ'. -/
/-- A weighted sum may be split into a subtraction of such sums over two subsets. -/
theorem weightedVSub_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)
    (p : ι → P) : (s \ s₂).weightedVSub p w - s₂.weightedVSub p (-w) = s.weightedVSub p w :=
  s.weightedVSubOfPoint_sdiff_sub h _ _ _
#align finset.weighted_vsub_sdiff_sub Finset.weightedVSub_sdiff_sub

/- warning: finset.weighted_vsub_subtype_eq_filter -> Finset.weightedVSub_subtype_eq_filter is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => ((Subtype.{succ u4} ι pred) -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k ((Subtype.{succ u4} ι pred) -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i))) (fun (i : Subtype.{succ u4} ι pred) => w ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Subtype.{succ u4} ι pred) -> k) => V) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) ((Subtype.{succ u4} ι pred) -> k) V (Pi.addCommMonoid.{u4, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) ((Subtype.{succ u4} ι pred) -> k) (fun (_x : (Subtype.{succ u4} ι pred) -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Subtype.{succ u4} ι pred) -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k ((Subtype.{succ u4} ι pred) -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} (Subtype.{succ u4} ι pred) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p (Subtype.val.{succ u4} ι pred i))) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w)
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_subtype_eq_filter Finset.weightedVSub_subtype_eq_filterₓ'. -/
/-- A weighted sum over `s.subtype pred` equals one over `s.filter pred`. -/
theorem weightedVSub_subtype_eq_filter (w : ι → k) (p : ι → P) (pred : ι → Prop)
    [DecidablePred pred] :
    ((s.Subtype pred).weightedVSub (fun i => p i) fun i => w i) =
      (s.filterₓ pred).weightedVSub p w :=
  s.weightedVSubOfPoint_subtype_eq_filter _ _ _ _
#align finset.weighted_vsub_subtype_eq_filter Finset.weightedVSub_subtype_eq_filter

/- warning: finset.weighted_vsub_filter_of_ne -> Finset.weightedVSub_filter_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Ne.{succ u1} k (w i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (pred i)) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Ne.{succ u3} k (w i) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) -> (pred i)) -> (Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_filter_of_ne Finset.weightedVSub_filter_of_neₓ'. -/
/-- A weighted sum over `s.filter pred` equals one over `s` if all the weights at indices in `s`
not satisfying `pred` are zero. -/
theorem weightedVSub_filter_of_ne (w : ι → k) (p : ι → P) {pred : ι → Prop} [DecidablePred pred]
    (h : ∀ i ∈ s, w i ≠ 0 → pred i) : (s.filterₓ pred).weightedVSub p w = s.weightedVSub p w :=
  s.weightedVSubOfPoint_filter_of_ne _ _ _ h
#align finset.weighted_vsub_filter_of_ne Finset.weightedVSub_filter_of_ne

/- warning: finset.weighted_vsub_const_smul -> Finset.weightedVSub_const_smul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (c : k), Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (SMul.smul.{u1, max u4 u1} k (ι -> k) (Function.hasSMul.{u4, u1, u1} ι k k (Mul.toSMul.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1)))) c w)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u2}} (s : Finset.{u2} ι) (w : ι -> k) (p : ι -> P) (c : k), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) (HSMul.hSMul.{u3, max u3 u2, max u3 u2} k (ι -> k) (ι -> k) (instHSMul.{u3, max u3 u2} k (ι -> k) (Pi.instSMul.{u2, u3, u3} ι k (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3534 : ι) => k) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MulZeroClass.toSMulWithZero.{u3} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))))))) c w)) (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u3, u3, max u3 u2, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u4} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u2, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u4, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) (HSMul.hSMul.{u3, max u3 u2, max u3 u2} k (ι -> k) (ι -> k) (instHSMul.{u3, max u3 u2} k (ι -> k) (Pi.instSMul.{u2, u3, u3} ι k (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3534 : ι) => k) (fun (i : ι) => SMulZeroClass.toSMul.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} k k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (MulZeroClass.toSMulWithZero.{u3} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))))))) c w)) (HSMul.hSMul.{u3, u4, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (instHSMul.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SMulZeroClass.toSMul.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (NegZeroClass.toZero.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubNegZeroMonoid.toNegZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionMonoid.toSubNegZeroMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (SubtractionCommMonoid.toSubtractionMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toDivisionAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))))) (Module.toMulActionWithZero.{u3, u4} k ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) _inst_3))))) c (FunLike.coe.{max (max (succ u4) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u4} (LinearMap.{u3, u3, max u3 u2, u4} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u4} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u2, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u4, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_const_smul Finset.weightedVSub_const_smulₓ'. -/
/-- A constant multiplier of the weights in `weighted_vsub_of` may be moved outside the sum. -/
theorem weightedVSub_const_smul (w : ι → k) (p : ι → P) (c : k) :
    s.weightedVSub p (c • w) = c • s.weightedVSub p w :=
  s.weightedVSubOfPoint_const_smul _ _ _ _
#align finset.weighted_vsub_const_smul Finset.weightedVSub_const_smul

variable (k)

/- warning: finset.affine_combination -> Finset.affineCombination is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}}, (Finset.{u4} ι) -> (ι -> P) -> (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S)
but is expected to have type
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}}, (Finset.{u4} ι) -> (ι -> P) -> (AffineMap.{u1, max u1 u4, max u1 u4, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u4} k _inst_1 ι) _inst_2 _inst_3 S)
Case conversion may be inaccurate. Consider using '#align finset.affine_combination Finset.affineCombinationₓ'. -/
/-- A weighted sum of the results of subtracting a default base point
from the given points, added to that base point, as an affine map on
the weights.  This is intended to be used when the sum of the weights
is 1, in which case it is an affine combination (barycenter) of the
points with the given weights; that condition is specified as a
hypothesis on those lemmas that require it. -/
def affineCombination (p : ι → P) : (ι → k) →ᵃ[k] P
    where
  toFun w := s.weightedVSubOfPoint p (Classical.choice S.Nonempty) w +ᵥ Classical.choice S.Nonempty
  linear := s.weightedVSub p
  map_vadd' w₁ w₂ := by simp_rw [vadd_vadd, weighted_vsub, vadd_eq_add, LinearMap.map_add]
#align finset.affine_combination Finset.affineCombination

/- warning: finset.affine_combination_linear -> Finset.affineCombination_linear is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (p : ι -> P), Eq.{max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (AddCommGroup.toAddCommMonoid.{max u4 u1} (ι -> k) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (AffineMap.linear.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p)) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p)
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u4, u3} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u2}} (s : Finset.{u2} ι) (p : ι -> P), Eq.{max (max (succ u4) (succ u3)) (succ u2)} (LinearMap.{u4, u4, max u4 u2, u3} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (Semiring.toNonAssocSemiring.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (ι -> k) V (AddCommGroup.toAddCommMonoid.{max u4 u2} (ι -> k) (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (AffineMap.linear.{u4, max u4 u2, max u4 u2, u3, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u2, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u2} k _inst_1 ι) _inst_2 _inst_3 S (Finset.affineCombination.{u4, u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p)) (Finset.weightedVSub.{u4, u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p)
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_linear Finset.affineCombination_linearₓ'. -/
/-- The linear map corresponding to `affine_combination` is
`weighted_vsub`. -/
@[simp]
theorem affineCombination_linear (p : ι → P) :
    (s.affineCombination k p).linear = s.weightedVSub p :=
  rfl
#align finset.affine_combination_linear Finset.affineCombination_linear

variable {k}

/- warning: finset.affine_combination_apply -> Finset.affineCombination_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p (Classical.choice.{succ u3} P (AddTorsor.nonempty.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S))) w) (Classical.choice.{succ u3} P (AddTorsor.nonempty.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u4}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u4} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u2}} (s : Finset.{u2} ι) (w : ι -> k) (p : ι -> P), Eq.{succ u4} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u3 u2)) (succ u1)) (succ u4), succ (max u3 u2), succ u4} (AffineMap.{u3, max u3 u2, max u3 u2, u1, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u2} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u2, max u3 u2, u1, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u2, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u2} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u4, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (HVAdd.hVAdd.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P P (instHVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddAction.toVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))) (AddTorsor.toAddAction.{u1, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) S))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u2) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u2 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u2, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u2, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u1, u4, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p (Classical.choice.{succ u4} P (AddTorsor.Nonempty.{u1, u4} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) S))) w) (Classical.choice.{succ u4} P (AddTorsor.Nonempty.{u1, u4} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) S)))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_apply Finset.affineCombination_applyₓ'. -/
/-- Applying `affine_combination` with given weights.  This is for the
case where a result involving a default base point is OK (for example,
when that base point will cancel out later); a more typical use case
for `affine_combination` would involve selecting a preferred base
point with
`affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one` and
then using `weighted_vsub_of_point_apply`. -/
theorem affineCombination_apply (w : ι → k) (p : ι → P) :
    s.affineCombination k p w =
      s.weightedVSubOfPoint p (Classical.choice S.Nonempty) w +ᵥ Classical.choice S.Nonempty :=
  rfl
#align finset.affine_combination_apply Finset.affineCombination_apply

/- warning: finset.affine_combination_apply_const -> Finset.affineCombination_apply_const is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p)) w) p)
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u4 u3)) (succ u1)) (succ u2), succ (max u4 u3), succ u2} (AffineMap.{u4, max u4 u3, max u4 u3, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ι s (fun (_x : ι) => p)) w) p)
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_apply_const Finset.affineCombination_apply_constₓ'. -/
/-- The value of `affine_combination`, where the given points are equal. -/
@[simp]
theorem affineCombination_apply_const (w : ι → k) (p : P) (h : (∑ i in s, w i) = 1) :
    s.affineCombination k (fun _ => p) w = p := by
  rw [affine_combination_apply, s.weighted_vsub_of_point_apply_const, h, one_smul, vsub_vadd]
#align finset.affine_combination_apply_const Finset.affineCombination_apply_const

/- warning: finset.affine_combination_congr -> Finset.affineCombination_congr is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u3} P (p₁ i) (p₂ i))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w₂)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w₁ : ι -> k} {w₂ : ι -> k}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u3} k (w₁ i) (w₂ i))) -> (forall {p₁ : ι -> P} {p₂ : ι -> P}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u2} P (p₁ i) (p₂ i))) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₁) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w₁) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w₂)))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_congr Finset.affineCombination_congrₓ'. -/
/-- `affine_combination` gives equal results for two families of weights and two families of
points that are equal on `s`. -/
theorem affineCombination_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}
    (hp : ∀ i ∈ s, p₁ i = p₂ i) : s.affineCombination k p₁ w₁ = s.affineCombination k p₂ w₂ := by
  simp_rw [affine_combination_apply, s.weighted_vsub_of_point_congr hw hp]
#align finset.affine_combination_congr Finset.affineCombination_congr

/- warning: finset.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one -> Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (forall (b : P), Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w) b))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p : ι -> P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (forall (b : P), Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u4 u3)) (succ u1)) (succ u2), succ (max u4 u3), succ u2} (AffineMap.{u4, max u4 u3, max u4 u3, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (HVAdd.hVAdd.{u1, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P P (instHVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddAction.toVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))) (AddTorsor.toAddAction.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) S))) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u4), max (succ u3) (succ u4), succ u1} (LinearMap.{u4, u4, max u4 u3, u1} k k (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, max u3 u4, u1} k k (ι -> k) V (Ring.toSemiring.{u4} k _inst_1) (Ring.toSemiring.{u4} k _inst_1) (Pi.addCommMonoid.{u3, u4} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) _inst_3 (RingHom.id.{u4} k (NonAssocRing.toNonAssocSemiring.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (Finset.weightedVSubOfPoint.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p b) w) b))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_oneₓ'. -/
/-- `affine_combination` gives the sum with any base point, when the
sum of the weights is 1. -/
theorem affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one (w : ι → k) (p : ι → P)
    (h : (∑ i in s, w i) = 1) (b : P) :
    s.affineCombination k p w = s.weightedVSubOfPoint p b w +ᵥ b :=
  s.weightedVSubOfPoint_vadd_eq_of_sum_eq_one w p h _ _
#align finset.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one

/- warning: finset.weighted_vsub_vadd_affine_combination -> Finset.weightedVSub_vadd_affineCombination is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w₁ : ι -> k) (w₂ : ι -> k) (p : ι -> P), Eq.{succ u3} P (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₂)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (HAdd.hAdd.{max u4 u1, max u4 u1, max u4 u1} (ι -> k) (ι -> k) (ι -> k) (instHAdd.{max u4 u1} (ι -> k) (Pi.instAdd.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1)))) w₁ w₂))
but is expected to have type
  forall {k : Type.{u1}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u2}} (s : Finset.{u2} ι) (w₁ : ι -> k) (w₂ : ι -> k) (p : ι -> P), Eq.{succ u4} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) (HVAdd.hVAdd.{u3, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) (instHVAdd.{u3, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) (AddAction.toVAdd.{u3, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) (SubNegMonoid.toAddMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) (AddGroup.toSubNegMonoid.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) _inst_2))) (AddTorsor.toAddAction.{u3, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₂) (AddCommGroup.toAddGroup.{u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w₁) _inst_2) S))) (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u1), max (succ u2) (succ u1), succ u3} (LinearMap.{u1, u1, max u1 u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u2, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u2, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u1, u3} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u2, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u2, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) _inst_3 (RingHom.id.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₁) (FunLike.coe.{max (max (succ (max u1 u2)) (succ u3)) (succ u4), succ (max u1 u2), succ u4} (AffineMap.{u1, max u1 u2, max u1 u2, u3, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u2, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u2} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u1, max u1 u2, max u1 u2, u3, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u2} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₂)) (FunLike.coe.{max (max (succ (max u1 u2)) (succ u3)) (succ u4), succ (max u1 u2), succ u4} (AffineMap.{u1, max u1 u2, max u1 u2, u3, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u2, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u2} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u1, max u1 u2, max u1 u2, u3, u4} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u2, u1} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u2, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u2} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u3, u4, u2} k V P _inst_1 _inst_2 _inst_3 S ι s p) (HAdd.hAdd.{max u1 u2, max u1 u2, max u1 u2} (ι -> k) (ι -> k) (ι -> k) (instHAdd.{max u1 u2} (ι -> k) (Pi.instAdd.{u2, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Distrib.toAdd.{u1} k (NonUnitalNonAssocSemiring.toDistrib.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))) w₁ w₂))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_vadd_affine_combination Finset.weightedVSub_vadd_affineCombinationₓ'. -/
/-- Adding a `weighted_vsub` to an `affine_combination`. -/
theorem weightedVSub_vadd_affineCombination (w₁ w₂ : ι → k) (p : ι → P) :
    s.weightedVSub p w₁ +ᵥ s.affineCombination k p w₂ = s.affineCombination k p (w₁ + w₂) := by
  rw [← vadd_eq_add, AffineMap.map_vadd, affine_combination_linear]
#align finset.weighted_vsub_vadd_affine_combination Finset.weightedVSub_vadd_affineCombination

/- warning: finset.affine_combination_vsub -> Finset.affineCombination_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w₁ : ι -> k) (w₂ : ι -> k) (p : ι -> P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₁) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₂)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (HSub.hSub.{max u4 u1, max u4 u1, max u4 u1} (ι -> k) (ι -> k) (ι -> k) (instHSub.{max u4 u1} (ι -> k) (Pi.instSub.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))) w₁ w₂))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u3} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u1}} (s : Finset.{u1} ι) (w₁ : ι -> k) (w₂ : ι -> k) (p : ι -> P), Eq.{succ u4} V (VSub.vsub.{u4, u3} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₁) (AddTorsor.toVSub.{u4, u3} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w₁) (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (FunLike.coe.{max (max (succ (max u2 u1)) (succ u4)) (succ u3), succ (max u2 u1), succ u3} (AffineMap.{u2, max u2 u1, max u2 u1, u4, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u1, max u2 u1, u4, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u4, u3, u1} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₁) (FunLike.coe.{max (max (succ (max u2 u1)) (succ u4)) (succ u3), succ (max u2 u1), succ u3} (AffineMap.{u2, max u2 u1, max u2 u1, u4, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u1, max u2 u1, u4, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u4, u3, u1} k V P _inst_1 _inst_2 _inst_3 S ι s p) w₂)) (FunLike.coe.{max (max (succ u4) (succ u1)) (succ u2), max (succ u1) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u1, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u3, u1} k V P _inst_1 _inst_2 _inst_3 S ι s p) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (ι -> k) (ι -> k) (ι -> k) (instHSub.{max u2 u1} (ι -> k) (Pi.instSub.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Ring.toSub.{u2} k _inst_1))) w₁ w₂))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_vsub Finset.affineCombination_vsubₓ'. -/
/-- Subtracting two `affine_combination`s. -/
theorem affineCombination_vsub (w₁ w₂ : ι → k) (p : ι → P) :
    s.affineCombination k p w₁ -ᵥ s.affineCombination k p w₂ = s.weightedVSub p (w₁ - w₂) := by
  rw [← AffineMap.linearMap_vsub, affine_combination_linear, vsub_eq_sub]
#align finset.affine_combination_vsub Finset.affineCombination_vsub

/- warning: finset.attach_affine_combination_of_injective -> Finset.attach_affineCombination_of_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_4 : DecidableEq.{succ u3} P] (s : Finset.{u3} P) (w : P -> k) (f : (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) -> P), (Function.Injective.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P f) -> (Eq.{succ u3} P (coeFn.{max (succ (max u3 u1)) (succ u2) (succ u3), max (succ (max u3 u1)) (succ u3)} (AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (Finset.attach.{u3} P s) f) (Function.comp.{succ u3, succ u3, succ u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P k w f)) (coeFn.{max (succ (max u3 u1)) (succ u2) (succ u3), max (succ (max u3 u1)) (succ u3)} (AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (P -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 S P (Finset.image.{u3, u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (fun (a : P) (b : P) => _inst_4 a b) f (Finset.univ.{u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) (Finset.Subtype.fintype.{u3} P s))) (id.{succ u3} P)) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] [_inst_4 : DecidableEq.{succ u3} P] (s : Finset.{u3} P) (w : P -> k) (f : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> P), (Function.Injective.{succ u3, succ u3} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P f) -> (Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => P) (Function.comp.{succ u3, succ u3, succ u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P k w f)) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u1)) (succ u3), succ (max u2 u3), succ u3} (AffineMap.{u2, max u2 u3, max u2 u3, u1, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) _inst_2 _inst_3 S) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) (fun (_x : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u1, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (Finset.attach.{u3} P s) f) (Function.comp.{succ u3, succ u3, succ u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P k w f)) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u1)) (succ u3), succ (max u2 u3), succ u3} (AffineMap.{u2, max u2 u3, max u2 u3, u1, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} P (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : P) => k) (fun (i : P) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} P (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : P) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : P) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : P) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 P) _inst_2 _inst_3 S) (P -> k) (fun (_x : P -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u1, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} P (fun (i : P) => k) (fun (i : P) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} P (fun (i : P) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : P) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : P) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 P) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 S P (Finset.image.{u3, u3} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P (fun (a : P) (b : P) => _inst_4 a b) f (Finset.univ.{u3} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (Finset.Subtype.fintype.{u3} P s))) (id.{succ u3} P)) w))
Case conversion may be inaccurate. Consider using '#align finset.attach_affine_combination_of_injective Finset.attach_affineCombination_of_injectiveₓ'. -/
theorem attach_affineCombination_of_injective [DecidableEq P] (s : Finset P) (w : P → k) (f : s → P)
    (hf : Function.Injective f) :
    s.attach.affineCombination k f (w ∘ f) = (image f univ).affineCombination k id w :=
  by
  simp only [affine_combination, weighted_vsub_of_point_apply, id.def, vadd_right_cancel_iff,
    Function.comp_apply, AffineMap.coe_mk]
  let g₁ : s → V := fun i => w (f i) • (f i -ᵥ Classical.choice S.nonempty)
  let g₂ : P → V := fun i => w i • (i -ᵥ Classical.choice S.nonempty)
  change univ.sum g₁ = (image f univ).Sum g₂
  have hgf : g₁ = g₂ ∘ f := by
    ext
    simp
  rw [hgf, sum_image]
  exact fun _ _ _ _ hxy => hf hxy
#align finset.attach_affine_combination_of_injective Finset.attach_affineCombination_of_injective

/- warning: finset.attach_affine_combination_coe -> Finset.attach_affineCombination_coe is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Finset.{u3} P) (w : P -> k), Eq.{succ u3} P (coeFn.{max (succ (max u3 u1)) (succ u2) (succ u3), max (succ (max u3 u1)) (succ u3)} (AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u3 u1, max u3 u1, u2, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) (Finset.attach.{u3} P s) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s))))))) (Function.comp.{succ u3, succ u3, succ u1} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P k w ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P (HasLiftT.mk.{succ u3, succ u3} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P (CoeTCₓ.coe.{succ u3, succ u3} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P (coeBase.{succ u3, succ u3} (Subtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s)))))))) (coeFn.{max (succ (max u3 u1)) (succ u2) (succ u3), max (succ (max u3 u1)) (succ u3)} (AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (P -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u3 u1, max u3 u1, u2, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u1} P (fun (i : P) => k) (fun (i : P) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} P (fun (i : P) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : P) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : P) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} P (fun (i : P) => k) (fun (i : P) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : P) => k) (fun (i : P) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 S P s (id.{succ u3} P)) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Finset.{u3} P) (w : P -> k), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => P) (Function.comp.{succ u3, succ u3, succ u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P k w (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)))) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u1)) (succ u3), succ (max u2 u3), succ u3} (AffineMap.{u2, max u2 u3, max u2 u3, u1, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) _inst_2 _inst_3 S) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) (fun (_x : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u1, u3} k ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) ((Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (Finset.attach.{u3} P s) (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) (Function.comp.{succ u3, succ u3, succ u2} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) P k w (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)))) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u1)) (succ u3), succ (max u2 u3), succ u3} (AffineMap.{u2, max u2 u3, max u2 u3, u1, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} P (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : P) => k) (fun (i : P) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} P (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : P) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : P) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : P) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 P) _inst_2 _inst_3 S) (P -> k) (fun (_x : P -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u1, u3} k (P -> k) (P -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} P (fun (i : P) => k) (fun (i : P) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} P (fun (i : P) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : P) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : P) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 P) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 S P s (id.{succ u3} P)) w)
Case conversion may be inaccurate. Consider using '#align finset.attach_affine_combination_coe Finset.attach_affineCombination_coeₓ'. -/
theorem attach_affineCombination_coe (s : Finset P) (w : P → k) :
    s.attach.affineCombination k (coe : s → P) (w ∘ coe) = s.affineCombination k id w := by
  classical rw [attach_affine_combination_of_injective s w (coe : s → P) Subtype.coe_injective,
      univ_eq_attach, attach_image_coe]
#align finset.attach_affine_combination_coe Finset.attach_affineCombination_coe

omit S

/- warning: finset.weighted_vsub_eq_linear_combination -> Finset.weightedVSub_eq_linear_combination is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) {w : ι -> k} {p : ι -> V}, (Eq.{succ u1} k (Finset.sum.{u1, u3} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s w) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (LinearMap.{u1, u1, max u3 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u3, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u3 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u3, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u3 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u3, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u3, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u2, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) ι s p) w) (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (p i))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) {w : ι -> k} {p : ι -> V}, (Eq.{succ u2} k (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s w) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)))))) -> (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u1) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u1} (LinearMap.{u2, u2, max u2 u3, u1} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u1} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u1, u1, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) ι s p) w) (Finset.sum.{u1, u3} V ι (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (w i) (p i))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_eq_linear_combination Finset.weightedVSub_eq_linear_combinationₓ'. -/
/-- Viewing a module as an affine space modelled on itself, a `weighted_vsub` is just a linear
combination. -/
@[simp]
theorem weightedVSub_eq_linear_combination {ι} (s : Finset ι) {w : ι → k} {p : ι → V}
    (hw : s.Sum w = 0) : s.weightedVSub p w = ∑ i in s, w i • p i := by
  simp [s.weighted_vsub_apply, vsub_eq_sub, smul_sub, ← Finset.sum_smul, hw]
#align finset.weighted_vsub_eq_linear_combination Finset.weightedVSub_eq_linear_combination

/- warning: finset.affine_combination_eq_linear_combination -> Finset.affineCombination_eq_linear_combination is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (p : ι -> V) (w : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u3} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u2} V (coeFn.{max (succ (max u3 u1)) (succ u2), max (succ (max u3 u1)) (succ u2)} (AffineMap.{u1, max u3 u1, max u3 u1, u2, u2} k (ι -> k) (ι -> k) V V _inst_1 (Pi.addCommGroup.{u3, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (fun (_x : AffineMap.{u1, max u3 u1, max u3 u1, u2, u2} k (ι -> k) (ι -> k) V V _inst_1 (Pi.addCommGroup.{u3, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) => (ι -> k) -> V) (AffineMap.hasCoeToFun.{u1, max u3 u1, max u3 u1, u2, u2} k (ι -> k) (ι -> k) V V _inst_1 (Pi.addCommGroup.{u3, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u3, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u3, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (Finset.affineCombination.{u1, u2, u2, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)) ι s p) w) (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (p i))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (p : ι -> V) (w : ι -> k), (Eq.{succ u2} k (Finset.sum.{u2, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) -> (Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => V) w) (FunLike.coe.{max (succ (max u2 u3)) (succ u1), succ (max u2 u3), succ u1} (AffineMap.{u2, max u2 u3, max u2 u3, u1, u1} k (ι -> k) (ι -> k) V V _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => V) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u1, u1} k (ι -> k) (ι -> k) V V _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (Finset.affineCombination.{u2, u1, u1, u3} k V V _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2)) ι s p) w) (Finset.sum.{u1, u3} V ι (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u1, u1} k V V (instHSMul.{u2, u1} k V (SMulZeroClass.toSMul.{u2, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u1} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u1} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (w i) (p i))))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_eq_linear_combination Finset.affineCombination_eq_linear_combinationₓ'. -/
/-- Viewing a module as an affine space modelled on itself, affine combinations are just linear
combinations. -/
@[simp]
theorem affineCombination_eq_linear_combination (s : Finset ι) (p : ι → V) (w : ι → k)
    (hw : (∑ i in s, w i) = 1) : s.affineCombination k p w = ∑ i in s, w i • p i := by
  simp [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw 0]
#align finset.affine_combination_eq_linear_combination Finset.affineCombination_eq_linear_combination

include S

/- warning: finset.affine_combination_of_eq_one_of_eq_zero -> Finset.affineCombination_of_eq_one_of_eq_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {i : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w i) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (forall (i2 : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i2 s) -> (Ne.{succ u4} ι i2 i) -> (Eq.{succ u1} k (w i2) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (p i))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {i : ι}, (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u3} k (w i) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) -> (forall (i2 : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i2 s) -> (Ne.{succ u4} ι i2 i) -> (Eq.{succ u3} k (w i2) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (p i))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_of_eq_one_of_eq_zero Finset.affineCombination_of_eq_one_of_eq_zeroₓ'. -/
/-- An `affine_combination` equals a point if that point is in the set
and has weight 1 and the other points in the set have weight 0. -/
@[simp]
theorem affineCombination_of_eq_one_of_eq_zero (w : ι → k) (p : ι → P) {i : ι} (his : i ∈ s)
    (hwi : w i = 1) (hw0 : ∀ i2 ∈ s, i2 ≠ i → w i2 = 0) : s.affineCombination k p w = p i :=
  by
  have h1 : (∑ i in s, w i) = 1 := hwi ▸ sum_eq_single i hw0 fun h => False.elim (h his)
  rw [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p h1 (p i),
    weighted_vsub_of_point_apply]
  convert zero_vadd V (p i)
  convert sum_eq_zero _
  intro i2 hi2
  by_cases h : i2 = i
  · simp [h]
  · simp [hw0 i2 hi2 h]
#align finset.affine_combination_of_eq_one_of_eq_zero Finset.affineCombination_of_eq_one_of_eq_zero

/- warning: finset.affine_combination_indicator_subset -> Finset.affineCombination_indicator_subset is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₁ s₂) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p) w) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Set.indicator.{u4, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s₁) w)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (w : ι -> k) (p : ι -> P) {s₁ : Finset.{u4} ι} {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₁ s₂) -> (Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₁ p) w) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Set.indicator.{u4, u2} ι k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (Finset.toSet.{u4} ι s₁) w)))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_indicator_subset Finset.affineCombination_indicator_subsetₓ'. -/
/-- An affine combination is unaffected by changing the weights to the
corresponding indicator function and adding points to the set. -/
theorem affineCombination_indicator_subset (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι}
    (h : s₁ ⊆ s₂) : s₁.affineCombination k p w = s₂.affineCombination k p (Set.indicator (↑s₁) w) :=
  by
  rw [affine_combination_apply, affine_combination_apply,
    weighted_vsub_of_point_indicator_subset _ _ _ h]
#align finset.affine_combination_indicator_subset Finset.affineCombination_indicator_subset

/- warning: finset.affine_combination_map -> Finset.affineCombination_map is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P), Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) w) (coeFn.{max (succ (max u5 u1)) (succ u2) (succ u3), max (succ (max u5 u1)) (succ u3)} (AffineMap.{u1, max u5 u1, max u5 u1, u2, u3} k (ι₂ -> k) (ι₂ -> k) V P _inst_1 (Pi.addCommGroup.{u5, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι₂) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u5 u1, max u5 u1, u2, u3} k (ι₂ -> k) (ι₂ -> k) V P _inst_1 (Pi.addCommGroup.{u5, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι₂) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι₂ -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u5 u1, max u5 u1, u2, u3} k (ι₂ -> k) (ι₂ -> k) V P _inst_1 (Pi.addCommGroup.{u5, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι₂) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι₂) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u5, u1, u1} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι₂) => k) (fun (i : ι₂) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e))) (Function.comp.{succ u5, succ u4, succ u1} ι₂ ι k w (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (w : ι -> k) (p : ι -> P), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) w) (FunLike.coe.{max (max (succ (max u2 u5)) (succ u1)) (succ u3), succ (max u2 u5), succ u3} (AffineMap.{u2, max u2 u5, max u2 u5, u1, u3} k (ι₂ -> k) (ι₂ -> k) V P _inst_1 (Pi.addCommGroup.{u5, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι₂) => k) (fun (i : ι₂) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u5, u2, u2} ι₂ (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u5} k _inst_1 ι₂) _inst_2 _inst_3 S) (ι₂ -> k) (fun (_x : ι₂ -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι₂ -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u5, max u2 u5, u1, u3} k (ι₂ -> k) (ι₂ -> k) V P _inst_1 (Pi.addCommGroup.{u5, u2} ι₂ (fun (i : ι₂) => k) (fun (i : ι₂) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u5, u2, u2} ι₂ (fun (i : ι₂) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι₂) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι₂) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u5} k _inst_1 ι₂) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u5} k V P _inst_1 _inst_2 _inst_3 S ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e))) (Function.comp.{succ u5, succ u4, succ u2} ι₂ ι k w (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e)))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_map Finset.affineCombination_mapₓ'. -/
/-- An affine combination, over the image of an embedding, equals an
affine combination with the same points and weights over the original
`finset`. -/
theorem affineCombination_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) :
    (s₂.map e).affineCombination k p w = s₂.affineCombination k (p ∘ e) (w ∘ e) := by
  simp_rw [affine_combination_apply, weighted_vsub_of_point_map]
#align finset.affine_combination_map Finset.affineCombination_map

/- warning: finset.sum_smul_vsub_eq_affine_combination_vsub -> Finset.sum_smul_vsub_eq_affineCombination_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P), Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) (p₂ i)))) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : ι -> P), Eq.{succ u4} V (Finset.sum.{u4, u3} V ι (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u2, u4, u4} k V V (instHSMul.{u2, u4} k V (SMulZeroClass.toSMul.{u2, u4} k V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u4} k V (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u4} k V (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u4, u1} V P (AddTorsor.toVSub.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (p₁ i) (p₂ i)))) (VSub.vsub.{u4, u1} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddTorsor.toVSub.{u4, u1} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddCommGroup.toAddGroup.{u4} V _inst_2) S) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u4)) (succ u1), succ (max u2 u3), succ u1} (AffineMap.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u4)) (succ u1), succ (max u2 u3), succ u1} (AffineMap.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_eq_affine_combination_vsub Finset.sum_smul_vsub_eq_affineCombination_vsubₓ'. -/
/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two `affine_combination`
expressions. -/
theorem sum_smul_vsub_eq_affineCombination_vsub (w : ι → k) (p₁ p₂ : ι → P) :
    (∑ i in s, w i • (p₁ i -ᵥ p₂ i)) = s.affineCombination k p₁ w -ᵥ s.affineCombination k p₂ w :=
  by
  simp_rw [affine_combination_apply, vadd_vsub_vadd_cancel_right]
  exact s.sum_smul_vsub_eq_weighted_vsub_of_point_sub _ _ _ _
#align finset.sum_smul_vsub_eq_affine_combination_vsub Finset.sum_smul_vsub_eq_affineCombination_vsub

/- warning: finset.sum_smul_vsub_const_eq_affine_combination_vsub -> Finset.sum_smul_vsub_const_eq_affineCombination_vsub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) p₂))) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) p₂))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₁ : ι -> P) (p₂ : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u4, u2, u2} k V V (instHSMul.{u4, u2} k V (SMulZeroClass.toSMul.{u4, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u4, u2} k V (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u4, u2} k V (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p₁ i) p₂))) (VSub.vsub.{u2, u1} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddTorsor.toVSub.{u2, u1} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (FunLike.coe.{max (max (succ (max u4 u3)) (succ u2)) (succ u1), succ (max u4 u3), succ u1} (AffineMap.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₁) w) p₂))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_vsub_const_eq_affine_combination_vsub Finset.sum_smul_vsub_const_eq_affineCombination_vsubₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the right is constant and the
sum of the weights is 1. -/
theorem sum_smul_vsub_const_eq_affineCombination_vsub (w : ι → k) (p₁ : ι → P) (p₂ : P)
    (h : (∑ i in s, w i) = 1) : (∑ i in s, w i • (p₁ i -ᵥ p₂)) = s.affineCombination k p₁ w -ᵥ p₂ :=
  by rw [sum_smul_vsub_eq_affine_combination_vsub, affine_combination_apply_const _ _ _ h]
#align finset.sum_smul_vsub_const_eq_affine_combination_vsub Finset.sum_smul_vsub_const_eq_affineCombination_vsub

/- warning: finset.sum_smul_const_vsub_eq_vsub_affine_combination -> Finset.sum_smul_const_vsub_eq_vsub_affineCombination is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u4} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (w i) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (p₂ i)))) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w)))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (w : ι -> k) (p₂ : ι -> P) (p₁ : P), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (Eq.{succ u2} V (Finset.sum.{u2, u3} V ι (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) s (fun (i : ι) => HSMul.hSMul.{u4, u2, u2} k V V (instHSMul.{u4, u2} k V (SMulZeroClass.toSMul.{u4, u2} k V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u4, u2} k V (MonoidWithZero.toZero.{u4} k (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u4, u2} k V (Semiring.toMonoidWithZero.{u4} k (Ring.toSemiring.{u4} k _inst_1)) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (w i) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (p₂ i)))) (VSub.vsub.{u2, u1} V P (AddTorsor.toVSub.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) p₁ (FunLike.coe.{max (max (succ (max u4 u3)) (succ u2)) (succ u1), succ (max u4 u3), succ u1} (AffineMap.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p₂) w)))
Case conversion may be inaccurate. Consider using '#align finset.sum_smul_const_vsub_eq_vsub_affine_combination Finset.sum_smul_const_vsub_eq_vsub_affineCombinationₓ'. -/
/-- A weighted sum of pairwise subtractions, where the point on the left is constant and the
sum of the weights is 1. -/
theorem sum_smul_const_vsub_eq_vsub_affineCombination (w : ι → k) (p₂ : ι → P) (p₁ : P)
    (h : (∑ i in s, w i) = 1) : (∑ i in s, w i • (p₁ -ᵥ p₂ i)) = p₁ -ᵥ s.affineCombination k p₂ w :=
  by rw [sum_smul_vsub_eq_affine_combination_vsub, affine_combination_apply_const _ _ _ h]
#align finset.sum_smul_const_vsub_eq_vsub_affine_combination Finset.sum_smul_const_vsub_eq_vsub_affineCombination

/- warning: finset.affine_combination_sdiff_sub -> Finset.affineCombination_sdiff_sub is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.hasSubset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u2} V (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.hasSdiff.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Neg.neg.{max u4 u1} (ι -> k) (Pi.instNeg.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => SubNegMonoid.toHasNeg.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) w))) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u1}} {V : Type.{u3}} {P : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u1, u3} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u2} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] {s₂ : Finset.{u4} ι}, (HasSubset.Subset.{u4} (Finset.{u4} ι) (Finset.instHasSubsetFinset.{u4} ι) s₂ s) -> (forall (w : ι -> k) (p : ι -> P), Eq.{succ u3} V (VSub.vsub.{u3, u2} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddTorsor.toVSub.{u3, u2} V ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AddCommGroup.toAddGroup.{u3} V _inst_2) S) (FunLike.coe.{max (max (succ (max u1 u4)) (succ u3)) (succ u2), succ (max u1 u4), succ u2} (AffineMap.{u1, max u1 u4, max u1 u4, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u4, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u1, max u1 u4, max u1 u4, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u3, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι (SDiff.sdiff.{u4} (Finset.{u4} ι) (Finset.instSDiffFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_4 a b)) s s₂) p) w) (FunLike.coe.{max (max (succ (max u1 u4)) (succ u3)) (succ u2), succ (max u1 u4), succ u2} (AffineMap.{u1, max u1 u4, max u1 u4, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u4, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u1, max u1 u4, max u1 u4, u3, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u1} k _inst_1)) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u1, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u3, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s₂ p) (Neg.neg.{max u1 u4} (ι -> k) (Pi.instNeg.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => Ring.toNeg.{u1} k _inst_1)) w))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u4) (succ u1), succ u3} (LinearMap.{u1, u1, max u1 u4, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u4 u1, u3} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u1, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1)) _inst_3 (RingHom.id.{u1} k (NonAssocRing.toNonAssocSemiring.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u3, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_sdiff_sub Finset.affineCombination_sdiff_subₓ'. -/
/-- A weighted sum may be split into a subtraction of affine combinations over two subsets. -/
theorem affineCombination_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)
    (p : ι → P) :
    (s \ s₂).affineCombination k p w -ᵥ s₂.affineCombination k p (-w) = s.weightedVSub p w :=
  by
  simp_rw [affine_combination_apply, vadd_vsub_vadd_cancel_right]
  exact s.weighted_vsub_sdiff_sub h _ _
#align finset.affine_combination_sdiff_sub Finset.affineCombination_sdiff_sub

/- warning: finset.affine_combination_eq_of_weighted_vsub_eq_zero_of_eq_neg_one -> Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {w : ι -> k} {p : ι -> P}, (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (forall {i : ι} [_inst_4 : DecidablePred.{succ u4} ι (fun (_x : ι) => Ne.{succ u4} ι _x i)], (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u1} k (w i) (Neg.neg.{u1} k (SubNegMonoid.toHasNeg.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι (fun (_x : ι) => Ne.{succ u4} ι _x i) (fun (a : ι) => _inst_4 a) s) p) w) (p i)))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u4}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u2, u4} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [S : AddTorsor.{u4, u1} V P (AddCommGroup.toAddGroup.{u4} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) {w : ι -> k} {p : ι -> P}, (Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (FunLike.coe.{max (max (succ u4) (succ u3)) (succ u2), max (succ u3) (succ u2), succ u4} (LinearMap.{u2, u2, max u2 u3, u4} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u3 u2, u4} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u3, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w) (OfNat.ofNat.{u4} V 0 (Zero.toOfNat0.{u4} V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2)))))))) -> (forall {i : ι} [_inst_4 : DecidablePred.{succ u3} ι (fun (_x : ι) => Ne.{succ u3} ι _x i)], (Membership.mem.{u3, u3} ι (Finset.{u3} ι) (Finset.instMembershipFinset.{u3} ι) i s) -> (Eq.{succ u2} k (w i) (Neg.neg.{u2} k (Ring.toNeg.{u2} k _inst_1) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))))) -> (Eq.{succ u1} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u2 u3)) (succ u4)) (succ u1), succ (max u2 u3), succ u1} (AffineMap.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u3, max u2 u3, u4, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u3, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u4, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u3} ι (fun (_x : ι) => Ne.{succ u3} ι _x i) (fun (a : ι) => _inst_4 a) s) p) w) (p i)))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_eq_of_weighted_vsub_eq_zero_of_eq_neg_one Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_oneₓ'. -/
/-- If a weighted sum is zero and one of the weights is `-1`, the corresponding point is
the affine combination of the other points with the given weights. -/
theorem affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one {w : ι → k} {p : ι → P}
    (hw : s.weightedVSub p w = (0 : V)) {i : ι} [DecidablePred (· ≠ i)] (his : i ∈ s)
    (hwi : w i = -1) : (s.filterₓ (· ≠ i)).affineCombination k p w = p i := by
  classical
    rw [← @vsub_eq_zero_iff_eq V, ← hw, ←
      s.affine_combination_sdiff_sub (singleton_subset_iff.2 his), sdiff_singleton_eq_erase, ←
      filter_ne']
    congr
    refine' (affine_combination_of_eq_one_of_eq_zero _ _ _ (mem_singleton_self _) _ _).symm
    · simp [hwi]
    · simp
#align finset.affine_combination_eq_of_weighted_vsub_eq_zero_of_eq_neg_one Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one

/- warning: finset.affine_combination_subtype_eq_filter -> Finset.affineCombination_subtype_eq_filter is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k ((Subtype.{succ u4} ι pred) -> k) ((Subtype.{succ u4} ι pred) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k ((Subtype.{succ u4} ι pred) -> k) ((Subtype.{succ u4} ι pred) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => ((Subtype.{succ u4} ι pred) -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k ((Subtype.{succ u4} ι pred) -> k) ((Subtype.{succ u4} ι pred) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i))) (fun (i : Subtype.{succ u4} ι pred) => w ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Subtype.{succ u4} ι pred) ι (HasLiftT.mk.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (CoeTCₓ.coe.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeBase.{succ u4, succ u4} (Subtype.{succ u4} ι pred) ι (coeSubtype.{succ u4} ι (fun (x : ι) => pred x))))) i))) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w)
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) (pred : ι -> Prop) [_inst_4 : DecidablePred.{succ u4} ι pred], Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u4} ι pred) -> k) => P) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k ((Subtype.{succ u4} ι pred) -> k) ((Subtype.{succ u4} ι pred) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 (Subtype.{succ u4} ι pred)) _inst_2 _inst_3 S) ((Subtype.{succ u4} ι pred) -> k) (fun (_x : (Subtype.{succ u4} ι pred) -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Subtype.{succ u4} ι pred) -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k ((Subtype.{succ u4} ι pred) -> k) ((Subtype.{succ u4} ι pred) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) (fun (i : Subtype.{succ u4} ι pred) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} (Subtype.{succ u4} ι pred) (fun (i : Subtype.{succ u4} ι pred) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : Subtype.{succ u4} ι pred) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : Subtype.{succ u4} ι pred) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 (Subtype.{succ u4} ι pred)) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (Subtype.{succ u4} ι pred) (Finset.subtype.{u4} ι pred (fun (a : ι) => _inst_4 a) s) (fun (i : Subtype.{succ u4} ι pred) => p (Subtype.val.{succ u4} ι pred i))) (fun (i : Subtype.{succ u4} ι pred) => w (Subtype.val.{succ u4} ι pred i))) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w)
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_subtype_eq_filter Finset.affineCombination_subtype_eq_filterₓ'. -/
/-- An affine combination over `s.subtype pred` equals one over `s.filter pred`. -/
theorem affineCombination_subtype_eq_filter (w : ι → k) (p : ι → P) (pred : ι → Prop)
    [DecidablePred pred] :
    ((s.Subtype pred).affineCombination k (fun i => p i) fun i => w i) =
      (s.filterₓ pred).affineCombination k p w :=
  by
  rw [affine_combination_apply, affine_combination_apply, weighted_vsub_of_point_subtype_eq_filter]
#align finset.affine_combination_subtype_eq_filter Finset.affineCombination_subtype_eq_filter

/- warning: finset.affine_combination_filter_of_ne -> Finset.affineCombination_filter_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Ne.{succ u1} k (w i) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (pred i)) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (w : ι -> k) (p : ι -> P) {pred : ι -> Prop} [_inst_4 : DecidablePred.{succ u4} ι pred], (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Ne.{succ u3} k (w i) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) -> (pred i)) -> (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι (Finset.filter.{u4} ι pred (fun (a : ι) => _inst_4 a) s) p) w) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_filter_of_ne Finset.affineCombination_filter_of_neₓ'. -/
/-- An affine combination over `s.filter pred` equals one over `s` if all the weights at indices
in `s` not satisfying `pred` are zero. -/
theorem affineCombination_filter_of_ne (w : ι → k) (p : ι → P) {pred : ι → Prop}
    [DecidablePred pred] (h : ∀ i ∈ s, w i ≠ 0 → pred i) :
    (s.filterₓ pred).affineCombination k p w = s.affineCombination k p w := by
  rw [affine_combination_apply, affine_combination_apply,
    s.weighted_vsub_of_point_filter_of_ne _ _ _ h]
#align finset.affine_combination_filter_of_ne Finset.affineCombination_filter_of_ne

variable {V}

/- warning: finset.eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype -> Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {v : V} {x : k} {s : Set.{u4} ι} {p : ι -> P} {b : P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) x) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) x) => Eq.{succ u2} V v (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p b) w)))))) (Exists.{succ u4} (Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) (fun (fs : Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) => Exists.{max (succ u4) (succ u1)} ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) (fun (w : (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) x) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) x) => Eq.{succ u2} V v (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) x s))))) i)) b) w)))))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {v : V} {x : k} {s : Set.{u4} ι} {p : ι -> P} {b : P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) => Exists.{max (succ u3) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) x) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) x) => Eq.{succ u2} V v (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p b) w)))))) (Exists.{succ u4} (Finset.{u4} (Set.Elem.{u4} ι s)) (fun (fs : Finset.{u4} (Set.Elem.{u4} ι s)) => Exists.{max (succ u3) (succ u4)} ((Set.Elem.{u4} ι s) -> k) (fun (w : (Set.Elem.{u4} ι s) -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) x) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) x) => Eq.{succ u2} V v (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) ((Set.Elem.{u4} ι s) -> k) V (Pi.addCommMonoid.{u4, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) ((Set.Elem.{u4} ι s) -> k) (fun (_x : (Set.Elem.{u4} ι s) -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Set.Elem.{u4} ι s) -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k ((Set.Elem.{u4} ι s) -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} (Set.Elem.{u4} ι s) (fun (ᾰ : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S (Set.Elem.{u4} ι s) fs (fun (i : Set.Elem.{u4} ι s) => p (Subtype.val.{succ u4} ι (fun (x : ι) => Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) x s) i)) b) w)))))
Case conversion may be inaccurate. Consider using '#align finset.eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtypeₓ'. -/
/-- Suppose an indexed family of points is given, along with a subset
of the index type.  A vector can be expressed as
`weighted_vsub_of_point` using a `finset` lying within that subset and
with a given sum of weights if and only if it can be expressed as
`weighted_vsub_of_point` with that sum of weights for the
corresponding indexed family whose index type is the subtype
corresponding to that subset. -/
theorem eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype {v : V} {x : k} {s : Set ι}
    {p : ι → P} {b : P} :
    (∃ (fs : Finset ι)(hfs : ↑fs ⊆ s)(w : ι → k)(hw : (∑ i in fs, w i) = x),
        v = fs.weightedVSubOfPoint p b w) ↔
      ∃ (fs : Finset s)(w : s → k)(hw : (∑ i in fs, w i) = x),
        v = fs.weightedVSubOfPoint (fun i : s => p i) b w :=
  by
  classical
    simp_rw [weighted_vsub_of_point_apply]
    constructor
    · rintro ⟨fs, hfs, w, rfl, rfl⟩
      use fs.subtype s, fun i => w i, sum_subtype_of_mem _ hfs, (sum_subtype_of_mem _ hfs).symm
    · rintro ⟨fs, w, rfl, rfl⟩
      refine'
          ⟨fs.map (Function.Embedding.subtype _), map_subtype_subset _, fun i =>
            if h : i ∈ s then w ⟨i, h⟩ else 0, _, _⟩ <;>
        simp
#align finset.eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype

variable (k)

/- warning: finset.eq_weighted_vsub_subset_iff_eq_weighted_vsub_subtype -> Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtype is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {v : V} {s : Set.{u4} ι} {p : ι -> P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) => Eq.{succ u2} V v (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p) w)))))) (Exists.{succ u4} (Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) (fun (fs : Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) => Exists.{max (succ u4) (succ u1)} ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) (fun (w : (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) => Eq.{succ u2} V v (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) x s))))) i))) w)))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {v : V} {s : Set.{u4} ι} {p : ι -> P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) => Exists.{max (succ u3) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) => Eq.{succ u2} V v (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p) w)))))) (Exists.{succ u4} (Finset.{u4} (Set.Elem.{u4} ι s)) (fun (fs : Finset.{u4} (Set.Elem.{u4} ι s)) => Exists.{max (succ u3) (succ u4)} ((Set.Elem.{u4} ι s) -> k) (fun (w : (Set.Elem.{u4} ι s) -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) => Eq.{succ u2} V v (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) ((Set.Elem.{u4} ι s) -> k) V (Pi.addCommMonoid.{u4, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) ((Set.Elem.{u4} ι s) -> k) (fun (_x : (Set.Elem.{u4} ι s) -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : (Set.Elem.{u4} ι s) -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k ((Set.Elem.{u4} ι s) -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} (Set.Elem.{u4} ι s) (fun (ᾰ : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 S (Set.Elem.{u4} ι s) fs (fun (i : Set.Elem.{u4} ι s) => p (Subtype.val.{succ u4} ι (fun (x : ι) => Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) x s) i))) w)))))
Case conversion may be inaccurate. Consider using '#align finset.eq_weighted_vsub_subset_iff_eq_weighted_vsub_subtype Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtypeₓ'. -/
/-- Suppose an indexed family of points is given, along with a subset
of the index type.  A vector can be expressed as `weighted_vsub` using
a `finset` lying within that subset and with sum of weights 0 if and
only if it can be expressed as `weighted_vsub` with sum of weights 0
for the corresponding indexed family whose index type is the subtype
corresponding to that subset. -/
theorem eq_weightedVSub_subset_iff_eq_weightedVSub_subtype {v : V} {s : Set ι} {p : ι → P} :
    (∃ (fs : Finset ι)(hfs : ↑fs ⊆ s)(w : ι → k)(hw : (∑ i in fs, w i) = 0),
        v = fs.weightedVSub p w) ↔
      ∃ (fs : Finset s)(w : s → k)(hw : (∑ i in fs, w i) = 0),
        v = fs.weightedVSub (fun i : s => p i) w :=
  eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype
#align finset.eq_weighted_vsub_subset_iff_eq_weighted_vsub_subtype Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtype

variable (V)

/- warning: finset.eq_affine_combination_subset_iff_eq_affine_combination_subtype -> Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p0 : P} {s : Set.{u4} ι} {p : ι -> P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.hasSubset.{u4} ι) ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) fs) s) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) => Eq.{succ u3} P p0 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p) w)))))) (Exists.{succ u4} (Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) (fun (fs : Finset.{u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s)) => Exists.{max (succ u4) (succ u1)} ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) (fun (w : (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) => Eq.{succ u3} P p0 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) ((coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => k) (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) fs (fun (i : coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) => p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (HasLiftT.mk.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (CoeTCₓ.coe.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeBase.{succ u4, succ u4} (coeSort.{succ u4, succ (succ u4)} (Set.{u4} ι) Type.{u4} (Set.hasCoeToSort.{u4} ι) s) ι (coeSubtype.{succ u4} ι (fun (x : ι) => Membership.Mem.{u4, u4} ι (Set.{u4} ι) (Set.hasMem.{u4} ι) x s))))) i))) w)))))
but is expected to have type
  forall (k : Type.{u3}) (V : Type.{u1}) {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} {p0 : P} {s : Set.{u4} ι} {p : ι -> P}, Iff (Exists.{succ u4} (Finset.{u4} ι) (fun (fs : Finset.{u4} ι) => Exists.{0} (HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) (fun (hfs : HasSubset.Subset.{u4} (Set.{u4} ι) (Set.instHasSubsetSet.{u4} ι) (Finset.toSet.{u4} ι fs) s) => Exists.{max (succ u3) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) => Eq.{succ u2} P p0 (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S ι fs p) w)))))) (Exists.{succ u4} (Finset.{u4} (Set.Elem.{u4} ι s)) (fun (fs : Finset.{u4} (Set.Elem.{u4} ι s)) => Exists.{max (succ u3) (succ u4)} ((Set.Elem.{u4} ι s) -> k) (fun (w : (Set.Elem.{u4} ι s) -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k (Set.Elem.{u4} ι s) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) fs (fun (i : Set.Elem.{u4} ι s) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) => Eq.{succ u2} P p0 (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k ((Set.Elem.{u4} ι s) -> k) ((Set.Elem.{u4} ι s) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 (Set.Elem.{u4} ι s)) _inst_2 _inst_3 S) ((Set.Elem.{u4} ι s) -> k) (fun (_x : (Set.Elem.{u4} ι s) -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : (Set.Elem.{u4} ι s) -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k ((Set.Elem.{u4} ι s) -> k) ((Set.Elem.{u4} ι s) -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} (Set.Elem.{u4} ι s) (fun (i : Set.Elem.{u4} ι s) => k) (fun (i : Set.Elem.{u4} ι s) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} (Set.Elem.{u4} ι s) (fun (i : Set.Elem.{u4} ι s) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : Set.Elem.{u4} ι s) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : Set.Elem.{u4} ι s) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 (Set.Elem.{u4} ι s)) _inst_2 _inst_3 S) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 S (Set.Elem.{u4} ι s) fs (fun (i : Set.Elem.{u4} ι s) => p (Subtype.val.{succ u4} ι (fun (x : ι) => Membership.mem.{u4, u4} ι (Set.{u4} ι) (Set.instMembershipSet.{u4} ι) x s) i))) w)))))
Case conversion may be inaccurate. Consider using '#align finset.eq_affine_combination_subset_iff_eq_affine_combination_subtype Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtypeₓ'. -/
/-- Suppose an indexed family of points is given, along with a subset
of the index type.  A point can be expressed as an
`affine_combination` using a `finset` lying within that subset and
with sum of weights 1 if and only if it can be expressed an
`affine_combination` with sum of weights 1 for the corresponding
indexed family whose index type is the subtype corresponding to that
subset. -/
theorem eq_affineCombination_subset_iff_eq_affineCombination_subtype {p0 : P} {s : Set ι}
    {p : ι → P} :
    (∃ (fs : Finset ι)(hfs : ↑fs ⊆ s)(w : ι → k)(hw : (∑ i in fs, w i) = 1),
        p0 = fs.affineCombination k p w) ↔
      ∃ (fs : Finset s)(w : s → k)(hw : (∑ i in fs, w i) = 1),
        p0 = fs.affineCombination k (fun i : s => p i) w :=
  by
  simp_rw [affine_combination_apply, eq_vadd_iff_vsub_eq]
  exact eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype
#align finset.eq_affine_combination_subset_iff_eq_affine_combination_subtype Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype

variable {k V}

/- warning: finset.map_affine_combination -> Finset.map_affineCombination is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {V₂ : Type.{u5}} {P₂ : Type.{u6}} [_inst_4 : AddCommGroup.{u5} V₂] [_inst_5 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_4)] [_inst_6 : AddTorsor.{u5, u6} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_4)] (p : ι -> P) (w : ι -> k), (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s w) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (forall (f : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6), Eq.{succ u6} P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) f (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) w)) (coeFn.{max (succ (max u4 u1)) (succ u5) (succ u6), max (succ (max u4 u1)) (succ u6)} (AffineMap.{u1, max u4 u1, max u4 u1, u5, u6} k (ι -> k) (ι -> k) V₂ P₂ _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_4 _inst_5 _inst_6) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u5, u6} k (ι -> k) (ι -> k) V₂ P₂ _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_4 _inst_5 _inst_6) => (ι -> k) -> P₂) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u5, u6} k (ι -> k) (ι -> k) V₂ P₂ _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_4 _inst_5 _inst_6) (Finset.affineCombination.{u1, u5, u6, u4} k V₂ P₂ _inst_1 _inst_4 _inst_5 _inst_6 ι s (Function.comp.{succ u4, succ u3, succ u6} ι P P₂ (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u3) (succ u6)} (AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) (fun (_x : AffineMap.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) => P -> P₂) (AffineMap.hasCoeToFun.{u1, u2, u3, u5, u6} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) f) p)) w))
but is expected to have type
  forall {k : Type.{u4}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u4} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u4, u2} k V (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) {V₂ : Type.{u6}} {P₂ : Type.{u5}} [_inst_4 : AddCommGroup.{u6} V₂] [_inst_5 : Module.{u4, u6} k V₂ (Ring.toSemiring.{u4} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₂ _inst_4)] [_inst_6 : AddTorsor.{u6, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u6} V₂ _inst_4)] (p : ι -> P) (w : ι -> k), (Eq.{succ u4} k (Finset.sum.{u4, u3} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) s w) (OfNat.ofNat.{u4} k 1 (One.toOfNat1.{u4} k (NonAssocRing.toOne.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1))))) -> (forall (f : AffineMap.{u4, u2, u1, u6, u5} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6), Eq.{succ u5} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P) => P₂) (FunLike.coe.{max (max (succ (max u4 u3)) (succ u2)) (succ u1), succ (max u4 u3), succ u1} (AffineMap.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (a : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) a) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w)) (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u6)) (succ u5), succ u1, succ u5} (AffineMap.{u4, u2, u1, u6, u5} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P) => P₂) _x) (AffineMap.funLike.{u4, u2, u1, u6, u5} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) f (FunLike.coe.{max (max (succ (max u4 u3)) (succ u2)) (succ u1), succ (max u4 u3), succ u1} (AffineMap.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u2, u1} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u4, u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S ι s p) w)) (FunLike.coe.{max (max (succ (max u4 u3)) (succ u6)) (succ u5), succ (max u4 u3), succ u5} (AffineMap.{u4, max u4 u3, max u4 u3, u6, u5} k (ι -> k) (ι -> k) V₂ P₂ _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_4 _inst_5 _inst_6) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P₂) _x) (AffineMap.funLike.{u4, max u4 u3, max u4 u3, u6, u5} k (ι -> k) (ι -> k) V₂ P₂ _inst_1 (Pi.addCommGroup.{u3, u4} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u4} k _inst_1)) (Pi.module.{u3, u4, u4} ι (fun (i : ι) => k) k (Ring.toSemiring.{u4} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u4} k (NonAssocRing.toNonUnitalNonAssocRing.{u4} k (Ring.toNonAssocRing.{u4} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u4} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u4, u3} k _inst_1 ι) _inst_4 _inst_5 _inst_6) (Finset.affineCombination.{u4, u6, u5, u3} k V₂ P₂ _inst_1 _inst_4 _inst_5 _inst_6 ι s (Function.comp.{succ u3, succ u1, succ u5} ι P P₂ (FunLike.coe.{max (max (max (succ u2) (succ u1)) (succ u6)) (succ u5), succ u1, succ u5} (AffineMap.{u4, u2, u1, u6, u5} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P) => P₂) _x) (AffineMap.funLike.{u4, u2, u1, u6, u5} k V P V₂ P₂ _inst_1 _inst_2 _inst_3 S _inst_4 _inst_5 _inst_6) f) p)) w))
Case conversion may be inaccurate. Consider using '#align finset.map_affine_combination Finset.map_affineCombinationₓ'. -/
/-- Affine maps commute with affine combinations. -/
theorem map_affineCombination {V₂ P₂ : Type _} [AddCommGroup V₂] [Module k V₂] [affine_space V₂ P₂]
    (p : ι → P) (w : ι → k) (hw : s.Sum w = 1) (f : P →ᵃ[k] P₂) :
    f (s.affineCombination k p w) = s.affineCombination k (f ∘ p) w :=
  by
  have b := Classical.choice (inferInstance : affine_space V P).Nonempty
  have b₂ := Classical.choice (inferInstance : affine_space V₂ P₂).Nonempty
  rw [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw b,
    s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w (f ∘ p) hw b₂, ←
    s.weighted_vsub_of_point_vadd_eq_of_sum_eq_one w (f ∘ p) hw (f b) b₂]
  simp only [weighted_vsub_of_point_apply, RingHom.id_apply, AffineMap.map_vadd,
    LinearMap.map_smulₛₗ, AffineMap.linearMap_vsub, LinearMap.map_sum]
#align finset.map_affine_combination Finset.map_affineCombination

variable (k)

omit S

#print Finset.affineCombinationSingleWeights /-
/-- Weights for expressing a single point as an affine combination. -/
def affineCombinationSingleWeights [DecidableEq ι] (i : ι) : ι → k :=
  Function.update (Function.const ι 0) i 1
#align finset.affine_combination_single_weights Finset.affineCombinationSingleWeights
-/

/- warning: finset.affine_combination_single_weights_apply_self -> Finset.affineCombinationSingleWeights_apply_self is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{succ u1} k (Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i i) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{succ u1} k (Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i i) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_single_weights_apply_self Finset.affineCombinationSingleWeights_apply_selfₓ'. -/
@[simp]
theorem affineCombinationSingleWeights_apply_self [DecidableEq ι] (i : ι) :
    affineCombinationSingleWeights k i i = 1 := by simp [affine_combination_single_weights]
#align finset.affine_combination_single_weights_apply_self Finset.affineCombinationSingleWeights_apply_self

/- warning: finset.affine_combination_single_weights_apply_of_ne -> Finset.affineCombinationSingleWeights_apply_of_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι j i) -> (Eq.{succ u1} k (Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι j i) -> (Eq.{succ u1} k (Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_single_weights_apply_of_ne Finset.affineCombinationSingleWeights_apply_of_neₓ'. -/
@[simp]
theorem affineCombinationSingleWeights_apply_of_ne [DecidableEq ι] {i j : ι} (h : j ≠ i) :
    affineCombinationSingleWeights k i j = 0 := by simp [affine_combination_single_weights, h]
#align finset.affine_combination_single_weights_apply_of_ne Finset.affineCombinationSingleWeights_apply_of_ne

/- warning: finset.sum_affine_combination_single_weights -> Finset.sum_affineCombinationSingleWeights is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι}, (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (j : ι) => Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι}, (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (j : ι) => Finset.affineCombinationSingleWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finset.sum_affine_combination_single_weights Finset.sum_affineCombinationSingleWeightsₓ'. -/
@[simp]
theorem sum_affineCombinationSingleWeights [DecidableEq ι] {i : ι} (h : i ∈ s) :
    (∑ j in s, affineCombinationSingleWeights k i j) = 1 :=
  by
  rw [← affine_combination_single_weights_apply_self k i]
  exact sum_eq_single_of_mem i h fun j _ hj => affine_combination_single_weights_apply_of_ne k hj
#align finset.sum_affine_combination_single_weights Finset.sum_affineCombinationSingleWeights

#print Finset.weightedVSubVSubWeights /-
/-- Weights for expressing the subtraction of two points as a `weighted_vsub`. -/
def weightedVSubVSubWeights [DecidableEq ι] (i j : ι) : ι → k :=
  affineCombinationSingleWeights k i - affineCombinationSingleWeights k j
#align finset.weighted_vsub_vsub_weights Finset.weightedVSubVSubWeights
-/

/- warning: finset.weighted_vsub_vsub_weights_self -> Finset.weightedVSubVSubWeights_self is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{max (succ u2) (succ u1)} (ι -> k) (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i i) (OfNat.ofNat.{max u2 u1} (ι -> k) 0 (OfNat.mk.{max u2 u1} (ι -> k) 0 (Zero.zero.{max u2 u1} (ι -> k) (Pi.instZero.{u2, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] (i : ι), Eq.{max (succ u1) (succ u2)} (ι -> k) (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i i) (OfNat.ofNat.{max u1 u2} (ι -> k) 0 (Zero.toOfNat0.{max u1 u2} (ι -> k) (Pi.instZero.{u2, u1} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.7166 : ι) => k) (fun (i : ι) => MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_vsub_weights_self Finset.weightedVSubVSubWeights_selfₓ'. -/
@[simp]
theorem weightedVSubVSubWeights_self [DecidableEq ι] (i : ι) : weightedVSubVSubWeights k i i = 0 :=
  by simp [weighted_vsub_vsub_weights]
#align finset.weighted_vsub_vsub_weights_self Finset.weightedVSubVSubWeights_self

/- warning: finset.weighted_vsub_vsub_weights_apply_left -> Finset.weightedVSubVSubWeights_apply_left is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j i) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j i) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_vsub_weights_apply_left Finset.weightedVSubVSubWeights_apply_leftₓ'. -/
@[simp]
theorem weightedVSubVSubWeights_apply_left [DecidableEq ι] {i j : ι} (h : i ≠ j) :
    weightedVSubVSubWeights k i j i = 1 := by simp [weighted_vsub_vsub_weights, h]
#align finset.weighted_vsub_vsub_weights_apply_left Finset.weightedVSubVSubWeights_apply_left

/- warning: finset.weighted_vsub_vsub_weights_apply_right -> Finset.weightedVSubVSubWeights_apply_right is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j j) (Neg.neg.{u1} k (SubNegMonoid.toHasNeg.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j j) (Neg.neg.{u1} k (Ring.toNeg.{u1} k _inst_1) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_vsub_weights_apply_right Finset.weightedVSubVSubWeights_apply_rightₓ'. -/
@[simp]
theorem weightedVSubVSubWeights_apply_right [DecidableEq ι] {i j : ι} (h : i ≠ j) :
    weightedVSubVSubWeights k i j j = -1 := by simp [weighted_vsub_vsub_weights, h.symm]
#align finset.weighted_vsub_vsub_weights_apply_right Finset.weightedVSubVSubWeights_apply_right

/- warning: finset.weighted_vsub_vsub_weights_apply_of_ne -> Finset.weightedVSubVSubWeights_apply_of_ne is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι} {t : ι}, (Ne.{succ u2} ι t i) -> (Ne.{succ u2} ι t j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j t) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι} {t : ι}, (Ne.{succ u2} ι t i) -> (Ne.{succ u2} ι t j) -> (Eq.{succ u1} k (Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j t) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_vsub_weights_apply_of_ne Finset.weightedVSubVSubWeights_apply_of_neₓ'. -/
@[simp]
theorem weightedVSubVSubWeights_apply_of_ne [DecidableEq ι] {i j t : ι} (hi : t ≠ i) (hj : t ≠ j) :
    weightedVSubVSubWeights k i j t = 0 := by simp [weighted_vsub_vsub_weights, hi, hj]
#align finset.weighted_vsub_vsub_weights_apply_of_ne Finset.weightedVSubVSubWeights_apply_of_ne

/- warning: finset.sum_weighted_vsub_vsub_weights -> Finset.sum_weightedVSubVSubWeights is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) j s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (t : ι) => Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j t)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u1}) [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) j s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (t : ι) => Finset.weightedVSubVSubWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j t)) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_weighted_vsub_vsub_weights Finset.sum_weightedVSubVSubWeightsₓ'. -/
@[simp]
theorem sum_weightedVSubVSubWeights [DecidableEq ι] {i j : ι} (hi : i ∈ s) (hj : j ∈ s) :
    (∑ t in s, weightedVSubVSubWeights k i j t) = 0 :=
  by
  simp_rw [weighted_vsub_vsub_weights, Pi.sub_apply, sum_sub_distrib]
  simp [hi, hj]
#align finset.sum_weighted_vsub_vsub_weights Finset.sum_weightedVSubVSubWeights

variable {k}

#print Finset.affineCombinationLineMapWeights /-
/-- Weights for expressing `line_map` as an affine combination. -/
def affineCombinationLineMapWeights [DecidableEq ι] (i j : ι) (c : k) : ι → k :=
  c • weightedVSubVSubWeights k j i + affineCombinationSingleWeights k i
#align finset.affine_combination_line_map_weights Finset.affineCombinationLineMapWeights
-/

#print Finset.affineCombinationLineMapWeights_self /-
@[simp]
theorem affineCombinationLineMapWeights_self [DecidableEq ι] (i : ι) (c : k) :
    affineCombinationLineMapWeights i i c = affineCombinationSingleWeights k i := by
  simp [affine_combination_line_map_weights]
#align finset.affine_combination_line_map_weights_self Finset.affineCombinationLineMapWeights_self
-/

/- warning: finset.affine_combination_line_map_weights_apply_left -> Finset.affineCombinationLineMapWeights_apply_left is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (forall (c : k), Eq.{succ u1} k (Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c i) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (SubNegMonoid.toHasSub.{u1} k (AddGroup.toSubNegMonoid.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))) c))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Ne.{succ u2} ι i j) -> (forall (c : k), Eq.{succ u1} k (Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c i) (HSub.hSub.{u1, u1, u1} k k k (instHSub.{u1} k (Ring.toSub.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) c))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_line_map_weights_apply_left Finset.affineCombinationLineMapWeights_apply_leftₓ'. -/
@[simp]
theorem affineCombinationLineMapWeights_apply_left [DecidableEq ι] {i j : ι} (h : i ≠ j) (c : k) :
    affineCombinationLineMapWeights i j c i = 1 - c := by
  simp [affine_combination_line_map_weights, h.symm, sub_eq_neg_add]
#align finset.affine_combination_line_map_weights_apply_left Finset.affineCombinationLineMapWeights_apply_left

#print Finset.affineCombinationLineMapWeights_apply_right /-
@[simp]
theorem affineCombinationLineMapWeights_apply_right [DecidableEq ι] {i j : ι} (h : i ≠ j) (c : k) :
    affineCombinationLineMapWeights i j c j = c := by
  simp [affine_combination_line_map_weights, h.symm]
#align finset.affine_combination_line_map_weights_apply_right Finset.affineCombinationLineMapWeights_apply_right
-/

/- warning: finset.affine_combination_line_map_weights_apply_of_ne -> Finset.affineCombinationLineMapWeights_apply_of_ne is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι} {t : ι}, (Ne.{succ u2} ι t i) -> (Ne.{succ u2} ι t j) -> (forall (c : k), Eq.{succ u1} k (Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c t) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι} {t : ι}, (Ne.{succ u2} ι t i) -> (Ne.{succ u2} ι t j) -> (forall (c : k), Eq.{succ u1} k (Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c t) (OfNat.ofNat.{u1} k 0 (Zero.toOfNat0.{u1} k (MonoidWithZero.toZero.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_line_map_weights_apply_of_ne Finset.affineCombinationLineMapWeights_apply_of_neₓ'. -/
@[simp]
theorem affineCombinationLineMapWeights_apply_of_ne [DecidableEq ι] {i j t : ι} (hi : t ≠ i)
    (hj : t ≠ j) (c : k) : affineCombinationLineMapWeights i j c t = 0 := by
  simp [affine_combination_line_map_weights, hi, hj]
#align finset.affine_combination_line_map_weights_apply_of_ne Finset.affineCombinationLineMapWeights_apply_of_ne

/- warning: finset.sum_affine_combination_line_map_weights -> Finset.sum_affineCombinationLineMapWeights is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) i s) -> (Membership.Mem.{u2, u2} ι (Finset.{u2} ι) (Finset.hasMem.{u2} ι) j s) -> (forall (c : k), Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (t : ι) => Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c t)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))
but is expected to have type
  forall {k : Type.{u1}} [_inst_1 : Ring.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_4 : DecidableEq.{succ u2} ι] {i : ι} {j : ι}, (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) i s) -> (Membership.mem.{u2, u2} ι (Finset.{u2} ι) (Finset.instMembershipFinset.{u2} ι) j s) -> (forall (c : k), Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (t : ι) => Finset.affineCombinationLineMapWeights.{u1, u2} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c t)) (OfNat.ofNat.{u1} k 1 (One.toOfNat1.{u1} k (NonAssocRing.toOne.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))))
Case conversion may be inaccurate. Consider using '#align finset.sum_affine_combination_line_map_weights Finset.sum_affineCombinationLineMapWeightsₓ'. -/
@[simp]
theorem sum_affineCombinationLineMapWeights [DecidableEq ι] {i j : ι} (hi : i ∈ s) (hj : j ∈ s)
    (c : k) : (∑ t in s, affineCombinationLineMapWeights i j c t) = 1 :=
  by
  simp_rw [affine_combination_line_map_weights, Pi.add_apply, sum_add_distrib]
  simp [hi, hj, ← mul_sum]
#align finset.sum_affine_combination_line_map_weights Finset.sum_affineCombinationLineMapWeights

include S

variable (k)

/- warning: finset.affine_combination_affine_combination_single_weights -> Finset.affineCombination_affineCombinationSingleWeights is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.affineCombinationSingleWeights.{u1, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i)) (p i))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι}, (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) (Finset.affineCombinationSingleWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i)) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.affineCombinationSingleWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i)) (p i))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_affine_combination_single_weights Finset.affineCombination_affineCombinationSingleWeightsₓ'. -/
/-- An affine combination with `affine_combination_single_weights` gives the specified point. -/
@[simp]
theorem affineCombination_affineCombinationSingleWeights [DecidableEq ι] (p : ι → P) {i : ι}
    (hi : i ∈ s) : s.affineCombination k p (affineCombinationSingleWeights k i) = p i :=
  by
  refine' s.affine_combination_of_eq_one_of_eq_zero _ _ hi (by simp) _
  rintro j - hj
  simp [hj]
#align finset.affine_combination_affine_combination_single_weights Finset.affineCombination_affineCombinationSingleWeights

/- warning: finset.weighted_vsub_weighted_vsub_vsub_weights -> Finset.weightedVSub_weightedVSubVSubWeights is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι} {j : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) j s) -> (Eq.{succ u2} V (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.weightedVSubVSubWeights.{u1, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j)) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) S) (p i) (p j)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [S : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι} {j : ι}, (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) j s) -> (Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) (Finset.weightedVSubVSubWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j)) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.weightedVSubVSubWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j)) (VSub.vsub.{u3, u1} V P (AddTorsor.toVSub.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2) S) (p i) (p j)))
Case conversion may be inaccurate. Consider using '#align finset.weighted_vsub_weighted_vsub_vsub_weights Finset.weightedVSub_weightedVSubVSubWeightsₓ'. -/
/-- A weighted subtraction with `weighted_vsub_vsub_weights` gives the result of subtracting the
specified points. -/
@[simp]
theorem weightedVSub_weightedVSubVSubWeights [DecidableEq ι] (p : ι → P) {i j : ι} (hi : i ∈ s)
    (hj : j ∈ s) : s.weightedVSub p (weightedVSubVSubWeights k i j) = p i -ᵥ p j := by
  rw [weighted_vsub_vsub_weights, ← affine_combination_vsub,
    s.affine_combination_affine_combination_single_weights k p hi,
    s.affine_combination_affine_combination_single_weights k p hj]
#align finset.weighted_vsub_weighted_vsub_vsub_weights Finset.weightedVSub_weightedVSubVSubWeights

variable {k}

/- warning: finset.affine_combination_affine_combination_line_map_weights -> Finset.affineCombination_affineCombinationLineMapWeights is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [S : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι} {j : ι}, (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) j s) -> (forall (c : k), Eq.{succ u3} P (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 S) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.affineCombinationLineMapWeights.{u1, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c)) (coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 S) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 S) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 S) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 S (p i) (p j)) c))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [S : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_4 : DecidableEq.{succ u4} ι] (p : ι -> P) {i : ι} {j : ι}, (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) j s) -> (forall (c : k), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) (Finset.affineCombinationLineMapWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c)) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 S) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 S ι s p) (Finset.affineCombinationLineMapWeights.{u2, u4} k _inst_1 ι (fun (a : ι) (b : ι) => _inst_4 a b) i j c)) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u2, succ u3} (AffineMap.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 S) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P) _x) (AffineMap.funLike.{u2, u2, u2, u1, u3} k k k V P _inst_1 (Ring.toAddCommGroup.{u2} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (Ring.toAddGroupWithOne.{u2} k _inst_1))) _inst_2 _inst_3 S) (AffineMap.lineMap.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 S (p i) (p j)) c))
Case conversion may be inaccurate. Consider using '#align finset.affine_combination_affine_combination_line_map_weights Finset.affineCombination_affineCombinationLineMapWeightsₓ'. -/
/-- An affine combination with `affine_combination_line_map_weights` gives the result of
`line_map`. -/
@[simp]
theorem affineCombination_affineCombinationLineMapWeights [DecidableEq ι] (p : ι → P) {i j : ι}
    (hi : i ∈ s) (hj : j ∈ s) (c : k) :
    s.affineCombination k p (affineCombinationLineMapWeights i j c) =
      AffineMap.lineMap (p i) (p j) c :=
  by
  rw [affine_combination_line_map_weights, ← weighted_vsub_vadd_affine_combination,
    weighted_vsub_const_smul, s.affine_combination_affine_combination_single_weights k p hi,
    s.weighted_vsub_weighted_vsub_vsub_weights k p hj hi, AffineMap.lineMap_apply]
#align finset.affine_combination_affine_combination_line_map_weights Finset.affineCombination_affineCombinationLineMapWeights

end Finset

namespace Finset

variable (k : Type _) {V : Type _} {P : Type _} [DivisionRing k] [AddCommGroup V] [Module k V]

variable [affine_space V P] {ι : Type _} (s : Finset ι) {ι₂ : Type _} (s₂ : Finset ι₂)

#print Finset.centroidWeights /-
/-- The weights for the centroid of some points. -/
def centroidWeights : ι → k :=
  Function.const ι (card s : k)⁻¹
#align finset.centroid_weights Finset.centroidWeights
-/

/- warning: finset.centroid_weights_apply -> Finset.centroidWeights_apply is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) (i : ι), Eq.{succ u1} k (Finset.centroidWeights.{u1, u2} k _inst_1 ι s i) (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat k (HasLiftT.mk.{1, succ u1} Nat k (CoeTCₓ.coe.{1, succ u1} Nat k (Nat.castCoe.{u1} k (AddMonoidWithOne.toNatCast.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))) (Finset.card.{u2} ι s)))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) (i : ι), Eq.{succ u2} k (Finset.centroidWeights.{u2, u1} k _inst_1 ι s i) (Inv.inv.{u2} k (DivisionRing.toInv.{u2} k _inst_1) (Nat.cast.{u2} k (NonAssocRing.toNatCast.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Finset.card.{u1} ι s)))
Case conversion may be inaccurate. Consider using '#align finset.centroid_weights_apply Finset.centroidWeights_applyₓ'. -/
/-- `centroid_weights` at any point. -/
@[simp]
theorem centroidWeights_apply (i : ι) : s.centroidWeights k i = (card s : k)⁻¹ :=
  rfl
#align finset.centroid_weights_apply Finset.centroidWeights_apply

/- warning: finset.centroid_weights_eq_const -> Finset.centroidWeights_eq_const is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι), Eq.{max (succ u2) (succ u1)} (ι -> k) (Finset.centroidWeights.{u1, u2} k _inst_1 ι s) (Function.const.{succ u1, succ u2} k ι (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k _inst_1)) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat k (HasLiftT.mk.{1, succ u1} Nat k (CoeTCₓ.coe.{1, succ u1} Nat k (Nat.castCoe.{u1} k (AddMonoidWithOne.toNatCast.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))) (Finset.card.{u2} ι s))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι), Eq.{max (succ u2) (succ u1)} (ι -> k) (Finset.centroidWeights.{u2, u1} k _inst_1 ι s) (Function.const.{succ u2, succ u1} k ι (Inv.inv.{u2} k (DivisionRing.toInv.{u2} k _inst_1) (Nat.cast.{u2} k (NonAssocRing.toNatCast.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Finset.card.{u1} ι s))))
Case conversion may be inaccurate. Consider using '#align finset.centroid_weights_eq_const Finset.centroidWeights_eq_constₓ'. -/
/-- `centroid_weights` equals a constant function. -/
theorem centroidWeights_eq_const : s.centroidWeights k = Function.const ι (card s : k)⁻¹ :=
  rfl
#align finset.centroid_weights_eq_const Finset.centroidWeights_eq_const

variable {k}

/- warning: finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero -> Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι), (Ne.{succ u1} k ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat k (HasLiftT.mk.{1, succ u1} Nat k (CoeTCₓ.coe.{1, succ u1} Nat k (Nat.castCoe.{u1} k (AddMonoidWithOne.toNatCast.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))) (Finset.card.{u2} ι s)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall {k : Type.{u2}} [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι), (Ne.{succ u2} k (Nat.cast.{u2} k (NonAssocRing.toNatCast.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Finset.card.{u1} ι s)) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1))))))) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zeroₓ'. -/
/-- The weights in the centroid sum to 1, if the number of points,
converted to `k`, is not zero. -/
theorem sum_centroidWeights_eq_one_of_cast_card_ne_zero (h : (card s : k) ≠ 0) :
    (∑ i in s, s.centroidWeights k i) = 1 := by simp [h]
#align finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zero

variable (k)

/- warning: finset.sum_centroid_weights_eq_one_of_card_ne_zero -> Finset.sum_centroidWeights_eq_one_of_card_ne_zero is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))], (Ne.{1} Nat (Finset.card.{u2} ι s) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))], (Ne.{1} Nat (Finset.card.{u1} ι s) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_eq_one_of_card_ne_zero Finset.sum_centroidWeights_eq_one_of_card_ne_zeroₓ'. -/
/-- In the characteristic zero case, the weights in the centroid sum
to 1 if the number of points is not zero. -/
theorem sum_centroidWeights_eq_one_of_card_ne_zero [CharZero k] (h : card s ≠ 0) :
    (∑ i in s, s.centroidWeights k i) = 1 := by simp [h]
#align finset.sum_centroid_weights_eq_one_of_card_ne_zero Finset.sum_centroidWeights_eq_one_of_card_ne_zero

/- warning: finset.sum_centroid_weights_eq_one_of_nonempty -> Finset.sum_centroidWeights_eq_one_of_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))], (Finset.Nonempty.{u2} ι s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))], (Finset.Nonempty.{u1} ι s) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_eq_one_of_nonempty Finset.sum_centroidWeights_eq_one_of_nonemptyₓ'. -/
/-- In the characteristic zero case, the weights in the centroid sum
to 1 if the set is nonempty. -/
theorem sum_centroidWeights_eq_one_of_nonempty [CharZero k] (h : s.Nonempty) :
    (∑ i in s, s.centroidWeights k i) = 1 :=
  s.sum_centroidWeights_eq_one_of_card_ne_zero k (ne_of_gt (card_pos.2 h))
#align finset.sum_centroid_weights_eq_one_of_nonempty Finset.sum_centroidWeights_eq_one_of_nonempty

/- warning: finset.sum_centroid_weights_eq_one_of_card_eq_add_one -> Finset.sum_centroidWeights_eq_one_of_card_eq_add_one is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {n : Nat}, (Eq.{1} Nat (Finset.card.{u2} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))] {n : Nat}, (Eq.{1} Nat (Finset.card.{u1} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) s (fun (i : ι) => Finset.centroidWeights.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_eq_one_of_card_eq_add_one Finset.sum_centroidWeights_eq_one_of_card_eq_add_oneₓ'. -/
/-- In the characteristic zero case, the weights in the centroid sum
to 1 if the number of points is `n + 1`. -/
theorem sum_centroidWeights_eq_one_of_card_eq_add_one [CharZero k] {n : ℕ} (h : card s = n + 1) :
    (∑ i in s, s.centroidWeights k i) = 1 :=
  s.sum_centroidWeights_eq_one_of_card_ne_zero k (h.symm ▸ Nat.succ_ne_zero n)
#align finset.sum_centroid_weights_eq_one_of_card_eq_add_one Finset.sum_centroidWeights_eq_one_of_card_eq_add_one

include V

#print Finset.centroid /-
/-- The centroid of some points.  Although defined for any `s`, this
is intended to be used in the case where the number of points,
converted to `k`, is not zero. -/
def centroid (p : ι → P) : P :=
  s.affineCombination k p (s.centroidWeights k)
#align finset.centroid Finset.centroid
-/

/- warning: finset.centroid_def -> Finset.centroid_def is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) (p : ι -> P), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroidWeights.{u1, u4} k _inst_1 ι s))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u1}} (s : Finset.{u1} ι) (p : ι -> P), Eq.{succ u4} P (Finset.centroid.{u3, u2, u4, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (FunLike.coe.{max (max (succ (max u3 u1)) (succ u2)) (succ u4), succ (max u3 u1), succ u4} (AffineMap.{u3, max u3 u1, max u3 u1, u2, u4} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u3} k _inst_1) (Pi.addCommGroup.{u1, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (Pi.module.{u1, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u1} k (DivisionRing.toRing.{u3} k _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u1, max u3 u1, u2, u4} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u3} k _inst_1) (Pi.addCommGroup.{u1, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (Pi.module.{u1, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k (DivisionRing.toRing.{u3} k _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u1} k (DivisionRing.toRing.{u3} k _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u3, u2, u4, u1} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroidWeights.{u3, u1} k _inst_1 ι s))
Case conversion may be inaccurate. Consider using '#align finset.centroid_def Finset.centroid_defₓ'. -/
/-- The definition of the centroid. -/
theorem centroid_def (p : ι → P) : s.centroid k p = s.affineCombination k p (s.centroidWeights k) :=
  rfl
#align finset.centroid_def Finset.centroid_def

/- warning: finset.centroid_univ -> Finset.centroid_univ is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] (s : Finset.{u3} P), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) (Finset.univ.{u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) (Finset.Subtype.fintype.{u3} P s)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Finset.{u3} P) Type.{u3} (Finset.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Finset.{u3} P) (Finset.hasMem.{u3} P) x s))))))) (Finset.centroid.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 P s (id.{succ u3} P))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] (s : Finset.{u3} P), Eq.{succ u3} P (Finset.centroid.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (Finset.univ.{u3} (Subtype.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s)) (Finset.Subtype.fintype.{u3} P s)) (Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Finset.{u3} P) (Finset.instMembershipFinset.{u3} P) x s))) (Finset.centroid.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 P s (id.{succ u3} P))
Case conversion may be inaccurate. Consider using '#align finset.centroid_univ Finset.centroid_univₓ'. -/
theorem centroid_univ (s : Finset P) : univ.centroid k (coe : s → P) = s.centroid k id :=
  by
  rw [centroid, centroid, ← s.attach_affine_combination_coe]
  congr
  ext
  simp
#align finset.centroid_univ Finset.centroid_univ

/- warning: finset.centroid_singleton -> Finset.centroid_singleton is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (p : ι -> P) (i : ι), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Singleton.singleton.{u4, u4} ι (Finset.{u4} ι) (Finset.hasSingleton.{u4} ι) i) p) (p i)
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u2}} {P : Type.{u4}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u1}} (p : ι -> P) (i : ι), Eq.{succ u4} P (Finset.centroid.{u3, u2, u4, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Singleton.singleton.{u1, u1} ι (Finset.{u1} ι) (Finset.instSingletonFinset.{u1} ι) i) p) (p i)
Case conversion may be inaccurate. Consider using '#align finset.centroid_singleton Finset.centroid_singletonₓ'. -/
/-- The centroid of a single point. -/
@[simp]
theorem centroid_singleton (p : ι → P) (i : ι) : ({i} : Finset ι).centroid k p = p i := by
  simp [centroid_def, affine_combination_apply]
#align finset.centroid_singleton Finset.centroid_singleton

/- warning: finset.centroid_pair -> Finset.centroid_pair is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : DecidableEq.{succ u4} ι] [_inst_6 : Invertible.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))] (p : ι -> P) (i₁ : ι) (i₂ : ι), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Insert.insert.{u4, u4} ι (Finset.{u4} ι) (Finset.hasInsert.{u4} ι (fun (a : ι) (b : ι) => _inst_5 a b)) i₁ (Singleton.singleton.{u4, u4} ι (Finset.{u4} ι) (Finset.hasSingleton.{u4} ι) i₂)) p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p i₂) (p i₁))) (p i₁))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_5 : DecidableEq.{succ u4} ι] [_inst_6 : Invertible.{u3} k (NonUnitalNonAssocRing.toMul.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1)))) (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (NonAssocRing.toNatCast.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (p : ι -> P) (i₁ : ι) (i₂ : ι), Eq.{succ u2} P (Finset.centroid.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Insert.insert.{u4, u4} ι (Finset.{u4} ι) (Finset.instInsertFinset.{u4} ι (fun (a : ι) (b : ι) => _inst_5 a b)) i₁ (Singleton.singleton.{u4, u4} ι (Finset.{u4} ι) (Finset.instSingletonFinset.{u4} ι) i₂)) p) (HVAdd.hVAdd.{u1, u2, u2} V P P (instHVAdd.{u1, u2} V P (AddAction.toVAdd.{u1, u2} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u1, u1} k V V (instHSMul.{u3, u1} k V (SMulZeroClass.toSMul.{u3, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u1} k V (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u1} k V (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u3, u1} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (Inv.inv.{u3} k (DivisionRing.toInv.{u3} k _inst_1) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (NonAssocRing.toNatCast.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (VSub.vsub.{u1, u2} V P (AddTorsor.toVSub.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) (p i₂) (p i₁))) (p i₁))
Case conversion may be inaccurate. Consider using '#align finset.centroid_pair Finset.centroid_pairₓ'. -/
/-- The centroid of two points, expressed directly as adding a vector
to a point. -/
theorem centroid_pair [DecidableEq ι] [Invertible (2 : k)] (p : ι → P) (i₁ i₂ : ι) :
    ({i₁, i₂} : Finset ι).centroid k p = (2⁻¹ : k) • (p i₂ -ᵥ p i₁) +ᵥ p i₁ :=
  by
  by_cases h : i₁ = i₂
  · simp [h]
  · have hc : (card ({i₁, i₂} : Finset ι) : k) ≠ 0 :=
      by
      rw [card_insert_of_not_mem (not_mem_singleton.2 h), card_singleton]
      norm_num
      exact nonzero_of_invertible _
    rw [centroid_def,
      affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one _ _ _
        (sum_centroid_weights_eq_one_of_cast_card_ne_zero _ hc) (p i₁)]
    simp [h]
#align finset.centroid_pair Finset.centroid_pair

/- warning: finset.centroid_pair_fin -> Finset.centroid_pair_fin is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Invertible.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))] (p : (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> P), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Finset.univ.{0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))))) p) (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (SMul.smul.{u1, u2} k V (SMulZeroClass.toHasSmul.{u1, u2} k V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} k V (MulZeroClass.toHasZero.{u1} k (MulZeroOneClass.toMulZeroClass.{u1} k (MonoidWithZero.toMulZeroOneClass.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} k V (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Inv.inv.{u1} k (DivInvMonoid.toHasInv.{u1} k (DivisionRing.toDivInvMonoid.{u1} k _inst_1)) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k (DivisionRing.toRing.{u1} k _inst_1))) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))) (VSub.vsub.{u2, u3} V P (AddTorsor.toHasVsub.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4) (p (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (p (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))))) (p (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))))
but is expected to have type
  forall (k : Type.{u3}) {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] [_inst_5 : Invertible.{u3} k (NonUnitalNonAssocRing.toMul.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1)))) (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (NonAssocRing.toNatCast.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (p : (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> P), Eq.{succ u2} P (Finset.centroid.{u3, u1, u2, 0} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Finset.univ.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) p) (HVAdd.hVAdd.{u1, u2, u2} V P P (instHVAdd.{u1, u2} V P (AddAction.toVAdd.{u1, u2} V P (SubNegMonoid.toAddMonoid.{u1} V (AddGroup.toSubNegMonoid.{u1} V (AddCommGroup.toAddGroup.{u1} V _inst_2))) (AddTorsor.toAddAction.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4))) (HSMul.hSMul.{u3, u1, u1} k V V (instHSMul.{u3, u1} k V (SMulZeroClass.toSMul.{u3, u1} k V (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u1} k V (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u1} k V (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1))) (NegZeroClass.toZero.{u1} V (SubNegZeroMonoid.toNegZeroClass.{u1} V (SubtractionMonoid.toSubNegZeroMonoid.{u1} V (SubtractionCommMonoid.toSubtractionMonoid.{u1} V (AddCommGroup.toDivisionAddCommMonoid.{u1} V _inst_2))))) (Module.toMulActionWithZero.{u3, u1} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) _inst_3))))) (Inv.inv.{u3} k (DivisionRing.toInv.{u3} k _inst_1) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (NonAssocRing.toNatCast.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))) (VSub.vsub.{u1, u2} V P (AddTorsor.toVSub.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2) _inst_4) (p (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (p (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))) (p (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))))
Case conversion may be inaccurate. Consider using '#align finset.centroid_pair_fin Finset.centroid_pair_finₓ'. -/
/-- The centroid of two points indexed by `fin 2`, expressed directly
as adding a vector to the first point. -/
theorem centroid_pair_fin [Invertible (2 : k)] (p : Fin 2 → P) :
    univ.centroid k p = (2⁻¹ : k) • (p 1 -ᵥ p 0) +ᵥ p 0 :=
  by
  rw [univ_fin2]
  convert centroid_pair k p 0 1
#align finset.centroid_pair_fin Finset.centroid_pair_fin

/- warning: finset.centroid_map -> Finset.centroid_map is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (p : ι -> P), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) (Finset.centroid.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (coeFn.{max 1 (succ u5) (succ u4), max (succ u5) (succ u4)} (Function.Embedding.{succ u5, succ u4} ι₂ ι) (fun (_x : Function.Embedding.{succ u5, succ u4} ι₂ ι) => ι₂ -> ι) (Function.Embedding.hasCoeToFun.{succ u5, succ u4} ι₂ ι) e)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) (e : Function.Embedding.{succ u5, succ u4} ι₂ ι) (p : ι -> P), Eq.{succ u3} P (Finset.centroid.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.map.{u5, u4} ι₂ ι e s₂) p) (Finset.centroid.{u2, u1, u3, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι₂ s₂ (Function.comp.{succ u5, succ u4, succ u3} ι₂ ι P p (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ (fun (_x : ι₂) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : ι₂) => ι) _x) (EmbeddingLike.toFunLike.{max (succ u4) (succ u5), succ u5, succ u4} (Function.Embedding.{succ u5, succ u4} ι₂ ι) ι₂ ι (Function.instEmbeddingLikeEmbedding.{succ u5, succ u4} ι₂ ι)) e)))
Case conversion may be inaccurate. Consider using '#align finset.centroid_map Finset.centroid_mapₓ'. -/
/-- A centroid, over the image of an embedding, equals a centroid with
the same points and weights over the original `finset`. -/
theorem centroid_map (e : ι₂ ↪ ι) (p : ι → P) : (s₂.map e).centroid k p = s₂.centroid k (p ∘ e) :=
  by simp [centroid_def, affine_combination_map, centroid_weights]
#align finset.centroid_map Finset.centroid_map

omit V

#print Finset.centroidWeightsIndicator /-
/-- `centroid_weights` gives the weights for the centroid as a
constant function, which is suitable when summing over the points
whose centroid is being taken.  This function gives the weights in a
form suitable for summing over a larger set of points, as an indicator
function that is zero outside the set whose centroid is being taken.
In the case of a `fintype`, the sum may be over `univ`. -/
def centroidWeightsIndicator : ι → k :=
  Set.indicator (↑s) (s.centroidWeights k)
#align finset.centroid_weights_indicator Finset.centroidWeightsIndicator
-/

/- warning: finset.centroid_weights_indicator_def -> Finset.centroidWeightsIndicator_def is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι), Eq.{max (succ u2) (succ u1)} (ι -> k) (Finset.centroidWeightsIndicator.{u1, u2} k _inst_1 ι s) (Set.indicator.{u2, u1} ι k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Finset.{u2} ι) (Set.{u2} ι) (HasLiftT.mk.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (CoeTCₓ.coe.{succ u2, succ u2} (Finset.{u2} ι) (Set.{u2} ι) (Finset.Set.hasCoeT.{u2} ι))) s) (Finset.centroidWeights.{u1, u2} k _inst_1 ι s))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι), Eq.{max (succ u2) (succ u1)} (ι -> k) (Finset.centroidWeightsIndicator.{u2, u1} k _inst_1 ι s) (Set.indicator.{u1, u2} ι k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)))) (Finset.toSet.{u1} ι s) (Finset.centroidWeights.{u2, u1} k _inst_1 ι s))
Case conversion may be inaccurate. Consider using '#align finset.centroid_weights_indicator_def Finset.centroidWeightsIndicator_defₓ'. -/
/-- The definition of `centroid_weights_indicator`. -/
theorem centroidWeightsIndicator_def :
    s.centroidWeightsIndicator k = Set.indicator (↑s) (s.centroidWeights k) :=
  rfl
#align finset.centroid_weights_indicator_def Finset.centroidWeightsIndicator_def

#print Finset.sum_centroidWeightsIndicator /-
/-- The sum of the weights for the centroid indexed by a `fintype`. -/
theorem sum_centroidWeightsIndicator [Fintype ι] :
    (∑ i, s.centroidWeightsIndicator k i) = ∑ i in s, s.centroidWeights k i :=
  (Set.sum_indicator_subset _ (subset_univ _)).symm
#align finset.sum_centroid_weights_indicator Finset.sum_centroidWeightsIndicator
-/

/- warning: finset.sum_centroid_weights_indicator_eq_one_of_card_ne_zero -> Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] [_inst_6 : Fintype.{u2} ι], (Ne.{1} Nat (Finset.card.{u2} ι s) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Finset.univ.{u2} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))] [_inst_6 : Fintype.{u1} ι], (Ne.{1} Nat (Finset.card.{u1} ι s) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) (Finset.univ.{u1} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_indicator_eq_one_of_card_ne_zero Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zeroₓ'. -/
/-- In the characteristic zero case, the weights in the centroid
indexed by a `fintype` sum to 1 if the number of points is not
zero. -/
theorem sum_centroidWeightsIndicator_eq_one_of_card_ne_zero [CharZero k] [Fintype ι]
    (h : card s ≠ 0) : (∑ i, s.centroidWeightsIndicator k i) = 1 :=
  by
  rw [sum_centroid_weights_indicator]
  exact s.sum_centroid_weights_eq_one_of_card_ne_zero k h
#align finset.sum_centroid_weights_indicator_eq_one_of_card_ne_zero Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero

/- warning: finset.sum_centroid_weights_indicator_eq_one_of_nonempty -> Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] [_inst_6 : Fintype.{u2} ι], (Finset.Nonempty.{u2} ι s) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Finset.univ.{u2} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))] [_inst_6 : Fintype.{u1} ι], (Finset.Nonempty.{u1} ι s) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) (Finset.univ.{u1} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_indicator_eq_one_of_nonempty Finset.sum_centroidWeightsIndicator_eq_one_of_nonemptyₓ'. -/
/-- In the characteristic zero case, the weights in the centroid
indexed by a `fintype` sum to 1 if the set is nonempty. -/
theorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype ι] (h : s.Nonempty) :
    (∑ i, s.centroidWeightsIndicator k i) = 1 :=
  by
  rw [sum_centroid_weights_indicator]
  exact s.sum_centroid_weights_eq_one_of_nonempty k h
#align finset.sum_centroid_weights_indicator_eq_one_of_nonempty Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty

/- warning: finset.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one -> Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) [_inst_1 : DivisionRing.{u1} k] {ι : Type.{u2}} (s : Finset.{u2} ι) [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] [_inst_6 : Fintype.{u2} ι] {n : Nat}, (Eq.{1} Nat (Finset.card.{u2} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Eq.{succ u1} k (Finset.sum.{u1, u2} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Finset.univ.{u2} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u1, u2} k _inst_1 ι s i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))
but is expected to have type
  forall (k : Type.{u2}) [_inst_1 : DivisionRing.{u2} k] {ι : Type.{u1}} (s : Finset.{u1} ι) [_inst_5 : CharZero.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (Ring.toAddGroupWithOne.{u2} k (DivisionRing.toRing.{u2} k _inst_1)))] [_inst_6 : Fintype.{u1} ι] {n : Nat}, (Eq.{1} Nat (Finset.card.{u1} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) (Finset.univ.{u1} ι _inst_6) (fun (i : ι) => Finset.centroidWeightsIndicator.{u2, u1} k _inst_1 ι s i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))))
Case conversion may be inaccurate. Consider using '#align finset.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_oneₓ'. -/
/-- In the characteristic zero case, the weights in the centroid
indexed by a `fintype` sum to 1 if the number of points is `n + 1`. -/
theorem sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one [CharZero k] [Fintype ι] {n : ℕ}
    (h : card s = n + 1) : (∑ i, s.centroidWeightsIndicator k i) = 1 :=
  by
  rw [sum_centroid_weights_indicator]
  exact s.sum_centroid_weights_eq_one_of_card_eq_add_one k h
#align finset.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one

include V

/- warning: finset.centroid_eq_affine_combination_fintype -> Finset.centroid_eq_affineCombination_fintype is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u1} k _inst_1) (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) (Finset.centroidWeightsIndicator.{u1, u4} k _inst_1 ι s))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) [_inst_5 : Fintype.{u4} ι] (p : ι -> P), Eq.{succ u3} P (Finset.centroid.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u2} k _inst_1) (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k (DivisionRing.toRing.{u2} k _inst_1) ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P (DivisionRing.toRing.{u2} k _inst_1) (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (DivisionRing.toRing.{u2} k _inst_1)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k (DivisionRing.toRing.{u2} k _inst_1))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k (DivisionRing.toRing.{u2} k _inst_1) ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u2, u1, u3, u4} k V P (DivisionRing.toRing.{u2} k _inst_1) _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) (Finset.centroidWeightsIndicator.{u2, u4} k _inst_1 ι s))
Case conversion may be inaccurate. Consider using '#align finset.centroid_eq_affine_combination_fintype Finset.centroid_eq_affineCombination_fintypeₓ'. -/
/-- The centroid as an affine combination over a `fintype`. -/
theorem centroid_eq_affineCombination_fintype [Fintype ι] (p : ι → P) :
    s.centroid k p = univ.affineCombination k p (s.centroidWeightsIndicator k) :=
  affineCombination_indicator_subset _ _ (subset_univ _)
#align finset.centroid_eq_affine_combination_fintype Finset.centroid_eq_affineCombination_fintype

/- warning: finset.centroid_eq_centroid_image_of_inj_on -> Finset.centroid_eq_centroid_image_of_inj_on is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {p : ι -> P}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (forall (j : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) j s) -> (Eq.{succ u3} P (p i) (p j)) -> (Eq.{succ u4} ι i j))) -> (forall {ps : Set.{u3} P} [_inst_5 : Fintype.{u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps)], (Eq.{succ u3} (Set.{u3} P) ps (Set.image.{u4, u3} ι P p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s))) -> (Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroid.{u1, u2, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) (Finset.univ.{u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) _inst_5) (fun (x : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) => (fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) ps) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x ps))))) x))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {p : ι -> P}, (forall (i : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) i s) -> (forall (j : ι), (Membership.mem.{u4, u4} ι (Finset.{u4} ι) (Finset.instMembershipFinset.{u4} ι) j s) -> (Eq.{succ u3} P (p i) (p j)) -> (Eq.{succ u4} ι i j))) -> (forall {ps : Set.{u3} P} [_inst_5 : Fintype.{u3} (Set.Elem.{u3} P ps)], (Eq.{succ u3} (Set.{u3} P) ps (Set.image.{u4, u3} ι P p (Finset.toSet.{u4} ι s))) -> (Eq.{succ u3} P (Finset.centroid.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroid.{u2, u1, u3, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.Elem.{u3} P ps) (Finset.univ.{u3} (Set.Elem.{u3} P ps) _inst_5) (fun (x : Set.Elem.{u3} P ps) => Subtype.val.{succ u3} P (fun (x : P) => Membership.mem.{u3, u3} P (Set.{u3} P) (Set.instMembershipSet.{u3} P) x ps) x))))
Case conversion may be inaccurate. Consider using '#align finset.centroid_eq_centroid_image_of_inj_on Finset.centroid_eq_centroid_image_of_inj_onₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j «expr ∈ » s) -/
/-- An indexed family of points that is injective on the given
`finset` has the same centroid as the image of that `finset`.  This is
stated in terms of a set equal to the image to provide control of
definitional equality for the index type used for the centroid of the
image. -/
theorem centroid_eq_centroid_image_of_inj_on {p : ι → P}
    (hi : ∀ (i) (_ : i ∈ s) (j) (_ : j ∈ s), p i = p j → i = j) {ps : Set P} [Fintype ps]
    (hps : ps = p '' ↑s) : s.centroid k p = (univ : Finset ps).centroid k fun x => x :=
  by
  let f : p '' ↑s → ι := fun x => x.property.some
  have hf : ∀ x, f x ∈ s ∧ p (f x) = x := fun x => x.property.some_spec
  let f' : ps → ι := fun x => f ⟨x, hps ▸ x.property⟩
  have hf' : ∀ x, f' x ∈ s ∧ p (f' x) = x := fun x => hf ⟨x, hps ▸ x.property⟩
  have hf'i : Function.Injective f' := by
    intro x y h
    rw [Subtype.ext_iff, ← (hf' x).2, ← (hf' y).2, h]
  let f'e : ps ↪ ι := ⟨f', hf'i⟩
  have hu : finset.univ.map f'e = s := by
    ext x
    rw [mem_map]
    constructor
    · rintro ⟨i, _, rfl⟩
      exact (hf' i).1
    · intro hx
      use ⟨p x, hps.symm ▸ Set.mem_image_of_mem _ hx⟩, mem_univ _
      refine' hi _ (hf' _).1 _ hx _
      rw [(hf' _).2]
      rfl
  rw [← hu, centroid_map]
  congr with x
  change p (f' x) = ↑x
  rw [(hf' x).2]
#align finset.centroid_eq_centroid_image_of_inj_on Finset.centroid_eq_centroid_image_of_inj_on

/- warning: finset.centroid_eq_of_inj_on_of_image_eq -> Finset.centroid_eq_of_inj_on_of_image_eq is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} (s : Finset.{u4} ι) {ι₂ : Type.{u5}} (s₂ : Finset.{u5} ι₂) {p : ι -> P}, (forall (i : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) i s) -> (forall (j : ι), (Membership.Mem.{u4, u4} ι (Finset.{u4} ι) (Finset.hasMem.{u4} ι) j s) -> (Eq.{succ u3} P (p i) (p j)) -> (Eq.{succ u4} ι i j))) -> (forall {p₂ : ι₂ -> P}, (forall (i : ι₂), (Membership.Mem.{u5, u5} ι₂ (Finset.{u5} ι₂) (Finset.hasMem.{u5} ι₂) i s₂) -> (forall (j : ι₂), (Membership.Mem.{u5, u5} ι₂ (Finset.{u5} ι₂) (Finset.hasMem.{u5} ι₂) j s₂) -> (Eq.{succ u3} P (p₂ i) (p₂ j)) -> (Eq.{succ u5} ι₂ i j))) -> (Eq.{succ u3} (Set.{u3} P) (Set.image.{u4, u3} ι P p ((fun (a : Type.{u4}) (b : Type.{u4}) [self : HasLiftT.{succ u4, succ u4} a b] => self.0) (Finset.{u4} ι) (Set.{u4} ι) (HasLiftT.mk.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (CoeTCₓ.coe.{succ u4, succ u4} (Finset.{u4} ι) (Set.{u4} ι) (Finset.Set.hasCoeT.{u4} ι))) s)) (Set.image.{u5, u3} ι₂ P p₂ ((fun (a : Type.{u5}) (b : Type.{u5}) [self : HasLiftT.{succ u5, succ u5} a b] => self.0) (Finset.{u5} ι₂) (Set.{u5} ι₂) (HasLiftT.mk.{succ u5, succ u5} (Finset.{u5} ι₂) (Set.{u5} ι₂) (CoeTCₓ.coe.{succ u5, succ u5} (Finset.{u5} ι₂) (Set.{u5} ι₂) (Finset.Set.hasCoeT.{u5} ι₂))) s₂))) -> (Eq.{succ u3} P (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroid.{u1, u2, u3, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι₂ s₂ p₂)))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u1}} {P : Type.{u4}} [_inst_1 : DivisionRing.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (DivisionSemiring.toSemiring.{u2} k (DivisionRing.toDivisionSemiring.{u2} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u4} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u5}} (s : Finset.{u5} ι) {ι₂ : Type.{u3}} (s₂ : Finset.{u3} ι₂) {p : ι -> P}, (forall (i : ι), (Membership.mem.{u5, u5} ι (Finset.{u5} ι) (Finset.instMembershipFinset.{u5} ι) i s) -> (forall (j : ι), (Membership.mem.{u5, u5} ι (Finset.{u5} ι) (Finset.instMembershipFinset.{u5} ι) j s) -> (Eq.{succ u4} P (p i) (p j)) -> (Eq.{succ u5} ι i j))) -> (forall {p₂ : ι₂ -> P}, (forall (i : ι₂), (Membership.mem.{u3, u3} ι₂ (Finset.{u3} ι₂) (Finset.instMembershipFinset.{u3} ι₂) i s₂) -> (forall (j : ι₂), (Membership.mem.{u3, u3} ι₂ (Finset.{u3} ι₂) (Finset.instMembershipFinset.{u3} ι₂) j s₂) -> (Eq.{succ u4} P (p₂ i) (p₂ j)) -> (Eq.{succ u3} ι₂ i j))) -> (Eq.{succ u4} (Set.{u4} P) (Set.image.{u5, u4} ι P p (Finset.toSet.{u5} ι s)) (Set.image.{u3, u4} ι₂ P p₂ (Finset.toSet.{u3} ι₂ s₂))) -> (Eq.{succ u4} P (Finset.centroid.{u2, u1, u4, u5} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (Finset.centroid.{u2, u1, u4, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι₂ s₂ p₂)))
Case conversion may be inaccurate. Consider using '#align finset.centroid_eq_of_inj_on_of_image_eq Finset.centroid_eq_of_inj_on_of_image_eqₓ'. -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j «expr ∈ » s) -/
/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i j «expr ∈ » s₂) -/
/-- Two indexed families of points that are injective on the given
`finset`s and with the same points in the image of those `finset`s
have the same centroid. -/
theorem centroid_eq_of_inj_on_of_image_eq {p : ι → P}
    (hi : ∀ (i) (_ : i ∈ s) (j) (_ : j ∈ s), p i = p j → i = j) {p₂ : ι₂ → P}
    (hi₂ : ∀ (i) (_ : i ∈ s₂) (j) (_ : j ∈ s₂), p₂ i = p₂ j → i = j) (he : p '' ↑s = p₂ '' ↑s₂) :
    s.centroid k p = s₂.centroid k p₂ := by
  classical rw [s.centroid_eq_centroid_image_of_inj_on k hi rfl,
      s₂.centroid_eq_centroid_image_of_inj_on k hi₂ he]
#align finset.centroid_eq_of_inj_on_of_image_eq Finset.centroid_eq_of_inj_on_of_image_eq

end Finset

section AffineSpace'

variable {k : Type _} {V : Type _} {P : Type _} [Ring k] [AddCommGroup V] [Module k V]
  [affine_space V P]

variable {ι : Type _}

include V

/- warning: weighted_vsub_mem_vector_span -> weightedVSub_mem_vectorSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {s : Finset.{u4} ι} {w : ι -> k}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) -> (forall (p : ι -> P), Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {s : Finset.{u4} ι} {w : ι -> k}, (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1)))))) -> (forall (p : ι -> P), Membership.mem.{u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u3, u2} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (FunLike.coe.{max (max (succ u2) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u2} (LinearMap.{u3, u3, max u3 u4, u2} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u2} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSub.{u3, u2, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (vectorSpan.{u3, u2, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p)))
Case conversion may be inaccurate. Consider using '#align weighted_vsub_mem_vector_span weightedVSub_mem_vectorSpanₓ'. -/
/-- A `weighted_vsub` with sum of weights 0 is in the `vector_span` of
an indexed family. -/
theorem weightedVSub_mem_vectorSpan {s : Finset ι} {w : ι → k} (h : (∑ i in s, w i) = 0)
    (p : ι → P) : s.weightedVSub p w ∈ vectorSpan k (Set.range p) := by
  classical
    rcases isEmpty_or_nonempty ι with (hι | ⟨⟨i0⟩⟩)
    · skip
      simp [Finset.eq_empty_of_isEmpty s]
    · rw [vectorSpan_range_eq_span_range_vsub_right k p i0, ← Set.image_univ,
        Finsupp.mem_span_image_iff_total,
        Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p h (p i0),
        Finset.weightedVSubOfPoint_apply]
      let w' := Set.indicator (↑s) w
      have hwx : ∀ i, w' i ≠ 0 → i ∈ s := fun i => Set.mem_of_indicator_ne_zero
      use Finsupp.onFinset s w' hwx, Set.subset_univ _
      rw [Finsupp.total_apply, Finsupp.onFinset_sum hwx]
      · apply Finset.sum_congr rfl
        intro i hi
        simp [w', Set.indicator_apply, if_pos hi]
      · exact fun _ => zero_smul k _
#align weighted_vsub_mem_vector_span weightedVSub_mem_vectorSpan

/- warning: affine_combination_mem_affine_span -> affineCombination_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {s : Finset.{u4} ι} {w : ι -> k}, (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) -> (forall (p : ι -> P), Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u3} k] {s : Finset.{u4} ι} {w : ι -> k}, (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) -> (forall (p : ι -> P), Membership.mem.{u2, u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) w) (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w) (affineSpan.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u4} P ι p)))
Case conversion may be inaccurate. Consider using '#align affine_combination_mem_affine_span affineCombination_mem_affineSpanₓ'. -/
/-- An `affine_combination` with sum of weights 1 is in the
`affine_span` of an indexed family, if the underlying ring is
nontrivial. -/
theorem affineCombination_mem_affineSpan [Nontrivial k] {s : Finset ι} {w : ι → k}
    (h : (∑ i in s, w i) = 1) (p : ι → P) :
    s.affineCombination k p w ∈ affineSpan k (Set.range p) := by
  classical
    have hnz : (∑ i in s, w i) ≠ 0 := h.symm ▸ one_ne_zero
    have hn : s.nonempty := Finset.nonempty_of_sum_ne_zero hnz
    cases' hn with i1 hi1
    let w1 : ι → k := Function.update (Function.const ι 0) i1 1
    have hw1 : (∑ i in s, w1 i) = 1 := by
      rw [Finset.sum_update_of_mem hi1, Finset.sum_const_zero, add_zero]
    have hw1s : s.affine_combination k p w1 = p i1 :=
      s.affine_combination_of_eq_one_of_eq_zero w1 p hi1 (Function.update_same _ _ _) fun _ _ hne =>
        Function.update_noteq hne _ _
    have hv : s.affine_combination k p w -ᵥ p i1 ∈ (affineSpan k (Set.range p)).direction :=
      by
      rw [direction_affineSpan, ← hw1s, Finset.affineCombination_vsub]
      apply weightedVSub_mem_vectorSpan
      simp [Pi.sub_apply, h, hw1]
    rw [← vsub_vadd (s.affine_combination k p w) (p i1)]
    exact AffineSubspace.vadd_mem_of_mem_direction hv (mem_affineSpan k (Set.mem_range_self _))
#align affine_combination_mem_affine_span affineCombination_mem_affineSpan

variable (k) {V}

/- warning: mem_vector_span_iff_eq_weighted_vsub -> mem_vectorSpan_iff_eq_weightedVSub is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {v : V} {p : ι -> P}, Iff (Membership.Mem.{u2, u2} V (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) v (vectorSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) (fun (h : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))))))) => Eq.{succ u2} V v (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSub.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
but is expected to have type
  forall (k : Type.{u2}) {V : Type.{u3}} {P : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V P (AddCommGroup.toAddGroup.{u3} V _inst_2)] {ι : Type.{u4}} {v : V} {p : ι -> P}, Iff (Membership.mem.{u3, u3} V (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) V (Submodule.setLike.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)) v (vectorSpan.{u2, u3, u1} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u1, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u2) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)))))) (fun (h : Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 0 (Zero.toOfNat0.{u2} k (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_1)))))) => Eq.{succ u3} V v (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u2), max (succ u4) (succ u2), succ u3} (LinearMap.{u2, u2, max u2 u4, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u4 u2, u3} k k (ι -> k) V (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (Pi.addCommMonoid.{u4, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.2390 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) _inst_3 (RingHom.id.{u2} k (NonAssocRing.toNonAssocSemiring.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.weightedVSub.{u2, u3, u1, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
Case conversion may be inaccurate. Consider using '#align mem_vector_span_iff_eq_weighted_vsub mem_vectorSpan_iff_eq_weightedVSubₓ'. -/
/-- A vector is in the `vector_span` of an indexed family if and only
if it is a `weighted_vsub` with sum of weights 0. -/
theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : ι → P} :
    v ∈ vectorSpan k (Set.range p) ↔
      ∃ (s : Finset ι)(w : ι → k)(h : (∑ i in s, w i) = 0), v = s.weightedVSub p w :=
  by
  classical
    constructor
    · rcases isEmpty_or_nonempty ι with (hι | ⟨⟨i0⟩⟩)
      swap
      · rw [vectorSpan_range_eq_span_range_vsub_right k p i0, ← Set.image_univ,
          Finsupp.mem_span_image_iff_total]
        rintro ⟨l, hl, hv⟩
        use insert i0 l.support
        set w :=
          (l : ι → k) - Function.update (Function.const ι 0 : ι → k) i0 (∑ i in l.support, l i) with
          hwdef
        use w
        have hw : (∑ i in insert i0 l.support, w i) = 0 :=
          by
          rw [hwdef]
          simp_rw [Pi.sub_apply, Finset.sum_sub_distrib,
            Finset.sum_update_of_mem (Finset.mem_insert_self _ _), Finset.sum_const_zero,
            Finset.sum_insert_of_eq_zero_if_not_mem Finsupp.not_mem_support_iff.1, add_zero,
            sub_self]
        use hw
        have hz : w i0 • (p i0 -ᵥ p i0 : V) = 0 := (vsub_self (p i0)).symm ▸ smul_zero _
        change (fun i => w i • (p i -ᵥ p i0 : V)) i0 = 0 at hz
        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w p hw (p i0),
          Finset.weightedVSubOfPoint_apply, ← hv, Finsupp.total_apply, Finset.sum_insert_zero hz]
        change (∑ i in l.support, l i • _) = _
        congr with i
        by_cases h : i = i0
        · simp [h]
        · simp [hwdef, h]
      · skip
        rw [Set.range_eq_empty, vectorSpan_empty, Submodule.mem_bot]
        rintro rfl
        use ∅
        simp
    · rintro ⟨s, w, hw, rfl⟩
      exact weightedVSub_mem_vectorSpan hw p
#align mem_vector_span_iff_eq_weighted_vsub mem_vectorSpan_iff_eq_weightedVSub

variable {k}

/- warning: eq_affine_combination_of_mem_affine_span -> eq_affineCombination_of_mem_affineSpan is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {p1 : P} {p : ι -> P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) -> (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) => Eq.{succ u3} P p1 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} {p1 : P} {p : ι -> P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) -> (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u2) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (fun (hw : Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) => Eq.{succ u3} P p1 (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
Case conversion may be inaccurate. Consider using '#align eq_affine_combination_of_mem_affine_span eq_affineCombination_of_mem_affineSpanₓ'. -/
/-- A point in the `affine_span` of an indexed family is an
`affine_combination` with sum of weights 1. See also
`eq_affine_combination_of_mem_affine_span_of_fintype`. -/
theorem eq_affineCombination_of_mem_affineSpan {p1 : P} {p : ι → P}
    (h : p1 ∈ affineSpan k (Set.range p)) :
    ∃ (s : Finset ι)(w : ι → k)(hw : (∑ i in s, w i) = 1), p1 = s.affineCombination k p w := by
  classical
    have hn : (affineSpan k (Set.range p) : Set P).Nonempty := ⟨p1, h⟩
    rw [affineSpan_nonempty, Set.range_nonempty_iff_nonempty] at hn
    cases' hn with i0
    have h0 : p i0 ∈ affineSpan k (Set.range p) := mem_affineSpan k (Set.mem_range_self i0)
    have hd : p1 -ᵥ p i0 ∈ (affineSpan k (Set.range p)).direction :=
      AffineSubspace.vsub_mem_direction h h0
    rw [direction_affineSpan, mem_vectorSpan_iff_eq_weightedVSub] at hd
    rcases hd with ⟨s, w, h, hs⟩
    let s' := insert i0 s
    let w' := Set.indicator (↑s) w
    have h' : (∑ i in s', w' i) = 0 := by
      rw [← h, Set.sum_indicator_subset _ (Finset.subset_insert i0 s)]
    have hs' : s'.weighted_vsub p w' = p1 -ᵥ p i0 :=
      by
      rw [hs]
      exact (Finset.weightedVSub_indicator_subset _ _ (Finset.subset_insert i0 s)).symm
    let w0 : ι → k := Function.update (Function.const ι 0) i0 1
    have hw0 : (∑ i in s', w0 i) = 1 := by
      rw [Finset.sum_update_of_mem (Finset.mem_insert_self _ _), Finset.sum_const_zero, add_zero]
    have hw0s : s'.affine_combination k p w0 = p i0 :=
      s'.affine_combination_of_eq_one_of_eq_zero w0 p (Finset.mem_insert_self _ _)
        (Function.update_same _ _ _) fun _ _ hne => Function.update_noteq hne _ _
    use s', w0 + w'
    constructor
    · simp [Pi.add_apply, Finset.sum_add_distrib, hw0, h']
    · rw [add_comm, ← Finset.weightedVSub_vadd_affineCombination, hw0s, hs', vsub_vadd]
#align eq_affine_combination_of_mem_affine_span eq_affineCombination_of_mem_affineSpan

/- warning: eq_affine_combination_of_mem_affine_span_of_fintype -> eq_affineCombination_of_mem_affineSpan_of_fintype is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] {p1 : P} {p : ι -> P}, (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) -> (Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) => Eq.{succ u3} P p1 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w))))
but is expected to have type
  forall {k : Type.{u2}} {V : Type.{u1}} {P : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u2, u1} k V (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Fintype.{u4} ι] {p1 : P} {p : ι -> P}, (Membership.mem.{u3, u3} P (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u3, u3} (AffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u2, u1, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) -> (Exists.{max (succ u2) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) (fun (hw : Eq.{succ u2} k (Finset.sum.{u2, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (Finset.univ.{u4} ι _inst_5) (fun (i : ι) => w i)) (OfNat.ofNat.{u2} k 1 (One.toOfNat1.{u2} k (NonAssocRing.toOne.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1))))) => Eq.{succ u3} P p1 (FunLike.coe.{max (max (succ (max u2 u4)) (succ u1)) (succ u3), succ (max u2 u4), succ u3} (AffineMap.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u2, max u2 u4, max u2 u4, u1, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k _inst_1)) (Pi.module.{u4, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u2} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u2, u1, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι (Finset.univ.{u4} ι _inst_5) p) w))))
Case conversion may be inaccurate. Consider using '#align eq_affine_combination_of_mem_affine_span_of_fintype eq_affineCombination_of_mem_affineSpan_of_fintypeₓ'. -/
theorem eq_affineCombination_of_mem_affineSpan_of_fintype [Fintype ι] {p1 : P} {p : ι → P}
    (h : p1 ∈ affineSpan k (Set.range p)) :
    ∃ (w : ι → k)(hw : (∑ i, w i) = 1), p1 = Finset.univ.affineCombination k p w := by
  classical
    obtain ⟨s, w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan h
    refine'
      ⟨(s : Set ι).indicator w, _, Finset.affineCombination_indicator_subset w p s.subset_univ⟩
    simp only [Finset.mem_coe, Set.indicator_apply, ← hw]
    rw [Fintype.sum_extend_by_zero s w]
#align eq_affine_combination_of_mem_affine_span_of_fintype eq_affineCombination_of_mem_affineSpan_of_fintype

variable (k V)

/- warning: mem_affine_span_iff_eq_affine_combination -> mem_affineSpan_iff_eq_affineCombination is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] {p1 : P} {p : ι -> P}, Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) (fun (hw : Eq.{succ u1} k (Finset.sum.{u1, u4} k ι (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u1} k 1 (OfNat.mk.{u1} k 1 (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))))))) => Eq.{succ u3} P p1 (coeFn.{max (succ (max u4 u1)) (succ u2) (succ u3), max (succ (max u4 u1)) (succ u3)} (AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) => (ι -> k) -> P) (AffineMap.hasCoeToFun.{u1, max u4 u1, max u4 u1, u2, u3} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u1} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Pi.module.{u4, u1, u1} ι (fun (i : ι) => k) k (Ring.toSemiring.{u1} k _inst_1) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (fun (i : ι) => Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (Pi.addTorsor.{u4, u1, u1} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
but is expected to have type
  forall (k : Type.{u3}) (V : Type.{u1}) {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u3} k] {p1 : P} {p : ι -> P}, Iff (Membership.mem.{u2, u2} P (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) p1 (affineSpan.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u3) (succ u4)} (ι -> k) (fun (w : ι -> k) => Exists.{0} (Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (fun (hw : Eq.{succ u3} k (Finset.sum.{u3, u4} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) s (fun (i : ι) => w i)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (NonAssocRing.toOne.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) => Eq.{succ u2} P p1 (FunLike.coe.{max (max (succ (max u3 u4)) (succ u1)) (succ u2), succ (max u3 u4), succ u2} (AffineMap.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3599 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (ι -> k) (fun (_x : ι -> k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : ι -> k) => P) _x) (AffineMap.funLike.{u3, max u3 u4, max u3 u4, u1, u2} k (ι -> k) (ι -> k) V P _inst_1 (Pi.addCommGroup.{u4, u3} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u3} k _inst_1)) (Pi.module.{u4, u3, u3} ι (fun (i : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u3, u4} k _inst_1 ι) _inst_2 _inst_3 _inst_4) (Finset.affineCombination.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) w)))))
Case conversion may be inaccurate. Consider using '#align mem_affine_span_iff_eq_affine_combination mem_affineSpan_iff_eq_affineCombinationₓ'. -/
/-- A point is in the `affine_span` of an indexed family if and only
if it is an `affine_combination` with sum of weights 1, provided the
underlying ring is nontrivial. -/
theorem mem_affineSpan_iff_eq_affineCombination [Nontrivial k] {p1 : P} {p : ι → P} :
    p1 ∈ affineSpan k (Set.range p) ↔
      ∃ (s : Finset ι)(w : ι → k)(hw : (∑ i in s, w i) = 1), p1 = s.affineCombination k p w :=
  by
  constructor
  · exact eq_affineCombination_of_mem_affineSpan
  · rintro ⟨s, w, hw, rfl⟩
    exact affineCombination_mem_affineSpan hw p
#align mem_affine_span_iff_eq_affine_combination mem_affineSpan_iff_eq_affineCombination

/- warning: mem_affine_span_iff_eq_weighted_vsub_of_point_vadd -> mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (V : Type.{u2}) {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u1} k] (p : ι -> P) (j : ι) (q : P), Iff (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4)) q (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u4) (succ u1)} (ι -> k) (fun (w : ι -> k) => Eq.{succ u3} P q (VAdd.vadd.{u2, u3} V P (AddAction.toHasVadd.{u2, u3} V P (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))) (AddTorsor.toAddAction.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2) _inst_4)) (coeFn.{max (succ (max u4 u1)) (succ u2), max (succ (max u4 u1)) (succ u2)} (LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) (fun (_x : LinearMap.{u1, u1, max u4 u1, u2} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3) => (ι -> k) -> V) (LinearMap.hasCoeToFun.{u1, u1, max u4 u1, u2} k k (ι -> k) V (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (Pi.addCommMonoid.{u4, u1} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u1} ι k k (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} k (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1)))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1))) _inst_3 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1)))) (Finset.weightedVSubOfPoint.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p (p j)) w) (p j)))))
but is expected to have type
  forall (k : Type.{u3}) (V : Type.{u1}) {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} [_inst_5 : Nontrivial.{u3} k] (p : ι -> P) (j : ι) (q : P), Iff (Membership.mem.{u2, u2} P (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4)) q (affineSpan.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u4} P ι p))) (Exists.{succ u4} (Finset.{u4} ι) (fun (s : Finset.{u4} ι) => Exists.{max (succ u3) (succ u4)} (ι -> k) (fun (w : ι -> k) => Eq.{succ u2} P q (HVAdd.hVAdd.{u1, u2, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P P (instHVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddAction.toVAdd.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2))) (AddTorsor.toAddAction.{u1, u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) P (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) w) _inst_2) _inst_4))) (FunLike.coe.{max (max (succ u1) (succ u4)) (succ u3), max (succ u4) (succ u3), succ u1} (LinearMap.{u3, u3, max u3 u4, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))) (ι -> k) V (Pi.addCommMonoid.{u4, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => V) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, max u4 u3, u1} k k (ι -> k) V (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (Pi.addCommMonoid.{u4, u3} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1))))) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2) (Pi.module.{u4, u3, u3} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.219 : ι) => k) k (Ring.toSemiring.{u3} k _inst_1) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (fun (i : ι) => AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1)) _inst_3 (RingHom.id.{u3} k (NonAssocRing.toNonAssocSemiring.{u3} k (Ring.toNonAssocRing.{u3} k _inst_1)))) (Finset.weightedVSubOfPoint.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p (p j)) w) (p j)))))
Case conversion may be inaccurate. Consider using '#align mem_affine_span_iff_eq_weighted_vsub_of_point_vadd mem_affineSpan_iff_eq_weightedVSubOfPoint_vaddₓ'. -/
/-- Given a family of points together with a chosen base point in that family, membership of the
affine span of this family corresponds to an identity in terms of `weighted_vsub_of_point`, with
weights that are not required to sum to 1. -/
theorem mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd [Nontrivial k] (p : ι → P) (j : ι) (q : P) :
    q ∈ affineSpan k (Set.range p) ↔
      ∃ (s : Finset ι)(w : ι → k), q = s.weightedVSubOfPoint p (p j) w +ᵥ p j :=
  by
  constructor
  · intro hq
    obtain ⟨s, w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan hq
    exact ⟨s, w, s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw (p j)⟩
  · rintro ⟨s, w, rfl⟩
    classical
      let w' : ι → k := Function.update w j (1 - (s \ {j}).Sum w)
      have h₁ : (insert j s).Sum w' = 1 := by
        by_cases hj : j ∈ s
        · simp [Finset.sum_update_of_mem hj, Finset.insert_eq_of_mem hj]
        · simp [w', Finset.sum_insert hj, Finset.sum_update_of_not_mem hj, hj]
      have hww : ∀ i, i ≠ j → w i = w' i := by
        intro i hij
        simp [w', hij]
      rw [s.weighted_vsub_of_point_eq_of_weights_eq p j w w' hww, ←
        s.weighted_vsub_of_point_insert w' p j, ←
        (insert j s).affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w' p h₁ (p j)]
      exact affineCombination_mem_affineSpan h₁ p
#align mem_affine_span_iff_eq_weighted_vsub_of_point_vadd mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd

variable {k V}

/- warning: affine_span_eq_affine_span_line_map_units -> affineSpan_eq_affineSpan_lineMap_units is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] [_inst_5 : Nontrivial.{u1} k] {s : Set.{u3} P} {p : P}, (Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) p s) -> (forall (w : (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) -> (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1))), Eq.{succ u3} (AffineSubspace.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u3} P (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) (fun (q : coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) => coeFn.{max (succ u1) (succ u2) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P) (AffineMap.hasCoeToFun.{u1, u1, u1, u2, u3} k k k V P _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 p ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (HasLiftT.mk.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (CoeTCₓ.coe.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeBase.{succ u3, succ u3} (coeSort.{succ u3, succ (succ u3)} (Set.{u3} P) Type.{u3} (Set.hasCoeToSort.{u3} P) s) P (coeSubtype.{succ u3} P (fun (x : P) => Membership.Mem.{u3, u3} P (Set.{u3} P) (Set.hasMem.{u3} P) x s))))) q)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (coeBase.{succ u1, succ u1} (Units.{u1} k (Ring.toMonoid.{u1} k _inst_1)) k (Units.hasCoe.{u1} k (Ring.toMonoid.{u1} k _inst_1))))) (w q))))) (affineSpan.{u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] [_inst_5 : Nontrivial.{u3} k] {s : Set.{u2} P} {p : P}, (Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) p s) -> (forall (w : (Set.Elem.{u2} P s) -> (Units.{u3} k (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))))), Eq.{succ u2} (AffineSubspace.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4) (affineSpan.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u2} P (Set.Elem.{u2} P s) (fun (q : Set.Elem.{u2} P s) => FunLike.coe.{max (max (succ u3) (succ u1)) (succ u2), succ u3, succ u2} (AffineMap.{u3, u3, u3, u1, u2} k k k V P _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P) _x) (AffineMap.funLike.{u3, u3, u3, u1, u2} k k k V P _inst_1 (Ring.toAddCommGroup.{u3} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u3} k _inst_1) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 p (Subtype.val.{succ u2} P (fun (x : P) => Membership.mem.{u2, u2} P (Set.{u2} P) (Set.instMembershipSet.{u2} P) x s) q)) (Units.val.{u3} k (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (w q))))) (affineSpan.{u3, u1, u2} k V P _inst_1 _inst_2 _inst_3 _inst_4 s))
Case conversion may be inaccurate. Consider using '#align affine_span_eq_affine_span_line_map_units affineSpan_eq_affineSpan_lineMap_unitsₓ'. -/
/-- Given a set of points, together with a chosen base point in this set, if we affinely transport
all other members of the set along the line joining them to this base point, the affine span is
unchanged. -/
theorem affineSpan_eq_affineSpan_lineMap_units [Nontrivial k] {s : Set P} {p : P} (hp : p ∈ s)
    (w : s → Units k) :
    affineSpan k (Set.range fun q : s => AffineMap.lineMap p ↑q (w q : k)) = affineSpan k s :=
  by
  have : s = Set.range (coe : s → P) := by simp
  conv_rhs => rw [this]
  apply le_antisymm <;> intro q hq <;>
            erw [mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd k V _ (⟨p, hp⟩ : s) q] at hq⊢ <;>
          obtain ⟨t, μ, rfl⟩ := hq <;>
        use t <;>
      [use fun x => μ x * ↑(w x), use fun x => μ x * ↑(w x)⁻¹] <;>
    simp [smul_smul]
#align affine_span_eq_affine_span_line_map_units affineSpan_eq_affineSpan_lineMap_units

end AffineSpace'

section DivisionRing

variable {k : Type _} {V : Type _} {P : Type _} [DivisionRing k] [AddCommGroup V] [Module k V]

variable [affine_space V P] {ι : Type _}

include V

open Set Finset

/- warning: centroid_mem_affine_span_of_cast_card_ne_zero -> centroid_mem_affineSpan_of_cast_card_ne_zero is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} {s : Finset.{u4} ι} (p : ι -> P), (Ne.{succ u1} k ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Nat k (HasLiftT.mk.{1, succ u1} Nat k (CoeTCₓ.coe.{1, succ u1} Nat k (Nat.castCoe.{u1} k (AddMonoidWithOne.toNatCast.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))) (Finset.card.{u4} ι s)) (OfNat.ofNat.{u1} k 0 (OfNat.mk.{u1} k 0 (Zero.zero.{u1} k (MulZeroClass.toHasZero.{u1} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k (DivisionRing.toRing.{u1} k _inst_1)))))))))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall {k : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u3} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u3, u1} k V (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u4}} {s : Finset.{u4} ι} (p : ι -> P), (Ne.{succ u3} k (Nat.cast.{u3} k (NonAssocRing.toNatCast.{u3} k (Ring.toNonAssocRing.{u3} k (DivisionRing.toRing.{u3} k _inst_1))) (Finset.card.{u4} ι s)) (OfNat.ofNat.{u3} k 0 (Zero.toOfNat0.{u3} k (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (DivisionSemiring.toSemiring.{u3} k (DivisionRing.toDivisionSemiring.{u3} k _inst_1))))))) -> (Membership.mem.{u2, u2} P (AffineSubspace.{u3, u1, u2} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u3, u1, u2} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u3, u1, u2} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u3, u1, u2, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u3, u1, u2} k V P (DivisionRing.toRing.{u3} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u4} P ι p)))
Case conversion may be inaccurate. Consider using '#align centroid_mem_affine_span_of_cast_card_ne_zero centroid_mem_affineSpan_of_cast_card_ne_zeroₓ'. -/
/-- The centroid lies in the affine span if the number of points,
converted to `k`, is not zero. -/
theorem centroid_mem_affineSpan_of_cast_card_ne_zero {s : Finset ι} (p : ι → P)
    (h : (card s : k) ≠ 0) : s.centroid k p ∈ affineSpan k (range p) :=
  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_cast_card_ne_zero h) p
#align centroid_mem_affine_span_of_cast_card_ne_zero centroid_mem_affineSpan_of_cast_card_ne_zero

variable (k)

/- warning: centroid_mem_affine_span_of_card_ne_zero -> centroid_mem_affineSpan_of_card_ne_zero is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {s : Finset.{u4} ι} (p : ι -> P), (Ne.{1} Nat (Finset.card.{u4} ι s) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} [_inst_5 : CharZero.{u4} k (AddGroupWithOne.toAddMonoidWithOne.{u4} k (Ring.toAddGroupWithOne.{u4} k (DivisionRing.toRing.{u4} k _inst_1)))] {s : Finset.{u3} ι} (p : ι -> P), (Ne.{1} Nat (Finset.card.{u3} ι s) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u3} P ι p)))
Case conversion may be inaccurate. Consider using '#align centroid_mem_affine_span_of_card_ne_zero centroid_mem_affineSpan_of_card_ne_zeroₓ'. -/
/-- In the characteristic zero case, the centroid lies in the affine
span if the number of points is not zero. -/
theorem centroid_mem_affineSpan_of_card_ne_zero [CharZero k] {s : Finset ι} (p : ι → P)
    (h : card s ≠ 0) : s.centroid k p ∈ affineSpan k (range p) :=
  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_card_ne_zero k h) p
#align centroid_mem_affine_span_of_card_ne_zero centroid_mem_affineSpan_of_card_ne_zero

/- warning: centroid_mem_affine_span_of_nonempty -> centroid_mem_affineSpan_of_nonempty is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {s : Finset.{u4} ι} (p : ι -> P), (Finset.Nonempty.{u4} ι s) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} [_inst_5 : CharZero.{u4} k (AddGroupWithOne.toAddMonoidWithOne.{u4} k (Ring.toAddGroupWithOne.{u4} k (DivisionRing.toRing.{u4} k _inst_1)))] {s : Finset.{u3} ι} (p : ι -> P), (Finset.Nonempty.{u3} ι s) -> (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u3} P ι p)))
Case conversion may be inaccurate. Consider using '#align centroid_mem_affine_span_of_nonempty centroid_mem_affineSpan_of_nonemptyₓ'. -/
/-- In the characteristic zero case, the centroid lies in the affine
span if the set is nonempty. -/
theorem centroid_mem_affineSpan_of_nonempty [CharZero k] {s : Finset ι} (p : ι → P)
    (h : s.Nonempty) : s.centroid k p ∈ affineSpan k (range p) :=
  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_nonempty k h) p
#align centroid_mem_affine_span_of_nonempty centroid_mem_affineSpan_of_nonempty

/- warning: centroid_mem_affine_span_of_card_eq_add_one -> centroid_mem_affineSpan_of_card_eq_add_one is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {V : Type.{u2}} {P : Type.{u3}} [_inst_1 : DivisionRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (DivisionRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}} [_inst_5 : CharZero.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k (DivisionRing.toRing.{u1} k _inst_1))))] {s : Finset.{u4} ι} (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Finset.card.{u4} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) -> (Membership.Mem.{u3, u3} P (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.hasMem.{u3, u3} (AffineSubspace.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.setLike.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u1, u2, u3, u4} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u1, u2, u3} k V P (DivisionRing.toRing.{u1} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u3, succ u4} P ι p)))
but is expected to have type
  forall (k : Type.{u4}) {V : Type.{u1}} {P : Type.{u2}} [_inst_1 : DivisionRing.{u4} k] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u4, u1} k V (DivisionSemiring.toSemiring.{u4} k (DivisionRing.toDivisionSemiring.{u4} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_2)] {ι : Type.{u3}} [_inst_5 : CharZero.{u4} k (AddGroupWithOne.toAddMonoidWithOne.{u4} k (Ring.toAddGroupWithOne.{u4} k (DivisionRing.toRing.{u4} k _inst_1)))] {s : Finset.{u3} ι} (p : ι -> P) {n : Nat}, (Eq.{1} Nat (Finset.card.{u3} ι s) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) -> (Membership.mem.{u2, u2} P (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) (SetLike.instMembership.{u2, u2} (AffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4) P (AffineSubspace.instSetLikeAffineSubspace.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4)) (Finset.centroid.{u4, u1, u2, u3} k V P _inst_1 _inst_2 _inst_3 _inst_4 ι s p) (affineSpan.{u4, u1, u2} k V P (DivisionRing.toRing.{u4} k _inst_1) _inst_2 _inst_3 _inst_4 (Set.range.{u2, succ u3} P ι p)))
Case conversion may be inaccurate. Consider using '#align centroid_mem_affine_span_of_card_eq_add_one centroid_mem_affineSpan_of_card_eq_add_oneₓ'. -/
/-- In the characteristic zero case, the centroid lies in the affine
span if the number of points is `n + 1`. -/
theorem centroid_mem_affineSpan_of_card_eq_add_one [CharZero k] {s : Finset ι} (p : ι → P) {n : ℕ}
    (h : card s = n + 1) : s.centroid k p ∈ affineSpan k (range p) :=
  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_card_eq_add_one k h) p
#align centroid_mem_affine_span_of_card_eq_add_one centroid_mem_affineSpan_of_card_eq_add_one

end DivisionRing

namespace AffineMap

variable {k : Type _} {V : Type _} (P : Type _) [CommRing k] [AddCommGroup V] [Module k V]

variable [affine_space V P] {ι : Type _} (s : Finset ι)

include V

/- warning: affine_map.weighted_vsub_of_point -> AffineMap.weightedVSubOfPoint is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}}, (Finset.{u4} ι) -> (ι -> k) -> (AffineMap.{u1, max u4 u2, max u4 u3, u2, u2} k (Prod.{max u4 u2, u2} (ι -> V) V) (Prod.{max u4 u3, u3} (ι -> P) P) V V (CommRing.toRing.{u1} k _inst_1) (Prod.addCommGroup.{max u4 u2, u2} (ι -> V) V (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => _inst_2)) _inst_2) (Prod.module.{u1, max u4 u2, u2} k (ι -> V) V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (Pi.addCommMonoid.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.Function.module.{u4, u1, u2} ι k V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) _inst_3) (Prod.addTorsor.{max u4 u2, max u4 u3, u2, u3} (ι -> V) (ι -> P) V P (Pi.addGroup.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => AddCommGroup.toAddGroup.{u2} V _inst_2)) (AddCommGroup.toAddGroup.{u2} V _inst_2) (Pi.addTorsor.{u4, u2, u3} ι (fun (i : ι) => V) (fun (i : ι) => AddCommGroup.toAddGroup.{u2} V _inst_2) (fun (ᾰ : ι) => P) (fun (i : ι) => _inst_4)) _inst_4) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))
but is expected to have type
  forall {k : Type.{u1}} {V : Type.{u2}} (P : Type.{u3}) [_inst_1 : CommRing.{u1} k] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} k V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_2)] {ι : Type.{u4}}, (Finset.{u4} ι) -> (ι -> k) -> (AffineMap.{u1, max u2 u4, max u3 u4, u2, u2} k (Prod.{max u2 u4, u2} (ι -> V) V) (Prod.{max u3 u4, u3} (ι -> P) P) V V (CommRing.toRing.{u1} k _inst_1) (Prod.instAddCommGroupSum.{max u2 u4, u2} (ι -> V) V (Pi.addCommGroup.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => _inst_2)) _inst_2) (Prod.module.{u1, max u2 u4, u2} k (ι -> V) V (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (Pi.addCommMonoid.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Pi.module.{u4, u2, u1} ι (fun (i : ι) => V) k (Ring.toSemiring.{u1} k (CommRing.toRing.{u1} k _inst_1)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (fun (i : ι) => _inst_3)) _inst_3) (Prod.instAddTorsorProdProdInstAddGroupSum.{u2, max u3 u4, u3, max u2 u4} V (ι -> P) P (ι -> V) (Pi.addGroup.{u4, u2} ι (fun (i : ι) => V) (fun (i : ι) => AddCommGroup.toAddGroup.{u2} V _inst_2)) (AddCommGroup.toAddGroup.{u2} V _inst_2) (AffineMap.instAddTorsorForAllForAllAddGroupToAddGroup.{u4, u2, u3} ι (fun (i : ι) => V) (fun (i : ι) => P) (fun (ᾰ : ι) => _inst_2) (fun (i : ι) => _inst_4)) _inst_4) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))
Case conversion may be inaccurate. Consider using '#align affine_map.weighted_vsub_of_point AffineMap.weightedVSubOfPointₓ'. -/
-- TODO: define `affine_map.proj`, `affine_map.fst`, `affine_map.snd`
/-- A weighted sum, as an affine map on the points involved. -/
def weightedVSubOfPoint (w : ι → k) : (ι → P) × P →ᵃ[k] V
    where
  toFun p := s.weightedVSubOfPoint p.fst p.snd w
  linear := ∑ i in s, w i • ((LinearMap.proj i).comp (LinearMap.fst _ _ _) - LinearMap.snd _ _ _)
  map_vadd' := by
    rintro ⟨p, b⟩ ⟨v, b'⟩
    simp [LinearMap.sum_apply, Finset.weightedVSubOfPoint, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc,
      add_sub, ← sub_add_eq_add_sub, smul_add, Finset.sum_add_distrib]
#align affine_map.weighted_vsub_of_point AffineMap.weightedVSubOfPoint

end AffineMap

