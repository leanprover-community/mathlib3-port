/-
Copyright (c) 2020 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov

! This file was ported from Lean 3 source module linear_algebra.affine_space.affine_equiv
! leanprover-community/mathlib commit 97eab48559068f3d6313da387714ef25768fb730
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.AffineMap
import Mathbin.LinearAlgebra.GeneralLinearGroup
import Mathbin.Algebra.Invertible

/-!
# Affine equivalences

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define `affine_equiv k P₁ P₂` (notation: `P₁ ≃ᵃ[k] P₂`) to be the type of affine
equivalences between `P₁` and `P₂, i.e., equivalences such that both forward and inverse maps are
affine maps.

We define the following equivalences:

* `affine_equiv.refl k P`: the identity map as an `affine_equiv`;

* `e.symm`: the inverse map of an `affine_equiv` as an `affine_equiv`;

* `e.trans e'`: composition of two `affine_equiv`s; note that the order follows `mathlib`'s
  `category_theory` convention (apply `e`, then `e'`), not the convention used in function
  composition and compositions of bundled morphisms.

We equip `affine_equiv k P P` with a `group` structure with multiplication corresponding to
composition in `affine_equiv.group`.

## Tags

affine space, affine equivalence
-/


open Function Set

open Affine

#print AffineEquiv /-
/-- An affine equivalence is an equivalence between affine spaces such that both forward
and inverse maps are affine.

We define it using an `equiv` for the map and a `linear_equiv` for the linear part in order
to allow affine equivalences with good definitional equalities. -/
@[nolint has_nonempty_instance]
structure AffineEquiv (k P₁ P₂ : Type _) {V₁ V₂ : Type _} [Ring k] [AddCommGroup V₁] [Module k V₁]
  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] extends P₁ ≃ P₂ where
  linear : V₁ ≃ₗ[k] V₂
  map_vadd' : ∀ (p : P₁) (v : V₁), to_equiv (v +ᵥ p) = linear v +ᵥ to_equiv p
#align affine_equiv AffineEquiv
-/

-- mathport name: «expr ≃ᵃ[ ] »
notation:25 P₁ " ≃ᵃ[" k:25 "] " P₂:0 => AffineEquiv k P₁ P₂

variable {k P₁ P₂ P₃ P₄ V₁ V₂ V₃ V₄ : Type _} [Ring k] [AddCommGroup V₁] [Module k V₁]
  [AddTorsor V₁ P₁] [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] [AddCommGroup V₃]
  [Module k V₃] [AddTorsor V₃ P₃] [AddCommGroup V₄] [Module k V₄] [AddTorsor V₄ P₄]

namespace AffineEquiv

include V₁ V₂

#print AffineEquiv.toAffineMap /-
/-- Reinterpret an `affine_equiv` as an `affine_map`. -/
def toAffineMap (e : P₁ ≃ᵃ[k] P₂) : P₁ →ᵃ[k] P₂ :=
  { e with }
#align affine_equiv.to_affine_map AffineEquiv.toAffineMap
-/

/- warning: affine_equiv.to_affine_map_mk -> AffineEquiv.toAffineMap_mk is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (f : Equiv.{succ u2, succ u3} P₁ P₂) (f' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (h : forall (p : P₁) (v : V₁), Eq.{succ u3} P₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) f (VAdd.vadd.{u4, u2} V₁ P₁ (AddAction.toHasVadd.{u4, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u4} V₁ (AddGroup.toSubNegMonoid.{u4} V₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2))) (AddTorsor.toAddAction.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4)) v p)) (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1))) f' v) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) f p))), Eq.{max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.mk.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' h)) (AffineMap.mk.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) f) ((fun (a : Sort.{max (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u4) (succ u5), max (succ u4) (succ u5)} a b] => self.0) (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (HasLiftT.mk.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (CoeTCₓ.coe.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (coeBase.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))) f') h)
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : Equiv.{succ u5, succ u4} P₁ P₂) (f' : LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (h : forall (p : P₁) (v : V₁), Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) (HVAdd.hVAdd.{u2, u5, u5} V₁ P₁ P₁ (instHVAdd.{u2, u5} V₁ P₁ (AddAction.toVAdd.{u2, u5} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) f (HVAdd.hVAdd.{u2, u5, u5} V₁ P₁ P₁ (instHVAdd.{u2, u5} V₁ P₁ (AddAction.toVAdd.{u2, u5} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (HVAdd.hVAdd.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (instHVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (AddAction.toVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5))) (AddTorsor.toAddAction.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u3, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u3, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u3, u2} k V₁ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u3, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u3, u1} k V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) f' v) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) f p))), Eq.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1)} (AffineMap.{u3, u2, u5, u1, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.mk.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f f' h)) (AffineMap.mk.{u3, u2, u5, u1, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) f) (LinearEquiv.toLinearMap.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 f') h)
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_affine_map_mk AffineEquiv.toAffineMap_mkₓ'. -/
@[simp]
theorem toAffineMap_mk (f : P₁ ≃ P₂) (f' : V₁ ≃ₗ[k] V₂) (h) :
    toAffineMap (mk f f' h) = ⟨f, f', h⟩ :=
  rfl
#align affine_equiv.to_affine_map_mk AffineEquiv.toAffineMap_mk

/- warning: affine_equiv.linear_to_affine_map -> AffineEquiv.linear_toAffineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u5)} (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) ((fun (a : Sort.{max (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u4) (succ u5), max (succ u4) (succ u5)} a b] => self.0) (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (HasLiftT.mk.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (CoeTCₓ.coe.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (coeBase.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))) (AffineEquiv.linear.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u1)} (LinearMap.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (LinearEquiv.toLinearMap.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (AffineEquiv.linear.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.linear_to_affine_map AffineEquiv.linear_toAffineMapₓ'. -/
@[simp]
theorem linear_toAffineMap (e : P₁ ≃ᵃ[k] P₂) : e.toAffineMap.linear = e.linear :=
  rfl
#align affine_equiv.linear_to_affine_map AffineEquiv.linear_toAffineMap

/- warning: affine_equiv.to_affine_map_injective -> AffineEquiv.toAffineMap_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)], Function.Injective.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)], Function.Injective.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2)} (AffineEquiv.{u1, u5, u4, u3, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u3, u5, u2, u4} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u1, u5, u4, u3, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_affine_map_injective AffineEquiv.toAffineMap_injectiveₓ'. -/
theorem toAffineMap_injective : Injective (toAffineMap : (P₁ ≃ᵃ[k] P₂) → P₁ →ᵃ[k] P₂) :=
  by
  rintro ⟨e, el, h⟩ ⟨e', el', h'⟩ H
  simp only [to_affine_map_mk, Equiv.coe_inj, LinearEquiv.toLinearMap_inj] at H
  congr
  exacts[H.1, H.2]
#align affine_equiv.to_affine_map_injective AffineEquiv.toAffineMap_injective

/- warning: affine_equiv.to_affine_map_inj -> AffineEquiv.toAffineMap_inj is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e')) (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineMap.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e')) (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_affine_map_inj AffineEquiv.toAffineMap_injₓ'. -/
@[simp]
theorem toAffineMap_inj {e e' : P₁ ≃ᵃ[k] P₂} : e.toAffineMap = e'.toAffineMap ↔ e = e' :=
  toAffineMap_injective.eq_iff
#align affine_equiv.to_affine_map_inj AffineEquiv.toAffineMap_inj

#print AffineEquiv.equivLike /-
instance equivLike : EquivLike (P₁ ≃ᵃ[k] P₂) P₁ P₂
    where
  coe f := f.toFun
  inv f := f.invFun
  left_inv f := f.left_inv
  right_inv f := f.right_inv
  coe_injective' f g h _ := toAffineMap_injective (FunLike.coe_injective h)
#align affine_equiv.equiv_like AffineEquiv.equivLike
-/

instance : CoeFun (P₁ ≃ᵃ[k] P₂) fun _ => P₁ → P₂ :=
  FunLike.hasCoeToFun

instance : Coe (P₁ ≃ᵃ[k] P₂) (P₁ ≃ P₂) :=
  ⟨AffineEquiv.toEquiv⟩

variable {k P₁}

/- warning: affine_equiv.map_vadd -> AffineEquiv.map_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₁) (v : V₁), Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e (VAdd.vadd.{u4, u2} V₁ P₁ (AddAction.toHasVadd.{u4, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u4} V₁ (AddGroup.toSubNegMonoid.{u4} V₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2))) (AddTorsor.toAddAction.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4)) v p)) (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.linear.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) v) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₁) (v : V₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) (HVAdd.hVAdd.{u2, u4, u4} V₁ P₁ P₁ (instHVAdd.{u2, u4} V₁ P₁ (AddAction.toVAdd.{u2, u4} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e (HVAdd.hVAdd.{u2, u4, u4} V₁ P₁ P₁ (instHVAdd.{u2, u4} V₁ P₁ (AddAction.toVAdd.{u2, u4} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (HVAdd.hVAdd.{u1, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p) (instHVAdd.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p) (AddAction.toVAdd.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5))) (AddTorsor.toAddAction.{u1, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u5, u2, u1} (LinearEquiv.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u5, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u5, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u5, u2} k V₁ (MonoidWithZero.toMonoid.{u5} k (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u5, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u5, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u5, u1} k V₂ (MonoidWithZero.toMonoid.{u5} k (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u5, u2, u1} (LinearEquiv.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u5} k (Semiring.toMonoidWithZero.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u5, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u5, u5, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u5, u5, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1))))))) (AffineEquiv.linear.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) v) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p))
Case conversion may be inaccurate. Consider using '#align affine_equiv.map_vadd AffineEquiv.map_vaddₓ'. -/
@[simp]
theorem map_vadd (e : P₁ ≃ᵃ[k] P₂) (p : P₁) (v : V₁) : e (v +ᵥ p) = e.linear v +ᵥ e p :=
  e.map_vadd' p v
#align affine_equiv.map_vadd AffineEquiv.map_vadd

/- warning: affine_equiv.coe_to_equiv -> AffineEquiv.coe_toEquiv is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3)} (P₁ -> P₂) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) (AffineEquiv.toEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u3)} (forall (ᾰ : P₁), (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) ᾰ) (FunLike.coe.{max (succ u4) (succ u3), succ u4, succ u3} (Equiv.{succ u4, succ u3} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u4, succ u3} P₁ P₂) (AffineEquiv.toEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_to_equiv AffineEquiv.coe_toEquivₓ'. -/
@[simp]
theorem coe_toEquiv (e : P₁ ≃ᵃ[k] P₂) : ⇑e.toEquiv = e :=
  rfl
#align affine_equiv.coe_to_equiv AffineEquiv.coe_toEquiv

instance : Coe (P₁ ≃ᵃ[k] P₂) (P₁ →ᵃ[k] P₂) :=
  ⟨toAffineMap⟩

/- warning: affine_equiv.coe_to_affine_map -> AffineEquiv.coe_toAffineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3)} ((fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (coeFn.{max (succ u4) (succ u2) (succ u5) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u3)} (forall (a : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) a) (FunLike.coe.{max (max (max (succ u2) (succ u4)) (succ u1)) (succ u3), succ u4, succ u3} (AffineMap.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_to_affine_map AffineEquiv.coe_toAffineMapₓ'. -/
@[simp]
theorem coe_toAffineMap (e : P₁ ≃ᵃ[k] P₂) : (e.toAffineMap : P₁ → P₂) = (e : P₁ → P₂) :=
  rfl
#align affine_equiv.coe_to_affine_map AffineEquiv.coe_toAffineMap

/- warning: affine_equiv.coe_coe -> AffineEquiv.coe_coe is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3)} ((fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) ((fun (a : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u2) (succ u5) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e)) (coeFn.{max (succ u4) (succ u2) (succ u5) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) ((fun (a : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u2) (succ u5) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u3)} (forall (a : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) a) (FunLike.coe.{max (max (max (succ u2) (succ u4)) (succ u1)) (succ u3), succ u4, succ u3} (AffineMap.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_coe AffineEquiv.coe_coeₓ'. -/
@[norm_cast, simp]
theorem coe_coe (e : P₁ ≃ᵃ[k] P₂) : ((e : P₁ →ᵃ[k] P₂) : P₁ → P₂) = e :=
  rfl
#align affine_equiv.coe_coe AffineEquiv.coe_coe

/- warning: affine_equiv.coe_linear -> AffineEquiv.coe_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u5)} (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 ((fun (a : Sort.{max (succ u2) (succ u3) (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u2) (succ u5) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u4) (succ u2) (succ u5) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e)) ((fun (a : Sort.{max (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u4) (succ u5), max (succ u4) (succ u5)} a b] => self.0) (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (HasLiftT.mk.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (CoeTCₓ.coe.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (coeBase.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearMap.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)))))) (AffineEquiv.linear.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u1)} (LinearMap.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (AffineMap.linear.{u5, u2, u4, u1, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.toAffineMap.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (LinearEquiv.toLinearMap.{u5, u5, u2, u1} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (AffineEquiv.linear.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_linear AffineEquiv.coe_linearₓ'. -/
@[simp]
theorem coe_linear (e : P₁ ≃ᵃ[k] P₂) : (e : P₁ →ᵃ[k] P₂).linear = e.linear :=
  rfl
#align affine_equiv.coe_linear AffineEquiv.coe_linear

/- warning: affine_equiv.ext -> AffineEquiv.ext is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (forall (x : P₁), Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e x) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e' x)) -> (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, (forall (x : P₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e x) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e' x)) -> (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
Case conversion may be inaccurate. Consider using '#align affine_equiv.ext AffineEquiv.extₓ'. -/
@[ext]
theorem ext {e e' : P₁ ≃ᵃ[k] P₂} (h : ∀ x, e x = e' x) : e = e' :=
  FunLike.ext _ _ h
#align affine_equiv.ext AffineEquiv.ext

#print AffineEquiv.coeFn_injective /-
theorem coeFn_injective : @Injective (P₁ ≃ᵃ[k] P₂) (P₁ → P₂) coeFn :=
  FunLike.coe_injective
#align affine_equiv.coe_fn_injective AffineEquiv.coeFn_injective
-/

/- warning: affine_equiv.coe_fn_inj -> AffineEquiv.coeFn_inj is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u2) (succ u3)} ((fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) e) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e')) (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u4) (succ u3)} (forall (a : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e')) (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_fn_inj AffineEquiv.coeFn_injₓ'. -/
@[simp, norm_cast]
theorem coeFn_inj {e e' : P₁ ≃ᵃ[k] P₂} : (e : P₁ → P₂) = e' ↔ e = e' :=
  coeFn_injective.eq_iff
#align affine_equiv.coe_fn_inj AffineEquiv.coeFn_inj

/- warning: affine_equiv.to_equiv_injective -> AffineEquiv.toEquiv_injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)], Function.Injective.{max (succ u2) (succ u3) (succ u4) (succ u5), max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (Equiv.{succ u2, succ u3} P₁ P₂) (AffineEquiv.toEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u3}} {V₂ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u1, u2} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)], Function.Injective.{max (max (max (succ u5) (succ u4)) (succ u3)) (succ u2), max (succ u5) (succ u4)} (AffineEquiv.{u1, u5, u4, u3, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (Equiv.{succ u5, succ u4} P₁ P₂) (AffineEquiv.toEquiv.{u1, u5, u4, u3, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_equiv_injective AffineEquiv.toEquiv_injectiveₓ'. -/
theorem toEquiv_injective : Injective (toEquiv : (P₁ ≃ᵃ[k] P₂) → P₁ ≃ P₂) := fun e e' H =>
  ext <| Equiv.ext_iff.1 H
#align affine_equiv.to_equiv_injective AffineEquiv.toEquiv_injective

/- warning: affine_equiv.to_equiv_inj -> AffineEquiv.toEquiv_inj is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2)} (Equiv.{succ u2, succ u3} P₁ P₂) (AffineEquiv.toEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (AffineEquiv.toEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e')) (Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] {e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} {e' : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7}, Iff (Eq.{max (succ u4) (succ u3)} (Equiv.{succ u4, succ u3} P₁ P₂) (AffineEquiv.toEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (AffineEquiv.toEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e')) (Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e e')
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_equiv_inj AffineEquiv.toEquiv_injₓ'. -/
@[simp]
theorem toEquiv_inj {e e' : P₁ ≃ᵃ[k] P₂} : e.toEquiv = e'.toEquiv ↔ e = e' :=
  toEquiv_injective.eq_iff
#align affine_equiv.to_equiv_inj AffineEquiv.toEquiv_inj

/- warning: affine_equiv.coe_mk -> AffineEquiv.coe_mk is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : Equiv.{succ u2, succ u3} P₁ P₂) (e' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (h : forall (p : P₁) (v : V₁), Eq.{succ u3} P₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e (VAdd.vadd.{u4, u2} V₁ P₁ (AddAction.toHasVadd.{u4, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u4} V₁ (AddGroup.toSubNegMonoid.{u4} V₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2))) (AddTorsor.toAddAction.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4)) v p)) (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1))) e' v) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e p))), Eq.{max (succ u2) (succ u3)} ((fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.mk.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e e' h)) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.mk.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e e' h)) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e)
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : Equiv.{succ u5, succ u4} P₁ P₂) (e' : LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (h : forall (p : P₁) (v : V₁), Eq.{succ u4} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) (HVAdd.hVAdd.{u2, u5, u5} V₁ P₁ P₁ (instHVAdd.{u2, u5} V₁ P₁ (AddAction.toVAdd.{u2, u5} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e (HVAdd.hVAdd.{u2, u5, u5} V₁ P₁ P₁ (instHVAdd.{u2, u5} V₁ P₁ (AddAction.toVAdd.{u2, u5} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p)) (HVAdd.hVAdd.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (instHVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (AddAction.toVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5))) (AddTorsor.toAddAction.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) p) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) v) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u3, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u3, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u3, u2} k V₁ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u3, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u3, u1} k V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) e' v) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e p))), Eq.{max (succ u5) (succ u4)} (forall (a : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) (AffineEquiv.mk.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e e' h)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_mk AffineEquiv.coe_mkₓ'. -/
@[simp]
theorem coe_mk (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (h) : ((⟨e, e', h⟩ : P₁ ≃ᵃ[k] P₂) : P₁ → P₂) = e :=
  rfl
#align affine_equiv.coe_mk AffineEquiv.coe_mk

/- warning: affine_equiv.mk' -> AffineEquiv.mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : P₁ -> P₂) (e' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_1.{u1} k _inst_1) (AffineEquiv.mk'._proof_2.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (p : P₁), (forall (p' : P₁), Eq.{succ u3} P₂ (e p') (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_5.{u1} k _inst_1) (AffineEquiv.mk'._proof_6.{u1} k _inst_1)) e' (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toHasVsub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (e p))) -> (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : P₁ -> P₂) (e' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (p : P₁), (forall (p' : P₁), Eq.{succ u3} P₂ (e p') (HVAdd.hVAdd.{u5, u3, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) P₂ P₂ (instHVAdd.{u5, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) P₂ (AddAction.toVAdd.{u5, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) P₂ (SubNegMonoid.toAddMonoid.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u5, u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) P₂ (AddCommGroup.toAddGroup.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u1, u4} k V₁ (AddMonoid.toZero.{u4} V₁ (AddCommMonoid.toAddMonoid.{u4} V₁ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u4} k V₁ (AddMonoid.toAddZeroClass.{u4} V₁ (AddCommMonoid.toAddMonoid.{u4} V₁ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u1, u4} k V₁ (MonoidWithZero.toMonoid.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AddCommMonoid.toAddMonoid.{u4} V₁ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)) (Module.toDistribMulAction.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u1, u5} k V₂ (AddMonoid.toZero.{u5} V₂ (AddCommMonoid.toAddMonoid.{u5} V₂ (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u1, u5} k V₂ (AddMonoid.toAddZeroClass.{u5} V₂ (AddCommMonoid.toAddMonoid.{u5} V₂ (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u1, u5} k V₂ (MonoidWithZero.toMonoid.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AddCommMonoid.toAddMonoid.{u5} V₂ (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)) (Module.toDistribMulAction.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u1} k (Semiring.toMonoidWithZero.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AddCommMonoid.toAddMonoid.{u4} V₁ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u5} V₂ (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)) (Module.toDistribMulAction.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u1, u4, u5, max u4 u5} k V₁ V₂ (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u4, u5, max u4 u5} k k V₁ V₂ (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1))))))) e' (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toVSub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (e p))) -> (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align affine_equiv.mk' AffineEquiv.mk'ₓ'. -/
/-- Construct an affine equivalence by verifying the relation between the map and its linear part at
one base point. Namely, this function takes a map `e : P₁ → P₂`, a linear equivalence
`e' : V₁ ≃ₗ[k] V₂`, and a point `p` such that for any other point `p'` we have
`e p' = e' (p' -ᵥ p) +ᵥ e p`. -/
def mk' (e : P₁ → P₂) (e' : V₁ ≃ₗ[k] V₂) (p : P₁) (h : ∀ p' : P₁, e p' = e' (p' -ᵥ p) +ᵥ e p) :
    P₁ ≃ᵃ[k] P₂ where
  toFun := e
  invFun := fun q' : P₂ => e'.symm (q' -ᵥ e p) +ᵥ p
  left_inv p' := by simp [h p']
  right_inv q' := by simp [h (e'.symm (q' -ᵥ e p) +ᵥ p)]
  linear := e'
  map_vadd' p' v := by simp [h p', h (v +ᵥ p'), vadd_vsub_assoc, vadd_vadd]
#align affine_equiv.mk' AffineEquiv.mk'

/- warning: affine_equiv.coe_mk' -> AffineEquiv.coe_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : Equiv.{succ u2, succ u3} P₁ P₂) (e' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (p : P₁) (h : forall (p' : P₁), Eq.{succ u3} P₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e p') (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_5.{u1} k _inst_1) (AffineEquiv.mk'._proof_6.{u1} k _inst_1)) e' (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toHasVsub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e p))), Eq.{max (succ u2) (succ u3)} (P₁ -> P₂) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.mk'.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e) e' p h)) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e)
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : Equiv.{succ u5, succ u4} P₁ P₂) (e' : LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (p : P₁) (h : forall (p' : P₁), Eq.{succ u4} P₂ (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e p') (HVAdd.hVAdd.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ P₂ (instHVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (AddAction.toVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u3, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u3, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u3, u2} k V₁ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u3, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u3, u1} k V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) e' (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e p))), Eq.{max (succ u5) (succ u4)} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) ᾰ) (FunLike.coe.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u4)) (succ u2)) (succ u1), succ u5, succ u4} (AffineEquiv.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) (AffineEquiv.mk'.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e) e' p h)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_mk' AffineEquiv.coe_mk'ₓ'. -/
@[simp]
theorem coe_mk' (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (p h) : ⇑(mk' e e' p h) = e :=
  rfl
#align affine_equiv.coe_mk' AffineEquiv.coe_mk'

/- warning: affine_equiv.linear_mk' -> AffineEquiv.linear_mk' is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : Equiv.{succ u2, succ u3} P₁ P₂) (e' : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (p : P₁) (h : forall (p' : P₁), Eq.{succ u3} P₂ (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e p') (VAdd.vadd.{u5, u3} V₂ P₂ (AddAction.toHasVadd.{u5, u3} V₂ P₂ (SubNegMonoid.toAddMonoid.{u5} V₂ (AddGroup.toSubNegMonoid.{u5} V₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5))) (AddTorsor.toAddAction.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5) _inst_7)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_3.{u1} k _inst_1) (AffineEquiv.mk'._proof_4.{u1} k _inst_1) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (AffineEquiv.mk'._proof_5.{u1} k _inst_1) (AffineEquiv.mk'._proof_6.{u1} k _inst_1)) e' (VSub.vsub.{u4, u2} V₁ P₁ (AddTorsor.toHasVsub.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2) _inst_4) p' p)) (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e p))), Eq.{max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6) (AffineEquiv.linear.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.mk'.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (coeFn.{max 1 (max (succ u2) (succ u3)) (succ u3) (succ u2), max (succ u2) (succ u3)} (Equiv.{succ u2, succ u3} P₁ P₂) (fun (_x : Equiv.{succ u2, succ u3} P₁ P₂) => P₁ -> P₂) (Equiv.hasCoeToFun.{succ u2, succ u3} P₁ P₂) e) e' p h)) e'
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u5}} {P₂ : Type.{u4}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u4} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : Equiv.{succ u5, succ u4} P₁ P₂) (e' : LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (p : P₁) (h : forall (p' : P₁), Eq.{succ u4} P₂ (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e p') (HVAdd.hVAdd.{u1, u4, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ P₂ (instHVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (AddAction.toVAdd.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) _inst_5))) (AddTorsor.toAddAction.{u1, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) P₂ (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) _inst_5) _inst_7))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u3, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u3, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u3, u2} k V₁ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u3, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u3, u1} k V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) e' (VSub.vsub.{u2, u5} V₁ P₁ (AddTorsor.toVSub.{u2, u5} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) p' p)) (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e p))), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (AffineEquiv.linear.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.mk'.{u3, u5, u4, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (succ u5) (succ u4), succ u5, succ u4} (Equiv.{succ u5, succ u4} P₁ P₂) P₁ (fun (_x : P₁) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : P₁) => P₂) _x) (Equiv.instFunLikeEquiv.{succ u5, succ u4} P₁ P₂) e) e' p h)) e'
Case conversion may be inaccurate. Consider using '#align affine_equiv.linear_mk' AffineEquiv.linear_mk'ₓ'. -/
@[simp]
theorem linear_mk' (e : P₁ ≃ P₂) (e' : V₁ ≃ₗ[k] V₂) (p h) : (mk' e e' p h).linear = e' :=
  rfl
#align affine_equiv.linear_mk' AffineEquiv.linear_mk'

#print AffineEquiv.symm /-
/-- Inverse of an affine equivalence as an affine equivalence. -/
@[symm]
def symm (e : P₁ ≃ᵃ[k] P₂) : P₂ ≃ᵃ[k] P₁
    where
  toEquiv := e.toEquiv.symm
  linear := e.linear.symm
  map_vadd' v p :=
    e.toEquiv.symm.apply_eq_iff_eq_symm_apply.2 <| by
      simpa using (e.to_equiv.apply_symm_apply v).symm
#align affine_equiv.symm AffineEquiv.symm
-/

/- warning: affine_equiv.symm_to_equiv -> AffineEquiv.symm_toEquiv is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3)} (Equiv.{succ u3, succ u2} P₂ P₁) (Equiv.symm.{succ u2, succ u3} P₁ P₂ (AffineEquiv.toEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.toEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u3)} (Equiv.{succ u3, succ u4} P₂ P₁) (Equiv.symm.{succ u4, succ u3} P₁ P₂ (AffineEquiv.toEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.toEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.symm_to_equiv AffineEquiv.symm_toEquivₓ'. -/
@[simp]
theorem symm_toEquiv (e : P₁ ≃ᵃ[k] P₂) : e.toEquiv.symm = e.symm.toEquiv :=
  rfl
#align affine_equiv.symm_to_equiv AffineEquiv.symm_toEquiv

/- warning: affine_equiv.symm_linear -> AffineEquiv.symm_linear is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u5) (succ u4)} (LinearEquiv.{u1, u1, u5, u4} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₂ V₁ (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) _inst_6 _inst_3) (LinearEquiv.symm.{u1, u1, u4, u5} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (AffineEquiv.linear.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.linear.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u1)} (LinearEquiv.{u5, u5, u1, u2} k k (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) V₂ V₁ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_6 _inst_3) (LinearEquiv.symm.{u5, u5, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u5} k _inst_1) (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHom.id.{u5} k (Semiring.toNonAssocSemiring.{u5} k (Ring.toSemiring.{u5} k _inst_1))) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (RingHomInvPair.ids.{u5} k (Ring.toSemiring.{u5} k _inst_1)) (AffineEquiv.linear.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.linear.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.symm_linear AffineEquiv.symm_linearₓ'. -/
@[simp]
theorem symm_linear (e : P₁ ≃ᵃ[k] P₂) : e.linear.symm = e.symm.linear :=
  rfl
#align affine_equiv.symm_linear AffineEquiv.symm_linear

#print AffineEquiv.Simps.apply /-
/-- See Note [custom simps projection] -/
def Simps.apply (e : P₁ ≃ᵃ[k] P₂) : P₁ → P₂ :=
  e
#align affine_equiv.simps.apply AffineEquiv.Simps.apply
-/

#print AffineEquiv.Simps.symmApply /-
/-- See Note [custom simps projection] -/
def Simps.symmApply (e : P₁ ≃ᵃ[k] P₂) : P₂ → P₁ :=
  e.symm
#align affine_equiv.simps.symm_apply AffineEquiv.Simps.symmApply
-/

initialize_simps_projections AffineEquiv (to_equiv_to_fun → apply, to_equiv_inv_fun → symm_apply,
  linear → linear, as_prefix linear, -toEquiv)

/- warning: affine_equiv.bijective -> AffineEquiv.bijective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Bijective.{succ u2, succ u3} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Bijective.{succ u4, succ u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.bijective AffineEquiv.bijectiveₓ'. -/
protected theorem bijective (e : P₁ ≃ᵃ[k] P₂) : Bijective e :=
  e.toEquiv.Bijective
#align affine_equiv.bijective AffineEquiv.bijective

/- warning: affine_equiv.surjective -> AffineEquiv.surjective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Surjective.{succ u2, succ u3} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Surjective.{succ u4, succ u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.surjective AffineEquiv.surjectiveₓ'. -/
protected theorem surjective (e : P₁ ≃ᵃ[k] P₂) : Surjective e :=
  e.toEquiv.Surjective
#align affine_equiv.surjective AffineEquiv.surjective

/- warning: affine_equiv.injective -> AffineEquiv.injective is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Injective.{succ u2, succ u3} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Function.Injective.{succ u4, succ u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.injective AffineEquiv.injectiveₓ'. -/
protected theorem injective (e : P₁ ≃ᵃ[k] P₂) : Injective e :=
  e.toEquiv.Injective
#align affine_equiv.injective AffineEquiv.injective

#print AffineEquiv.ofBijective /-
/-- Bijective affine maps are affine isomorphisms. -/
@[simps]
noncomputable def ofBijective {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Bijective φ) : P₁ ≃ᵃ[k] P₂ :=
  {
    Equiv.ofBijective _
      hφ with
    linear := LinearEquiv.ofBijective φ.linear (φ.linear_bijective_iff.mpr hφ)
    map_vadd' := φ.map_vadd }
#align affine_equiv.of_bijective AffineEquiv.ofBijective
-/

/- warning: affine_equiv.of_bijective.symm_eq -> AffineEquiv.ofBijective.symm_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] {φ : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} (hφ : Function.Bijective.{succ u2, succ u3} P₁ P₂ (coeFn.{max (succ u4) (succ u2) (succ u5) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) φ)), Eq.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3)} (Equiv.{succ u3, succ u2} P₂ P₁) (AffineEquiv.toEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.ofBijective.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ hφ))) (Equiv.symm.{succ u2, succ u3} P₁ P₂ (Equiv.ofBijective.{succ u2, succ u3} P₁ P₂ (coeFn.{max (succ u4) (succ u2) (succ u5) (succ u3), max (succ u2) (succ u3)} (AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineMap.hasCoeToFun.{u1, u4, u2, u5, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) φ) hφ))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u3}} {P₂ : Type.{u1}} {V₁ : Type.{u4}} {V₂ : Type.{u2}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u5, u4} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u2} V₂] [_inst_6 : Module.{u5, u2} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₂ _inst_5)] [_inst_7 : AddTorsor.{u2, u1} V₂ P₂ (AddCommGroup.toAddGroup.{u2} V₂ _inst_5)] {φ : AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7} (hφ : Function.Bijective.{succ u3, succ u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) φ)), Eq.{max (succ u3) (succ u1)} (Equiv.{succ u1, succ u3} P₂ P₁) (AffineEquiv.toEquiv.{u5, u1, u3, u2, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 (AffineEquiv.symm.{u5, u3, u1, u4, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.ofBijective.{u5, u3, u1, u4, u2} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 φ hφ))) (Equiv.symm.{succ u3, succ u1} P₁ P₂ (Equiv.ofBijective.{succ u3, succ u1} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u3, succ u1} (AffineMap.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₂) _x) (AffineMap.funLike.{u5, u4, u3, u2, u1} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) φ) hφ))
Case conversion may be inaccurate. Consider using '#align affine_equiv.of_bijective.symm_eq AffineEquiv.ofBijective.symm_eqₓ'. -/
theorem ofBijective.symm_eq {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Bijective φ) :
    (ofBijective hφ).symm.toEquiv = (Equiv.ofBijective _ hφ).symm :=
  rfl
#align affine_equiv.of_bijective.symm_eq AffineEquiv.ofBijective.symm_eq

/- warning: affine_equiv.range_eq -> AffineEquiv.range_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (Set.{u3} P₂) (Set.range.{u3, succ u2} P₂ P₁ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e)) (Set.univ.{u3} P₂)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{succ u3} (Set.{u3} P₂) (Set.range.{u3, succ u4} P₂ P₁ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e)) (Set.univ.{u3} P₂)
Case conversion may be inaccurate. Consider using '#align affine_equiv.range_eq AffineEquiv.range_eqₓ'. -/
@[simp]
theorem range_eq (e : P₁ ≃ᵃ[k] P₂) : range e = univ :=
  e.Surjective.range_eq
#align affine_equiv.range_eq AffineEquiv.range_eq

/- warning: affine_equiv.apply_symm_apply -> AffineEquiv.apply_symm_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₂), Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e (coeFn.{max (succ u3) (succ u2) (succ u5) (succ u4), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) => P₂ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) p)) p
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₂), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (a : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) a) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) p)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) p)) p
Case conversion may be inaccurate. Consider using '#align affine_equiv.apply_symm_apply AffineEquiv.apply_symm_applyₓ'. -/
@[simp]
theorem apply_symm_apply (e : P₁ ≃ᵃ[k] P₂) (p : P₂) : e (e.symm p) = p :=
  e.toEquiv.apply_symm_apply p
#align affine_equiv.apply_symm_apply AffineEquiv.apply_symm_apply

/- warning: affine_equiv.symm_apply_apply -> AffineEquiv.symm_apply_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₁), Eq.{succ u2} P₁ (coeFn.{max (succ u3) (succ u2) (succ u5) (succ u4), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) => P₂ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p)) p
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (p : P₁), Eq.{succ u4} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (a : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p)) (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p)) p
Case conversion may be inaccurate. Consider using '#align affine_equiv.symm_apply_apply AffineEquiv.symm_apply_applyₓ'. -/
@[simp]
theorem symm_apply_apply (e : P₁ ≃ᵃ[k] P₂) (p : P₁) : e.symm (e p) = p :=
  e.toEquiv.symm_apply_apply p
#align affine_equiv.symm_apply_apply AffineEquiv.symm_apply_apply

/- warning: affine_equiv.apply_eq_iff_eq_symm_apply -> AffineEquiv.apply_eq_iff_eq_symm_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {p₁ : P₁} {p₂ : P₂}, Iff (Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p₁) p₂) (Eq.{succ u2} P₁ p₁ (coeFn.{max (succ u3) (succ u2) (succ u5) (succ u4), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) => P₂ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) p₂))
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {p₁ : P₁} {p₂ : (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p₁}, Iff (Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p₁) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p₁) p₂) (Eq.{succ u4} P₁ p₁ (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) p₂))
Case conversion may be inaccurate. Consider using '#align affine_equiv.apply_eq_iff_eq_symm_apply AffineEquiv.apply_eq_iff_eq_symm_applyₓ'. -/
theorem apply_eq_iff_eq_symm_apply (e : P₁ ≃ᵃ[k] P₂) {p₁ p₂} : e p₁ = p₂ ↔ p₁ = e.symm p₂ :=
  e.toEquiv.apply_eq_iff_eq_symm_apply
#align affine_equiv.apply_eq_iff_eq_symm_apply AffineEquiv.apply_eq_iff_eq_symm_apply

/- warning: affine_equiv.apply_eq_iff_eq -> AffineEquiv.apply_eq_iff_eq is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {p₁ : P₁} {p₂ : P₁}, Iff (Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p₁) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p₂)) (Eq.{succ u2} P₁ p₁ p₂)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) {p₁ : P₁} {p₂ : P₁}, Iff (Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) p₁) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p₁) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p₂)) (Eq.{succ u4} P₁ p₁ p₂)
Case conversion may be inaccurate. Consider using '#align affine_equiv.apply_eq_iff_eq AffineEquiv.apply_eq_iff_eqₓ'. -/
@[simp]
theorem apply_eq_iff_eq (e : P₁ ≃ᵃ[k] P₂) {p₁ p₂ : P₁} : e p₁ = e p₂ ↔ p₁ = p₂ :=
  e.toEquiv.apply_eq_iff_eq
#align affine_equiv.apply_eq_iff_eq AffineEquiv.apply_eq_iff_eq

/- warning: affine_equiv.image_symm -> AffineEquiv.image_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (f : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u3} P₂), Eq.{succ u2} (Set.{u2} P₁) (Set.image.{u3, u2} P₂ P₁ (coeFn.{max (succ u3) (succ u2) (succ u5) (succ u4), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) => P₂ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) s) (Set.preimage.{u2, u3} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u3} P₂), Eq.{succ u4} (Set.{u4} P₁) (Set.image.{u3, u4} P₂ P₁ (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) s) (Set.preimage.{u4, u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f) s)
Case conversion may be inaccurate. Consider using '#align affine_equiv.image_symm AffineEquiv.image_symmₓ'. -/
@[simp]
theorem image_symm (f : P₁ ≃ᵃ[k] P₂) (s : Set P₂) : f.symm '' s = f ⁻¹' s :=
  f.symm.toEquiv.image_eq_preimage _
#align affine_equiv.image_symm AffineEquiv.image_symm

/- warning: affine_equiv.preimage_symm -> AffineEquiv.preimage_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (f : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u2} P₁), Eq.{succ u3} (Set.{u3} P₂) (Set.preimage.{u3, u2} P₂ P₁ (coeFn.{max (succ u3) (succ u2) (succ u5) (succ u4), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) => P₂ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u5, u4} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) s) (Set.image.{u2, u3} P₁ P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) f) s)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (f : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (s : Set.{u4} P₁), Eq.{succ u3} (Set.{u3} P₂) (Set.preimage.{u3, u4} P₂ P₁ (FunLike.coe.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₁) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (EquivLike.toEmbeddingLike.{max (max (max (succ u3) (succ u4)) (succ u1)) (succ u2), succ u3, succ u4} (AffineEquiv.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4) P₂ P₁ (AffineEquiv.equivLike.{u5, u3, u4, u1, u2} k P₂ P₁ V₂ V₁ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 f)) s) (Set.image.{u4, u3} P₁ P₂ (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) f) s)
Case conversion may be inaccurate. Consider using '#align affine_equiv.preimage_symm AffineEquiv.preimage_symmₓ'. -/
@[simp]
theorem preimage_symm (f : P₁ ≃ᵃ[k] P₂) (s : Set P₁) : f.symm ⁻¹' s = f '' s :=
  (f.symm.image_symm _).symm
#align affine_equiv.preimage_symm AffineEquiv.preimage_symm

variable (k P₁)

omit V₂

#print AffineEquiv.refl /-
/-- Identity map as an `affine_equiv`. -/
@[refl]
def refl : P₁ ≃ᵃ[k] P₁ where
  toEquiv := Equiv.refl P₁
  linear := LinearEquiv.refl k V₁
  map_vadd' _ _ := rfl
#align affine_equiv.refl AffineEquiv.refl
-/

/- warning: affine_equiv.coe_refl -> AffineEquiv.coe_refl is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{succ u2} (P₁ -> P₁) (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (id.{succ u2} P₁)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{succ u3} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (id.{succ u3} P₁)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_refl AffineEquiv.coe_reflₓ'. -/
@[simp]
theorem coe_refl : ⇑(refl k P₁) = id :=
  rfl
#align affine_equiv.coe_refl AffineEquiv.coe_refl

/- warning: affine_equiv.coe_refl_to_affine_map -> AffineEquiv.coe_refl_to_affineMap is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u3) (succ u2)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u3) (succ u2)} a b] => self.0) (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (coeBase.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4)))) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (AffineMap.id.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{max (succ u3) (succ u2)} (AffineMap.{u1, u2, u3, u2, u3} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.toAffineMap.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (AffineMap.id.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_refl_to_affine_map AffineEquiv.coe_refl_to_affineMapₓ'. -/
@[simp]
theorem coe_refl_to_affineMap : ↑(refl k P₁) = AffineMap.id k P₁ :=
  rfl
#align affine_equiv.coe_refl_to_affine_map AffineEquiv.coe_refl_to_affineMap

/- warning: affine_equiv.refl_apply -> AffineEquiv.refl_apply is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁), Eq.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4) x) x
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (x : P₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4) x) x
Case conversion may be inaccurate. Consider using '#align affine_equiv.refl_apply AffineEquiv.refl_applyₓ'. -/
@[simp]
theorem refl_apply (x : P₁) : refl k P₁ x = x :=
  rfl
#align affine_equiv.refl_apply AffineEquiv.refl_apply

/- warning: affine_equiv.to_equiv_refl -> AffineEquiv.toEquiv_refl is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{succ u2} (Equiv.{succ u2, succ u2} P₁ P₁) (AffineEquiv.toEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (Equiv.refl.{succ u2} P₁)
but is expected to have type
  forall (k : Type.{u2}) (P₁ : Type.{u3}) {V₁ : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u2, u1} k V₁ (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)], Eq.{succ u3} (Equiv.{succ u3, succ u3} P₁ P₁) (AffineEquiv.toEquiv.{u2, u3, u3, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u2, u3, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (Equiv.refl.{succ u3} P₁)
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_equiv_refl AffineEquiv.toEquiv_reflₓ'. -/
@[simp]
theorem toEquiv_refl : (refl k P₁).toEquiv = Equiv.refl P₁ :=
  rfl
#align affine_equiv.to_equiv_refl AffineEquiv.toEquiv_refl

/- warning: affine_equiv.linear_refl -> AffineEquiv.linear_refl is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{succ u3} (LinearEquiv.{u1, u1, u3, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₁ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) _inst_3 _inst_3) (AffineEquiv.linear.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (LinearEquiv.refl.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) _inst_3)
but is expected to have type
  forall (k : Type.{u2}) (P₁ : Type.{u1}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u2, u3} k V₁ (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{succ u3} (LinearEquiv.{u2, u2, u3, u3} k k (Ring.toSemiring.{u2} k _inst_1) (Ring.toSemiring.{u2} k _inst_1) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k _inst_1))) (RingHomInvPair.ids.{u2} k (Ring.toSemiring.{u2} k _inst_1)) (RingHomInvPair.ids.{u2} k (Ring.toSemiring.{u2} k _inst_1)) V₁ V₁ (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) _inst_3 _inst_3) (AffineEquiv.linear.{u2, u1, u1, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u2, u1, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (LinearEquiv.refl.{u2, u3} k V₁ (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align affine_equiv.linear_refl AffineEquiv.linear_reflₓ'. -/
@[simp]
theorem linear_refl : (refl k P₁).linear = LinearEquiv.refl k V₁ :=
  rfl
#align affine_equiv.linear_refl AffineEquiv.linear_refl

/- warning: affine_equiv.symm_refl -> AffineEquiv.symm_refl is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)) (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align affine_equiv.symm_refl AffineEquiv.symm_reflₓ'. -/
@[simp]
theorem symm_refl : (refl k P₁).symm = refl k P₁ :=
  rfl
#align affine_equiv.symm_refl AffineEquiv.symm_refl

variable {k P₁}

include V₂ V₃

#print AffineEquiv.trans /-
/-- Composition of two `affine_equiv`alences, applied left to right. -/
@[trans]
def trans (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) : P₁ ≃ᵃ[k] P₃
    where
  toEquiv := e.toEquiv.trans e'.toEquiv
  linear := e.linear.trans e'.linear
  map_vadd' p v := by
    simp only [LinearEquiv.trans_apply, coe_to_equiv, (· ∘ ·), Equiv.coe_trans, map_vadd]
#align affine_equiv.trans AffineEquiv.trans
-/

/- warning: affine_equiv.coe_trans -> AffineEquiv.coe_trans is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {P₃ : Type.{u4}} {V₁ : Type.{u5}} {V₂ : Type.{u6}} {V₃ : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u5} V₁] [_inst_3 : Module.{u1, u5} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₁ _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u5} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u6} V₂] [_inst_6 : Module.{u1, u6} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₂ _inst_5)] [_inst_7 : AddTorsor.{u6, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u6} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u7} V₃] [_inst_9 : Module.{u1, u7} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u7} V₃ _inst_8)] [_inst_10 : AddTorsor.{u7, u4} V₃ P₃ (AddCommGroup.toAddGroup.{u7} V₃ _inst_8)] (e : AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{max (succ u2) (succ u4)} (P₁ -> P₃) (coeFn.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u2) (succ u4)} (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (fun (_x : AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) => P₁ -> P₃) (AffineEquiv.hasCoeToFun.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineEquiv.trans.{u1, u2, u3, u4, u5, u6, u7} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e')) (Function.comp.{succ u2, succ u3, succ u4} P₁ P₂ P₃ (coeFn.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u3) (succ u4)} (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (fun (_x : AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) => P₂ -> P₃) (AffineEquiv.hasCoeToFun.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) e') (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e))
but is expected to have type
  forall {k : Type.{u7}} {P₁ : Type.{u6}} {P₂ : Type.{u5}} {P₃ : Type.{u2}} {V₁ : Type.{u4}} {V₂ : Type.{u3}} {V₃ : Type.{u1}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u7, u4} k V₁ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u6} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u7, u3} k V₂ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u1} V₃] [_inst_9 : Module.{u7, u1} k V₃ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₃ _inst_8)] [_inst_10 : AddTorsor.{u1, u2} V₃ P₃ (AddCommGroup.toAddGroup.{u1} V₃ _inst_8)] (e : AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{max (succ u6) (succ u2)} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₃) ᾰ) (FunLike.coe.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₃) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ P₃ (EquivLike.toEmbeddingLike.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ P₃ (AffineEquiv.equivLike.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10))) (AffineEquiv.trans.{u7, u6, u5, u2, u4, u3, u1} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e')) (Function.comp.{succ u6, succ u5, succ u2} P₁ P₂ P₃ (FunLike.coe.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₃) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ P₃ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ P₃ (AffineEquiv.equivLike.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10))) e') (FunLike.coe.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_trans AffineEquiv.coe_transₓ'. -/
@[simp]
theorem coe_trans (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) : ⇑(e.trans e') = e' ∘ e :=
  rfl
#align affine_equiv.coe_trans AffineEquiv.coe_trans

/- warning: affine_equiv.coe_trans_to_affine_map -> AffineEquiv.coe_trans_to_affineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {P₃ : Type.{u4}} {V₁ : Type.{u5}} {V₂ : Type.{u6}} {V₃ : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u5} V₁] [_inst_3 : Module.{u1, u5} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₁ _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u5} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u6} V₂] [_inst_6 : Module.{u1, u6} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₂ _inst_5)] [_inst_7 : AddTorsor.{u6, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u6} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u7} V₃] [_inst_9 : Module.{u1, u7} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u7} V₃ _inst_8)] [_inst_10 : AddTorsor.{u7, u4} V₃ P₃ (AddCommGroup.toAddGroup.{u7} V₃ _inst_8)] (e : AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{max (succ u5) (succ u2) (succ u7) (succ u4)} (AffineMap.{u1, u5, u2, u7, u4} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) ((fun (a : Sort.{max (succ u2) (succ u4) (succ u5) (succ u7)}) (b : Sort.{max (succ u5) (succ u2) (succ u7) (succ u4)}) [self : HasLiftT.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u5) (succ u2) (succ u7) (succ u4)} a b] => self.0) (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u5, u2, u7, u4} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (HasLiftT.mk.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u5) (succ u2) (succ u7) (succ u4)} (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u5, u2, u7, u4} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (CoeTCₓ.coe.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u5) (succ u2) (succ u7) (succ u4)} (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u5, u2, u7, u4} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (coeBase.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u5) (succ u2) (succ u7) (succ u4)} (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u5, u2, u7, u4} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10)))) (AffineEquiv.trans.{u1, u2, u3, u4, u5, u6, u7} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e')) (AffineMap.comp.{u1, u5, u2, u6, u3, u7, u4} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 ((fun (a : Sort.{max (succ u3) (succ u4) (succ u6) (succ u7)}) (b : Sort.{max (succ u6) (succ u3) (succ u7) (succ u4)}) [self : HasLiftT.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u6) (succ u3) (succ u7) (succ u4)} a b] => self.0) (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u6, u3, u7, u4} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (HasLiftT.mk.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u6) (succ u3) (succ u7) (succ u4)} (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u6, u3, u7, u4} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (CoeTCₓ.coe.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u6) (succ u3) (succ u7) (succ u4)} (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u6, u3, u7, u4} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (coeBase.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u6) (succ u3) (succ u7) (succ u4)} (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (AffineMap.{u1, u6, u3, u7, u4} k V₂ P₂ V₃ P₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (AffineEquiv.AffineMap.hasCoe.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10)))) e') ((fun (a : Sort.{max (succ u2) (succ u3) (succ u5) (succ u6)}) (b : Sort.{max (succ u5) (succ u2) (succ u6) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u5) (succ u2) (succ u6) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u5, u2, u6, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (HasLiftT.mk.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u5) (succ u2) (succ u6) (succ u3)} (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u5, u2, u6, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (CoeTCₓ.coe.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u5) (succ u2) (succ u6) (succ u3)} (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u5, u2, u6, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (coeBase.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u5) (succ u2) (succ u6) (succ u3)} (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineMap.{u1, u5, u2, u6, u3} k V₁ P₁ V₂ P₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.AffineMap.hasCoe.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7)))) e))
but is expected to have type
  forall {k : Type.{u7}} {P₁ : Type.{u6}} {P₂ : Type.{u5}} {P₃ : Type.{u2}} {V₁ : Type.{u4}} {V₂ : Type.{u3}} {V₃ : Type.{u1}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u7, u4} k V₁ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u6} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u7, u3} k V₂ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u1} V₃] [_inst_9 : Module.{u7, u1} k V₃ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₃ _inst_8)] [_inst_10 : AddTorsor.{u1, u2} V₃ P₃ (AddCommGroup.toAddGroup.{u1} V₃ _inst_8)] (e : AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10), Eq.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1)} (AffineMap.{u7, u4, u6, u1, u2} k V₁ P₁ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineEquiv.toAffineMap.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 (AffineEquiv.trans.{u7, u6, u5, u2, u4, u3, u1} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e')) (AffineMap.comp.{u7, u4, u6, u3, u5, u1, u2} k V₁ P₁ V₂ P₂ V₃ P₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 (AffineEquiv.toAffineMap.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e') (AffineEquiv.toAffineMap.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_trans_to_affine_map AffineEquiv.coe_trans_to_affineMapₓ'. -/
@[simp]
theorem coe_trans_to_affineMap (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) :
    (e.trans e' : P₁ →ᵃ[k] P₃) = (e' : P₂ →ᵃ[k] P₃).comp e :=
  rfl
#align affine_equiv.coe_trans_to_affine_map AffineEquiv.coe_trans_to_affineMap

/- warning: affine_equiv.trans_apply -> AffineEquiv.trans_apply is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {P₃ : Type.{u4}} {V₁ : Type.{u5}} {V₂ : Type.{u6}} {V₃ : Type.{u7}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u5} V₁] [_inst_3 : Module.{u1, u5} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₁ _inst_2)] [_inst_4 : AddTorsor.{u5, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u5} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u6} V₂] [_inst_6 : Module.{u1, u6} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₂ _inst_5)] [_inst_7 : AddTorsor.{u6, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u6} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u7} V₃] [_inst_9 : Module.{u1, u7} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u7} V₃ _inst_8)] [_inst_10 : AddTorsor.{u7, u4} V₃ P₃ (AddCommGroup.toAddGroup.{u7} V₃ _inst_8)] (e : AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (p : P₁), Eq.{succ u4} P₃ (coeFn.{max (succ u2) (succ u4) (succ u5) (succ u7), max (succ u2) (succ u4)} (AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (fun (_x : AffineEquiv.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) => P₁ -> P₃) (AffineEquiv.hasCoeToFun.{u1, u2, u4, u5, u7} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) (AffineEquiv.trans.{u1, u2, u3, u4, u5, u6, u7} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e') p) (coeFn.{max (succ u3) (succ u4) (succ u6) (succ u7), max (succ u3) (succ u4)} (AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (fun (_x : AffineEquiv.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) => P₂ -> P₃) (AffineEquiv.hasCoeToFun.{u1, u3, u4, u6, u7} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) e' (coeFn.{max (succ u2) (succ u3) (succ u5) (succ u6), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u5, u6} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e p))
but is expected to have type
  forall {k : Type.{u7}} {P₁ : Type.{u6}} {P₂ : Type.{u5}} {P₃ : Type.{u2}} {V₁ : Type.{u4}} {V₂ : Type.{u3}} {V₃ : Type.{u1}} [_inst_1 : Ring.{u7} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u7, u4} k V₁ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u6} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u7, u3} k V₂ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] [_inst_7 : AddTorsor.{u3, u5} V₂ P₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u1} V₃] [_inst_9 : Module.{u7, u1} k V₃ (Ring.toSemiring.{u7} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₃ _inst_8)] [_inst_10 : AddTorsor.{u1, u2} V₃ P₃ (AddCommGroup.toAddGroup.{u1} V₃ _inst_8)] (e : AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e' : AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (p : P₁), Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₃) p) (FunLike.coe.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₃) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ P₃ (EquivLike.toEmbeddingLike.{max (max (max (succ u6) (succ u2)) (succ u4)) (succ u1), succ u6, succ u2} (AffineEquiv.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10) P₁ P₃ (AffineEquiv.equivLike.{u7, u6, u2, u4, u1} k P₁ P₃ V₁ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10))) (AffineEquiv.trans.{u7, u6, u5, u2, u4, u3, u1} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e e') p) (FunLike.coe.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ (fun (_x : P₂) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₂) => P₃) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ P₃ (EquivLike.toEmbeddingLike.{max (max (max (succ u5) (succ u2)) (succ u3)) (succ u1), succ u5, succ u2} (AffineEquiv.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) P₂ P₃ (AffineEquiv.equivLike.{u7, u5, u2, u3, u1} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10))) e' (FunLike.coe.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u6) (succ u5)) (succ u4)) (succ u3), succ u6, succ u5} (AffineEquiv.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u7, u6, u5, u4, u3} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e p))
Case conversion may be inaccurate. Consider using '#align affine_equiv.trans_apply AffineEquiv.trans_applyₓ'. -/
@[simp]
theorem trans_apply (e : P₁ ≃ᵃ[k] P₂) (e' : P₂ ≃ᵃ[k] P₃) (p : P₁) : e.trans e' p = e' (e p) :=
  rfl
#align affine_equiv.trans_apply AffineEquiv.trans_apply

include V₄

/- warning: affine_equiv.trans_assoc -> AffineEquiv.trans_assoc is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {P₃ : Type.{u4}} {P₄ : Type.{u5}} {V₁ : Type.{u6}} {V₂ : Type.{u7}} {V₃ : Type.{u8}} {V₄ : Type.{u9}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u6} V₁] [_inst_3 : Module.{u1, u6} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₁ _inst_2)] [_inst_4 : AddTorsor.{u6, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u6} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u7} V₂] [_inst_6 : Module.{u1, u7} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u7} V₂ _inst_5)] [_inst_7 : AddTorsor.{u7, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u7} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u8} V₃] [_inst_9 : Module.{u1, u8} k V₃ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u8} V₃ _inst_8)] [_inst_10 : AddTorsor.{u8, u4} V₃ P₃ (AddCommGroup.toAddGroup.{u8} V₃ _inst_8)] [_inst_11 : AddCommGroup.{u9} V₄] [_inst_12 : Module.{u1, u9} k V₄ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u9} V₄ _inst_11)] [_inst_13 : AddTorsor.{u9, u5} V₄ P₄ (AddCommGroup.toAddGroup.{u9} V₄ _inst_11)] (e₁ : AffineEquiv.{u1, u2, u3, u6, u7} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e₂ : AffineEquiv.{u1, u3, u4, u7, u8} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (e₃ : AffineEquiv.{u1, u4, u5, u8, u9} k P₃ P₄ V₃ V₄ _inst_1 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13), Eq.{max (succ u2) (succ u5) (succ u6) (succ u9)} (AffineEquiv.{u1, u2, u5, u6, u9} k P₁ P₄ V₁ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_11 _inst_12 _inst_13) (AffineEquiv.trans.{u1, u2, u4, u5, u6, u8, u9} k P₁ P₃ P₄ V₁ V₃ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 (AffineEquiv.trans.{u1, u2, u3, u4, u6, u7, u8} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e₁ e₂) e₃) (AffineEquiv.trans.{u1, u2, u3, u5, u6, u7, u9} k P₁ P₂ P₄ V₁ V₂ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_11 _inst_12 _inst_13 e₁ (AffineEquiv.trans.{u1, u3, u4, u5, u7, u8, u9} k P₂ P₃ P₄ V₂ V₃ V₄ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 e₂ e₃))
but is expected to have type
  forall {k : Type.{u9}} {P₁ : Type.{u8}} {P₂ : Type.{u7}} {P₃ : Type.{u4}} {P₄ : Type.{u2}} {V₁ : Type.{u6}} {V₂ : Type.{u5}} {V₃ : Type.{u3}} {V₄ : Type.{u1}} [_inst_1 : Ring.{u9} k] [_inst_2 : AddCommGroup.{u6} V₁] [_inst_3 : Module.{u9, u6} k V₁ (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u6} V₁ _inst_2)] [_inst_4 : AddTorsor.{u6, u8} V₁ P₁ (AddCommGroup.toAddGroup.{u6} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u9, u5} k V₂ (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u7} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] [_inst_8 : AddCommGroup.{u3} V₃] [_inst_9 : Module.{u9, u3} k V₃ (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₃ _inst_8)] [_inst_10 : AddTorsor.{u3, u4} V₃ P₃ (AddCommGroup.toAddGroup.{u3} V₃ _inst_8)] [_inst_11 : AddCommGroup.{u1} V₄] [_inst_12 : Module.{u9, u1} k V₄ (Ring.toSemiring.{u9} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₄ _inst_11)] [_inst_13 : AddTorsor.{u1, u2} V₄ P₄ (AddCommGroup.toAddGroup.{u1} V₄ _inst_11)] (e₁ : AffineEquiv.{u9, u8, u7, u6, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (e₂ : AffineEquiv.{u9, u7, u4, u5, u3} k P₂ P₃ V₂ V₃ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10) (e₃ : AffineEquiv.{u9, u4, u2, u3, u1} k P₃ P₄ V₃ V₄ _inst_1 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13), Eq.{max (max (max (succ u8) (succ u2)) (succ u6)) (succ u1)} (AffineEquiv.{u9, u8, u2, u6, u1} k P₁ P₄ V₁ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_11 _inst_12 _inst_13) (AffineEquiv.trans.{u9, u8, u4, u2, u6, u3, u1} k P₁ P₃ P₄ V₁ V₃ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 (AffineEquiv.trans.{u9, u8, u7, u4, u6, u5, u3} k P₁ P₂ P₃ V₁ V₂ V₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 e₁ e₂) e₃) (AffineEquiv.trans.{u9, u8, u7, u2, u6, u5, u1} k P₁ P₂ P₄ V₁ V₂ V₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_11 _inst_12 _inst_13 e₁ (AffineEquiv.trans.{u9, u7, u4, u2, u5, u3, u1} k P₂ P₃ P₄ V₂ V₃ V₄ _inst_1 _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 _inst_13 e₂ e₃))
Case conversion may be inaccurate. Consider using '#align affine_equiv.trans_assoc AffineEquiv.trans_assocₓ'. -/
theorem trans_assoc (e₁ : P₁ ≃ᵃ[k] P₂) (e₂ : P₂ ≃ᵃ[k] P₃) (e₃ : P₃ ≃ᵃ[k] P₄) :
    (e₁.trans e₂).trans e₃ = e₁.trans (e₂.trans e₃) :=
  ext fun _ => rfl
#align affine_equiv.trans_assoc AffineEquiv.trans_assoc

omit V₃ V₄

/- warning: affine_equiv.trans_refl -> AffineEquiv.trans_refl is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u1, u2, u3, u3, u4, u5, u5} k P₁ P₂ P₂ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7 e (AffineEquiv.refl.{u1, u3, u5} k P₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7)) e
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u5, u4, u3, u3, u2, u1, u1} k P₁ P₂ P₂ V₁ V₂ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7 e (AffineEquiv.refl.{u5, u3, u1} k P₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7)) e
Case conversion may be inaccurate. Consider using '#align affine_equiv.trans_refl AffineEquiv.trans_reflₓ'. -/
@[simp]
theorem trans_refl (e : P₁ ≃ᵃ[k] P₂) : e.trans (refl k P₂) = e :=
  ext fun _ => rfl
#align affine_equiv.trans_refl AffineEquiv.trans_refl

/- warning: affine_equiv.refl_trans -> AffineEquiv.refl_trans is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u3) (succ u4) (succ u5)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u1, u2, u2, u3, u4, u4, u5} k P₁ P₁ P₂ V₁ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.refl.{u1, u2, u4} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4) e) e
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1)} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u5, u4, u4, u3, u2, u2, u1} k P₁ P₁ P₂ V₁ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.refl.{u5, u4, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4) e) e
Case conversion may be inaccurate. Consider using '#align affine_equiv.refl_trans AffineEquiv.refl_transₓ'. -/
@[simp]
theorem refl_trans (e : P₁ ≃ᵃ[k] P₂) : (refl k P₁).trans e = e :=
  ext fun _ => rfl
#align affine_equiv.refl_trans AffineEquiv.refl_trans

/- warning: affine_equiv.self_trans_symm -> AffineEquiv.self_trans_symm is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u2) (succ u4)} (AffineEquiv.{u1, u2, u2, u4, u4} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.trans.{u1, u2, u3, u2, u4, u5, u4} k P₁ P₂ P₁ V₁ V₂ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 e (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.refl.{u1, u2, u4} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u4) (succ u2)} (AffineEquiv.{u5, u4, u4, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.trans.{u5, u4, u3, u4, u2, u1, u2} k P₁ P₂ P₁ V₁ V₂ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 e (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e)) (AffineEquiv.refl.{u5, u4, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align affine_equiv.self_trans_symm AffineEquiv.self_trans_symmₓ'. -/
@[simp]
theorem self_trans_symm (e : P₁ ≃ᵃ[k] P₂) : e.trans e.symm = refl k P₁ :=
  ext e.symm_apply_apply
#align affine_equiv.self_trans_symm AffineEquiv.self_trans_symm

/- warning: affine_equiv.symm_trans_self -> AffineEquiv.symm_trans_self is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u3) (succ u5)} (AffineEquiv.{u1, u3, u3, u5, u5} k P₂ P₂ V₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u1, u3, u2, u3, u5, u4, u5} k P₂ P₁ P₂ V₂ V₁ V₂ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.symm.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) e) (AffineEquiv.refl.{u1, u3, u5} k P₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7), Eq.{max (succ u3) (succ u1)} (AffineEquiv.{u5, u3, u3, u1, u1} k P₂ P₂ V₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7 _inst_5 _inst_6 _inst_7) (AffineEquiv.trans.{u5, u3, u4, u3, u1, u2, u1} k P₂ P₁ P₂ V₂ V₁ V₂ _inst_1 _inst_5 _inst_6 _inst_7 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 (AffineEquiv.symm.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 e) e) (AffineEquiv.refl.{u5, u3, u1} k P₂ V₂ _inst_1 _inst_5 _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align affine_equiv.symm_trans_self AffineEquiv.symm_trans_selfₓ'. -/
@[simp]
theorem symm_trans_self (e : P₁ ≃ᵃ[k] P₂) : e.symm.trans e = refl k P₂ :=
  ext e.apply_symm_apply
#align affine_equiv.symm_trans_self AffineEquiv.symm_trans_self

/- warning: affine_equiv.apply_line_map -> AffineEquiv.apply_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {P₂ : Type.{u3}} {V₁ : Type.{u4}} {V₂ : Type.{u5}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u4} V₁] [_inst_3 : Module.{u1, u4} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u4} V₁ _inst_2)] [_inst_4 : AddTorsor.{u4, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u4} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u5} V₂] [_inst_6 : Module.{u1, u5} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u5} V₂ _inst_5)] [_inst_7 : AddTorsor.{u5, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u5} V₂ _inst_5)] (e : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (a : P₁) (b : P₁) (c : k), Eq.{succ u3} P₂ (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e (coeFn.{max (succ u1) (succ u4) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u4, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u4, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P₁) (AffineMap.hasCoeToFun.{u1, u1, u1, u4, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u4, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 a b) c)) (coeFn.{max (succ u1) (succ u5) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u5, u3} k k k V₂ P₂ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (fun (_x : AffineMap.{u1, u1, u1, u5, u3} k k k V₂ P₂ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) => k -> P₂) (AffineMap.hasCoeToFun.{u1, u1, u1, u5, u3} k k k V₂ P₂ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_5 _inst_6 _inst_7) (AffineMap.lineMap.{u1, u5, u3} k V₂ P₂ _inst_1 _inst_5 _inst_6 _inst_7 (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e a) (coeFn.{max (succ u2) (succ u3) (succ u4) (succ u5), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (fun (_x : AffineEquiv.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) => P₁ -> P₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u4, u5} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) e b)) c)
but is expected to have type
  forall {k : Type.{u5}} {P₁ : Type.{u4}} {P₂ : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u5} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u5, u2} k V₁ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u4} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u5, u1} k V₂ (Ring.toSemiring.{u5} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] [_inst_7 : AddTorsor.{u1, u3} V₂ P₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5)] (e : AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) (a : P₁) (b : P₁) (c : k), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) (FunLike.coe.{max (max (succ u5) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u5, u5, u5, u2, u4} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (a : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) a) (AffineMap.funLike.{u5, u5, u5, u2, u4} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 a b) c)) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e (FunLike.coe.{max (max (succ u5) (succ u2)) (succ u4), succ u5, succ u4} (AffineMap.{u5, u5, u5, u2, u4} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) _x) (AffineMap.funLike.{u5, u5, u5, u2, u4} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u5, u2, u4} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 a b) c)) (FunLike.coe.{max (max (succ u5) (succ u1)) (succ u3), succ u5, succ u3} (AffineMap.{u5, u5, u5, u1, u3} k k k V₂ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_5 _inst_6 _inst_7) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) _x) (AffineMap.funLike.{u5, u5, u5, u1, u3} k k k V₂ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) _inst_1 (Ring.toAddCommGroup.{u5} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u5} k _inst_1) (addGroupIsAddTorsor.{u5} k (AddGroupWithOne.toAddGroup.{u5} k (Ring.toAddGroupWithOne.{u5} k _inst_1))) _inst_5 _inst_6 _inst_7) (AffineMap.lineMap.{u5, u1, u3} k V₂ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) a) _inst_1 _inst_5 _inst_6 _inst_7 (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e a) (FunLike.coe.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₂) _x) (EmbeddingLike.toFunLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (EquivLike.toEmbeddingLike.{max (max (max (succ u4) (succ u3)) (succ u2)) (succ u1), succ u4, succ u3} (AffineEquiv.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7) P₁ P₂ (AffineEquiv.equivLike.{u5, u4, u3, u2, u1} k P₁ P₂ V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7))) e b)) c)
Case conversion may be inaccurate. Consider using '#align affine_equiv.apply_line_map AffineEquiv.apply_lineMapₓ'. -/
@[simp]
theorem apply_lineMap (e : P₁ ≃ᵃ[k] P₂) (a b : P₁) (c : k) :
    e (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c :=
  e.toAffineMap.apply_lineMap a b c
#align affine_equiv.apply_line_map AffineEquiv.apply_lineMap

omit V₂

instance : Group (P₁ ≃ᵃ[k] P₁) where
  one := refl k P₁
  mul e e' := e'.trans e
  inv := symm
  mul_assoc e₁ e₂ e₃ := trans_assoc _ _ _
  one_mul := trans_refl
  mul_one := refl_trans
  mul_left_inv := self_trans_symm

/- warning: affine_equiv.one_def -> AffineEquiv.one_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (OfNat.mk.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.one.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasOne.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))))) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.toOfNat1.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (InvOneClass.toOne.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvOneMonoid.toInvOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivisionMonoid.toDivInvOneMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivisionMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))))) (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align affine_equiv.one_def AffineEquiv.one_defₓ'. -/
theorem one_def : (1 : P₁ ≃ᵃ[k] P₁) = refl k P₁ :=
  rfl
#align affine_equiv.one_def AffineEquiv.one_def

/- warning: affine_equiv.coe_one -> AffineEquiv.coe_one is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{succ u2} (P₁ -> P₁) (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (OfNat.ofNat.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (OfNat.mk.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.one.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasOne.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))))))) (id.{succ u2} P₁)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{succ u3} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (OfNat.ofNat.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) 1 (One.toOfNat1.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (InvOneClass.toOne.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvOneMonoid.toInvOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivisionMonoid.toDivInvOneMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivisionMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))))) (id.{succ u3} P₁)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_one AffineEquiv.coe_oneₓ'. -/
@[simp]
theorem coe_one : ⇑(1 : P₁ ≃ᵃ[k] P₁) = id :=
  rfl
#align affine_equiv.coe_one AffineEquiv.coe_one

/- warning: affine_equiv.mul_def -> AffineEquiv.mul_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (e : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (e' : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ (max u2 u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))) e e') (AffineEquiv.trans.{u1, u2, u2, u2, u3, u3, u3} k P₁ P₁ P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 e' e)
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u2}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] (e : AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (e' : AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toMul.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u3, u2, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))) e e') (AffineEquiv.trans.{u3, u2, u2, u2, u1, u1, u1} k P₁ P₁ P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 e' e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.mul_def AffineEquiv.mul_defₓ'. -/
theorem mul_def (e e' : P₁ ≃ᵃ[k] P₁) : e * e' = e'.trans e :=
  rfl
#align affine_equiv.mul_def AffineEquiv.mul_def

/- warning: affine_equiv.coe_mul -> AffineEquiv.coe_mul is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (e : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (e' : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (P₁ -> P₁) (coeFn.{succ (max u2 u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toHasMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))) e e')) (Function.comp.{succ u2, succ u2, succ u2} P₁ P₁ P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) e) (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) e'))
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u2}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] (e : AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (e' : AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ u2} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHMul.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (MulOneClass.toMul.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u3, u2, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))))) e e')) (Function.comp.{succ u2, succ u2, succ u2} P₁ P₁ P₁ (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) e) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) e'))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_mul AffineEquiv.coe_mulₓ'. -/
@[simp]
theorem coe_mul (e e' : P₁ ≃ᵃ[k] P₁) : ⇑(e * e') = e ∘ e' :=
  rfl
#align affine_equiv.coe_mul AffineEquiv.coe_mul

/- warning: affine_equiv.inv_def -> AffineEquiv.inv_def is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (e : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{succ (max u2 u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Inv.inv.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toHasInv.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))) e) (AffineEquiv.symm.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 e)
but is expected to have type
  forall {k : Type.{u3}} {P₁ : Type.{u2}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] (e : AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4), Eq.{max (succ u2) (succ u1)} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Inv.inv.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (InvOneClass.toInv.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvOneMonoid.toInvOneClass.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivisionMonoid.toDivInvOneMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivisionMonoid.{max u2 u1} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u3, u2, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))) e) (AffineEquiv.symm.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 e)
Case conversion may be inaccurate. Consider using '#align affine_equiv.inv_def AffineEquiv.inv_defₓ'. -/
theorem inv_def (e : P₁ ≃ᵃ[k] P₁) : e⁻¹ = e.symm :=
  rfl
#align affine_equiv.inv_def AffineEquiv.inv_def

#print AffineEquiv.linearHom /-
/-- `affine_equiv.linear` on automorphisms is a `monoid_hom`. -/
@[simps]
def linearHom : (P₁ ≃ᵃ[k] P₁) →* V₁ ≃ₗ[k] V₁
    where
  toFun := linear
  map_one' := rfl
  map_mul' _ _ := rfl
#align affine_equiv.linear_hom AffineEquiv.linearHom
-/

/- warning: affine_equiv.equiv_units_affine_map -> AffineEquiv.equivUnitsAffineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], MulEquiv.{max u2 u3, max u3 u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Units.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) (MulOneClass.toHasMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (MulOneClass.toHasMul.{max u3 u2} (Units.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) (Units.mulOneClass.{max u3 u2} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.monoid.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], MulEquiv.{max u3 u2, max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Units.{max u2 u3} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) (MulOneClass.toMul.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (MulOneClass.toMul.{max u2 u3} (Units.{max u2 u3} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)) (Units.instMulOneClassUnits.{max u2 u3} (AffineMap.{u1, u3, u2, u3, u2} k V₁ P₁ V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineMap.instMonoidAffineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4)))
Case conversion may be inaccurate. Consider using '#align affine_equiv.equiv_units_affine_map AffineEquiv.equivUnitsAffineMapₓ'. -/
/-- The group of `affine_equiv`s are equivalent to the group of units of `affine_map`.

This is the affine version of `linear_map.general_linear_group.general_linear_equiv`. -/
@[simps]
def equivUnitsAffineMap : (P₁ ≃ᵃ[k] P₁) ≃* (P₁ →ᵃ[k] P₁)ˣ
    where
  toFun e := ⟨e, e.symm, congr_arg coe e.symm_trans_self, congr_arg coe e.self_trans_symm⟩
  invFun u :=
    { toFun := (u : P₁ →ᵃ[k] P₁)
      invFun := (↑u⁻¹ : P₁ →ᵃ[k] P₁)
      left_inv := AffineMap.congr_fun u.inv_mul
      right_inv := AffineMap.congr_fun u.mul_inv
      linear :=
        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u
      map_vadd' := fun _ _ => (u : P₁ →ᵃ[k] P₁).map_vadd _ _ }
  left_inv e := AffineEquiv.ext fun x => rfl
  right_inv u := Units.ext <| AffineMap.ext fun x => rfl
  map_mul' e₁ e₂ := rfl
#align affine_equiv.equiv_units_affine_map AffineEquiv.equivUnitsAffineMap

variable (k)

#print AffineEquiv.vaddConst /-
/-- The map `v ↦ v +ᵥ b` as an affine equivalence between a module `V` and an affine space `P` with
tangent space `V`. -/
@[simps]
def vaddConst (b : P₁) : V₁ ≃ᵃ[k] P₁
    where
  toEquiv := Equiv.vaddConst b
  linear := LinearEquiv.refl _ _
  map_vadd' p v := add_vadd _ _ _
#align affine_equiv.vadd_const AffineEquiv.vaddConst
-/

#print AffineEquiv.constVSub /-
/-- `p' ↦ p -ᵥ p'` as an equivalence. -/
def constVSub (p : P₁) : P₁ ≃ᵃ[k] V₁
    where
  toEquiv := Equiv.constVSub p
  linear := LinearEquiv.neg k
  map_vadd' p' v := by simp [vsub_vadd_eq_vsub_sub, neg_add_eq_sub]
#align affine_equiv.const_vsub AffineEquiv.constVSub
-/

/- warning: affine_equiv.coe_const_vsub -> AffineEquiv.coe_constVSub is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (p : P₁), Eq.{max (succ u2) (succ u3)} (P₁ -> V₁) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u3, u3} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (fun (_x : AffineEquiv.{u1, u2, u3, u3, u3} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) => P₁ -> V₁) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u3, u3} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AffineEquiv.constVSub.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 p)) (VSub.vsub.{u3, u2} V₁ P₁ (AddTorsor.toHasVsub.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4) p)
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (p : P₁), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : P₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => V₁) ᾰ) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (AffineEquiv.{u1, u3, u2, u2, u2} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => V₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u2} (AffineEquiv.{u1, u3, u2, u2, u2} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) P₁ V₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u2} (AffineEquiv.{u1, u3, u2, u2, u2} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) P₁ V₁ (AffineEquiv.equivLike.{u1, u3, u2, u2, u2} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))))) (AffineEquiv.constVSub.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 p)) ((fun (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.6944 : P₁) (x._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.6946 : P₁) => VSub.vsub.{u2, u3} V₁ P₁ (AddTorsor.toVSub.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) x._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.6944 x._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.6946) p)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_const_vsub AffineEquiv.coe_constVSubₓ'. -/
@[simp]
theorem coe_constVSub (p : P₁) : ⇑(constVSub k p) = (· -ᵥ ·) p :=
  rfl
#align affine_equiv.coe_const_vsub AffineEquiv.coe_constVSub

/- warning: affine_equiv.coe_const_vsub_symm -> AffineEquiv.coe_constVSub_symm is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (p : P₁), Eq.{max (succ u3) (succ u2)} (V₁ -> P₁) (coeFn.{max (succ u2) (succ u3), max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u2, u3, u3} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u3, u2, u3, u3} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) => V₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u3, u2, u3, u3} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u3, u3, u3} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) (AffineEquiv.constVSub.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 p))) (fun (v : V₁) => VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) (Neg.neg.{u3} V₁ (SubNegMonoid.toHasNeg.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) v) p)
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (p : P₁), Eq.{max (succ u3) (succ u2)} (forall (ᾰ : V₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : V₁) => P₁) ᾰ) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (AffineEquiv.{u1, u2, u3, u2, u2} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) V₁ (fun (_x : V₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : V₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u3} (AffineEquiv.{u1, u2, u3, u2, u2} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) V₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u3} (AffineEquiv.{u1, u2, u3, u2, u2} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_2 _inst_3 _inst_4) V₁ P₁ (AffineEquiv.equivLike.{u1, u2, u3, u2, u2} k V₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_2 _inst_3 _inst_4))) (AffineEquiv.symm.{u1, u3, u2, u2, u2} k P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) (AffineEquiv.constVSub.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 p))) (fun (v : V₁) => HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) (Neg.neg.{u2} V₁ (NegZeroClass.toNeg.{u2} V₁ (SubNegZeroMonoid.toNegZeroClass.{u2} V₁ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₁ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₁ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₁ _inst_2))))) v) p)
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_const_vsub_symm AffineEquiv.coe_constVSub_symmₓ'. -/
@[simp]
theorem coe_constVSub_symm (p : P₁) : ⇑(constVSub k p).symm = fun v => -v +ᵥ p :=
  rfl
#align affine_equiv.coe_const_vsub_symm AffineEquiv.coe_constVSub_symm

variable (P₁)

#print AffineEquiv.constVAdd /-
/-- The map `p ↦ v +ᵥ p` as an affine automorphism of an affine space.

Note that there is no need for an `affine_map.const_vadd` as it is always an equivalence.
This is roughly to `distrib_mul_action.to_linear_equiv` as `+ᵥ` is to `•`. -/
@[simps apply linear]
def constVAdd (v : V₁) : P₁ ≃ᵃ[k] P₁
    where
  toEquiv := Equiv.constVAdd P₁ v
  linear := LinearEquiv.refl _ _
  map_vadd' p w := vadd_comm _ _ _
#align affine_equiv.const_vadd AffineEquiv.constVAdd
-/

/- warning: affine_equiv.const_vadd_zero -> AffineEquiv.constVAdd_zero is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{u3} V₁ 0 (OfNat.mk.{u3} V₁ 0 (Zero.zero.{u3} V₁ (AddZeroClass.toHasZero.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))))))))) (AffineEquiv.refl.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)], Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (OfNat.ofNat.{u2} V₁ 0 (Zero.toOfNat0.{u2} V₁ (NegZeroClass.toZero.{u2} V₁ (SubNegZeroMonoid.toNegZeroClass.{u2} V₁ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₁ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₁ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₁ _inst_2)))))))) (AffineEquiv.refl.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)
Case conversion may be inaccurate. Consider using '#align affine_equiv.const_vadd_zero AffineEquiv.constVAdd_zeroₓ'. -/
@[simp]
theorem constVAdd_zero : constVAdd k P₁ 0 = AffineEquiv.refl _ _ :=
  ext <| zero_vadd _
#align affine_equiv.const_vadd_zero AffineEquiv.constVAdd_zero

/- warning: affine_equiv.const_vadd_add -> AffineEquiv.constVAdd_add is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (v : V₁) (w : V₁), Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (HAdd.hAdd.{u3, u3, u3} V₁ V₁ V₁ (instHAdd.{u3} V₁ (AddZeroClass.toHasAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)))))) v w)) (AffineEquiv.trans.{u1, u2, u2, u2, u3, u3, u3} k P₁ P₁ P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 w) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v))
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (v : V₁) (w : V₁), Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (HAdd.hAdd.{u2, u2, u2} V₁ V₁ V₁ (instHAdd.{u2} V₁ (AddZeroClass.toAdd.{u2} V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)))))) v w)) (AffineEquiv.trans.{u1, u3, u3, u3, u2, u2, u2} k P₁ P₁ P₁ V₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 w) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v))
Case conversion may be inaccurate. Consider using '#align affine_equiv.const_vadd_add AffineEquiv.constVAdd_addₓ'. -/
@[simp]
theorem constVAdd_add (v w : V₁) :
    constVAdd k P₁ (v + w) = (constVAdd k P₁ w).trans (constVAdd k P₁ v) :=
  ext <| add_vadd _ _
#align affine_equiv.const_vadd_add AffineEquiv.constVAdd_add

/- warning: affine_equiv.const_vadd_symm -> AffineEquiv.constVAdd_symm is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (v : V₁), Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v)) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (Neg.neg.{u3} V₁ (SubNegMonoid.toHasNeg.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) v))
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (v : V₁), Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v)) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (Neg.neg.{u2} V₁ (NegZeroClass.toNeg.{u2} V₁ (SubNegZeroMonoid.toNegZeroClass.{u2} V₁ (SubtractionMonoid.toSubNegZeroMonoid.{u2} V₁ (SubtractionCommMonoid.toSubtractionMonoid.{u2} V₁ (AddCommGroup.toDivisionAddCommMonoid.{u2} V₁ _inst_2))))) v))
Case conversion may be inaccurate. Consider using '#align affine_equiv.const_vadd_symm AffineEquiv.constVAdd_symmₓ'. -/
@[simp]
theorem constVAdd_symm (v : V₁) : (constVAdd k P₁ v).symm = constVAdd k P₁ (-v) :=
  ext fun _ => rfl
#align affine_equiv.const_vadd_symm AffineEquiv.constVAdd_symm

#print AffineEquiv.constVAddHom /-
/-- A more bundled version of `affine_equiv.const_vadd`. -/
@[simps]
def constVAddHom : Multiplicative V₁ →* P₁ ≃ᵃ[k] P₁
    where
  toFun v := constVAdd k P₁ v.toAdd
  map_one' := constVAdd_zero _ _
  map_mul' := constVAdd_add _ _
#align affine_equiv.const_vadd_hom AffineEquiv.constVAddHom
-/

/- warning: affine_equiv.const_vadd_nsmul -> AffineEquiv.constVAdd_nsmul is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (n : Nat) (v : V₁), Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (SMul.smul.{0, u3} Nat V₁ (AddMonoid.SMul.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)))) n v)) (HPow.hPow.{max u2 u3, 0, max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Nat (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHPow.{max u2 u3, 0} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Nat (Monoid.Pow.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v) n)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (n : Nat) (v : V₁), Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (HSMul.hSMul.{0, u2, u2} Nat V₁ V₁ (instHSMul.{0, u2} Nat V₁ (AddMonoid.SMul.{u2} V₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))))) n v)) (HPow.hPow.{max u3 u2, 0, max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Nat (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHPow.{max u3 u2, 0} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Nat (Monoid.Pow.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4))))) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v) n)
Case conversion may be inaccurate. Consider using '#align affine_equiv.const_vadd_nsmul AffineEquiv.constVAdd_nsmulₓ'. -/
theorem constVAdd_nsmul (n : ℕ) (v : V₁) : constVAdd k P₁ (n • v) = constVAdd k P₁ v ^ n :=
  (constVAddHom k P₁).map_pow _ _
#align affine_equiv.const_vadd_nsmul AffineEquiv.constVAdd_nsmul

/- warning: affine_equiv.const_vadd_zsmul -> AffineEquiv.constVAdd_zsmul is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) (P₁ : Type.{u2}) {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (z : Int) (v : V₁), Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (SMul.smul.{0, u3} Int V₁ (SubNegMonoid.SMulInt.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) z v)) (HPow.hPow.{max u2 u3, 0, max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Int (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHPow.{max u2 u3, 0} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Int (DivInvMonoid.Pow.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineEquiv.constVAdd.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v) z)
but is expected to have type
  forall (k : Type.{u1}) (P₁ : Type.{u3}) {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (z : Int) (v : V₁), Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 (HSMul.hSMul.{0, u2, u2} Int V₁ V₁ (instHSMul.{0, u2} Int V₁ (SubNegMonoid.SMulInt.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)))) z v)) (HPow.hPow.{max u3 u2, 0, max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Int (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (instHPow.{max u3 u2, 0} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) Int (DivInvMonoid.Pow.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.group.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4)))) (AffineEquiv.constVAdd.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 v) z)
Case conversion may be inaccurate. Consider using '#align affine_equiv.const_vadd_zsmul AffineEquiv.constVAdd_zsmulₓ'. -/
theorem constVAdd_zsmul (z : ℤ) (v : V₁) : constVAdd k P₁ (z • v) = constVAdd k P₁ v ^ z :=
  (constVAddHom k P₁).map_zpow _ _
#align affine_equiv.const_vadd_zsmul AffineEquiv.constVAdd_zsmul

section Homothety

omit V₁

variable {R V P : Type _} [CommRing R] [AddCommGroup V] [Module R V] [affine_space V P]

include V

/- warning: affine_equiv.homothety_units_mul_hom -> AffineEquiv.homothetyUnitsMulHom is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_14 : CommRing.{u1} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)], P -> (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17)))))
but is expected to have type
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_14 : CommRing.{u1} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)], P -> (MonoidHom.{u1, max u2 u3} (Units.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14))))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u1} R (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17)))))
Case conversion may be inaccurate. Consider using '#align affine_equiv.homothety_units_mul_hom AffineEquiv.homothetyUnitsMulHomₓ'. -/
/-- Fixing a point in affine space, homothety about this point gives a group homomorphism from (the
centre of) the units of the scalars into the group of affine equivalences. -/
def homothetyUnitsMulHom (p : P) : Rˣ →* P ≃ᵃ[R] P :=
  equivUnitsAffineMap.symm.toMonoidHom.comp <| Units.map (AffineMap.homothetyHom p)
#align affine_equiv.homothety_units_mul_hom AffineEquiv.homothetyUnitsMulHom

/- warning: affine_equiv.coe_homothety_units_mul_hom_apply -> AffineEquiv.coe_homothetyUnitsMulHom_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_14 : CommRing.{u1} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)] (p : P) (t : Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))), Eq.{succ u3} ((fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ u1) (succ (max u3 u2))} (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (fun (_x : MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) => (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineEquiv.homothetyUnitsMulHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t)) (coeFn.{max (succ u3) (succ u2), succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (AffineEquiv.hasCoeToFun.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ u1) (succ (max u3 u2))} (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (fun (_x : MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) => (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineEquiv.homothetyUnitsMulHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t)) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.homothety.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_17 _inst_16 p ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14)))))) t)))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_14 : CommRing.{u3} R] [_inst_15 : AddCommGroup.{u1} V] [_inst_16 : Module.{u3, u1} R V (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_15)] [_inst_17 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_15)] (p : P) (t : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))), Eq.{succ u2} (forall (a : P), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P) => P) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P) => P) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P P (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P P (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17))) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u3, max (succ u1) (succ u2)} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (fun (_x : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) _x) (MulHomClass.toFunLike.{max (max u1 u2) u3, u3, max u1 u2} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulOneClass.toMul.{u3} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))))) (MulOneClass.toMul.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (MonoidHomClass.toMulHomClass.{max (max u1 u2) u3, u3, max u1 u2} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17)))) (MonoidHom.monoidHomClass.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))))) (AffineEquiv.homothetyUnitsMulHom.{u3, u1, u2} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t)) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u2} (AffineMap.{u3, u1, u2, u1, u2} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P) => P) _x) (AffineMap.funLike.{u3, u1, u2, u1, u2} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.homothety.{u3, u1, u2} R V P _inst_14 _inst_15 _inst_17 _inst_16 p (Units.val.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))) t)))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_homothety_units_mul_hom_apply AffineEquiv.coe_homothetyUnitsMulHom_applyₓ'. -/
@[simp]
theorem coe_homothetyUnitsMulHom_apply (p : P) (t : Rˣ) :
    (homothetyUnitsMulHom p t : P → P) = AffineMap.homothety p (t : R) :=
  rfl
#align affine_equiv.coe_homothety_units_mul_hom_apply AffineEquiv.coe_homothetyUnitsMulHom_apply

/- warning: affine_equiv.coe_homothety_units_mul_hom_apply_symm -> AffineEquiv.coe_homothetyUnitsMulHom_apply_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_14 : CommRing.{u1} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)] (p : P) (t : Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))), Eq.{succ u3} ((fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (AffineEquiv.symm.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17 (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ u1) (succ (max u3 u2))} (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (fun (_x : MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) => (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineEquiv.homothetyUnitsMulHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t))) (coeFn.{max (succ u3) (succ u2), succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (fun (_x : AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (AffineEquiv.hasCoeToFun.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.symm.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17 (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ u1) (succ (max u3 u2))} (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (fun (_x : MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) => (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineEquiv.homothetyUnitsMulHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t))) (coeFn.{max (succ u2) (succ u3), succ u3} (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (fun (_x : AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) => P -> P) (AffineMap.hasCoeToFun.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.homothety.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_17 _inst_16 p ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14)))))) (Inv.inv.{u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Units.hasInv.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) t))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u1}} {P : Type.{u2}} [_inst_14 : CommRing.{u3} R] [_inst_15 : AddCommGroup.{u1} V] [_inst_16 : Module.{u3, u1} R V (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_15)] [_inst_17 : AddTorsor.{u1, u2} V P (AddCommGroup.toAddGroup.{u1} V _inst_15)] (p : P) (t : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))), Eq.{succ u2} (forall (a : P), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P) => P) a) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P) => P) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P P (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P P (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17))) (AffineEquiv.symm.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17 (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u3, max (succ u1) (succ u2)} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (fun (_x : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) _x) (MulHomClass.toFunLike.{max (max u1 u2) u3, u3, max u1 u2} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulOneClass.toMul.{u3} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))))) (MulOneClass.toMul.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (MonoidHomClass.toMulHomClass.{max (max u1 u2) u3, u3, max u1 u2} (MonoidHom.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17)))) (MonoidHom.monoidHomClass.{u3, max u1 u2} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u1 u2} (AffineEquiv.{u3, u2, u2, u1, u1} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u2, u1} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))))) (AffineEquiv.homothetyUnitsMulHom.{u3, u1, u2} R V P _inst_14 _inst_15 _inst_16 _inst_17 p) t))) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u2} (AffineMap.{u3, u1, u2, u1, u2} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P) => P) _x) (AffineMap.funLike.{u3, u1, u2, u1, u2} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.homothety.{u3, u1, u2} R V P _inst_14 _inst_15 _inst_17 _inst_16 p (Units.val.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))) (Inv.inv.{u3} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Units.instInvUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) t))))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_homothety_units_mul_hom_apply_symm AffineEquiv.coe_homothetyUnitsMulHom_apply_symmₓ'. -/
@[simp]
theorem coe_homothetyUnitsMulHom_apply_symm (p : P) (t : Rˣ) :
    ((homothetyUnitsMulHom p t).symm : P → P) = AffineMap.homothety p (↑t⁻¹ : R) :=
  rfl
#align affine_equiv.coe_homothety_units_mul_hom_apply_symm AffineEquiv.coe_homothetyUnitsMulHom_apply_symm

/- warning: affine_equiv.coe_homothety_units_mul_hom_eq_homothety_hom_coe -> AffineEquiv.coe_homothetyUnitsMulHom_eq_homothetyHom_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {V : Type.{u2}} {P : Type.{u3}} [_inst_14 : CommRing.{u1} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u1, u2} R V (Ring.toSemiring.{u1} R (CommRing.toRing.{u1} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u3} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)] (p : P), Eq.{max (succ u1) (succ u2) (succ u3)} ((Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (Function.comp.{succ u1, max (succ u3) (succ u2), max (succ u2) (succ u3)} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) ((fun (a : Sort.{max (succ u3) (succ u2)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u3) (succ u2), max (succ u2) (succ u3)} a b] => self.0) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (HasLiftT.mk.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (CoeTCₓ.coe.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (coeBase.{max (succ u3) (succ u2), max (succ u2) (succ u3)} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.AffineMap.hasCoe.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17))))) (coeFn.{max (succ (max u3 u2)) (succ u1), max (succ u1) (succ (max u3 u2))} (MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (fun (_x : MonoidHom.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) => (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) -> (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u3 u2} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.mulOneClass.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) (Monoid.toMulOneClass.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u3 u2} (AffineEquiv.{u1, u3, u3, u2, u2} R P P V V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u1, u3, u2} R P V (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineEquiv.homothetyUnitsMulHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_16 _inst_17 p))) (Function.comp.{succ u1, succ u1, max (succ u2) (succ u3)} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (coeFn.{max (succ (max u2 u3)) (succ u1), max (succ u1) (succ (max u2 u3))} (MonoidHom.{u1, max u2 u3} R (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.monoid.{u1, u2, u3} R V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))) (fun (_x : MonoidHom.{u1, max u2 u3} R (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.monoid.{u1, u2, u3} R V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))) => R -> (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (MonoidHom.hasCoeToFun.{u1, max u2 u3} R (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u3} (AffineMap.{u1, u2, u3, u2, u3} R V P V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.monoid.{u1, u2, u3} R V P (CommRing.toRing.{u1} R _inst_14) _inst_15 _inst_16 _inst_17))) (AffineMap.homothetyHom.{u1, u2, u3} R V P _inst_14 _inst_15 _inst_17 _inst_16 p)) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (CoeTCₓ.coe.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (coeBase.{succ u1, succ u1} (Units.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))) R (Units.hasCoe.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_14))))))))
but is expected to have type
  forall {R : Type.{u3}} {V : Type.{u2}} {P : Type.{u1}} [_inst_14 : CommRing.{u3} R] [_inst_15 : AddCommGroup.{u2} V] [_inst_16 : Module.{u3, u2} R V (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_15)] [_inst_17 : AddTorsor.{u2, u1} V P (AddCommGroup.toAddGroup.{u2} V _inst_15)] (p : P), Eq.{max (max (succ u3) (succ u2)) (succ u1)} ((Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) -> (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17)) (Function.comp.{succ u3, max (succ u2) (succ u1), max (succ u2) (succ u1)} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.toAffineMap.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u3, max (succ u2) (succ u1)} (MonoidHom.{u3, max u2 u1} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (fun (_x : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) => AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) _x) (MulHomClass.toFunLike.{max (max u2 u1) u3, u3, max u2 u1} (MonoidHom.{u3, max u2 u1} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulOneClass.toMul.{u3} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))))) (MulOneClass.toMul.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (MonoidHomClass.toMulHomClass.{max (max u2 u1) u3, u3, max u2 u1} (MonoidHom.{u3, max u2 u1} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17)))) (MonoidHom.monoidHomClass.{u3, max u2 u1} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Units.instMulOneClassUnits.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (DivInvMonoid.toMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Group.toDivInvMonoid.{max u2 u1} (AffineEquiv.{u3, u1, u1, u2, u2} R P P V V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineEquiv.group.{u3, u1, u2} R P V (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))))) (AffineEquiv.homothetyUnitsMulHom.{u3, u2, u1} R V P _inst_14 _inst_15 _inst_16 _inst_17 p))) (Function.comp.{succ u3, succ u3, max (succ u2) (succ u1)} (Units.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), succ u3, max (succ u2) (succ u1)} (MonoidHom.{u3, max u1 u2} R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) _x) (MulHomClass.toFunLike.{max (max u2 u1) u3, u3, max u2 u1} (MonoidHom.{u3, max u1 u2} R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))) R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulOneClass.toMul.{u3} R (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14)))))) (MulOneClass.toMul.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))) (MonoidHomClass.toMulHomClass.{max (max u2 u1) u3, u3, max u2 u1} (MonoidHom.{u3, max u1 u2} R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))) R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17)) (MonoidHom.monoidHomClass.{u3, max u2 u1} R (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (MulZeroOneClass.toMulOneClass.{u3} R (NonAssocSemiring.toMulZeroOneClass.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))) (Monoid.toMulOneClass.{max u2 u1} (AffineMap.{u3, u2, u1, u2, u1} R V P V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17 _inst_15 _inst_16 _inst_17) (AffineMap.instMonoidAffineMap.{u3, u2, u1} R V P (CommRing.toRing.{u3} R _inst_14) _inst_15 _inst_16 _inst_17))))) (AffineMap.homothetyHom.{u3, u2, u1} R V P _inst_14 _inst_15 _inst_17 _inst_16 p)) (Units.val.{u3} R (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_14))))))
Case conversion may be inaccurate. Consider using '#align affine_equiv.coe_homothety_units_mul_hom_eq_homothety_hom_coe AffineEquiv.coe_homothetyUnitsMulHom_eq_homothetyHom_coeₓ'. -/
@[simp]
theorem coe_homothetyUnitsMulHom_eq_homothetyHom_coe (p : P) :
    (coe : (P ≃ᵃ[R] P) → P →ᵃ[R] P) ∘ homothetyUnitsMulHom p =
      AffineMap.homothetyHom p ∘ (coe : Rˣ → R) :=
  funext fun _ => rfl
#align affine_equiv.coe_homothety_units_mul_hom_eq_homothety_hom_coe AffineEquiv.coe_homothetyUnitsMulHom_eq_homothetyHom_coe

end Homothety

variable {P₁}

open Function

#print AffineEquiv.pointReflection /-
/-- Point reflection in `x` as a permutation. -/
def pointReflection (x : P₁) : P₁ ≃ᵃ[k] P₁ :=
  (constVSub k x).trans (vaddConst k x)
#align affine_equiv.point_reflection AffineEquiv.pointReflection
-/

/- warning: affine_equiv.point_reflection_apply -> AffineEquiv.pointReflection_apply is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁) (y : P₁), Eq.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) (VSub.vsub.{u3, u2} V₁ P₁ (AddTorsor.toHasVsub.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4) x y) x)
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (x : P₁) (y : P₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) y) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) (HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) (VSub.vsub.{u2, u3} V₁ P₁ (AddTorsor.toVSub.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4) x y) x)
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_apply AffineEquiv.pointReflection_applyₓ'. -/
theorem pointReflection_apply (x y : P₁) : pointReflection k x y = x -ᵥ y +ᵥ x :=
  rfl
#align affine_equiv.point_reflection_apply AffineEquiv.pointReflection_apply

/- warning: affine_equiv.point_reflection_symm -> AffineEquiv.pointReflection_symm is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁), Eq.{max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (x : P₁), Eq.{max (succ u3) (succ u2)} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.symm.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.pointReflection.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)) (AffineEquiv.pointReflection.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_symm AffineEquiv.pointReflection_symmₓ'. -/
@[simp]
theorem pointReflection_symm (x : P₁) : (pointReflection k x).symm = pointReflection k x :=
  toEquiv_injective <| Equiv.pointReflection_symm x
#align affine_equiv.point_reflection_symm AffineEquiv.pointReflection_symm

/- warning: affine_equiv.to_equiv_point_reflection -> AffineEquiv.toEquiv_pointReflection is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁), Eq.{succ u2} (Equiv.{succ u2, succ u2} P₁ P₁) (AffineEquiv.toEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)) (Equiv.pointReflection.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4 x)
but is expected to have type
  forall (k : Type.{u2}) {P₁ : Type.{u3}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u2} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u2, u1} k V₁ (Ring.toSemiring.{u2} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] (x : P₁), Eq.{succ u3} (Equiv.{succ u3, succ u3} P₁ P₁) (AffineEquiv.toEquiv.{u2, u3, u3, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4 (AffineEquiv.pointReflection.{u2, u3, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x)) (Equiv.pointReflection.{u1, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2) _inst_4 x)
Case conversion may be inaccurate. Consider using '#align affine_equiv.to_equiv_point_reflection AffineEquiv.toEquiv_pointReflectionₓ'. -/
@[simp]
theorem toEquiv_pointReflection (x : P₁) :
    (pointReflection k x).toEquiv = Equiv.pointReflection x :=
  rfl
#align affine_equiv.to_equiv_point_reflection AffineEquiv.toEquiv_pointReflection

/- warning: affine_equiv.point_reflection_self -> AffineEquiv.pointReflection_self is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁), Eq.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) x) x
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (x : P₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) x) x
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_self AffineEquiv.pointReflection_selfₓ'. -/
@[simp]
theorem pointReflection_self (x : P₁) : pointReflection k x x = x :=
  vsub_vadd _ _
#align affine_equiv.point_reflection_self AffineEquiv.pointReflection_self

/- warning: affine_equiv.point_reflection_involutive -> AffineEquiv.pointReflection_involutive is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (x : P₁), Function.Involutive.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x))
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (x : P₁), Function.Involutive.{succ u3} P₁ (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u1, u3, u2} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x))
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_involutive AffineEquiv.pointReflection_involutiveₓ'. -/
theorem pointReflection_involutive (x : P₁) : Involutive (pointReflection k x : P₁ → P₁) :=
  Equiv.pointReflection_involutive x
#align affine_equiv.point_reflection_involutive AffineEquiv.pointReflection_involutive

/- warning: affine_equiv.point_reflection_fixed_iff_of_injective_bit0 -> AffineEquiv.pointReflection_fixed_iff_of_injective_bit0 is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] {x : P₁} {y : P₁}, (Function.Injective.{succ u3, succ u3} V₁ V₁ (bit0.{u3} V₁ (AddZeroClass.toHasAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))))))) -> (Iff (Eq.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) y) (Eq.{succ u2} P₁ y x))
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] {x : P₁} {y : P₁}, (Function.Injective.{succ u3, succ u3} V₁ V₁ (bit0.{u3} V₁ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))))))) -> (Iff (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) y) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) y) (Eq.{succ u2} P₁ y x))
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_fixed_iff_of_injective_bit0 AffineEquiv.pointReflection_fixed_iff_of_injective_bit0ₓ'. -/
/-- `x` is the only fixed point of `point_reflection x`. This lemma requires
`x + x = y + y ↔ x = y`. There is no typeclass to use here, so we add it as an explicit argument. -/
theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P₁} (h : Injective (bit0 : V₁ → V₁)) :
    pointReflection k x y = y ↔ y = x :=
  Equiv.pointReflection_fixed_iff_of_injective_bit0 h
#align affine_equiv.point_reflection_fixed_iff_of_injective_bit0 AffineEquiv.pointReflection_fixed_iff_of_injective_bit0

/- warning: affine_equiv.injective_point_reflection_left_of_injective_bit0 -> AffineEquiv.injective_pointReflection_left_of_injective_bit0 is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], (Function.Injective.{succ u3, succ u3} V₁ V₁ (bit0.{u3} V₁ (AddZeroClass.toHasAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))))))) -> (forall (y : P₁), Function.Injective.{succ u2, succ u2} P₁ P₁ (fun (x : P₁) => coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y))
but is expected to have type
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)], (Function.Injective.{succ u3, succ u3} V₁ V₁ (bit0.{u3} V₁ (AddZeroClass.toAdd.{u3} V₁ (AddMonoid.toAddZeroClass.{u3} V₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))))))) -> (forall (y : P₁), Function.Injective.{succ u2, succ u2} P₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) y) (fun (x : P₁) => FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y))
Case conversion may be inaccurate. Consider using '#align affine_equiv.injective_point_reflection_left_of_injective_bit0 AffineEquiv.injective_pointReflection_left_of_injective_bit0ₓ'. -/
theorem injective_pointReflection_left_of_injective_bit0 (h : Injective (bit0 : V₁ → V₁)) (y : P₁) :
    Injective fun x : P₁ => pointReflection k x y :=
  Equiv.injective_pointReflection_left_of_injective_bit0 h y
#align affine_equiv.injective_point_reflection_left_of_injective_bit0 AffineEquiv.injective_pointReflection_left_of_injective_bit0

/- warning: affine_equiv.injective_point_reflection_left_of_module -> AffineEquiv.injective_pointReflection_left_of_module is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_14 : Invertible.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1)) (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1)) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))] (y : P₁), Function.Injective.{succ u2, succ u2} P₁ P₁ (fun (x : P₁) => coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y)
but is expected to have type
  forall (k : Type.{u3}) {P₁ : Type.{u2}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] [_inst_14 : Invertible.{u3} k (NonUnitalNonAssocRing.toMul.{u3} k (NonUnitalRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonUnitalRing.{u3} k _inst_1))) (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (Semiring.toNatCast.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] (y : P₁), Function.Injective.{succ u2, succ u2} P₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) y) (fun (x : P₁) => FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u3, u2, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y)
Case conversion may be inaccurate. Consider using '#align affine_equiv.injective_point_reflection_left_of_module AffineEquiv.injective_pointReflection_left_of_moduleₓ'. -/
theorem injective_pointReflection_left_of_module [Invertible (2 : k)] :
    ∀ y, Injective fun x : P₁ => pointReflection k x y :=
  injective_pointReflection_left_of_injective_bit0 k fun x y h => by
    rwa [bit0, bit0, ← two_smul k x, ← two_smul k y,
      (isUnit_of_invertible (2 : k)).smul_left_cancel] at h
#align affine_equiv.injective_point_reflection_left_of_module AffineEquiv.injective_pointReflection_left_of_module

/- warning: affine_equiv.point_reflection_fixed_iff_of_module -> AffineEquiv.pointReflection_fixed_iff_of_module is a dubious translation:
lean 3 declaration is
  forall (k : Type.{u1}) {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] [_inst_14 : Invertible.{u1} k (Distrib.toHasMul.{u1} k (Ring.toDistrib.{u1} k _inst_1)) (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) (OfNat.ofNat.{u1} k 2 (OfNat.mk.{u1} k 2 (bit0.{u1} k (Distrib.toHasAdd.{u1} k (Ring.toDistrib.{u1} k _inst_1)) (One.one.{u1} k (AddMonoidWithOne.toOne.{u1} k (AddGroupWithOne.toAddMonoidWithOne.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1))))))))] {x : P₁} {y : P₁}, Iff (Eq.{succ u2} P₁ (coeFn.{max (succ u2) (succ u3), succ u2} (AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (fun (_x : AffineEquiv.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u1, u2, u2, u3, u3} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) (AffineEquiv.pointReflection.{u1, u2, u3} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) y) (Eq.{succ u2} P₁ y x)
but is expected to have type
  forall (k : Type.{u3}) {P₁ : Type.{u2}} {V₁ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u1} V₁] [_inst_3 : Module.{u3, u1} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₁ _inst_2)] [_inst_4 : AddTorsor.{u1, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u1} V₁ _inst_2)] [_inst_14 : Invertible.{u3} k (NonUnitalNonAssocRing.toMul.{u3} k (NonUnitalRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonUnitalRing.{u3} k _inst_1))) (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (OfNat.ofNat.{u3} k 2 (instOfNat.{u3} k 2 (Semiring.toNatCast.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (instAtLeastTwoHAddNatInstHAddInstAddNatOfNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)))))] {x : P₁} {y : P₁}, Iff (Eq.{succ u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) y) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u2} (AffineEquiv.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u3, u2, u2, u1, u1} k P₁ P₁ V₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 _inst_2 _inst_3 _inst_4))) (AffineEquiv.pointReflection.{u3, u2, u1} k P₁ V₁ _inst_1 _inst_2 _inst_3 _inst_4 x) y) y) (Eq.{succ u2} P₁ y x)
Case conversion may be inaccurate. Consider using '#align affine_equiv.point_reflection_fixed_iff_of_module AffineEquiv.pointReflection_fixed_iff_of_moduleₓ'. -/
theorem pointReflection_fixed_iff_of_module [Invertible (2 : k)] {x y : P₁} :
    pointReflection k x y = y ↔ y = x :=
  ((injective_pointReflection_left_of_module k y).eq_iff' (pointReflection_self k y)).trans eq_comm
#align affine_equiv.point_reflection_fixed_iff_of_module AffineEquiv.pointReflection_fixed_iff_of_module

end AffineEquiv

namespace LinearEquiv

#print LinearEquiv.toAffineEquiv /-
/-- Interpret a linear equivalence between modules as an affine equivalence. -/
def toAffineEquiv (e : V₁ ≃ₗ[k] V₂) : V₁ ≃ᵃ[k] V₂
    where
  toEquiv := e.toEquiv
  linear := e
  map_vadd' p v := e.map_add v p
#align linear_equiv.to_affine_equiv LinearEquiv.toAffineEquiv
-/

/- warning: linear_equiv.coe_to_affine_equiv -> LinearEquiv.coe_toAffineEquiv is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {V₁ : Type.{u2}} {V₂ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u3} V₂] [_inst_6 : Module.{u1, u3} k V₂ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5)] (e : LinearEquiv.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5) _inst_3 _inst_6), Eq.{max (succ u2) (succ u3)} (V₁ -> V₂) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AffineEquiv.{u1, u2, u3, u2, u3} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5))) (fun (_x : AffineEquiv.{u1, u2, u3, u2, u3} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5))) => V₁ -> V₂) (AffineEquiv.hasCoeToFun.{u1, u2, u3, u2, u3} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u3} V₂ (AddCommGroup.toAddGroup.{u3} V₂ _inst_5))) (LinearEquiv.toAffineEquiv.{u1, u2, u3} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5) _inst_3 _inst_6) (fun (_x : LinearEquiv.{u1, u1, u2, u3} k k (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5) _inst_3 _inst_6) => V₁ -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} k k V₁ V₂ (Ring.toSemiring.{u1} k _inst_1) (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHom.id.{u1} k (Semiring.toNonAssocSemiring.{u1} k (Ring.toSemiring.{u1} k _inst_1))) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (RingHomInvPair.ids.{u1} k (Ring.toSemiring.{u1} k _inst_1))) e)
but is expected to have type
  forall {k : Type.{u3}} {V₁ : Type.{u2}} {V₂ : Type.{u1}} [_inst_1 : Ring.{u3} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_5 : AddCommGroup.{u1} V₂] [_inst_6 : Module.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)] (e : LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6), Eq.{max (succ u2) (succ u1)} (forall (ᾰ : V₁), (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : V₁) => V₂) ᾰ) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (AffineEquiv.{u3, u2, u1, u2, u1} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5))) V₁ (fun (_x : V₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : V₁) => V₂) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u1), succ u2, succ u1} (AffineEquiv.{u3, u2, u1, u2, u1} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5))) V₁ V₂ (EquivLike.toEmbeddingLike.{max (succ u2) (succ u1), succ u2, succ u1} (AffineEquiv.{u3, u2, u1, u2, u1} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5))) V₁ V₂ (AffineEquiv.equivLike.{u3, u2, u1, u2, u1} k V₁ V₂ V₁ V₂ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) _inst_5 _inst_6 (addGroupIsAddTorsor.{u1} V₂ (AddCommGroup.toAddGroup.{u1} V₂ _inst_5))))) (LinearEquiv.toAffineEquiv.{u3, u2, u1} k V₁ V₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 e)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) V₁ (fun (_x : V₁) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V₁) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (SMulZeroClass.toSMul.{u3, u2} k V₁ (AddMonoid.toZero.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribSMul.toSMulZeroClass.{u3, u2} k V₁ (AddMonoid.toAddZeroClass.{u2} V₁ (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2))) (DistribMulAction.toDistribSMul.{u3, u2} k V₁ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u3, u1} k V₂ (AddMonoid.toZero.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribSMul.toSMulZeroClass.{u3, u1} k V₂ (AddMonoid.toAddZeroClass.{u1} V₂ (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5))) (DistribMulAction.toDistribSMul.{u3, u1} k V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u1, u3, u2, u1} (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) k V₁ V₂ (MonoidWithZero.toMonoid.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (AddCommMonoid.toAddMonoid.{u2} V₁ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)) (AddCommMonoid.toAddMonoid.{u1} V₂ (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5)) (Module.toDistribMulAction.{u3, u2} k V₁ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) _inst_3) (Module.toDistribMulAction.{u3, u1} k V₂ (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_6) (SemilinearMapClass.distribMulActionHomClass.{u3, u2, u1, max u2 u1} k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (SemilinearEquivClass.instSemilinearMapClass.{u3, u3, u2, u1, max u2 u1} k k V₁ V₂ (LinearEquiv.{u3, u3, u2, u1} k k (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) V₁ V₂ (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6) (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u3, u3, u2, u1} k k V₁ V₂ (Ring.toSemiring.{u3} k _inst_1) (Ring.toSemiring.{u3} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2) (AddCommGroup.toAddCommMonoid.{u1} V₂ _inst_5) _inst_3 _inst_6 (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHom.id.{u3} k (Semiring.toNonAssocSemiring.{u3} k (Ring.toSemiring.{u3} k _inst_1))) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1)) (RingHomInvPair.ids.{u3} k (Ring.toSemiring.{u3} k _inst_1))))))) e)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_to_affine_equiv LinearEquiv.coe_toAffineEquivₓ'. -/
@[simp]
theorem coe_toAffineEquiv (e : V₁ ≃ₗ[k] V₂) : ⇑e.toAffineEquiv = e :=
  rfl
#align linear_equiv.coe_to_affine_equiv LinearEquiv.coe_toAffineEquiv

end LinearEquiv

namespace AffineMap

open AffineEquiv

include V₁

/- warning: affine_map.line_map_vadd -> AffineMap.lineMap_vadd is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (v : V₁) (v' : V₁) (p : P₁) (c : k), Eq.{succ u2} P₁ (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) (coeFn.{max (succ u1) (succ u3), max (succ u1) (succ u3)} (AffineMap.{u1, u1, u1, u3, u3} k k k V₁ V₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (fun (_x : AffineMap.{u1, u1, u1, u3, u3} k k k V₁ V₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) => k -> V₁) (AffineMap.hasCoeToFun.{u1, u1, u1, u3, u3} k k k V₁ V₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AffineMap.lineMap.{u1, u3, u3} k V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)) v v') c) p) (coeFn.{max (succ u1) (succ u3) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P₁) (AffineMap.hasCoeToFun.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) v p) (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) v' p)) c)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (v : V₁) (v' : V₁) (p : P₁) (c : k), Eq.{succ u3} P₁ (HVAdd.hVAdd.{u2, u3, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) P₁ P₁ (instHVAdd.{u2, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) P₁ (AddAction.toVAdd.{u2, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) P₁ (SubNegMonoid.toAddMonoid.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) (AddGroup.toSubNegMonoid.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) (AddCommGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) _inst_2))) (AddTorsor.toAddAction.{u2, u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) P₁ (AddCommGroup.toAddGroup.{u2} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) c) _inst_2) _inst_4))) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (AffineMap.{u1, u1, u1, u2, u2} k k k V₁ V₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => V₁) _x) (AffineMap.funLike.{u1, u1, u1, u2, u2} k k k V₁ V₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AffineMap.lineMap.{u1, u2, u2} k V₁ V₁ _inst_1 _inst_2 _inst_3 (addGroupIsAddTorsor.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)) v v') c) p) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u1, succ u3} (AffineMap.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) _x) (AffineMap.funLike.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p) (HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v' p)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.line_map_vadd AffineMap.lineMap_vaddₓ'. -/
theorem lineMap_vadd (v v' : V₁) (p : P₁) (c : k) :
    lineMap v v' c +ᵥ p = lineMap (v +ᵥ p) (v' +ᵥ p) c :=
  (vaddConst k p).apply_lineMap v v' c
#align affine_map.line_map_vadd AffineMap.lineMap_vadd

#print AffineMap.lineMap_vsub /-
theorem lineMap_vsub (p₁ p₂ p₃ : P₁) (c : k) :
    lineMap p₁ p₂ c -ᵥ p₃ = lineMap (p₁ -ᵥ p₃) (p₂ -ᵥ p₃) c :=
  (vaddConst k p₃).symm.apply_lineMap p₁ p₂ c
#align affine_map.line_map_vsub AffineMap.lineMap_vsub
-/

#print AffineMap.vsub_lineMap /-
theorem vsub_lineMap (p₁ p₂ p₃ : P₁) (c : k) :
    p₁ -ᵥ lineMap p₂ p₃ c = lineMap (p₁ -ᵥ p₂) (p₁ -ᵥ p₃) c :=
  (constVSub k p₁).apply_lineMap p₂ p₃ c
#align affine_map.vsub_line_map AffineMap.vsub_lineMap
-/

/- warning: affine_map.vadd_line_map -> AffineMap.vadd_lineMap is a dubious translation:
lean 3 declaration is
  forall {k : Type.{u1}} {P₁ : Type.{u2}} {V₁ : Type.{u3}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u3} V₁] [_inst_3 : Module.{u1, u3} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u3} V₁ _inst_2)] [_inst_4 : AddTorsor.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2)] (v : V₁) (p₁ : P₁) (p₂ : P₁) (c : k), Eq.{succ u2} P₁ (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) v (coeFn.{max (succ u1) (succ u3) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P₁) (AffineMap.hasCoeToFun.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) c)) (coeFn.{max (succ u1) (succ u3) (succ u2), max (succ u1) (succ u2)} (AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (fun (_x : AffineMap.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) => k -> P₁) (AffineMap.hasCoeToFun.{u1, u1, u1, u3, u2} k k k V₁ P₁ _inst_1 (NonUnitalNonAssocRing.toAddCommGroup.{u1} k (NonAssocRing.toNonUnitalNonAssocRing.{u1} k (Ring.toNonAssocRing.{u1} k _inst_1))) (Semiring.toModule.{u1} k (Ring.toSemiring.{u1} k _inst_1)) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (AddCommGroupWithOne.toAddGroupWithOne.{u1} k (Ring.toAddCommGroupWithOne.{u1} k _inst_1)))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u3, u2} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) v p₁) (VAdd.vadd.{u3, u2} V₁ P₁ (AddAction.toHasVadd.{u3, u2} V₁ P₁ (SubNegMonoid.toAddMonoid.{u3} V₁ (AddGroup.toSubNegMonoid.{u3} V₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2))) (AddTorsor.toAddAction.{u3, u2} V₁ P₁ (AddCommGroup.toAddGroup.{u3} V₁ _inst_2) _inst_4)) v p₂)) c)
but is expected to have type
  forall {k : Type.{u1}} {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_1 : Ring.{u1} k] [_inst_2 : AddCommGroup.{u2} V₁] [_inst_3 : Module.{u1, u2} k V₁ (Ring.toSemiring.{u1} k _inst_1) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] (v : V₁) (p₁ : P₁) (p₂ : P₁) (c : k), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) (HVAdd.hVAdd.{u2, u3, u3} V₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) (instHVAdd.{u2, u3} V₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) (AddAction.toVAdd.{u2, u3} V₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) c) (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u1, succ u3} (AffineMap.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) _x) (AffineMap.funLike.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 p₁ p₂) c)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), succ u1, succ u3} (AffineMap.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) k (fun (_x : k) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : k) => P₁) _x) (AffineMap.funLike.{u1, u1, u1, u2, u3} k k k V₁ P₁ _inst_1 (Ring.toAddCommGroup.{u1} k _inst_1) (AffineMap.instModuleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocRingToNonUnitalRing.{u1} k _inst_1) (addGroupIsAddTorsor.{u1} k (AddGroupWithOne.toAddGroup.{u1} k (Ring.toAddGroupWithOne.{u1} k _inst_1))) _inst_2 _inst_3 _inst_4) (AffineMap.lineMap.{u1, u2, u3} k V₁ P₁ _inst_1 _inst_2 _inst_3 _inst_4 (HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p₁) (HVAdd.hVAdd.{u2, u3, u3} V₁ P₁ P₁ (instHVAdd.{u2, u3} V₁ P₁ (AddAction.toVAdd.{u2, u3} V₁ P₁ (SubNegMonoid.toAddMonoid.{u2} V₁ (AddGroup.toSubNegMonoid.{u2} V₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2))) (AddTorsor.toAddAction.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2) _inst_4))) v p₂)) c)
Case conversion may be inaccurate. Consider using '#align affine_map.vadd_line_map AffineMap.vadd_lineMapₓ'. -/
theorem vadd_lineMap (v : V₁) (p₁ p₂ : P₁) (c : k) :
    v +ᵥ lineMap p₁ p₂ c = lineMap (v +ᵥ p₁) (v +ᵥ p₂) c :=
  (constVAdd k P₁ v).apply_lineMap p₁ p₂ c
#align affine_map.vadd_line_map AffineMap.vadd_lineMap

variable {R' : Type _} [CommRing R'] [Module R' V₁]

/- warning: affine_map.homothety_neg_one_apply -> AffineMap.homothety_neg_one_apply is a dubious translation:
lean 3 declaration is
  forall {P₁ : Type.{u1}} {V₁ : Type.{u2}} [_inst_2 : AddCommGroup.{u2} V₁] [_inst_4 : AddTorsor.{u2, u1} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] {R' : Type.{u3}} [_inst_14 : CommRing.{u3} R'] [_inst_15 : Module.{u3, u2} R' V₁ (Ring.toSemiring.{u3} R' (CommRing.toRing.{u3} R' _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] (c : P₁) (p : P₁), Eq.{succ u1} P₁ (coeFn.{max (succ u2) (succ u1), succ u1} (AffineMap.{u3, u2, u1, u2, u1} R' V₁ P₁ V₁ P₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) (fun (_x : AffineMap.{u3, u2, u1, u2, u1} R' V₁ P₁ V₁ P₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) => P₁ -> P₁) (AffineMap.hasCoeToFun.{u3, u2, u1, u2, u1} R' V₁ P₁ V₁ P₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) (AffineMap.homothety.{u3, u2, u1} R' V₁ P₁ _inst_14 _inst_2 _inst_4 _inst_15 c (Neg.neg.{u3} R' (SubNegMonoid.toHasNeg.{u3} R' (AddGroup.toSubNegMonoid.{u3} R' (AddGroupWithOne.toAddGroup.{u3} R' (AddCommGroupWithOne.toAddGroupWithOne.{u3} R' (Ring.toAddCommGroupWithOne.{u3} R' (CommRing.toRing.{u3} R' _inst_14)))))) (OfNat.ofNat.{u3} R' 1 (OfNat.mk.{u3} R' 1 (One.one.{u3} R' (AddMonoidWithOne.toOne.{u3} R' (AddGroupWithOne.toAddMonoidWithOne.{u3} R' (AddCommGroupWithOne.toAddGroupWithOne.{u3} R' (Ring.toAddCommGroupWithOne.{u3} R' (CommRing.toRing.{u3} R' _inst_14)))))))))) p) (coeFn.{max (succ u1) (succ u2), succ u1} (AffineEquiv.{u3, u1, u1, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) (fun (_x : AffineEquiv.{u3, u1, u1, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) => P₁ -> P₁) (AffineEquiv.hasCoeToFun.{u3, u1, u1, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) (AffineEquiv.pointReflection.{u3, u1, u2} R' P₁ V₁ (CommRing.toRing.{u3} R' _inst_14) _inst_2 _inst_15 _inst_4 c) p)
but is expected to have type
  forall {P₁ : Type.{u3}} {V₁ : Type.{u2}} [_inst_2 : AddCommGroup.{u2} V₁] [_inst_4 : AddTorsor.{u2, u3} V₁ P₁ (AddCommGroup.toAddGroup.{u2} V₁ _inst_2)] {R' : Type.{u1}} [_inst_14 : CommRing.{u1} R'] [_inst_15 : Module.{u1, u2} R' V₁ (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_14)) (AddCommGroup.toAddCommMonoid.{u2} V₁ _inst_2)] (c : P₁) (p : P₁), Eq.{succ u3} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₁) p) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u3} (AffineMap.{u1, u2, u3, u2, u3} R' V₁ P₁ V₁ P₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1004 : P₁) => P₁) _x) (AffineMap.funLike.{u1, u2, u3, u2, u3} R' V₁ P₁ V₁ P₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) (AffineMap.homothety.{u1, u2, u3} R' V₁ P₁ _inst_14 _inst_2 _inst_4 _inst_15 c (Neg.neg.{u1} R' (Ring.toNeg.{u1} R' (CommRing.toRing.{u1} R' _inst_14)) (OfNat.ofNat.{u1} R' 1 (One.toOfNat1.{u1} R' (Semiring.toOne.{u1} R' (Ring.toSemiring.{u1} R' (CommRing.toRing.{u1} R' _inst_14))))))) p) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) P₁ (fun (_x : P₁) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineEquiv._hyg.1471 : P₁) => P₁) _x) (EmbeddingLike.toFunLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) P₁ P₁ (EquivLike.toEmbeddingLike.{max (succ u3) (succ u2), succ u3, succ u3} (AffineEquiv.{u1, u3, u3, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4) P₁ P₁ (AffineEquiv.equivLike.{u1, u3, u3, u2, u2} R' P₁ P₁ V₁ V₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 _inst_2 _inst_15 _inst_4))) (AffineEquiv.pointReflection.{u1, u3, u2} R' P₁ V₁ (CommRing.toRing.{u1} R' _inst_14) _inst_2 _inst_15 _inst_4 c) p)
Case conversion may be inaccurate. Consider using '#align affine_map.homothety_neg_one_apply AffineMap.homothety_neg_one_applyₓ'. -/
theorem homothety_neg_one_apply (c p : P₁) : homothety c (-1 : R') p = pointReflection R' c p := by
  simp [homothety_apply, point_reflection_apply]
#align affine_map.homothety_neg_one_apply AffineMap.homothety_neg_one_apply

end AffineMap

