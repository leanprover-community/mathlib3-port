/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash

! This file was ported from Lean 3 source module linear_algebra.affine_space.matrix
! leanprover-community/mathlib commit fe8d0ff42c3c24d789f491dc2622b6cac3d61564
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.AffineSpace.Basis
import Mathbin.LinearAlgebra.Determinant

/-!
# Matrix results for barycentric co-ordinates

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Results about the matrix of barycentric co-ordinates for a family of points in an affine space, with
respect to some affine basis.
-/


open Affine BigOperators Matrix

open Set

universe u₁ u₂ u₃ u₄

variable {ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄}

variable [AddCommGroup V] [affine_space V P]

namespace AffineBasis

section Ring

variable [Ring k] [Module k V] (b : AffineBasis ι k P)

#print AffineBasis.toMatrix /-
/-- Given an affine basis `p`, and a family of points `q : ι' → P`, this is the matrix whose
rows are the barycentric coordinates of `q` with respect to `p`.

It is an affine equivalent of `basis.to_matrix`. -/
noncomputable def toMatrix {ι' : Type _} (q : ι' → P) : Matrix ι' ι k := fun i j => b.Coord j (q i)
#align affine_basis.to_matrix AffineBasis.toMatrix
-/

/- warning: affine_basis.to_matrix_apply -> AffineBasis.toMatrix_apply is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u5}} (q : ι' -> P) (i : ι') (j : ι), Eq.{succ u2} k (AffineBasis.toMatrix.{u1, u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' q i j) (coeFn.{max (succ u3) (succ u4) (succ u2), max (succ u4) (succ u2)} (AffineMap.{u2, u3, u4, u2, u2} k V P k k _inst_3 _inst_1 _inst_4 _inst_2 (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_3)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))) (fun (_x : AffineMap.{u2, u3, u4, u2, u2} k V P k k _inst_3 _inst_1 _inst_4 _inst_2 (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_3)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))) => P -> k) (AffineMap.hasCoeToFun.{u2, u3, u4, u2, u2} k V P k k _inst_3 _inst_1 _inst_4 _inst_2 (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k _inst_3)) (addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))) (AffineBasis.coord.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b j) (q i))
but is expected to have type
  forall {ι : Type.{u2}} {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u5}} [_inst_1 : AddCommGroup.{u4} V] [_inst_2 : AddTorsor.{u4, u5} V P (AddCommGroup.toAddGroup.{u4} V _inst_1)] [_inst_3 : Ring.{u3} k] [_inst_4 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_3) (AddCommGroup.toAddCommMonoid.{u4} V _inst_1)] (b : AffineBasis.{u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u1}} (q : ι' -> P) (i : ι') (j : ι), Eq.{succ u3} k (AffineBasis.toMatrix.{u2, u3, u4, u5, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' q i j) (FunLike.coe.{max (max (succ u4) (succ u5)) (succ u3), succ u5, succ u3} (AffineMap.{u3, u4, u5, u3, u3} k V P k k _inst_3 _inst_1 _inst_4 _inst_2 (Ring.toAddCommGroup.{u3} k _inst_3) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_3)) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_3)))) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => k) _x) (AffineMap.funLike.{u3, u4, u5, u3, u3} k V P k k _inst_3 _inst_1 _inst_4 _inst_2 (Ring.toAddCommGroup.{u3} k _inst_3) (Semiring.toModule.{u3} k (Ring.toSemiring.{u3} k _inst_3)) (addGroupIsAddTorsor.{u3} k (AddGroupWithOne.toAddGroup.{u3} k (Ring.toAddGroupWithOne.{u3} k _inst_3)))) (AffineBasis.coord.{u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b j) (q i))
Case conversion may be inaccurate. Consider using '#align affine_basis.to_matrix_apply AffineBasis.toMatrix_applyₓ'. -/
@[simp]
theorem toMatrix_apply {ι' : Type _} (q : ι' → P) (i : ι') (j : ι) :
    b.toMatrix q i j = b.Coord j (q i) :=
  rfl
#align affine_basis.to_matrix_apply AffineBasis.toMatrix_apply

/- warning: affine_basis.to_matrix_self -> AffineBasis.toMatrix_self is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : DecidableEq.{succ u1} ι], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} ι ι k) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4)) b)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.hasOne.{u2, u1} ι k (fun (a : ι) (b : ι) => _inst_5 a b) (MulZeroClass.toHasZero.{u2} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))))) (AddMonoidWithOne.toOne.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))))))
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_5 : DecidableEq.{succ u1} ι], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} ι ι k) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) b)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.one.{u2, u1} ι k (fun (a : ι) (b : ι) => _inst_5 a b) (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_3))) (Semiring.toOne.{u2} k (Ring.toSemiring.{u2} k _inst_3)))))
Case conversion may be inaccurate. Consider using '#align affine_basis.to_matrix_self AffineBasis.toMatrix_selfₓ'. -/
@[simp]
theorem toMatrix_self [DecidableEq ι] : b.toMatrix b = (1 : Matrix ι ι k) :=
  by
  ext (i j)
  rw [to_matrix_apply, coord_apply, Matrix.one_eq_pi_single, Pi.single_apply]
#align affine_basis.to_matrix_self AffineBasis.toMatrix_self

variable {ι' : Type _} [Fintype ι'] [Fintype ι] (b₂ : AffineBasis ι k P)

/- warning: affine_basis.to_matrix_row_sum_one -> AffineBasis.toMatrix_row_sum_one is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] {ι' : Type.{u5}} (q : ι' -> P) (i : ι'), Eq.{succ u2} k (Finset.sum.{u2, u1} k ι (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3)))) (Finset.univ.{u1} ι _inst_6) (fun (j : ι) => AffineBasis.toMatrix.{u1, u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' q i j)) (OfNat.ofNat.{u2} k 1 (OfNat.mk.{u2} k 1 (One.one.{u2} k (AddMonoidWithOne.toOne.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3)))))))
but is expected to have type
  forall {ι : Type.{u2}} {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u5}} [_inst_1 : AddCommGroup.{u4} V] [_inst_2 : AddTorsor.{u4, u5} V P (AddCommGroup.toAddGroup.{u4} V _inst_1)] [_inst_3 : Ring.{u3} k] [_inst_4 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_3) (AddCommGroup.toAddCommMonoid.{u4} V _inst_1)] (b : AffineBasis.{u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u2} ι] {ι' : Type.{u1}} (q : ι' -> P) (i : ι'), Eq.{succ u3} k (Finset.sum.{u3, u2} k ι (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_3)))) (Finset.univ.{u2} ι _inst_6) (fun (j : ι) => AffineBasis.toMatrix.{u2, u3, u4, u5, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' q i j)) (OfNat.ofNat.{u3} k 1 (One.toOfNat1.{u3} k (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_3))))
Case conversion may be inaccurate. Consider using '#align affine_basis.to_matrix_row_sum_one AffineBasis.toMatrix_row_sum_oneₓ'. -/
theorem toMatrix_row_sum_one {ι' : Type _} (q : ι' → P) (i : ι') : (∑ j, b.toMatrix q i j) = 1 := by
  simp
#align affine_basis.to_matrix_row_sum_one AffineBasis.toMatrix_row_sum_one

/- warning: affine_basis.affine_independent_of_to_matrix_right_inv -> AffineBasis.affineIndependent_of_toMatrix_right_inv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u5}} [_inst_5 : Fintype.{u5} ι'] [_inst_6 : Fintype.{u1} ι] [_inst_7 : DecidableEq.{succ u5} ι'] (p : ι' -> P) {A : Matrix.{u1, u5, u2} ι ι' k}, (Eq.{succ (max u5 u2)} (Matrix.{u5, u5, u2} ι' ι' k) (Matrix.mul.{u2, u5, u1, u5} ι' ι ι' k _inst_6 (Distrib.toHasMul.{u2} k (Ring.toDistrib.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3)))) (AffineBasis.toMatrix.{u1, u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' p) A) (OfNat.ofNat.{max u5 u2} (Matrix.{u5, u5, u2} ι' ι' k) 1 (OfNat.mk.{max u5 u2} (Matrix.{u5, u5, u2} ι' ι' k) 1 (One.one.{max u5 u2} (Matrix.{u5, u5, u2} ι' ι' k) (Matrix.hasOne.{u2, u5} ι' k (fun (a : ι') (b : ι') => _inst_7 a b) (MulZeroClass.toHasZero.{u2} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))))) (AddMonoidWithOne.toOne.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))))))) -> (AffineIndependent.{u2, u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2 ι' p)
but is expected to have type
  forall {ι : Type.{u2}} {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u5}} [_inst_1 : AddCommGroup.{u4} V] [_inst_2 : AddTorsor.{u4, u5} V P (AddCommGroup.toAddGroup.{u4} V _inst_1)] [_inst_3 : Ring.{u3} k] [_inst_4 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_3) (AddCommGroup.toAddCommMonoid.{u4} V _inst_1)] (b : AffineBasis.{u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u1}} [_inst_5 : Fintype.{u1} ι'] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u1} ι'] (p : ι' -> P) {A : Matrix.{u2, u1, u3} ι ι' k}, (Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} ι' ι' k) (Matrix.mul.{u3, u1, u2, u1} ι' ι ι' k _inst_6 (NonUnitalNonAssocRing.toMul.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_3)))) (AffineBasis.toMatrix.{u2, u3, u4, u5, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' p) A) (OfNat.ofNat.{max u3 u1} (Matrix.{u1, u1, u3} ι' ι' k) 1 (One.toOfNat1.{max u3 u1} (Matrix.{u1, u1, u3} ι' ι' k) (Matrix.one.{u3, u1} ι' k (fun (a : ι') (b : ι') => _inst_7 a b) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_3))) (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_3)))))) -> (AffineIndependent.{u3, u4, u5, u1} k V P _inst_3 _inst_1 _inst_4 _inst_2 ι' p)
Case conversion may be inaccurate. Consider using '#align affine_basis.affine_independent_of_to_matrix_right_inv AffineBasis.affineIndependent_of_toMatrix_right_invₓ'. -/
/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the
coordinates of `p` with respect `b` has a right inverse, then `p` is affine independent. -/
theorem affineIndependent_of_toMatrix_right_inv [DecidableEq ι'] (p : ι' → P) {A : Matrix ι ι' k}
    (hA : b.toMatrix p ⬝ A = 1) : AffineIndependent k p :=
  by
  rw [affineIndependent_iff_eq_of_fintype_affineCombination_eq]
  intro w₁ w₂ hw₁ hw₂ hweq
  have hweq' : (b.to_matrix p).vecMul w₁ = (b.to_matrix p).vecMul w₂ :=
    by
    ext j
    change (∑ i, w₁ i • b.coord j (p i)) = ∑ i, w₂ i • b.coord j (p i)
    rw [← finset.univ.affine_combination_eq_linear_combination _ _ hw₁, ←
      finset.univ.affine_combination_eq_linear_combination _ _ hw₂, ←
      finset.univ.map_affine_combination p w₁ hw₁, ← finset.univ.map_affine_combination p w₂ hw₂,
      hweq]
  replace hweq' := congr_arg (fun w => A.vec_mul w) hweq'
  simpa only [Matrix.vecMul_vecMul, ← Matrix.mul_eq_mul, hA, Matrix.vecMul_one] using hweq'
#align affine_basis.affine_independent_of_to_matrix_right_inv AffineBasis.affineIndependent_of_toMatrix_right_inv

/- warning: affine_basis.affine_span_eq_top_of_to_matrix_left_inv -> AffineBasis.affineSpan_eq_top_of_toMatrix_left_inv is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u5}} [_inst_5 : Fintype.{u5} ι'] [_inst_6 : Fintype.{u1} ι] [_inst_7 : DecidableEq.{succ u1} ι] [_inst_8 : Nontrivial.{u2} k] (p : ι' -> P) {A : Matrix.{u1, u5, u2} ι ι' k}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} ι ι k) (Matrix.mul.{u2, u1, u5, u1} ι ι' ι k _inst_5 (Distrib.toHasMul.{u2} k (Ring.toDistrib.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3)))) A (AffineBasis.toMatrix.{u1, u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' p)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.hasOne.{u2, u1} ι k (fun (a : ι) (b : ι) => _inst_7 a b) (MulZeroClass.toHasZero.{u2} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))))) (AddMonoidWithOne.toOne.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))))))) -> (Eq.{succ u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (affineSpan.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2 (Set.range.{u4, succ u5} P ι' p)) (Top.top.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (CompleteLattice.toHasTop.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (AffineSubspace.completeLattice.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2))))
but is expected to have type
  forall {ι : Type.{u2}} {k : Type.{u3}} {V : Type.{u4}} {P : Type.{u5}} [_inst_1 : AddCommGroup.{u4} V] [_inst_2 : AddTorsor.{u4, u5} V P (AddCommGroup.toAddGroup.{u4} V _inst_1)] [_inst_3 : Ring.{u3} k] [_inst_4 : Module.{u3, u4} k V (Ring.toSemiring.{u3} k _inst_3) (AddCommGroup.toAddCommMonoid.{u4} V _inst_1)] (b : AffineBasis.{u2, u3, u4, u5} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) {ι' : Type.{u1}} [_inst_5 : Fintype.{u1} ι'] [_inst_6 : Fintype.{u2} ι] [_inst_7 : DecidableEq.{succ u2} ι] [_inst_8 : Nontrivial.{u3} k] (p : ι' -> P) {A : Matrix.{u2, u1, u3} ι ι' k}, (Eq.{max (succ u2) (succ u3)} (Matrix.{u2, u2, u3} ι ι k) (Matrix.mul.{u3, u2, u1, u2} ι ι' ι k _inst_5 (NonUnitalNonAssocRing.toMul.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} k (NonAssocRing.toNonUnitalNonAssocRing.{u3} k (Ring.toNonAssocRing.{u3} k _inst_3)))) A (AffineBasis.toMatrix.{u2, u3, u4, u5, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι' p)) (OfNat.ofNat.{max u2 u3} (Matrix.{u2, u2, u3} ι ι k) 1 (One.toOfNat1.{max u2 u3} (Matrix.{u2, u2, u3} ι ι k) (Matrix.one.{u3, u2} ι k (fun (a : ι) (b : ι) => _inst_7 a b) (MonoidWithZero.toZero.{u3} k (Semiring.toMonoidWithZero.{u3} k (Ring.toSemiring.{u3} k _inst_3))) (Semiring.toOne.{u3} k (Ring.toSemiring.{u3} k _inst_3)))))) -> (Eq.{succ u5} (AffineSubspace.{u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2) (affineSpan.{u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2 (Set.range.{u5, succ u1} P ι' p)) (Top.top.{u5} (AffineSubspace.{u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2) (CompleteLattice.toTop.{u5} (AffineSubspace.{u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2) (AffineSubspace.instCompleteLatticeAffineSubspace.{u3, u4, u5} k V P _inst_3 _inst_1 _inst_4 _inst_2))))
Case conversion may be inaccurate. Consider using '#align affine_basis.affine_span_eq_top_of_to_matrix_left_inv AffineBasis.affineSpan_eq_top_of_toMatrix_left_invₓ'. -/
/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the
coordinates of `p` with respect `b` has a left inverse, then `p` spans the entire space. -/
theorem affineSpan_eq_top_of_toMatrix_left_inv [DecidableEq ι] [Nontrivial k] (p : ι' → P)
    {A : Matrix ι ι' k} (hA : A ⬝ b.toMatrix p = 1) : affineSpan k (range p) = ⊤ :=
  by
  suffices ∀ i, b i ∈ affineSpan k (range p)
    by
    rw [eq_top_iff, ← b.tot, affineSpan_le]
    rintro q ⟨i, rfl⟩
    exact this i
  intro i
  have hAi : (∑ j, A i j) = 1 := by
    calc
      (∑ j, A i j) = ∑ j, A i j * ∑ l, b.to_matrix p j l := by simp
      _ = ∑ j, ∑ l, A i j * b.to_matrix p j l := by simp_rw [Finset.mul_sum]
      _ = ∑ l, ∑ j, A i j * b.to_matrix p j l := by rw [Finset.sum_comm]
      _ = ∑ l, (A ⬝ b.to_matrix p) i l := rfl
      _ = 1 := by simp [hA, Matrix.one_apply, Finset.filter_eq]
      
  have hbi : b i = finset.univ.affine_combination k p (A i) :=
    by
    apply b.ext_elem
    intro j
    rw [b.coord_apply, finset.univ.map_affine_combination _ _ hAi,
      finset.univ.affine_combination_eq_linear_combination _ _ hAi]
    change _ = (A ⬝ b.to_matrix p) i j
    simp_rw [hA, Matrix.one_apply, @eq_comm _ i j]
  rw [hbi]
  exact affineCombination_mem_affineSpan hAi p
#align affine_basis.affine_span_eq_top_of_to_matrix_left_inv AffineBasis.affineSpan_eq_top_of_toMatrix_left_inv

#print AffineBasis.toMatrix_vecMul_coords /-
/-- A change of basis formula for barycentric coordinates.

See also `affine_basis.to_matrix_inv_mul_affine_basis_to_matrix`. -/
@[simp]
theorem toMatrix_vecMul_coords (x : P) : (b.toMatrix b₂).vecMul (b₂.coords x) = b.coords x :=
  by
  ext j
  change _ = b.coord j x
  conv_rhs => rw [← b₂.affine_combination_coord_eq_self x]
  rw [Finset.map_affineCombination _ _ _ (b₂.sum_coord_apply_eq_one x)]
  simp [Matrix.vecMul, Matrix.dotProduct, to_matrix_apply, coords]
#align affine_basis.to_matrix_vec_mul_coords AffineBasis.toMatrix_vecMul_coords
-/

variable [DecidableEq ι]

/- warning: affine_basis.to_matrix_mul_to_matrix -> AffineBasis.toMatrix_mul_toMatrix is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_7 : DecidableEq.{succ u1} ι], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} ι ι k) (Matrix.mul.{u2, u1, u1, u1} ι ι ι k _inst_6 (Distrib.toHasMul.{u2} k (Ring.toDistrib.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3)))) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4)) b₂)) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b₂ ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4)) b))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.hasOne.{u2, u1} ι k (fun (a : ι) (b : ι) => _inst_7 a b) (MulZeroClass.toHasZero.{u2} k (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))))) (AddMonoidWithOne.toOne.{u2} k (AddGroupWithOne.toAddMonoidWithOne.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k _inst_3))))))))
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_7 : DecidableEq.{succ u1} ι], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} ι ι k) (Matrix.mul.{u2, u1, u1, u1} ι ι ι k _inst_6 (NonUnitalNonAssocRing.toMul.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k _inst_3)))) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) b₂)) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b₂ ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) b))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.one.{u2, u1} ι k (fun (a : ι) (b : ι) => _inst_7 a b) (MonoidWithZero.toZero.{u2} k (Semiring.toMonoidWithZero.{u2} k (Ring.toSemiring.{u2} k _inst_3))) (Semiring.toOne.{u2} k (Ring.toSemiring.{u2} k _inst_3)))))
Case conversion may be inaccurate. Consider using '#align affine_basis.to_matrix_mul_to_matrix AffineBasis.toMatrix_mul_toMatrixₓ'. -/
theorem toMatrix_mul_toMatrix : b.toMatrix b₂ ⬝ b₂.toMatrix b = 1 :=
  by
  ext (l m)
  change (b₂.to_matrix b).vecMul (b.coords (b₂ l)) m = _
  rw [to_matrix_vec_mul_coords, coords_apply, ← to_matrix_apply, to_matrix_self]
#align affine_basis.to_matrix_mul_to_matrix AffineBasis.toMatrix_mul_toMatrix

/- warning: affine_basis.is_unit_to_matrix -> AffineBasis.isUnit_toMatrix is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_7 : DecidableEq.{succ u1} ι], IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.ring.{u2, u1} ι k _inst_6 (fun (a : ι) (b : ι) => _inst_7 a b) _inst_3)) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4)) b₂))
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_7 : DecidableEq.{succ u1} ι], IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.semiring.{u2, u1} ι k (Ring.toSemiring.{u2} k _inst_3) _inst_6 (fun (a : ι) (b : ι) => _inst_7 a b)))) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) b₂))
Case conversion may be inaccurate. Consider using '#align affine_basis.is_unit_to_matrix AffineBasis.isUnit_toMatrixₓ'. -/
theorem isUnit_toMatrix : IsUnit (b.toMatrix b₂) :=
  ⟨{  val := b.toMatrix b₂
      inv := b₂.toMatrix b
      val_inv := b.toMatrix_mul_toMatrix b₂
      inv_val := b₂.toMatrix_mul_toMatrix b }, rfl⟩
#align affine_basis.is_unit_to_matrix AffineBasis.isUnit_toMatrix

/- warning: affine_basis.is_unit_to_matrix_iff -> AffineBasis.isUnit_toMatrix_iff is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] [_inst_7 : DecidableEq.{succ u1} ι] [_inst_8 : Nontrivial.{u2} k] (p : ι -> P), Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.ring.{u2, u1} ι k _inst_6 (fun (a : ι) (b : ι) => _inst_7 a b) _inst_3)) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι p)) (And (AffineIndependent.{u2, u3, u4, u1} k V P _inst_3 _inst_1 _inst_4 _inst_2 ι p) (Eq.{succ u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (affineSpan.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2 (Set.range.{u4, succ u1} P ι p)) (Top.top.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (CompleteLattice.toHasTop.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (AffineSubspace.completeLattice.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2)))))
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : Ring.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k _inst_3) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 _inst_3 _inst_4) [_inst_6 : Fintype.{u1} ι] [_inst_7 : DecidableEq.{succ u1} ι] [_inst_8 : Nontrivial.{u2} k] (p : ι -> P), Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.semiring.{u2, u1} ι k (Ring.toSemiring.{u2} k _inst_3) _inst_6 (fun (a : ι) (b : ι) => _inst_7 a b)))) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 _inst_3 _inst_4 b ι p)) (And (AffineIndependent.{u2, u3, u4, u1} k V P _inst_3 _inst_1 _inst_4 _inst_2 ι p) (Eq.{succ u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (affineSpan.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2 (Set.range.{u4, succ u1} P ι p)) (Top.top.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (CompleteLattice.toTop.{u4} (AffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2) (AffineSubspace.instCompleteLatticeAffineSubspace.{u2, u3, u4} k V P _inst_3 _inst_1 _inst_4 _inst_2)))))
Case conversion may be inaccurate. Consider using '#align affine_basis.is_unit_to_matrix_iff AffineBasis.isUnit_toMatrix_iffₓ'. -/
theorem isUnit_toMatrix_iff [Nontrivial k] (p : ι → P) :
    IsUnit (b.toMatrix p) ↔ AffineIndependent k p ∧ affineSpan k (range p) = ⊤ :=
  by
  constructor
  · rintro ⟨⟨B, A, hA, hA'⟩, rfl : B = b.to_matrix p⟩
    rw [Matrix.mul_eq_mul] at hA hA'
    exact
      ⟨b.affine_independent_of_to_matrix_right_inv p hA,
        b.affine_span_eq_top_of_to_matrix_left_inv p hA'⟩
  · rintro ⟨h_tot, h_ind⟩
    let b' : AffineBasis ι k P := ⟨p, h_tot, h_ind⟩
    change IsUnit (b.to_matrix b')
    exact b.is_unit_to_matrix b'
#align affine_basis.is_unit_to_matrix_iff AffineBasis.isUnit_toMatrix_iff

end Ring

section CommRing

variable [CommRing k] [Module k V] [DecidableEq ι] [Fintype ι]

variable (b b₂ : AffineBasis ι k P)

/- warning: affine_basis.to_matrix_inv_vec_mul_to_matrix -> AffineBasis.toMatrix_inv_vecMul_toMatrix is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : CommRing.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] [_inst_5 : DecidableEq.{succ u1} ι] [_inst_6 : Fintype.{u1} ι] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (x : P), Eq.{max (succ u1) (succ u2)} (ι -> k) (Matrix.vecMul.{u2, u1, u1} ι ι k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))) _inst_6 (coeFn.{max (succ u3) (succ u4) (succ (max u1 u2)), max (succ u4) (succ (max u1 u2))} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (fun (_x : AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) => P -> ι -> k) (AffineMap.hasCoeToFun.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b) x) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.hasInv.{u1, u2} ι k _inst_6 (fun (a : ι) (b : ι) => _inst_5 a b) _inst_3) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4)) b₂)))) (coeFn.{max (succ u3) (succ u4) (succ (max u1 u2)), max (succ u4) (succ (max u1 u2))} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (fun (_x : AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) => P -> ι -> k) (AffineMap.hasCoeToFun.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b₂) x)
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : CommRing.{u2} k] [_inst_4 : Module.{u2, u3} k V (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] [_inst_5 : DecidableEq.{succ u1} ι] [_inst_6 : Fintype.{u1} ι] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (x : P), Eq.{max (succ u1) (succ u2)} (ι -> k) (Matrix.vecMul.{u2, u1, u1} ι ι k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))) _inst_6 (FunLike.coe.{max (max (succ u3) (succ u4)) (succ (max u1 u2)), succ u4, succ (max u1 u2)} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) _x) (AffineMap.funLike.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b) x) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} ι ι k) (Matrix.inv.{u1, u2} ι k _inst_6 (fun (a : ι) (b : ι) => _inst_5 a b) _inst_3) (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) b₂)))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ (max u1 u2)), succ u4, succ (max u1 u2)} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) _x) (AffineMap.funLike.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b₂) x)
Case conversion may be inaccurate. Consider using '#align affine_basis.to_matrix_inv_vec_mul_to_matrix AffineBasis.toMatrix_inv_vecMul_toMatrixₓ'. -/
/-- A change of basis formula for barycentric coordinates.

See also `affine_basis.to_matrix_vec_mul_coords`. -/
@[simp]
theorem toMatrix_inv_vecMul_toMatrix (x : P) :
    (b.toMatrix b₂)⁻¹.vecMul (b.coords x) = b₂.coords x :=
  by
  have hu := b.is_unit_to_matrix b₂
  rw [Matrix.isUnit_iff_isUnit_det] at hu
  rw [← b.to_matrix_vec_mul_coords b₂, Matrix.vecMul_vecMul, Matrix.mul_nonsing_inv _ hu,
    Matrix.vecMul_one]
#align affine_basis.to_matrix_inv_vec_mul_to_matrix AffineBasis.toMatrix_inv_vecMul_toMatrix

/- warning: affine_basis.det_smul_coords_eq_cramer_coords -> AffineBasis.det_smul_coords_eq_cramer_coords is a dubious translation:
lean 3 declaration is
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : CommRing.{u2} k] [_inst_4 : Module.{u2, u3} k V (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] [_inst_5 : DecidableEq.{succ u1} ι] [_inst_6 : Fintype.{u1} ι] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (x : P), Eq.{succ (max u1 u2)} (ι -> k) (SMul.smul.{u2, max u1 u2} k (ι -> k) (Function.hasSMul.{u1, u2, u2} ι k k (Mul.toSMul.{u2} k (Distrib.toHasMul.{u2} k (Ring.toDistrib.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Matrix.det.{u2, u1} ι (fun (a : ι) (b : ι) => _inst_5 a b) _inst_6 k _inst_3 (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4)) b₂))) (coeFn.{max (succ u3) (succ u4) (succ (max u1 u2)), max (succ u4) (succ (max u1 u2))} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (fun (_x : AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) => P -> ι -> k) (AffineMap.hasCoeToFun.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b₂) x)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (ι -> k) (ι -> k) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (ι -> k) (ι -> k) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3))))) => (ι -> k) -> ι -> k) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} k k (ι -> k) (ι -> k) (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.Function.module.{u1, u2, u2} ι k k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Matrix.cramer.{u1, u2} ι k (fun (a : ι) (b : ι) => _inst_5 a b) _inst_6 _inst_3 (Matrix.transpose.{u2, u1, u1} ι ι k (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (coeFn.{max (succ u1) (succ u4), max (succ u1) (succ u4)} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (fun (_x : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) => ι -> P) (FunLike.hasCoeToFun.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => P) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4)) b₂)))) (coeFn.{max (succ u3) (succ u4) (succ (max u1 u2)), max (succ u4) (succ (max u1 u2))} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (fun (_x : AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) => P -> ι -> k) (AffineMap.hasCoeToFun.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => AddCommGroup.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toAddCommGroup.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Pi.addTorsor.{u1, u2, u2} ι (fun (i : ι) => k) (fun (i : ι) => AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (fun (ᾰ : ι) => k) (fun (i : ι) => addGroupIsAddTorsor.{u2} k (AddGroupWithOne.toAddGroup.{u2} k (AddCommGroupWithOne.toAddGroupWithOne.{u2} k (Ring.toAddCommGroupWithOne.{u2} k (CommRing.toRing.{u2} k _inst_3))))))) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b) x))
but is expected to have type
  forall {ι : Type.{u1}} {k : Type.{u2}} {V : Type.{u3}} {P : Type.{u4}} [_inst_1 : AddCommGroup.{u3} V] [_inst_2 : AddTorsor.{u3, u4} V P (AddCommGroup.toAddGroup.{u3} V _inst_1)] [_inst_3 : CommRing.{u2} k] [_inst_4 : Module.{u2, u3} k V (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_1)] [_inst_5 : DecidableEq.{succ u1} ι] [_inst_6 : Fintype.{u1} ι] (b : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (b₂ : AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) (x : P), Eq.{max (succ u1) (succ u2)} ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) x) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} k ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) x) ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) x) (instHSMul.{u2, max u1 u2} k ((fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) x) (Pi.instSMul.{u1, u2, u2} ι k (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.2922 : ι) => k) (fun (i : ι) => Algebra.toSMul.{u2, u2} k k (CommRing.toCommSemiring.{u2} k _inst_3) (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (Algebra.id.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3))))) (Matrix.det.{u2, u1} ι (fun (a : ι) (b : ι) => _inst_5 a b) _inst_6 k _inst_3 (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) b₂))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ (max u1 u2)), succ u4, succ (max u1 u2)} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) _x) (AffineMap.funLike.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b₂) x)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} k k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)))) (ι -> k) (ι -> k) (Pi.addCommMonoid.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3))))) (ι -> k) (fun (_x : ι -> k) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : ι -> k) => ι -> k) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} k k (ι -> k) (ι -> k) (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.addCommMonoid.{u1, u2} ι (fun (ᾰ : ι) => k) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3)))))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.273 : ι) => k) k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3)))) (RingHom.id.{u2} k (Semiring.toNonAssocSemiring.{u2} k (CommSemiring.toSemiring.{u2} k (CommRing.toCommSemiring.{u2} k _inst_3))))) (Matrix.cramer.{u1, u2} ι k (fun (a : ι) (b : ι) => _inst_5 a b) _inst_6 _inst_3 (Matrix.transpose.{u2, u1, u1} ι ι k (AffineBasis.toMatrix.{u1, u2, u3, u4, u1} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b ι (FunLike.coe.{max (succ u1) (succ u4), succ u1, succ u4} (AffineBasis.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.AffineSpace.Basis._hyg.252 : ι) => P) _x) (AffineBasis.funLike.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4) b₂)))) (FunLike.coe.{max (max (succ u3) (succ u4)) (succ (max u1 u2)), succ u4, succ (max u1 u2)} (AffineMap.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.Combination._hyg.3598 : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) P (fun (_x : P) => (fun (a._@.Mathlib.LinearAlgebra.AffineSpace.AffineMap._hyg.1003 : P) => ι -> k) _x) (AffineMap.funLike.{u2, u3, u4, max u1 u2, max u1 u2} k V P (ι -> k) (ι -> k) (CommRing.toRing.{u2} k _inst_3) _inst_1 _inst_4 _inst_2 (Pi.addCommGroup.{u1, u2} ι (fun (i : ι) => k) (fun (i : ι) => Ring.toAddCommGroup.{u2} k (CommRing.toRing.{u2} k _inst_3))) (Pi.module.{u1, u2, u2} ι (fun (i : ι) => k) k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)) (fun (i : ι) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} k (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} k (NonAssocRing.toNonUnitalNonAssocRing.{u2} k (Ring.toNonAssocRing.{u2} k (CommRing.toRing.{u2} k _inst_3))))) (fun (i : ι) => Semiring.toModule.{u2} k (Ring.toSemiring.{u2} k (CommRing.toRing.{u2} k _inst_3)))) (Finset.instAddTorsorForAllAddGroupToAddGroupToAddGroupWithOne.{u2, u1} k (CommRing.toRing.{u2} k _inst_3) ι)) (AffineBasis.coords.{u1, u2, u3, u4} ι k V P _inst_1 _inst_2 (CommRing.toRing.{u2} k _inst_3) _inst_4 b) x))
Case conversion may be inaccurate. Consider using '#align affine_basis.det_smul_coords_eq_cramer_coords AffineBasis.det_smul_coords_eq_cramer_coordsₓ'. -/
/-- If we fix a background affine basis `b`, then for any other basis `b₂`, we can characterise
the barycentric coordinates provided by `b₂` in terms of determinants relative to `b`. -/
theorem det_smul_coords_eq_cramer_coords (x : P) :
    (b.toMatrix b₂).det • b₂.coords x = (b.toMatrix b₂)ᵀ.cramer (b.coords x) :=
  by
  have hu := b.is_unit_to_matrix b₂
  rw [Matrix.isUnit_iff_isUnit_det] at hu
  rw [← b.to_matrix_inv_vec_mul_to_matrix, Matrix.det_smul_inv_vecMul_eq_cramer_transpose _ _ hu]
#align affine_basis.det_smul_coords_eq_cramer_coords AffineBasis.det_smul_coords_eq_cramer_coords

end CommRing

end AffineBasis

