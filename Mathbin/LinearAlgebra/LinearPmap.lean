/-
Copyright (c) 2020 Yury Kudryashov All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Moritz Doll

! This file was ported from Lean 3 source module linear_algebra.linear_pmap
! leanprover-community/mathlib commit 8709a597a377df3433d863887978b3d01a07c587
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Basic
import Mathbin.LinearAlgebra.Prod

/-!
# Partially defined linear maps

A `linear_pmap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`.
We define a `semilattice_inf` with `order_bot` instance on this this, and define three operations:

* `mk_span_singleton` defines a partial linear map defined on the span of a singleton.
* `sup` takes two partial linear maps `f`, `g` that agree on the intersection of their
  domains, and returns the unique partial linear map on `f.domain ⊔ g.domain` that
  extends both `f` and `g`.
* `Sup` takes a `directed_on (≤)` set of partial linear maps, and returns the unique
  partial linear map on the `Sup` of their domains that extends all these maps.

Moreover, we define
* `linear_pmap.graph` is the graph of the partial linear map viewed as a submodule of `E × F`.

Partially defined maps are currently used in `mathlib` to prove Hahn-Banach theorem
and its variations. Namely, `linear_pmap.Sup` implies that every chain of `linear_pmap`s
is bounded above.
They are also the basis for the theory of unbounded operators.

-/


open Set

universe u v w

#print LinearPMap /-
/-- A `linear_pmap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`. -/
structure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)
  [AddCommGroup F] [Module R F] where
  domain : Submodule R E
  toFun : domain →ₗ[R] F
#align linear_pmap LinearPMap
-/

-- mathport name: «expr →ₗ.[ ] »
notation:25 E " →ₗ.[" R:25 "] " F:0 => LinearPMap R E F

variable {R : Type _} [Ring R] {E : Type _} [AddCommGroup E] [Module R E] {F : Type _}
  [AddCommGroup F] [Module R F] {G : Type _} [AddCommGroup G] [Module R G]

namespace LinearPMap

open Submodule

instance : CoeFun (E →ₗ.[R] F) fun f : E →ₗ.[R] F => f.domain → F :=
  ⟨fun f => f.toFun⟩

/- warning: linear_pmap.to_fun_eq_coe -> LinearPMap.toFun_eq_coe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearPMap.toFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => F) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) _inst_5) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (fun (_x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearPMap.toFun.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x)
Case conversion may be inaccurate. Consider using '#align linear_pmap.to_fun_eq_coe LinearPMap.toFun_eq_coeₓ'. -/
@[simp]
theorem toFun_eq_coe (f : E →ₗ.[R] F) (x : f.domain) : f.toFun x = f x :=
  rfl
#align linear_pmap.to_fun_eq_coe LinearPMap.toFun_eq_coe

/- warning: linear_pmap.ext -> LinearPMap.ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall {{x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)}} {{y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)}}, (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))) -> (Eq.{max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall {{x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))}} {{y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))}}, (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))) -> (Eq.{max (succ u2) (succ u1)} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.ext LinearPMap.extₓ'. -/
@[ext]
theorem ext {f g : E →ₗ.[R] F} (h : f.domain = g.domain)
    (h' : ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (h : (x : E) = y), f x = g y) : f = g :=
  by
  rcases f with ⟨f_dom, f⟩
  rcases g with ⟨g_dom, g⟩
  obtain rfl : f_dom = g_dom := h
  obtain rfl : f = g := LinearMap.ext fun x => h' rfl
  rfl
#align linear_pmap.ext LinearPMap.ext

/- warning: linear_pmap.map_zero -> LinearPMap.map_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (OfNat.ofNat.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) 0 (OfNat.mk.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) 0 (Zero.zero.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Submodule.hasZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))))))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (OfNat.ofNat.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) 0 (Zero.toOfNat0.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Submodule.instZeroSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))))) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4)))))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.map_zero LinearPMap.map_zeroₓ'. -/
@[simp]
theorem map_zero (f : E →ₗ.[R] F) : f 0 = 0 :=
  f.toFun.map_zero
#align linear_pmap.map_zero LinearPMap.map_zero

/- warning: linear_pmap.ext_iff -> LinearPMap.ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, Iff (Eq.{max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) (Exists.{0} (Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (fun (domain_eq : Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) => forall {{x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)}} {{y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)}}, (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, Iff (Eq.{max (succ u2) (succ u1)} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) (Exists.{0} (Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (fun (domain_eq : Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) => forall {{x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))}} {{y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))}}, (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.ext_iff LinearPMap.ext_iffₓ'. -/
theorem ext_iff {f g : E →ₗ.[R] F} :
    f = g ↔
      ∃ domain_eq : f.domain = g.domain,
        ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (h : (x : E) = y), f x = g y :=
  ⟨fun EQ =>
    EQ ▸
      ⟨rfl, fun x y h => by
        congr
        exact_mod_cast h⟩,
    fun ⟨deq, feq⟩ => ext deq feq⟩
#align linear_pmap.ext_iff LinearPMap.ext_iff

/- warning: linear_pmap.ext' -> LinearPMap.ext' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {s : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3} {f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5} {g : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5}, (Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) s) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5) f g) -> (Eq.{max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.mk.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 s f) (LinearPMap.mk.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 s g))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {s : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3} {f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x s)) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5} {g : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x s)) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5}, (Eq.{max (succ u2) (succ u1)} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x s)) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 s) _inst_5) f g) -> (Eq.{max (succ u2) (succ u1)} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.mk.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 s f) (LinearPMap.mk.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 s g))
Case conversion may be inaccurate. Consider using '#align linear_pmap.ext' LinearPMap.ext'ₓ'. -/
theorem ext' {s : Submodule R E} {f g : s →ₗ[R] F} (h : f = g) : mk s f = mk s g :=
  h ▸ rfl
#align linear_pmap.ext' LinearPMap.ext'

/- warning: linear_pmap.map_add -> LinearPMap.map_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (HAdd.hAdd.{u2, u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (instHAdd.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Submodule.hasAdd.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x y)) (HAdd.hAdd.{u3, u3, u3} F F F (instHAdd.{u3} F (AddZeroClass.toHasAdd.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f y))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (HAdd.hAdd.{u2, u2, u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (instHAdd.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Submodule.instAddSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x y)) (HAdd.hAdd.{u1, u1, u1} F F F (instHAdd.{u1} F (AddZeroClass.toAdd.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_4)))))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f y))
Case conversion may be inaccurate. Consider using '#align linear_pmap.map_add LinearPMap.map_addₓ'. -/
theorem map_add (f : E →ₗ.[R] F) (x y : f.domain) : f (x + y) = f x + f y :=
  f.toFun.map_add x y
#align linear_pmap.map_add LinearPMap.map_add

/- warning: linear_pmap.map_neg -> LinearPMap.map_neg is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (Neg.neg.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddSubgroupClass.neg.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.addSubgroupClass.{u1, u2} R E _inst_1 _inst_2 _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) x)) (Neg.neg.{u3} F (SubNegMonoid.toHasNeg.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (Neg.neg.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (AddSubgroupClass.neg.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.instAddSubgroupClassSubmoduleToSemiringToAddCommMonoidToSubNegMonoidToAddGroupInstSetLikeSubmodule.{u3, u2} R E _inst_1 _inst_2 _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) x)) (Neg.neg.{u1} F (NegZeroClass.toNeg.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.map_neg LinearPMap.map_negₓ'. -/
theorem map_neg (f : E →ₗ.[R] F) (x : f.domain) : f (-x) = -f x :=
  f.toFun.map_neg x
#align linear_pmap.map_neg LinearPMap.map_neg

/- warning: linear_pmap.map_sub -> LinearPMap.map_sub is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (HSub.hSub.{u2, u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (instHSub.{u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (AddSubgroupClass.sub.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.addSubgroupClass.{u1, u2} R E _inst_1 _inst_2 _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x y)) (HSub.hSub.{u3, u3, u3} F F F (instHSub.{u3} F (SubNegMonoid.toHasSub.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f y))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (HSub.hSub.{u2, u2, u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (instHSub.{u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (AddSubgroupClass.sub.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)) (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.instAddSubgroupClassSubmoduleToSemiringToAddCommMonoidToSubNegMonoidToAddGroupInstSetLikeSubmodule.{u3, u2} R E _inst_1 _inst_2 _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x y)) (HSub.hSub.{u1, u1, u1} F F F (instHSub.{u1} F (SubNegMonoid.toSub.{u1} F (AddGroup.toSubNegMonoid.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_4)))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f y))
Case conversion may be inaccurate. Consider using '#align linear_pmap.map_sub LinearPMap.map_subₓ'. -/
theorem map_sub (f : E →ₗ.[R] F) (x y : f.domain) : f (x - y) = f x - f y :=
  f.toFun.map_sub x y
#align linear_pmap.map_sub LinearPMap.map_sub

/- warning: linear_pmap.map_smul -> LinearPMap.map_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (c : R) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (SMul.smul.{u1, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Submodule.hasSmul.{u1, u1, u2} R R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (Mul.toSMul.{u1} R (MulOneClass.toHasMul.{u1} R (Monoid.toMulOneClass.{u1} R (Ring.toMonoid.{u1} R _inst_1)))) (MulAction.toHasSmul.{u1, u2} R E (Ring.toMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))) (IsScalarTower.left.{u1, u2} R E (Ring.toMonoid.{u1} R _inst_1) (MulActionWithZero.toMulAction.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x)) (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (c : R) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (HSMul.hSMul.{u3, u2, u2} R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (instHSMul.{u3, u2} R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Submodule.instSMulSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u3, u2} R R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (SMulZeroClass.toSMul.{u3, u3} R R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (SMulWithZero.toSMulZeroClass.{u3, u3} R R (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (MulZeroClass.toSMulWithZero.{u3} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonUnitalRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonUnitalRing.{u3} R _inst_1))))))) (SMulZeroClass.toSMul.{u3, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} R E (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (IsScalarTower.left.{u3, u2} R E (MonoidWithZero.toMonoid.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (MulActionWithZero.toMulAction.{u3, u2} R E (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) c x)) (HSMul.hSMul.{u3, u1, u1} R F F (instHSMul.{u3, u1} R F (SMulZeroClass.toSMul.{u3, u1} R F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u3, u1} R F (MonoidWithZero.toZero.{u3} R (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u3, u1} R F (Semiring.toMonoidWithZero.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))))) c (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.map_smul LinearPMap.map_smulₓ'. -/
theorem map_smul (f : E →ₗ.[R] F) (c : R) (x : f.domain) : f (c • x) = c • f x :=
  f.toFun.map_smul c x
#align linear_pmap.map_smul LinearPMap.map_smul

/- warning: linear_pmap.mk_apply -> LinearPMap.mk_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (p : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.mk.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p f) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f x)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (p : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mk.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p f) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) (fun (_x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)) F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p) _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) f x)
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_apply LinearPMap.mk_applyₓ'. -/
@[simp]
theorem mk_apply (p : Submodule R E) (f : p →ₗ[R] F) (x : p) : mk p f x = f x :=
  rfl
#align linear_pmap.mk_apply LinearPMap.mk_apply

/- warning: linear_pmap.mk_span_singleton' -> LinearPMap.mkSpanSingleton' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (x : E) (y : F), (forall (c : R), (Eq.{succ u2} E (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c y) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (x : E) (y : F), (forall (c : R), (Eq.{succ u2} E (HSMul.hSMul.{u1, u2, u2} R E E (instHSMul.{u1, u2} R E (SMulZeroClass.toSMul.{u1, u2} R E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} R E (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) c x) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) -> (Eq.{succ u3} F (HSMul.hSMul.{u1, u3, u3} R F F (instHSMul.{u1, u3} R F (SMulZeroClass.toSMul.{u1, u3} R F (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u1, u3} R F (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5))))) c y) (OfNat.ofNat.{u3} F 0 (Zero.toOfNat0.{u3} F (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))))))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_span_singleton' LinearPMap.mkSpanSingleton'ₓ'. -/
/-- The unique `linear_pmap` on `R ∙ x` that sends `x` to `y`. This version works for modules
over rings, and requires a proof of `∀ c, c • x = 0 → c • y = 0`. -/
noncomputable def mkSpanSingleton' (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) : E →ₗ.[R] F
    where
  domain := R ∙ x
  toFun :=
    have H : ∀ c₁ c₂ : R, c₁ • x = c₂ • x → c₁ • y = c₂ • y :=
      by
      intro c₁ c₂ h
      rw [← sub_eq_zero, ← sub_smul] at h⊢
      exact H _ h
    { toFun := fun z => Classical.choose (mem_span_singleton.1 z.Prop) • y
      map_add' := fun y z => by
        rw [← add_smul]
        apply H
        simp only [add_smul, sub_smul, Classical.choose_spec (mem_span_singleton.1 _)]
        apply coe_add
      map_smul' := fun c z => by
        rw [smul_smul]
        apply H
        simp only [mul_smul, Classical.choose_spec (mem_span_singleton.1 _)]
        apply coe_smul }
#align linear_pmap.mk_span_singleton' LinearPMap.mkSpanSingleton'

/- warning: linear_pmap.domain_mk_span_singleton -> LinearPMap.domain_mkSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u2} E (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c y) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))), Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H)) (Submodule.span.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.hasSingleton.{u2} E) x))
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) c x) (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2)))))))) -> (Eq.{succ u1} F (HSMul.hSMul.{u2, u1, u1} R F F (instHSMul.{u2, u1} R F (SMulZeroClass.toSMul.{u2, u1} R F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R F (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R F (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))))) c y) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))))))), Eq.{succ u3} (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (LinearPMap.domain.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H)) (Submodule.span.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3 (Singleton.singleton.{u3, u3} E (Set.{u3} E) (Set.instSingletonSet.{u3} E) x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.domain_mk_span_singleton LinearPMap.domain_mkSpanSingletonₓ'. -/
@[simp]
theorem domain_mkSpanSingleton (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) :
    (mkSpanSingleton' x y H).domain = R ∙ x :=
  rfl
#align linear_pmap.domain_mk_span_singleton LinearPMap.domain_mkSpanSingleton

/- warning: linear_pmap.mk_span_singleton'_apply -> LinearPMap.mkSpanSingleton'_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u2} E (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c y) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) (c : R) (h : Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H) (Subtype.mk.{succ u2} E (fun (x_1 : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x_1 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))) (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) h)) (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c y)
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) c x) (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2)))))))) -> (Eq.{succ u1} F (HSMul.hSMul.{u2, u1, u1} R F F (instHSMul.{u2, u1} R F (SMulZeroClass.toSMul.{u2, u1} R F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R F (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R F (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))))) c y) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))))))) (c : R) (h : Membership.mem.{u3, u3} E (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) c x) (LinearPMap.domain.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))), Eq.{succ u1} F (LinearPMap.toFun'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H) (Subtype.mk.{succ u3} E (fun (x_1 : E) => Membership.mem.{u3, u3} E (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x_1 (LinearPMap.domain.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))) (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) c x) h)) (HSMul.hSMul.{u2, u1, u1} R F F (instHSMul.{u2, u1} R F (SMulZeroClass.toSMul.{u2, u1} R F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R F (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R F (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))))) c y)
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_span_singleton'_apply LinearPMap.mkSpanSingleton'_applyₓ'. -/
@[simp]
theorem mkSpanSingleton'_apply (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) (c : R) (h) :
    mkSpanSingleton' x y H ⟨c • x, h⟩ = c • y :=
  by
  dsimp [mk_span_singleton']
  rw [← sub_eq_zero, ← sub_smul]
  apply H
  simp only [sub_smul, one_smul, sub_eq_zero]
  apply Classical.choose_spec (mem_span_singleton.1 h)
#align linear_pmap.mk_span_singleton'_apply LinearPMap.mkSpanSingleton'_apply

/- warning: linear_pmap.mk_span_singleton'_apply_self -> LinearPMap.mkSpanSingleton'_apply_self is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u2} E (SMul.smul.{u1, u2} R E (SMulZeroClass.toHasSmul.{u1, u2} R E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} R E (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} R E (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)))) (Module.toMulActionWithZero.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) c x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (SMul.smul.{u1, u3} R F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) c y) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) (h : Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H) (Subtype.mk.{succ u2} E (fun (x_1 : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x_1 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))) x h)) y
but is expected to have type
  forall {R : Type.{u2}} [_inst_1 : Ring.{u2} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (x : E) (y : F) (H : forall (c : R), (Eq.{succ u3} E (HSMul.hSMul.{u2, u3, u3} R E E (instHSMul.{u2, u3} R E (SMulZeroClass.toSMul.{u2, u3} R E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} R E (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} R E (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2))))) (Module.toMulActionWithZero.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3))))) c x) (OfNat.ofNat.{u3} E 0 (Zero.toOfNat0.{u3} E (NegZeroClass.toZero.{u3} E (SubNegZeroMonoid.toNegZeroClass.{u3} E (SubtractionMonoid.toSubNegZeroMonoid.{u3} E (SubtractionCommMonoid.toSubtractionMonoid.{u3} E (AddCommGroup.toDivisionAddCommMonoid.{u3} E _inst_2)))))))) -> (Eq.{succ u1} F (HSMul.hSMul.{u2, u1, u1} R F F (instHSMul.{u2, u1} R F (SMulZeroClass.toSMul.{u2, u1} R F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u2, u1} R F (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u2, u1} R F (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R _inst_1)) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u2, u1} R F (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))))) c y) (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))))))) (h : Membership.mem.{u3, u3} E (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))), Eq.{succ u1} F (LinearPMap.toFun'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H) (Subtype.mk.{succ u3} E (fun (x_1 : E) => Membership.mem.{u3, u3} E (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u2, u3} R E (Ring.toSemiring.{u2} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x_1 (LinearPMap.domain.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.mkSpanSingleton'.{u2, u3, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 x y H))) x h)) y
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_span_singleton'_apply_self LinearPMap.mkSpanSingleton'_apply_selfₓ'. -/
@[simp]
theorem mkSpanSingleton'_apply_self (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) (h) :
    mkSpanSingleton' x y H ⟨x, h⟩ = y := by
  convert mk_span_singleton'_apply x y H 1 _ <;> rwa [one_smul]
#align linear_pmap.mk_span_singleton'_apply_self LinearPMap.mkSpanSingleton'_apply_self

/- warning: linear_pmap.mk_span_singleton -> LinearPMap.mkSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_8 : DivisionRing.{u1} K] [_inst_9 : AddCommGroup.{u2} E] [_inst_10 : Module.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9)] [_inst_11 : AddCommGroup.{u3} F] [_inst_12 : Module.{u1, u3} K F (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_11)] (x : E), F -> (Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_9))))))))) -> (LinearPMap.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12)
but is expected to have type
  forall {K : Type.{u1}} {E : Type.{u2}} {F : Type.{u3}} [_inst_8 : DivisionRing.{u1} K] [_inst_9 : AddCommGroup.{u2} E] [_inst_10 : Module.{u1, u2} K E (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9)] [_inst_11 : AddCommGroup.{u3} F] [_inst_12 : Module.{u1, u3} K F (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_11)] (x : E), F -> (Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_9)))))))) -> (LinearPMap.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12)
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_span_singleton LinearPMap.mkSpanSingletonₓ'. -/
/-- The unique `linear_pmap` on `span R {x}` that sends a non-zero vector `x` to `y`.
This version works for modules over division rings. -/
@[reducible]
noncomputable def mkSpanSingleton {K E F : Type _} [DivisionRing K] [AddCommGroup E] [Module K E]
    [AddCommGroup F] [Module K F] (x : E) (y : F) (hx : x ≠ 0) : E →ₗ.[K] F :=
  mkSpanSingleton' x y fun c hc =>
    (smul_eq_zero.1 hc).elim (fun hc => by rw [hc, zero_smul]) fun hx' => absurd hx' hx
#align linear_pmap.mk_span_singleton LinearPMap.mkSpanSingleton

/- warning: linear_pmap.mk_span_singleton_apply -> LinearPMap.mkSpanSingleton_apply is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) {E : Type.{u2}} {F : Type.{u3}} [_inst_8 : DivisionRing.{u1} K] [_inst_9 : AddCommGroup.{u2} E] [_inst_10 : Module.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9)] [_inst_11 : AddCommGroup.{u3} F] [_inst_12 : Module.{u1, u3} K F (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_11)] {x : E} (hx : Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_9))))))))) (y : F), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12) (fun (f : LinearPMap.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10)) (LinearPMap.domain.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12) (LinearPMap.mkSpanSingleton.{u1, u2, u3} K E F _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 x y hx) (Subtype.mk.{succ u2} E (fun (x_1 : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) E (Submodule.setLike.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10)) x_1 (LinearPMap.domain.{u1, u2, u3} K (DivisionRing.toRing.{u1} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12 (LinearPMap.mkSpanSingleton.{u1, u2, u3} K E F _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 x y hx))) x (Submodule.mem_span_singleton_self.{u1, u2} K E (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10 x))) y
but is expected to have type
  forall (K : Type.{u3}) {E : Type.{u2}} {F : Type.{u1}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : AddCommGroup.{u2} E] [_inst_10 : Module.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9)] [_inst_11 : AddCommGroup.{u1} F] [_inst_12 : Module.{u3, u1} K F (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_11)] {x : E} (hx : Ne.{succ u2} E x (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_9)))))))) (y : F), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 x y hx) (Subtype.mk.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10)) x_1 (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_9 _inst_10 F _inst_11 _inst_12 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_9 _inst_10 _inst_11 _inst_12 x y hx))) x (Submodule.mem_span_singleton_self.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_9) _inst_10 x))) y
Case conversion may be inaccurate. Consider using '#align linear_pmap.mk_span_singleton_apply LinearPMap.mkSpanSingleton_applyₓ'. -/
theorem mkSpanSingleton_apply (K : Type _) {E F : Type _} [DivisionRing K] [AddCommGroup E]
    [Module K E] [AddCommGroup F] [Module K F] {x : E} (hx : x ≠ 0) (y : F) :
    mkSpanSingleton x y hx ⟨x, (Submodule.mem_span_singleton_self x : x ∈ Submodule.span K {x})⟩ =
      y :=
  LinearPMap.mkSpanSingleton'_apply_self _ _ _ _
#align linear_pmap.mk_span_singleton_apply LinearPMap.mkSpanSingleton_apply

/- warning: linear_pmap.fst -> LinearPMap.fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) -> (LinearPMap.{u1, max u2 u3, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) -> (LinearPMap.{u1, max u3 u2, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.instAddCommGroupSum.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align linear_pmap.fst LinearPMap.fstₓ'. -/
/-- Projection to the first coordinate as a `linear_pmap` -/
protected def fst (p : Submodule R E) (p' : Submodule R F) : E × F →ₗ.[R] E
    where
  domain := p.Prod p'
  toFun := (LinearMap.fst R E F).comp (p.Prod p').Subtype
#align linear_pmap.fst LinearPMap.fst

/- warning: linear_pmap.fst_apply -> LinearPMap.fst_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (p : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (p' : Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (x : coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')), Eq.{succ u2} E (coeFn.{max (succ (max u2 u3)) (succ u2), max (succ (max u2 u3)) (succ u2)} (LinearPMap.{u1, max u2 u3, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3) (fun (f : LinearPMap.{u1, max u2 u3, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3) => (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3 f)) -> E) (LinearPMap.hasCoeToFun.{u1, max u2 u3, u2} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3) (LinearPMap.fst.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p p') x) (Prod.fst.{u2, u3} E F ((fun (a : Type.{max u2 u3}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ (max u2 u3), max (succ u2) (succ u3)} a b] => self.0) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (HasLiftT.mk.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (CoeTCₓ.coe.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (coeBase.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (coeSubtype.{max (succ u2) (succ u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')))))) x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (p : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (p' : Submodule.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) (x : Subtype.{succ (max u2 u1)} (Prod.{u2, u1} E F) (fun (x : Prod.{u2, u1} E F) => Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (Submodule.prod.{u3, u2, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5 p'))), Eq.{succ u2} E (LinearPMap.toFun'.{u3, max u2 u1, u2} R _inst_1 (Prod.{u2, u1} E F) (Prod.instAddCommGroupSum.{u2, u1} E F _inst_2 _inst_4) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) E _inst_2 _inst_3 (LinearPMap.fst.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p p') x) (Prod.fst.{u2, u1} E F (Subtype.val.{succ (max u2 u1)} (Prod.{u2, u1} E F) (fun (x : Prod.{u2, u1} E F) => Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Set.{max u2 u1} (Prod.{u2, u1} E F)) (Set.instMembershipSet.{max u2 u1} (Prod.{u2, u1} E F)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Submodule.prod.{u3, u2, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5 p'))) x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.fst_apply LinearPMap.fst_applyₓ'. -/
@[simp]
theorem fst_apply (p : Submodule R E) (p' : Submodule R F) (x : p.Prod p') :
    LinearPMap.fst p p' x = (x : E × F).1 :=
  rfl
#align linear_pmap.fst_apply LinearPMap.fst_apply

/- warning: linear_pmap.snd -> LinearPMap.snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) -> (LinearPMap.{u1, max u2 u3, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) -> (LinearPMap.{u1, max u3 u2, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.instAddCommGroupSum.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_pmap.snd LinearPMap.sndₓ'. -/
/-- Projection to the second coordinate as a `linear_pmap` -/
protected def snd (p : Submodule R E) (p' : Submodule R F) : E × F →ₗ.[R] F
    where
  domain := p.Prod p'
  toFun := (LinearMap.snd R E F).comp (p.Prod p').Subtype
#align linear_pmap.snd LinearPMap.snd

/- warning: linear_pmap.snd_apply -> LinearPMap.snd_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (p : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (p' : Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (x : coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')), Eq.{succ u3} F (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearPMap.{u1, max u2 u3, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, max u2 u3, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5) => (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, max u2 u3, u3} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5) (LinearPMap.snd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p p') x) (Prod.snd.{u2, u3} E F ((fun (a : Type.{max u2 u3}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ (max u2 u3), max (succ u2) (succ u3)} a b] => self.0) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (HasLiftT.mk.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (CoeTCₓ.coe.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (coeBase.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')) (Prod.{u2, u3} E F) (coeSubtype.{max (succ u2) (succ u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (Submodule.prod.{u1, u2, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p')))))) x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (p : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (p' : Submodule.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) (x : Subtype.{succ (max u2 u1)} (Prod.{u2, u1} E F) (fun (x : Prod.{u2, u1} E F) => Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (Submodule.prod.{u3, u2, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5 p'))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, max u2 u1, u1} R _inst_1 (Prod.{u2, u1} E F) (Prod.instAddCommGroupSum.{u2, u1} E F _inst_2 _inst_4) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) F _inst_4 _inst_5 (LinearPMap.snd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 p p') x) (Prod.snd.{u2, u1} E F (Subtype.val.{succ (max u2 u1)} (Prod.{u2, u1} E F) (fun (x : Prod.{u2, u1} E F) => Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Set.{max u2 u1} (Prod.{u2, u1} E F)) (Set.instMembershipSet.{max u2 u1} (Prod.{u2, u1} E F)) x (SetLike.coe.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Submodule.prod.{u3, u2, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 p F (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5 p'))) x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.snd_apply LinearPMap.snd_applyₓ'. -/
@[simp]
theorem snd_apply (p : Submodule R E) (p' : Submodule R F) (x : p.Prod p') :
    LinearPMap.snd p p' x = (x : E × F).2 :=
  rfl
#align linear_pmap.snd_apply LinearPMap.snd_apply

instance : Neg (E →ₗ.[R] F) :=
  ⟨fun f => ⟨f.domain, -f.toFun⟩⟩

/- warning: linear_pmap.neg_apply -> LinearPMap.neg_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Neg.neg.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f))), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Neg.neg.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f) x) (Neg.neg.{u3} F (SubNegMonoid.toHasNeg.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Neg.neg.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f)))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Neg.neg.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f) x) (Neg.neg.{u1} F (NegZeroClass.toNeg.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.neg_apply LinearPMap.neg_applyₓ'. -/
@[simp]
theorem neg_apply (f : E →ₗ.[R] F) (x) : (-f) x = -f x :=
  rfl
#align linear_pmap.neg_apply LinearPMap.neg_apply

instance : LE (E →ₗ.[R] F) :=
  ⟨fun f g => f.domain ≤ g.domain ∧ ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (h : (x : E) = y), f x = g y⟩

/- warning: linear_pmap.apply_comp_of_le -> LinearPMap.apply_comp_ofLe is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {T : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (h : LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T S) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) S (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (fun (_x : LinearMap.{u1, u1, u2, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) -> (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (Submodule.ofLe.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S) (And.left (LE.le.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (forall {{x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)}} {{y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)}}, (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) S y))) h)) x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {T : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (h : LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T S) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u3, u3, u2, u2} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) (fun (_x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) => Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u2} R R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (Submodule.ofLe.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S) (And.left (LE.le.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (forall {{x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))}} {{y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))}}, (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S y))) h)) x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.apply_comp_of_le LinearPMap.apply_comp_ofLeₓ'. -/
theorem apply_comp_ofLe {T S : E →ₗ.[R] F} (h : T ≤ S) (x : T.domain) :
    T x = S (Submodule.ofLe h.1 x) :=
  h.2 rfl
#align linear_pmap.apply_comp_of_le LinearPMap.apply_comp_ofLe

/- warning: linear_pmap.exists_of_le -> LinearPMap.exists_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {T : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T S) -> (forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)), Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) (fun (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) => And (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S)))))) y)) (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) S y))))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {T : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) T S) -> (forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))), Exists.{succ u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) (fun (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) => And (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S))) y)) (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 T x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 S y))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.exists_of_le LinearPMap.exists_of_leₓ'. -/
theorem exists_of_le {T S : E →ₗ.[R] F} (h : T ≤ S) (x : T.domain) :
    ∃ y : S.domain, (x : E) = y ∧ T x = S y :=
  ⟨⟨x.1, h.1 x.2⟩, ⟨rfl, h.2 rfl⟩⟩
#align linear_pmap.exists_of_le LinearPMap.exists_of_le

/- warning: linear_pmap.eq_of_le_of_domain_eq -> LinearPMap.eq_of_le_of_domain_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) -> (Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (Eq.{max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) -> (Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (Eq.{max (succ u2) (succ u1)} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.eq_of_le_of_domain_eq LinearPMap.eq_of_le_of_domain_eqₓ'. -/
theorem eq_of_le_of_domain_eq {f g : E →ₗ.[R] F} (hle : f ≤ g) (heq : f.domain = g.domain) :
    f = g :=
  ext HEq hle.2
#align linear_pmap.eq_of_le_of_domain_eq LinearPMap.eq_of_le_of_domain_eq

#print LinearPMap.eqLocus /-
/-- Given two partial linear maps `f`, `g`, the set of points `x` such that
both `f` and `g` are defined at `x` and `f x = g x` form a submodule. -/
def eqLocus (f g : E →ₗ.[R] F) : Submodule R E
    where
  carrier := { x | ∃ (hf : x ∈ f.domain)(hg : x ∈ g.domain), f ⟨x, hf⟩ = g ⟨x, hg⟩ }
  zero_mem' := ⟨zero_mem _, zero_mem _, f.map_zero.trans g.map_zero.symm⟩
  add_mem' := fun x y ⟨hfx, hgx, hx⟩ ⟨hfy, hgy, hy⟩ =>
    ⟨add_mem hfx hfy, add_mem hgx hgy, by
      erw [f.map_add ⟨x, hfx⟩ ⟨y, hfy⟩, g.map_add ⟨x, hgx⟩ ⟨y, hgy⟩, hx, hy]⟩
  smul_mem' := fun c x ⟨hfx, hgx, hx⟩ =>
    ⟨smul_mem _ c hfx, smul_mem _ c hgx, by erw [f.map_smul c ⟨x, hfx⟩, g.map_smul c ⟨x, hgx⟩, hx]⟩
#align linear_pmap.eq_locus LinearPMap.eqLocus
-/

instance : HasInf (E →ₗ.[R] F) :=
  ⟨fun f g => ⟨f.eqLocus g, f.toFun.comp <| ofLe fun x hx => hx.fst⟩⟩

instance : Bot (E →ₗ.[R] F) :=
  ⟨⟨⊥, 0⟩⟩

instance : Inhabited (E →ₗ.[R] F) :=
  ⟨⊥⟩

instance : SemilatticeInf (E →ₗ.[R] F) where
  le := (· ≤ ·)
  le_refl f := ⟨le_refl f.domain, fun x y h => Subtype.eq h ▸ rfl⟩
  le_trans := fun f g h ⟨fg_le, fg_eq⟩ ⟨gh_le, gh_eq⟩ =>
    ⟨le_trans fg_le gh_le, fun x z hxz =>
      have hxy : (x : E) = ofLe fg_le x := rfl
      (fg_eq hxy).trans (gh_eq <| hxy.symm.trans hxz)⟩
  le_antisymm f g fg gf := eq_of_le_of_domain_eq fg (le_antisymm fg.1 gf.1)
  inf := (· ⊓ ·)
  le_inf := fun f g h ⟨fg_le, fg_eq⟩ ⟨fh_le, fh_eq⟩ =>
    ⟨fun x hx =>
      ⟨fg_le hx, fh_le hx, by refine' (fg_eq _).symm.trans (fh_eq _) <;> [exact ⟨x, hx⟩, rfl, rfl]⟩,
      fun x ⟨y, yg, hy⟩ h => by
      apply fg_eq
      exact h⟩
  inf_le_left f g := ⟨fun x hx => hx.fst, fun x y h => congr_arg f <| Subtype.eq <| h⟩
  inf_le_right f g :=
    ⟨fun x hx => hx.snd.fst, fun ⟨x, xf, xg, hx⟩ y h => hx.trans <| congr_arg g <| Subtype.eq <| h⟩

instance : OrderBot (E →ₗ.[R] F) where
  bot := ⊥
  bot_le f :=
    ⟨bot_le, fun x y h => by
      have hx : x = 0 := Subtype.eq ((mem_bot R).1 x.2)
      have hy : y = 0 := Subtype.eq (h.symm.trans (congr_arg _ hx))
      rw [hx, hy, map_zero, map_zero]⟩

/- warning: linear_pmap.le_of_eq_locus_ge -> LinearPMap.le_of_eqLocus_ge is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.eqLocus.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g)) -> (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.eqLocus.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g)) -> (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.le_of_eq_locus_ge LinearPMap.le_of_eqLocus_geₓ'. -/
theorem le_of_eqLocus_ge {f g : E →ₗ.[R] F} (H : f.domain ≤ f.eqLocus g) : f ≤ g :=
  suffices f ≤ f ⊓ g from le_trans this inf_le_right
  ⟨H, fun x y hxy => ((inf_le_left : f ⊓ g ≤ f).2 hxy.symm).symm⟩
#align linear_pmap.le_of_eq_locus_ge LinearPMap.le_of_eqLocus_ge

/- warning: linear_pmap.domain_mono -> LinearPMap.domain_mono is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], StrictMono.{max u2 u3, u2} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (SemilatticeInf.toPartialOrder.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.semilatticeInf.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5))) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u1, u2} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)], StrictMono.{max u3 u2, u3} (LinearPMap.{u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Submodule.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (PartialOrder.toPreorder.{max u3 u2} (LinearPMap.{u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (SemilatticeInf.toPartialOrder.{max u3 u2} (LinearPMap.{u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.semilatticeInf.{u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5))) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (Submodule.completeLattice.{u1, u3} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_pmap.domain_mono LinearPMap.domain_monoₓ'. -/
theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) := fun f g hlt =>
  lt_of_le_of_ne hlt.1.1 fun heq => ne_of_lt hlt <| eq_of_le_of_domain_eq (le_of_lt hlt) HEq
#align linear_pmap.domain_mono LinearPMap.domain_mono

private theorem sup_aux (f g : E →ₗ.[R] F)
    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) :
    ∃ fg : ↥(f.domain ⊔ g.domain) →ₗ[R] F,
      ∀ (x : f.domain) (y : g.domain) (z), (x : E) + y = ↑z → fg z = f x + g y :=
  by
  choose x hx y hy hxy using fun z : f.domain ⊔ g.domain => mem_sup.1 z.Prop
  set fg := fun z => f ⟨x z, hx z⟩ + g ⟨y z, hy z⟩
  have fg_eq :
    ∀ (x' : f.domain) (y' : g.domain) (z' : f.domain ⊔ g.domain) (H : (x' : E) + y' = z'),
      fg z' = f x' + g y' :=
    by
    intro x' y' z' H
    dsimp [fg]
    rw [add_comm, ← sub_eq_sub_iff_add_eq_add, eq_comm, ← map_sub, ← map_sub]
    apply h
    simp only [← eq_sub_iff_add_eq] at hxy
    simp only [AddSubgroupClass.coe_sub, coe_mk, coe_mk, hxy, ← sub_add, ← sub_sub, sub_self,
      zero_sub, ← H]
    apply neg_add_eq_sub
  refine' ⟨{ toFun := fg.. }, fg_eq⟩
  · rintro ⟨z₁, hz₁⟩ ⟨z₂, hz₂⟩
    rw [← add_assoc, add_right_comm (f _), ← map_add, add_assoc, ← map_add]
    apply fg_eq
    simp only [coe_add, coe_mk, ← add_assoc]
    rw [add_right_comm (x _), hxy, add_assoc, hxy, coe_mk, coe_mk]
  · intro c z
    rw [smul_add, ← map_smul, ← map_smul]
    apply fg_eq
    simp only [coe_smul, coe_mk, ← smul_add, hxy, RingHom.id_apply]
#align linear_pmap.sup_aux linear_pmap.sup_aux

/- warning: linear_pmap.sup -> LinearPMap.sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u3} F (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup LinearPMap.supₓ'. -/
/-- Given two partial linear maps that agree on the intersection of their domains,
`f.sup g h` is the unique partial linear map on `f.domain ⊔ g.domain` that agrees
with `f` and `g`. -/
protected noncomputable def sup (f g : E →ₗ.[R] F)
    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : E →ₗ.[R] F :=
  ⟨_, Classical.choose (sup_aux f g h)⟩
#align linear_pmap.sup LinearPMap.sup

/- warning: linear_pmap.domain_sup -> LinearPMap.domain_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))), Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)) (HasSup.sup.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))), Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)) (HasSup.sup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))
Case conversion may be inaccurate. Consider using '#align linear_pmap.domain_sup LinearPMap.domain_supₓ'. -/
@[simp]
theorem domain_sup (f g : E →ₗ.[R] F)
    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) :
    (f.sup g h).domain = f.domain ⊔ g.domain :=
  rfl
#align linear_pmap.domain_sup LinearPMap.domain_sup

/- warning: linear_pmap.sup_apply -> LinearPMap.sup_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (H : forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (z : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))), (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toHasAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H))))))) z)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H) z) (HAdd.hAdd.{u3, u3, u3} F F F (instHAdd.{u3} F (AddZeroClass.toHasAdd.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (H : forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) (z : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (HasSup.sup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))), (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (HasSup.sup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))) z)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.sup.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H) z) (HAdd.hAdd.{u1, u1, u1} F F F (instHAdd.{u1} F (AddZeroClass.toAdd.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_4)))))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup_apply LinearPMap.sup_applyₓ'. -/
theorem sup_apply {f g : E →ₗ.[R] F} (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y)
    (x y z) (hz : (↑x : E) + ↑y = ↑z) : f.sup g H z = f x + g y :=
  Classical.choose_spec (sup_aux f g H) x y z hz
#align linear_pmap.sup_apply LinearPMap.sup_apply

/- warning: linear_pmap.left_le_sup -> LinearPMap.left_le_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))), LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))), LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (LinearPMap.sup.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)
Case conversion may be inaccurate. Consider using '#align linear_pmap.left_le_sup LinearPMap.left_le_supₓ'. -/
protected theorem left_le_sup (f g : E →ₗ.[R] F)
    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : f ≤ f.sup g h :=
  by
  refine' ⟨le_sup_left, fun z₁ z₂ hz => _⟩
  rw [← add_zero (f _), ← g.map_zero]
  refine' (sup_apply h _ _ _ _).symm
  simpa
#align linear_pmap.left_le_sup LinearPMap.left_le_sup

/- warning: linear_pmap.right_le_sup -> LinearPMap.right_le_sup is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))), LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (h : forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))), LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g (LinearPMap.sup.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g h)
Case conversion may be inaccurate. Consider using '#align linear_pmap.right_le_sup LinearPMap.right_le_supₓ'. -/
protected theorem right_le_sup (f g : E →ₗ.[R] F)
    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : g ≤ f.sup g h :=
  by
  refine' ⟨le_sup_right, fun z₁ z₂ hz => _⟩
  rw [← zero_add (g _), ← f.map_zero]
  refine' (sup_apply h _ _ _ _).symm
  simpa
#align linear_pmap.right_le_sup LinearPMap.right_le_sup

/- warning: linear_pmap.sup_le -> LinearPMap.sup_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {h : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (H : forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y))), (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f h) -> (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g h) -> (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.sup.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H) h)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {h : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (H : forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y))), (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f h) -> (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g h) -> (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.sup.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f g H) h)
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup_le LinearPMap.sup_leₓ'. -/
protected theorem sup_le {f g h : E →ₗ.[R] F}
    (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) (fh : f ≤ h) (gh : g ≤ h) :
    f.sup g H ≤ h :=
  have Hf : f ≤ f.sup g H ⊓ h := le_inf (f.left_le_sup g H) fh
  have Hg : g ≤ f.sup g H ⊓ h := le_inf (f.right_le_sup g H) gh
  le_of_eqLocus_ge <| sup_le Hf.1 Hg.1
#align linear_pmap.sup_le LinearPMap.sup_le

/- warning: linear_pmap.sup_h_of_disjoint -> LinearPMap.sup_h_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (Disjoint.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Submodule.orderBot.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)), (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g y)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (Disjoint.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g y)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup_h_of_disjoint LinearPMap.sup_h_of_disjointₓ'. -/
/-- Hypothesis for `linear_pmap.sup` holds, if `f.domain` is disjoint with `g.domain`. -/
theorem sup_h_of_disjoint (f g : E →ₗ.[R] F) (h : Disjoint f.domain g.domain) (x : f.domain)
    (y : g.domain) (hxy : (x : E) = y) : f x = g y :=
  by
  rw [disjoint_def] at h
  have hy : y = 0 := Subtype.eq (h y (hxy ▸ x.2) y.2)
  have hx : x = 0 := Subtype.eq (hxy.trans <| congr_arg _ hy)
  simp [*]
#align linear_pmap.sup_h_of_disjoint LinearPMap.sup_h_of_disjoint

section Smul

variable {M N : Type _} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F]

variable [Monoid N] [DistribMulAction N F] [SMulCommClass R N F]

instance : SMul M (E →ₗ.[R] F) :=
  ⟨fun a f =>
    { domain := f.domain
      toFun := a • f.toFun }⟩

/- warning: linear_pmap.smul_domain -> LinearPMap.smul_domain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {M : Type.{u4}} [_inst_8 : Monoid.{u4} M] [_inst_9 : DistribMulAction.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))] [_inst_10 : SMulCommClass.{u1, u4, u3} R M F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {M : Type.{u1}} [_inst_8 : Monoid.{u1} M] [_inst_9 : DistribMulAction.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))] [_inst_10 : SMulCommClass.{u4, u1, u2} R M F (SMulZeroClass.toSMul.{u4, u2} R F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u4, u2} R F (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u2} R F (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (Module.toMulActionWithZero.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5)))) (SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) a f)) (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)
Case conversion may be inaccurate. Consider using '#align linear_pmap.smul_domain LinearPMap.smul_domainₓ'. -/
@[simp]
theorem smul_domain (a : M) (f : E →ₗ.[R] F) : (a • f).domain = f.domain :=
  rfl
#align linear_pmap.smul_domain LinearPMap.smul_domain

/- warning: linear_pmap.smul_apply -> LinearPMap.smul_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {M : Type.{u4}} [_inst_8 : Monoid.{u4} M] [_inst_9 : DistribMulAction.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))] [_inst_10 : SMulCommClass.{u1, u4, u3} R M F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f))), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f) x) (SMul.smul.{u4, u3} M F (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9))) a (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x))
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {M : Type.{u1}} [_inst_8 : Monoid.{u1} M] [_inst_9 : DistribMulAction.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))] [_inst_10 : SMulCommClass.{u4, u1, u2} R M F (SMulZeroClass.toSMul.{u4, u2} R F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u4, u2} R F (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u2} R F (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (Module.toMulActionWithZero.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5)))) (SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) a f)))), Eq.{succ u2} F (LinearPMap.toFun'.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) a f) x) (HSMul.hSMul.{u1, u2, u2} M F F (instHSMul.{u1, u2} M F (SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9)))) a (LinearPMap.toFun'.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.smul_apply LinearPMap.smul_applyₓ'. -/
theorem smul_apply (a : M) (f : E →ₗ.[R] F) (x : (a • f).domain) : (a • f) x = a • f x :=
  rfl
#align linear_pmap.smul_apply LinearPMap.smul_apply

/- warning: linear_pmap.coe_smul -> LinearPMap.coe_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {M : Type.{u4}} [_inst_8 : Monoid.{u4} M] [_inst_9 : DistribMulAction.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))] [_inst_10 : SMulCommClass.{u1, u4, u3} R M F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ (max u2 u3)} ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f))) -> F) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f)) (SMul.smul.{u4, max u2 u3} M ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f))) -> F) (Function.hasSMul.{u2, u4, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) a f))) M F (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9)))) a (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f))
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {M : Type.{u1}} [_inst_8 : Monoid.{u1} M] [_inst_9 : DistribMulAction.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))] [_inst_10 : SMulCommClass.{u4, u1, u2} R M F (SMulZeroClass.toSMul.{u4, u2} R F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u4, u2} R F (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u2} R F (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (Module.toMulActionWithZero.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5)))) (SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9)))] (a : M) (f : LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{max (succ u3) (succ u2)} ((Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) a f)))) -> F) (LinearPMap.toFun'.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) a f)) (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M ((Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) -> F) ((Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) -> F) (instHSMul.{u1, max u3 u2} M ((Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) -> F) (Pi.instSMul.{u3, u2, u1} (Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) M (fun (a._@.Mathlib.LinearAlgebra.LinearPMap._hyg.808 : Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => F) (fun (i : Subtype.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9))))) a (LinearPMap.toFun'.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.coe_smul LinearPMap.coe_smulₓ'. -/
@[simp]
theorem coe_smul (a : M) (f : E →ₗ.[R] F) : ⇑(a • f) = a • f :=
  rfl
#align linear_pmap.coe_smul LinearPMap.coe_smul

instance [SMulCommClass M N F] : SMulCommClass M N (E →ₗ.[R] F) :=
  ⟨fun a b f => ext' <| smul_comm a b f.toFun⟩

instance [SMul M N] [IsScalarTower M N F] : IsScalarTower M N (E →ₗ.[R] F) :=
  ⟨fun a b f => ext' <| smul_assoc a b f.toFun⟩

instance : MulAction M (E →ₗ.[R] F) where
  smul := (· • ·)
  one_smul := fun ⟨s, f⟩ => ext' <| one_smul M f
  mul_smul a b f := ext' <| mul_smul a b f.toFun

end Smul

section Vadd

instance : VAdd (E →ₗ[R] F) (E →ₗ.[R] F) :=
  ⟨fun f g =>
    { domain := g.domain
      toFun := f.comp g.domain.Subtype + g.toFun }⟩

/- warning: linear_pmap.vadd_domain -> LinearPMap.vadd_domain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.vadd_domain LinearPMap.vadd_domainₓ'. -/
@[simp]
theorem vadd_domain (f : E →ₗ[R] F) (g : E →ₗ.[R] F) : (f +ᵥ g).domain = g.domain :=
  rfl
#align linear_pmap.vadd_domain LinearPMap.vadd_domain

/- warning: linear_pmap.vadd_apply -> LinearPMap.vadd_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) x) (HAdd.hAdd.{u3, u3, u3} F F F (instHAdd.{u3} F (AddZeroClass.toHasAdd.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R E F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))))))) x)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g) x) (HAdd.hAdd.{u1, u1, u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) F ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (instHAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) _inst_4)))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R E F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) f (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) x)) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.vadd_apply LinearPMap.vadd_applyₓ'. -/
theorem vadd_apply (f : E →ₗ[R] F) (g : E →ₗ.[R] F) (x : (f +ᵥ g).domain) :
    (f +ᵥ g) x = f x + g x :=
  rfl
#align linear_pmap.vadd_apply LinearPMap.vadd_apply

/- warning: linear_pmap.coe_vadd -> LinearPMap.coe_vadd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ (max u2 u3)} ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) -> F) (coeFn.{succ (max u2 u3), succ (max u2 u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)) (HAdd.hAdd.{max u2 u3, max u2 u3, max u2 u3} ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) -> F) ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) -> F) ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) -> F) (instHAdd.{max u2 u3} ((coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) -> F) (Pi.instAdd.{u2, u3} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) (fun (ᾰ : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) => F) (fun (i : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (VAdd.vadd.{max u2 u3, max u2 u3} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g))) => AddZeroClass.toHasAdd.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) F (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.comp.{u1, u1, u1, u2, u2, u3} R R R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) E F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Submodule.addCommMonoid.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (Submodule.module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomCompTriple.right_ids.{u1, u1} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f (Submodule.subtype.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) g))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{max (succ u2) (succ u1)} ((Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)))) -> F) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HVAdd.hVAdd.{max u2 u1, max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHVAdd.{max u2 u1, max u2 u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.vadd.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) f g)) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (forall (ᾰ : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) ᾰ) ((Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) -> F) (forall (ᾰ : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) ᾰ) (instHAdd.{max u2 u1} (forall (ᾰ : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) ᾰ) (Pi.instAdd.{u2, u1} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) (fun (ᾰ : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) ᾰ) (fun (i : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => AddZeroClass.toAdd.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) i) (AddMonoid.toAddZeroClass.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) i) (SubNegMonoid.toAddMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) i) (AddGroup.toSubNegMonoid.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) i) (AddCommGroup.toAddGroup.{u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) i) _inst_4))))))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) F (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_5) (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) (fun (_x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.comp.{u3, u3, u3, u2, u2, u1} R R R (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))) E F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) _inst_3 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomCompTriple.ids.{u3, u3} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) f (Submodule.subtype.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3 (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))
Case conversion may be inaccurate. Consider using '#align linear_pmap.coe_vadd LinearPMap.coe_vaddₓ'. -/
@[simp]
theorem coe_vadd (f : E →ₗ[R] F) (g : E →ₗ.[R] F) : ⇑(f +ᵥ g) = f.comp g.domain.Subtype + g :=
  rfl
#align linear_pmap.coe_vadd LinearPMap.coe_vadd

instance : AddAction (E →ₗ[R] F) (E →ₗ.[R] F)
    where
  vadd := (· +ᵥ ·)
  zero_vadd := fun ⟨s, f⟩ => ext' <| zero_add _
  add_vadd := fun f₁ f₂ ⟨s, g⟩ => ext' <| LinearMap.ext fun x => add_assoc _ _ _

end Vadd

section

variable {K : Type _} [DivisionRing K] [Module K E] [Module K F]

/- warning: linear_pmap.sup_span_singleton -> LinearPMap.supSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_10 : Module.{u3, u2} K F (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E), F -> (Not (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))) -> (LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10)
but is expected to have type
  forall {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u1} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_10 : Module.{u3, u2} K F (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E), F -> (Not (Membership.mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))) -> (LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10)
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup_span_singleton LinearPMap.supSpanSingletonₓ'. -/
/-- Extend a `linear_pmap` to `f.domain ⊔ K ∙ x`. -/
noncomputable def supSpanSingleton (f : E →ₗ.[K] F) (x : E) (y : F) (hx : x ∉ f.domain) :
    E →ₗ.[K] F :=
  f.sup (mkSpanSingleton x y fun h₀ => hx <| h₀.symm ▸ f.domain.zero_mem) <|
    sup_h_of_disjoint _ _ <| by simpa [disjoint_span_singleton]
#align linear_pmap.sup_span_singleton LinearPMap.supSpanSingleton

/- warning: linear_pmap.domain_sup_span_singleton -> LinearPMap.domain_supSpanSingleton is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_10 : Module.{u3, u2} K F (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E) (y : F) (hx : Not (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))), Eq.{succ u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.supSpanSingleton.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx)) (HasSup.sup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SemilatticeSup.toHasSup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (Lattice.toSemilatticeSup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (Submodule.completeLattice.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9))))) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (Submodule.span.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9 (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.hasSingleton.{u1} E) x)))
but is expected to have type
  forall {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_10 : Module.{u3, u1} K F (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E) (y : F) (hx : Not (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))), Eq.{succ u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.supSpanSingleton.{u2, u1, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx)) (HasSup.sup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (Submodule.completeLattice.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (Submodule.span.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.instSingletonSet.{u2} E) x)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.domain_sup_span_singleton LinearPMap.domain_supSpanSingletonₓ'. -/
@[simp]
theorem domain_supSpanSingleton (f : E →ₗ.[K] F) (x : E) (y : F) (hx : x ∉ f.domain) :
    (f.supSpanSingleton x y hx).domain = f.domain ⊔ K ∙ x :=
  rfl
#align linear_pmap.domain_sup_span_singleton LinearPMap.domain_supSpanSingleton

/- warning: linear_pmap.sup_span_singleton_apply_mk -> LinearPMap.supSpanSingleton_apply_mk is a dubious translation:
lean 3 declaration is
  forall {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] [_inst_10 : Module.{u3, u2} K F (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E) (y : F) (hx : Not (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))) (x' : E) (hx' : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x' (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (c : K), Eq.{succ u2} F (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (fun (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) => (coeSort.{succ u1, succ (succ u1)} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) -> F) (LinearPMap.hasCoeToFun.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (LinearPMap.supSpanSingleton.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx) (Subtype.mk.{succ u1} E (fun (x_1 : E) => Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x_1 (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.supSpanSingleton.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx))) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)) (Iff.mpr (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)) (HasSup.sup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SemilatticeSup.toHasSup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (Lattice.toSemilatticeSup.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (ConditionallyCompleteLattice.toLattice.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (Submodule.completeLattice.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9))))) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx))))) (Exists.{succ u1} E (fun (y_1 : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) => Exists.{succ u1} E (fun (z : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) => Eq.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) y_1 z) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x))))))) (Submodule.mem_sup.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9 (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Exists.intro.{succ u1} E (fun (y_1 : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) => Exists.{succ u1} E (fun (z : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) => Eq.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) y_1 z) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)))))) x' (Exists.intro.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x' (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x' (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) => Exists.{succ u1} E (fun (z : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) => Eq.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) x' z) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x))))) hx' (Exists.intro.{succ u1} E (fun (z : E) => Exists.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) => Eq.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) x' z) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)))) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x) (Exists.intro.{0} (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (fun (H : Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u1, u2} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton._proof_1.{u1, u2, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) => Eq.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)) (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (SubNegMonoid.toAddMonoid.{u1} E (AddGroup.toSubNegMonoid.{u1} E (AddCommGroup.toAddGroup.{u1} E _inst_2)))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x))) (Iff.mpr (Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x) (Submodule.span.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9 (Singleton.singleton.{u1, u1} E (Set.{u1} E) (Set.hasSingleton.{u1} E) x))) (Exists.{succ u3} K (fun (a : K) => Eq.{succ u1} E (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) a x) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x))) (Submodule.mem_span_singleton.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9 (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x) x) (Exists.intro.{succ u3} K (fun (a : K) => Eq.{succ u1} E (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) a x) (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)) c (rfl.{succ u1} E (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)))) (rfl.{succ u1} E (HAdd.hAdd.{u1, u1, u1} E E E (instHAdd.{u1} E (AddZeroClass.toHasAdd.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2))))) x' (SMul.smul.{u3, u1} K E (SMulZeroClass.toHasSmul.{u3, u1} K E (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u1} K E (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u1} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u1} E (AddMonoid.toAddZeroClass.{u1} E (AddCommMonoid.toAddMonoid.{u1} E (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)))) (Module.toMulActionWithZero.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)))) c x)))))))))) (HAdd.hAdd.{u2, u2, u2} F F F (instHAdd.{u2} F (AddZeroClass.toHasAdd.{u2} F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))))) (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (fun (f : LinearPMap.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) => (coeSort.{succ u1, succ (succ u1)} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) Type.{u1} (SetLike.hasCoeToSort.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) -> F) (LinearPMap.hasCoeToFun.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) f (Subtype.mk.{succ u1} E (fun (x : E) => Membership.Mem.{u1, u1} E (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) (SetLike.hasMem.{u1, u1} (Submodule.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9) E (Submodule.setLike.{u3, u1} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u1, u2} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) x' hx')) (SMul.smul.{u3, u2} K F (SMulZeroClass.toHasSmul.{u3, u2} K F (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u3, u2} K F (MulZeroClass.toHasZero.{u3} K (MulZeroOneClass.toMulZeroClass.{u3} K (MonoidWithZero.toMulZeroOneClass.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))))) (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u3, u2} K F (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddZeroClass.toHasZero.{u2} F (AddMonoid.toAddZeroClass.{u2} F (AddCommMonoid.toAddMonoid.{u2} F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)))) (Module.toMulActionWithZero.{u3, u2} K F (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_10)))) c y))
but is expected to have type
  forall {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] {K : Type.{u3}} [_inst_8 : DivisionRing.{u3} K] [_inst_9 : Module.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] [_inst_10 : Module.{u3, u1} K F (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10) (x : E) (y : F) (hx : Not (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f))) (x' : E) (hx' : Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x' (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (c : K), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.supSpanSingleton.{u2, u1, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx) (Subtype.mk.{succ u2} E (fun (x_1 : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x_1 (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.supSpanSingleton.{u2, u1, u3} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x y hx))) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)) (Iff.mpr (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)) (HasSup.sup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SemilatticeSup.toHasSup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (Lattice.toSemilatticeSup.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (Submodule.completeLattice.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx))))) (Exists.{succ u2} E (fun (y_1 : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (Exists.{succ u2} E (fun (z : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) y_1 z) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x))))))) (Submodule.mem_sup.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9 (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Exists.intro.{succ u2} E (fun (y_1 : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) y_1 (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (Exists.{succ u2} E (fun (z : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) y_1 z) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)))))) x' (And.intro (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x' (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) (Exists.{succ u2} E (fun (z : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) x' z) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x))))) hx' (Exists.intro.{succ u2} E (fun (z : E) => And (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) z (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) x' z) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)))) (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x) (And.intro (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x) (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 (LinearPMap.mkSpanSingleton.{u3, u2, u1} K E F _inst_8 _inst_2 _inst_9 _inst_4 _inst_10 x y (LinearPMap.supSpanSingleton.proof_1.{u2, u3, u1} E _inst_2 F _inst_4 K _inst_8 _inst_9 _inst_10 f x hx)))) (Eq.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)) (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2)))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2))))) (Module.toMulActionWithZero.{u3, u2} K E (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x))) (Iff.mpr (Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x) (Submodule.span.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9 (Singleton.singleton.{u2, u2} E (Set.{u2} E) (Set.instSingletonSet.{u2} E) x))) (Exists.{succ u3} K (fun (a : K) => Eq.{succ u2} E (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) a x) (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x))) (Submodule.mem_span_singleton.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9 (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x) x) (Exists.intro.{succ u3} K (fun (a : K) => Eq.{succ u2} E (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) a x) (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)) c (rfl.{succ u2} E (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)))) (rfl.{succ u2} E (HAdd.hAdd.{u2, u2, u2} E E E (instHAdd.{u2} E (AddZeroClass.toAdd.{u2} E (AddMonoid.toAddZeroClass.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))))) x' (HSMul.hSMul.{u3, u2, u2} K E E (instHSMul.{u3, u2} K E (SMulZeroClass.toSMul.{u3, u2} K E (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (SMulWithZero.toSMulZeroClass.{u3, u2} K E (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (MulActionWithZero.toSMulWithZero.{u3, u2} K E (Semiring.toMonoidWithZero.{u3} K (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8))) (AddMonoid.toZero.{u2} E (AddCommMonoid.toAddMonoid.{u2} E (AddCommGroup.toAddCommMonoid.{u2} E _inst_2))) (Module.toMulActionWithZero.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9))))) c x)))))))))) (HAdd.hAdd.{u1, u1, u1} F F F (instHAdd.{u1} F (AddZeroClass.toAdd.{u1} F (AddMonoid.toAddZeroClass.{u1} F (SubNegMonoid.toAddMonoid.{u1} F (AddGroup.toSubNegMonoid.{u1} F (AddCommGroup.toAddGroup.{u1} F _inst_4)))))) (LinearPMap.toFun'.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f (Subtype.mk.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9) E (Submodule.instSetLikeSubmodule.{u3, u2} K E (Ring.toSemiring.{u3} K (DivisionRing.toRing.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_9)) x (LinearPMap.domain.{u3, u2, u1} K (DivisionRing.toRing.{u3} K _inst_8) E _inst_2 _inst_9 F _inst_4 _inst_10 f)) x' hx')) (HSMul.hSMul.{u3, u1, u1} K F F (instHSMul.{u3, u1} K F (SMulZeroClass.toSMul.{u3, u1} K F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u3, u1} K F (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u3, u1} K F (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8))) (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))) (Module.toMulActionWithZero.{u3, u1} K F (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_8)) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_10))))) c y))
Case conversion may be inaccurate. Consider using '#align linear_pmap.sup_span_singleton_apply_mk LinearPMap.supSpanSingleton_apply_mkₓ'. -/
@[simp]
theorem supSpanSingleton_apply_mk (f : E →ₗ.[K] F) (x : E) (y : F) (hx : x ∉ f.domain) (x' : E)
    (hx' : x' ∈ f.domain) (c : K) :
    f.supSpanSingleton x y hx
        ⟨x' + c • x, mem_sup.2 ⟨x', hx', _, mem_span_singleton.2 ⟨c, rfl⟩, rfl⟩⟩ =
      f ⟨x', hx'⟩ + c • y :=
  by
  erw [sup_apply _ ⟨x', hx'⟩ ⟨c • x, _⟩, mk_span_singleton'_apply]
  rfl
  exact mem_span_singleton.2 ⟨c, rfl⟩
#align linear_pmap.sup_span_singleton_apply_mk LinearPMap.supSpanSingleton_apply_mk

end

private theorem Sup_aux (c : Set (E →ₗ.[R] F)) (hc : DirectedOn (· ≤ ·) c) :
    ∃ f : ↥(supₛ (domain '' c)) →ₗ[R] F, (⟨_, f⟩ : E →ₗ.[R] F) ∈ upperBounds c :=
  by
  cases' c.eq_empty_or_nonempty with ceq cne
  · subst c
    simp
  have hdir : DirectedOn (· ≤ ·) (domain '' c) := directedOn_image.2 (hc.mono domain_mono.monotone)
  have P : ∀ x : Sup (domain '' c), { p : c // (x : E) ∈ p.val.domain } :=
    by
    rintro x
    apply Classical.indefiniteDescription
    have := (mem_Sup_of_directed (cne.image _) hdir).1 x.2
    rwa [bex_image_iff, SetCoe.exists'] at this
  set f : Sup (domain '' c) → F := fun x => (P x).val.val ⟨x, (P x).property⟩
  have f_eq : ∀ (p : c) (x : Sup (domain '' c)) (y : p.1.1) (hxy : (x : E) = y), f x = p.1 y :=
    by
    intro p x y hxy
    rcases hc (P x).1.1 (P x).1.2 p.1 p.2 with ⟨q, hqc, hxq, hpq⟩
    refine' (hxq.2 _).trans (hpq.2 _).symm
    exacts[of_le hpq.1 y, hxy, rfl]
  refine' ⟨{ toFun := f.. }, _⟩
  · intro x y
    rcases hc (P x).1.1 (P x).1.2 (P y).1.1 (P y).1.2 with ⟨p, hpc, hpx, hpy⟩
    set x' := of_le hpx.1 ⟨x, (P x).2⟩
    set y' := of_le hpy.1 ⟨y, (P y).2⟩
    rw [f_eq ⟨p, hpc⟩ x x' rfl, f_eq ⟨p, hpc⟩ y y' rfl, f_eq ⟨p, hpc⟩ (x + y) (x' + y') rfl,
      map_add]
  · intro c x
    simp [f_eq (P x).1 (c • x) (c • ⟨x, (P x).2⟩) rfl, ← map_smul]
  · intro p hpc
    refine' ⟨le_supₛ <| mem_image_of_mem domain hpc, fun x y hxy => Eq.symm _⟩
    exact f_eq ⟨p, hpc⟩ _ _ hxy.symm
#align linear_pmap.Sup_aux linear_pmap.Sup_aux

#print LinearPMap.supₛ /-
/-- Glue a collection of partially defined linear maps to a linear map defined on `Sup`
of these submodules. -/
protected noncomputable def supₛ (c : Set (E →ₗ.[R] F)) (hc : DirectedOn (· ≤ ·) c) : E →ₗ.[R] F :=
  ⟨_, Classical.choose <| supₛ_aux c hc⟩
#align linear_pmap.Sup LinearPMap.supₛ
-/

#print LinearPMap.le_supₛ /-
protected theorem le_supₛ {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {f : E →ₗ.[R] F}
    (hf : f ∈ c) : f ≤ LinearPMap.supₛ c hc :=
  Classical.choose_spec (supₛ_aux c hc) hf
#align linear_pmap.le_Sup LinearPMap.le_supₛ
-/

#print LinearPMap.supₛ_le /-
protected theorem supₛ_le {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {g : E →ₗ.[R] F}
    (hg : ∀ f ∈ c, f ≤ g) : LinearPMap.supₛ c hc ≤ g :=
  le_of_eqLocus_ge <|
    supₛ_le fun _ ⟨f, hf, Eq⟩ =>
      Eq ▸
        have : f ≤ LinearPMap.supₛ c hc ⊓ g := le_inf (LinearPMap.le_supₛ _ hf) (hg f hf)
        this.1
#align linear_pmap.Sup_le LinearPMap.supₛ_le
-/

/- warning: linear_pmap.Sup_apply -> LinearPMap.supₛ_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {c : Set.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)} (hc : DirectedOn.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) c) {l : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (hl : Membership.Mem.{max u2 u3, max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Set.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) (Set.hasMem.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) l c) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc) (Subtype.mk.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)))))) x) (And.left (LE.le.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) (forall {{x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)}} {{y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))}}, (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) l x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc) y))) (LinearPMap.le_supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc l hl) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)))))) x) (Subtype.property.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) x)))) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) l x)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {c : Set.{max u3 u2} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)} (hc : DirectedOn.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (x._@.Mathlib.LinearAlgebra.LinearPMap._hyg.10387 : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x._@.Mathlib.LinearAlgebra.LinearPMap._hyg.10389 : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) x._@.Mathlib.LinearAlgebra.LinearPMap._hyg.10387 x._@.Mathlib.LinearAlgebra.LinearPMap._hyg.10389) c) {l : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} (hl : Membership.mem.{max u2 u3, max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Set.{max u3 u2} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) (Set.instMembershipSet.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)) l c) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l))), Eq.{succ u3} F (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc) (Subtype.mk.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l))) x) (And.left (LE.le.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3))))) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc))) (forall {{x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l))}} {{y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc)))}}, (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc)))) y)) -> (Eq.{succ u3} F (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l x) (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc) y))) (LinearPMap.le_supₛ.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 c hc l hl) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l))) x) (Subtype.property.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l)) x)))) (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 l x)
Case conversion may be inaccurate. Consider using '#align linear_pmap.Sup_apply LinearPMap.supₛ_applyₓ'. -/
protected theorem supₛ_apply {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {l : E →ₗ.[R] F}
    (hl : l ∈ c) (x : l.domain) :
    (LinearPMap.supₛ c hc) ⟨x, (LinearPMap.le_supₛ hc hl).1 x.2⟩ = l x :=
  by
  symm
  apply (Classical.choose_spec (Sup_aux c hc) hl).2
  rfl
#align linear_pmap.Sup_apply LinearPMap.supₛ_apply

end LinearPMap

namespace LinearMap

#print LinearMap.toPMap /-
/-- Restrict a linear map to a submodule, reinterpreting the result as a `linear_pmap`. -/
def toPMap (f : E →ₗ[R] F) (p : Submodule R E) : E →ₗ.[R] F :=
  ⟨p, f.comp p.Subtype⟩
#align linear_map.to_pmap LinearMap.toPMap
-/

/- warning: linear_map.to_pmap_apply -> LinearMap.toPMap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (p : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p), Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearMap.toPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f p) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) => E -> F) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R E F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) p) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p))))) x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (p : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x p)), Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearMap.toPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f p) x) (FunLike.coe.{max (succ u2) (succ u1), succ u2, succ u1} (LinearMap.{u3, u3, u2, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) E (fun (_x : E) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : E) => F) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, u1} R R E F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) f (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) p)) x))
Case conversion may be inaccurate. Consider using '#align linear_map.to_pmap_apply LinearMap.toPMap_applyₓ'. -/
@[simp]
theorem toPMap_apply (f : E →ₗ[R] F) (p : Submodule R E) (x : p) : f.toPMap p x = f x :=
  rfl
#align linear_map.to_pmap_apply LinearMap.toPMap_apply

#print LinearMap.compPMap /-
/-- Compose a linear map with a `linear_pmap` -/
def compPMap (g : F →ₗ[R] G) (f : E →ₗ.[R] F) : E →ₗ.[R] G
    where
  domain := f.domain
  toFun := g.comp f.toFun
#align linear_map.comp_pmap LinearMap.compPMap
-/

/- warning: linear_map.comp_pmap_apply -> LinearMap.compPMap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)] (g : LinearMap.{u1, u1, u3, u4} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) F G (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6) _inst_5 _inst_7) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 (LinearMap.compPMap.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 g f))), Eq.{succ u4} G (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) (fun (f : LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f)) -> G) (LinearPMap.hasCoeToFun.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) (LinearMap.compPMap.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 g f) x) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) F G (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6) _inst_5 _inst_7) (fun (_x : LinearMap.{u1, u1, u3, u4} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) F G (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6) _inst_5 _inst_7) => F -> G) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R F G (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6) _inst_5 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) g (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x))
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u4, u1} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u4, u3} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u2}} [_inst_6 : AddCommGroup.{u2} G] [_inst_7 : Module.{u4, u2} R G (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} G _inst_6)] (g : LinearMap.{u4, u4, u3, u2} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) F G (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} G _inst_6) _inst_5 _inst_7) (f : LinearPMap.{u4, u1, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submodule.{u4, u1} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u4, u1} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u1} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u1, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 (LinearMap.compPMap.{u4, u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 g f)))), Eq.{succ u2} G (LinearPMap.toFun'.{u4, u1, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 (LinearMap.compPMap.{u4, u1, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 g f) x) (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (LinearMap.{u4, u4, u3, u2} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) F G (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} G _inst_6) _inst_5 _inst_7) F (fun (_x : F) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : F) => G) _x) (LinearMap.instFunLikeLinearMap.{u4, u4, u3, u2} R R F G (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} G _inst_6) _inst_5 _inst_7 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1)))) g (LinearPMap.toFun'.{u4, u1, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_pmap_apply LinearMap.compPMap_applyₓ'. -/
@[simp]
theorem compPMap_apply (g : F →ₗ[R] G) (f : E →ₗ.[R] F) (x) : g.compPMap f x = g (f x) :=
  rfl
#align linear_map.comp_pmap_apply LinearMap.compPMap_apply

end LinearMap

namespace LinearPMap

/- warning: linear_pmap.cod_restrict -> LinearPMap.codRestrict is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (p : Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5), (forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Membership.Mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) p) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) p) (Submodule.addCommGroup.{u1, u3} R F _inst_1 _inst_4 _inst_5 p) (Submodule.module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (p : Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5), (forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Membership.mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) p) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 (Subtype.{succ u3} F (fun (x : F) => Membership.mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) x p)) (Submodule.instAddCommGroupSubtypeMemSubmoduleToSemiringToAddCommMonoidInstMembershipInstSetLikeSubmodule.{u1, u3} R F _inst_1 _inst_4 _inst_5 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 p))
Case conversion may be inaccurate. Consider using '#align linear_pmap.cod_restrict LinearPMap.codRestrictₓ'. -/
/-- Restrict codomain of a `linear_pmap` -/
def codRestrict (f : E →ₗ.[R] F) (p : Submodule R F) (H : ∀ x, f x ∈ p) : E →ₗ.[R] p
    where
  domain := f.domain
  toFun := f.toFun.codRestrict p H
#align linear_pmap.cod_restrict LinearPMap.codRestrict

/- warning: linear_pmap.comp -> LinearPMap.comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)] (g : LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (forall (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Membership.Mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x) (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g)) -> (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)] (g : LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), (forall (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Membership.mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.instMembership.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) (LinearPMap.toFun'.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g)) -> (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align linear_pmap.comp LinearPMap.compₓ'. -/
/-- Compose two `linear_pmap`s -/
def comp (g : F →ₗ.[R] G) (f : E →ₗ.[R] F) (H : ∀ x : f.domain, f x ∈ g.domain) : E →ₗ.[R] G :=
  g.toFun.compPMap <| f.codRestrict _ H
#align linear_pmap.comp LinearPMap.comp

/- warning: linear_pmap.coprod -> LinearPMap.coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)], (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) -> (LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) -> (LinearPMap.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)], (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) -> (LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) -> (LinearPMap.{u1, max u3 u2, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.instAddCommGroupSum.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7)
Case conversion may be inaccurate. Consider using '#align linear_pmap.coprod LinearPMap.coprodₓ'. -/
/-- `f.coprod g` is the partially defined linear map defined on `f.domain × g.domain`,
and sending `p` to `f p.1 + g p.2`. -/
def coprod (f : E →ₗ.[R] G) (g : F →ₗ.[R] G) : E × F →ₗ.[R] G
    where
  domain := f.domain.Prod g.domain
  toFun :=
    (f.comp (LinearPMap.fst f.domain g.domain) fun x => x.2.1).toFun +
      (g.comp (LinearPMap.snd f.domain g.domain) fun x => x.2.2).toFun
#align linear_pmap.coprod LinearPMap.coprod

/- warning: linear_pmap.coprod_apply -> LinearPMap.coprod_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {G : Type.{u4}} [_inst_6 : AddCommGroup.{u4} G] [_inst_7 : Module.{u1, u4} R G (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u4} G _inst_6)] (f : LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) (g : LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) (x : coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))), Eq.{succ u4} G (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearPMap.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7) (fun (f : LinearPMap.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7) => (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 f)) -> G) (LinearPMap.hasCoeToFun.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7) (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g) x) (HAdd.hAdd.{u4, u4, u4} G G G (instHAdd.{u4} G (AddZeroClass.toHasAdd.{u4} G (AddMonoid.toAddZeroClass.{u4} G (SubNegMonoid.toAddMonoid.{u4} G (AddGroup.toSubNegMonoid.{u4} G (AddCommGroup.toAddGroup.{u4} G _inst_6)))))) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) (fun (f : LinearPMap.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f)) -> G) (LinearPMap.hasCoeToFun.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) f (Subtype.mk.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f)) (Prod.fst.{u2, u3} E F ((fun (a : Type.{max u2 u3}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ (max u2 u3), max (succ u2) (succ u3)} a b] => self.0) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (HasLiftT.mk.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (CoeTCₓ.coe.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (coeBase.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (coeSubtype.{max (succ u2) (succ u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))))))) x)) (And.left (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (Prod.fst.{u2, u3} E F (Subtype.val.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f))) (Membership.Mem.{u3, u3} F (Set.{u3} F) (Set.hasMem.{u3} F) (Prod.snd.{u2, u3} E F (Subtype.val.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g))) (Subtype.property.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)))) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) (fun (f : LinearPMap.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) => (coeSort.{succ u3, succ (succ u3)} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) Type.{u3} (SetLike.hasCoeToSort.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 f)) -> G) (LinearPMap.hasCoeToFun.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) g (Subtype.mk.{succ u3} F (fun (x : F) => Membership.Mem.{u3, u3} F (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (SetLike.hasMem.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)) x (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g)) (Prod.snd.{u2, u3} E F ((fun (a : Type.{max u2 u3}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{succ (max u2 u3), max (succ u2) (succ u3)} a b] => self.0) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (HasLiftT.mk.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (CoeTCₓ.coe.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (coeBase.{succ (max u2 u3), max (succ u2) (succ u3)} (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) (Prod.{u2, u3} E F) (coeSubtype.{max (succ u2) (succ u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))))))) x)) (And.right (Membership.Mem.{u2, u2} E (Set.{u2} E) (Set.hasMem.{u2} E) (Prod.fst.{u2, u3} E F (Subtype.val.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (HasLiftT.mk.{succ u2, succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (CoeTCₓ.coe.{succ u2, succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Set.{u2} E) (SetLike.Set.hasCoeT.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)))) (LinearPMap.domain.{u1, u2, u4} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f))) (Membership.Mem.{u3, u3} F (Set.{u3} F) (Set.hasMem.{u3} F) (Prod.snd.{u2, u3} E F (Subtype.val.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) ((fun (a : Type.{u3}) (b : Type.{u3}) [self : HasLiftT.{succ u3, succ u3} a b] => self.0) (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (HasLiftT.mk.{succ u3, succ u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (CoeTCₓ.coe.{succ u3, succ u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) (Set.{u3} F) (SetLike.Set.hasCoeT.{u3, u3} (Submodule.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5) F (Submodule.setLike.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (LinearPMap.domain.{u1, u3, u4} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g))) (Subtype.property.{succ (max u2 u3)} (Prod.{u2, u3} E F) (fun (x : Prod.{u2, u3} E F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u2 u3} (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u1, max u2 u3, u4} R _inst_1 (Prod.{u2, u3} E F) (Prod.addCommGroup.{u2, u3} E F _inst_2 _inst_4) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)))))
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {G : Type.{u2}} [_inst_6 : AddCommGroup.{u2} G] [_inst_7 : Module.{u4, u2} R G (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} G _inst_6)] (f : LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7) (g : LinearPMap.{u4, u1, u2} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7) (x : Subtype.{succ (max u3 u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g)))), Eq.{succ u2} G (LinearPMap.toFun'.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g) x) (HAdd.hAdd.{u2, u2, u2} G G G (instHAdd.{u2} G (AddZeroClass.toAdd.{u2} G (AddMonoid.toAddZeroClass.{u2} G (SubNegMonoid.toAddMonoid.{u2} G (AddGroup.toSubNegMonoid.{u2} G (AddCommGroup.toAddGroup.{u2} G _inst_6)))))) (LinearPMap.toFun'.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f (Subtype.mk.{succ u3} E (fun (x : E) => Membership.mem.{u3, u3} E (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (SetLike.instMembership.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3)) x (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f)) (Prod.fst.{u3, u1} E F (Subtype.val.{succ (max u3 u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Set.{max u3 u1} (Prod.{u3, u1} E F)) (Set.instMembershipSet.{max u3 u1} (Prod.{u3, u1} E F)) x (SetLike.coe.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g)))) x)) (And.left (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) (Prod.fst.{u3, u1} E F (Subtype.val.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) (SetLike.coe.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f))) (Membership.mem.{u1, u1} F (Set.{u1} F) (Set.instMembershipSet.{u1} F) (Prod.snd.{u3, u1} E F (Subtype.val.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) (SetLike.coe.{u1, u1} (Submodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) (LinearPMap.domain.{u4, u1, u2} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g))) (Subtype.property.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)))) (LinearPMap.toFun'.{u4, u1, u2} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g (Subtype.mk.{succ u1} F (fun (x : F) => Membership.mem.{u1, u1} F (Submodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) (SetLike.instMembership.{u1, u1} (Submodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5)) x (LinearPMap.domain.{u4, u1, u2} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g)) (Prod.snd.{u3, u1} E F (Subtype.val.{succ (max u3 u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Set.{max u3 u1} (Prod.{u3, u1} E F)) (Set.instMembershipSet.{max u3 u1} (Prod.{u3, u1} E F)) x (SetLike.coe.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g)))) x)) (And.right (Membership.mem.{u3, u3} E (Set.{u3} E) (Set.instMembershipSet.{u3} E) (Prod.fst.{u3, u1} E F (Subtype.val.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) (SetLike.coe.{u3, u3} (Submodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (LinearPMap.domain.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 G _inst_6 _inst_7 f))) (Membership.mem.{u1, u1} F (Set.{u1} F) (Set.instMembershipSet.{u1} F) (Prod.snd.{u3, u1} E F (Subtype.val.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)) (SetLike.coe.{u1, u1} (Submodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) F (Submodule.instSetLikeSubmodule.{u4, u1} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5) (LinearPMap.domain.{u4, u1, u2} R _inst_1 F _inst_4 _inst_5 G _inst_6 _inst_7 g))) (Subtype.property.{max (succ u3) (succ u1)} (Prod.{u3, u1} E F) (fun (x : Prod.{u3, u1} E F) => Membership.mem.{max u3 u1, max u3 u1} (Prod.{u3, u1} E F) (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u3 u1, max u3 u1} (Submodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u3, u1} E F) (Submodule.instSetLikeSubmodule.{u4, max u3 u1} R (Prod.{u3, u1} E F) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{max u3 u1} (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4)) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.domain.{u4, max u3 u1, u2} R _inst_1 (Prod.{u3, u1} E F) (Prod.instAddCommGroupSum.{u3, u1} E F _inst_2 _inst_4) (Prod.module.{u4, u3, u1} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) G _inst_6 _inst_7 (LinearPMap.coprod.{u4, u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 G _inst_6 _inst_7 f g))) x)))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.coprod_apply LinearPMap.coprod_applyₓ'. -/
@[simp]
theorem coprod_apply (f : E →ₗ.[R] G) (g : F →ₗ.[R] G) (x) :
    f.coprod g x = f ⟨(x : E × F).1, x.2.1⟩ + g ⟨(x : E × F).2, x.2.2⟩ :=
  rfl
#align linear_pmap.coprod_apply LinearPMap.coprod_apply

#print LinearPMap.domRestrict /-
/-- Restrict a partially defined linear map to a submodule of `E` contained in `f.domain`. -/
def domRestrict (f : E →ₗ.[R] F) (S : Submodule R E) : E →ₗ.[R] F :=
  ⟨S ⊓ f.domain, f.toFun.comp (Submodule.ofLe (by simp))⟩
#align linear_pmap.dom_restrict LinearPMap.domRestrict
-/

/- warning: linear_pmap.dom_restrict_domain -> LinearPMap.domRestrict_domain is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {S : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3}, Eq.{succ u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.domRestrict.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {S : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3}, Eq.{succ u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.domRestrict.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S)) (HasInf.inf.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.instHasInfSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.dom_restrict_domain LinearPMap.domRestrict_domainₓ'. -/
@[simp]
theorem domRestrict_domain (f : E →ₗ.[R] F) {S : Submodule R E} :
    (f.domRestrict S).domain = S ⊓ f.domain :=
  rfl
#align linear_pmap.dom_restrict_domain LinearPMap.domRestrict_domain

/- warning: linear_pmap.dom_restrict_apply -> LinearPMap.domRestrict_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3} {{x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))}} {{y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)}}, (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (HasInf.inf.{u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.hasInf.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))))))) x) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) y)) -> (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.domRestrict.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f y))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3} {{x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (HasInf.inf.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.instHasInfSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))}} {{y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))}}, (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (HasInf.inf.{u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Submodule.instHasInfSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) S (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))) x) (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) y)) -> (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (LinearPMap.domRestrict.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S) x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f y))
Case conversion may be inaccurate. Consider using '#align linear_pmap.dom_restrict_apply LinearPMap.domRestrict_applyₓ'. -/
theorem domRestrict_apply {f : E →ₗ.[R] F} {S : Submodule R E} ⦃x : S ⊓ f.domain⦄ ⦃y : f.domain⦄
    (h : (x : E) = y) : f.domRestrict S x = f y :=
  by
  have : Submodule.ofLe (by simp) x = y := by
    ext
    simp [h]
  rw [← this]
  exact LinearPMap.mk_apply _ _ _
#align linear_pmap.dom_restrict_apply LinearPMap.domRestrict_apply

/- warning: linear_pmap.dom_restrict_le -> LinearPMap.domRestrict_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3}, LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.domRestrict.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S) f
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {S : Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3}, LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.domRestrict.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f S) f
Case conversion may be inaccurate. Consider using '#align linear_pmap.dom_restrict_le LinearPMap.domRestrict_leₓ'. -/
theorem domRestrict_le {f : E →ₗ.[R] F} {S : Submodule R E} : f.domRestrict S ≤ f :=
  ⟨by simp, fun x y hxy => domRestrict_apply hxy⟩
#align linear_pmap.dom_restrict_le LinearPMap.domRestrict_le

/-! ### Graph -/


section Graph

/- warning: linear_pmap.graph -> LinearPMap.graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) -> (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)], (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) -> (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_pmap.graph LinearPMap.graphₓ'. -/
/-- The graph of a `linear_pmap` viewed as a submodule on `E × F`. -/
def graph (f : E →ₗ.[R] F) : Submodule R (E × F) :=
  f.toFun.graph.map (f.domain.Subtype.Prod_map (LinearMap.id : F →ₗ[R] F))
#align linear_pmap.graph LinearPMap.graph

/- warning: linear_pmap.mem_graph_iff' -> LinearPMap.mem_graph_iff' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u3} E F}, Iff (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (fun (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) => Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} E F) (Prod.mk.{u2, u3} E F ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) y) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f y)) x))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u1} E F}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (fun (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => Eq.{max (succ u2) (succ u1)} (Prod.{u2, u1} E F) (Prod.mk.{u2, u1} E F (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) y) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f y)) x))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_graph_iff' LinearPMap.mem_graph_iff'ₓ'. -/
theorem mem_graph_iff' (f : E →ₗ.[R] F) {x : E × F} : x ∈ f.graph ↔ ∃ y : f.domain, (↑y, f y) = x :=
  by simp [graph]
#align linear_pmap.mem_graph_iff' LinearPMap.mem_graph_iff'

/- warning: linear_pmap.mem_graph_iff -> LinearPMap.mem_graph_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u3} E F}, Iff (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (fun (y : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) => And (Eq.{succ u2} E ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) y) (Prod.fst.{u2, u3} E F x)) (Eq.{succ u3} F (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f y) (Prod.snd.{u2, u3} E F x))))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u1} E F}, Iff (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u2} (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (fun (y : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) => And (Eq.{succ u2} E (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) y) (Prod.fst.{u2, u1} E F x)) (Eq.{succ u1} F (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f y) (Prod.snd.{u2, u1} E F x))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_graph_iff LinearPMap.mem_graph_iffₓ'. -/
@[simp]
theorem mem_graph_iff (f : E →ₗ.[R] F) {x : E × F} :
    x ∈ f.graph ↔ ∃ y : f.domain, (↑y : E) = x.1 ∧ f y = x.2 :=
  by
  cases x
  simp_rw [mem_graph_iff', Prod.mk.inj_iff]
#align linear_pmap.mem_graph_iff LinearPMap.mem_graph_iff

/- warning: linear_pmap.mem_graph -> LinearPMap.mem_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (HasLiftT.mk.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (CoeTCₓ.coe.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeBase.{succ u2, succ u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) E (coeSubtype.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))))) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f x)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (x : Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))), Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F (Subtype.val.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Set.{u2} E) (Set.instMembershipSet.{u2} E) x (SetLike.coe.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) x) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x)) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_graph LinearPMap.mem_graphₓ'. -/
/-- The tuple `(x, f x)` is contained in the graph of `f`. -/
theorem mem_graph (f : E →ₗ.[R] F) (x : domain f) : ((x : E), f x) ∈ f.graph := by simp
#align linear_pmap.mem_graph LinearPMap.mem_graph

variable {M : Type _} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F] (y : M)

/- warning: linear_pmap.smul_graph -> LinearPMap.smul_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {M : Type.{u4}} [_inst_8 : Monoid.{u4} M] [_inst_9 : DistribMulAction.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))] [_inst_10 : SMulCommClass.{u1, u4, u3} R M F (SMulZeroClass.toHasSmul.{u1, u3} R F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (SMulWithZero.toSmulZeroClass.{u1, u3} R F (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1))))) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (MulActionWithZero.toSMulWithZero.{u1, u3} R F (Semiring.toMonoidWithZero.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (AddCommMonoid.toAddMonoid.{u3} F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)))) (Module.toMulActionWithZero.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5)))) (SMulZeroClass.toHasSmul.{u4, u3} M F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))))) (DistribSMul.toSmulZeroClass.{u4, u3} M F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))) (DistribMulAction.toDistribSMul.{u4, u3} M F _inst_8 (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4))) _inst_9)))] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (z : M), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (SMul.smul.{u4, max u2 u3} M (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u1, u2, u3, u4} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10) z f)) (Submodule.map.{u1, u1, max u2 u3, max u2 u3, max u2 u3} R R (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, max u2 u3} R R (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R E F E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5 _inst_3 _inst_5 (LinearMap.id.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SMul.smul.{u4, u3} M (LinearMap.{u1, u1, u3, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 _inst_5) (LinearMap.hasSmul.{u1, u1, u4, u3, u3} R R M F F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) _inst_8 _inst_9 _inst_10) z (LinearMap.id.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5))) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
but is expected to have type
  forall {R : Type.{u4}} [_inst_1 : Ring.{u4} R] {E : Type.{u3}} [_inst_2 : AddCommGroup.{u3} E] [_inst_3 : Module.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {M : Type.{u1}} [_inst_8 : Monoid.{u1} M] [_inst_9 : DistribMulAction.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))] [_inst_10 : SMulCommClass.{u4, u1, u2} R M F (SMulZeroClass.toSMul.{u4, u2} R F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (SMulWithZero.toSMulZeroClass.{u4, u2} R F (MonoidWithZero.toZero.{u4} R (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (MulActionWithZero.toSMulWithZero.{u4, u2} R F (Semiring.toMonoidWithZero.{u4} R (Ring.toSemiring.{u4} R _inst_1)) (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (Module.toMulActionWithZero.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5)))) (SMulZeroClass.toSMul.{u1, u2} M F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))) (DistribSMul.toSMulZeroClass.{u1, u2} M F (AddMonoid.toAddZeroClass.{u2} F (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4)))) (DistribMulAction.toDistribSMul.{u1, u2} M F _inst_8 (SubNegMonoid.toAddMonoid.{u2} F (AddGroup.toSubNegMonoid.{u2} F (AddCommGroup.toAddGroup.{u2} F _inst_4))) _inst_9)))] (f : LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (z : M), Eq.{max (succ u3) (succ u2)} (Submodule.{u4, max u2 u3} R (Prod.{u3, u2} E F) (Ring.toSemiring.{u4} R _inst_1) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (HSMul.hSMul.{u1, max u3 u2, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (instHSMul.{u1, max u3 u2} M (LinearPMap.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.smul.{u4, u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 M _inst_8 _inst_9 _inst_10)) z f)) (Submodule.map.{u4, u4, max u3 u2, max u3 u2, max u3 u2} R R (Prod.{u3, u2} E F) (Prod.{u3, u2} E F) (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (RingHomSurjective.ids.{u4} R (Ring.toSemiring.{u4} R _inst_1)) (LinearMap.{u4, u4, max u2 u3, max u2 u3} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) (Prod.{u3, u2} E F) (Prod.{u3, u2} E F) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u4, u4, max u3 u2, max u3 u2} R R (Prod.{u3, u2} E F) (Prod.{u3, u2} E F) (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.instAddCommMonoidSum.{u3, u2} E F (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) (Prod.module.{u4, u3, u2} R E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1)))) (LinearMap.prodMap.{u4, u3, u2, u3, u2} R E F E F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5 _inst_3 _inst_5 (LinearMap.id.{u4, u3} R E (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} E _inst_2) _inst_3) (HSMul.hSMul.{u1, u2, u2} M (LinearMap.{u4, u4, u2, u2} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5 _inst_5) (LinearMap.{u4, u4, u2, u2} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5 _inst_5) (instHSMul.{u1, u2} M (LinearMap.{u4, u4, u2, u2} R R (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5 _inst_5) (LinearMap.instSMulLinearMap.{u4, u4, u1, u2, u2} R R M F F (Ring.toSemiring.{u4} R _inst_1) (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5 _inst_5 (RingHom.id.{u4} R (Semiring.toNonAssocSemiring.{u4} R (Ring.toSemiring.{u4} R _inst_1))) _inst_8 _inst_9 _inst_10)) z (LinearMap.id.{u4, u2} R F (Ring.toSemiring.{u4} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_5))) (LinearPMap.graph.{u4, u3, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.smul_graph LinearPMap.smul_graphₓ'. -/
/-- The graph of `z • f` as a pushforward. -/
theorem smul_graph (f : E →ₗ.[R] F) (z : M) :
    (z • f).graph =
      f.graph.map ((LinearMap.id : E →ₗ[R] E).Prod_map (z • (LinearMap.id : F →ₗ[R] F))) :=
  by
  ext x; cases x
  constructor <;> intro h
  · rw [mem_graph_iff] at h
    rcases h with ⟨y, hy, h⟩
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ⟨x', hx', h⟩
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx'⊢
  rcases hx' with ⟨y, hy, hx'⟩
  use y
  rw [← h.1, ← h.2]
  simp [hy, hx']
#align linear_pmap.smul_graph LinearPMap.smul_graph

/- warning: linear_pmap.neg_graph -> LinearPMap.neg_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Neg.neg.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f)) (Submodule.map.{u1, u1, max u2 u3, max u2 u3, max u2 u3} R R (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, max u2 u3} R R (Prod.{u2, u3} E F) (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R E F E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5 _inst_3 _inst_5 (LinearMap.id.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Neg.neg.{u3} (LinearMap.{u1, u1, u3, u3} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5 _inst_5) (LinearMap.hasNeg.{u1, u1, u3, u3} R R F F (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_4 _inst_5 _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.id.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_5))) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5), Eq.{max (succ u2) (succ u1)} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Neg.neg.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.neg.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f)) (Submodule.map.{u3, u3, max u2 u1, max u2 u1, max u2 u1} R R (Prod.{u2, u1} E F) (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u1 u2, max u1 u2} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Prod.{u2, u1} E F) (Prod.{u2, u1} E F) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u2 u1, max u2 u1} R R (Prod.{u2, u1} E F) (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.prodMap.{u3, u2, u1, u2, u1} R E F E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5 _inst_3 _inst_5 (LinearMap.id.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (Neg.neg.{u1} (LinearMap.{u3, u3, u1, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) F F (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5 _inst_5) (LinearMap.instNegLinearMapToAddCommMonoid.{u3, u3, u1, u1} R R F F (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_4 _inst_5 _inst_5 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.id.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_5))) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.neg_graph LinearPMap.neg_graphₓ'. -/
/-- The graph of `-f` as a pushforward. -/
theorem neg_graph (f : E →ₗ.[R] F) :
    (-f).graph = f.graph.map ((LinearMap.id : E →ₗ[R] E).Prod_map (-(LinearMap.id : F →ₗ[R] F))) :=
  by
  ext; cases x
  constructor <;> intro h
  · rw [mem_graph_iff] at h
    rcases h with ⟨y, hy, h⟩
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ⟨x', hx', h⟩
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx'⊢
  rcases hx' with ⟨y, hy, hx'⟩
  use y
  rw [← h.1, ← h.2]
  simp [hy, hx']
#align linear_pmap.neg_graph LinearPMap.neg_graph

/- warning: linear_pmap.mem_graph_snd_inj -> LinearPMap.mem_graph_snd_inj is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : E} {y : E} {x' : F} {y' : F}, (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x x') (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F y y') (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E x y) -> (Eq.{succ u3} F x' y')
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : E} {y : E} {x' : F} {y' : F}, (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x x') (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F y y') (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E x y) -> (Eq.{succ u1} F x' y')
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_graph_snd_inj LinearPMap.mem_graph_snd_injₓ'. -/
theorem mem_graph_snd_inj (f : E →ₗ.[R] F) {x y : E} {x' y' : F} (hx : (x, x') ∈ f.graph)
    (hy : (y, y') ∈ f.graph) (hxy : x = y) : x' = y' :=
  by
  rw [mem_graph_iff] at hx hy
  rcases hx with ⟨x'', hx1, hx2⟩
  rcases hy with ⟨y'', hy1, hy2⟩
  simp only at hx1 hx2 hy1 hy2
  rw [← hx1, ← hy1, SetLike.coe_eq_coe] at hxy
  rw [← hx2, ← hy2, hxy]
#align linear_pmap.mem_graph_snd_inj LinearPMap.mem_graph_snd_inj

/- warning: linear_pmap.mem_graph_snd_inj' -> LinearPMap.mem_graph_snd_inj' is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u3} E F} {y : Prod.{u2, u3} E F}, (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) y (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (Prod.fst.{u2, u3} E F y)) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (Prod.snd.{u2, u3} E F y))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : Prod.{u2, u1} E F} {y : Prod.{u2, u1} E F}, (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) x (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.mem.{max u2 u1, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) y (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E (Prod.fst.{u2, u1} E F x) (Prod.fst.{u2, u1} E F y)) -> (Eq.{succ u1} F (Prod.snd.{u2, u1} E F x) (Prod.snd.{u2, u1} E F y))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_graph_snd_inj' LinearPMap.mem_graph_snd_inj'ₓ'. -/
theorem mem_graph_snd_inj' (f : E →ₗ.[R] F) {x y : E × F} (hx : x ∈ f.graph) (hy : y ∈ f.graph)
    (hxy : x.1 = y.1) : x.2 = y.2 := by
  cases x
  cases y
  exact f.mem_graph_snd_inj hx hy hxy
#align linear_pmap.mem_graph_snd_inj' LinearPMap.mem_graph_snd_inj'

/- warning: linear_pmap.graph_fst_eq_zero_snd -> LinearPMap.graph_fst_eq_zero_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : E} {x' : F}, (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x x') (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E x (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F x' (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] (f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) {x : E} {x' : F}, (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x x') (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Eq.{succ u2} E x (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) -> (Eq.{succ u1} F x' (OfNat.ofNat.{u1} F 0 (Zero.toOfNat0.{u1} F (NegZeroClass.toZero.{u1} F (SubNegZeroMonoid.toNegZeroClass.{u1} F (SubtractionMonoid.toSubNegZeroMonoid.{u1} F (SubtractionCommMonoid.toSubtractionMonoid.{u1} F (AddCommGroup.toDivisionAddCommMonoid.{u1} F _inst_4))))))))
Case conversion may be inaccurate. Consider using '#align linear_pmap.graph_fst_eq_zero_snd LinearPMap.graph_fst_eq_zero_sndₓ'. -/
/-- The property that `f 0 = 0` in terms of the graph. -/
theorem graph_fst_eq_zero_snd (f : E →ₗ.[R] F) {x : E} {x' : F} (h : (x, x') ∈ f.graph)
    (hx : x = 0) : x' = 0 :=
  f.mem_graph_snd_inj h f.graph.zero_mem hx
#align linear_pmap.graph_fst_eq_zero_snd LinearPMap.graph_fst_eq_zero_snd

/- warning: linear_pmap.mem_domain_iff -> LinearPMap.mem_domain_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E}, Iff (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u3} F (fun (y : F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x y) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E}, Iff (Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Exists.{succ u1} F (fun (y : F) => Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x y) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_domain_iff LinearPMap.mem_domain_iffₓ'. -/
theorem mem_domain_iff {f : E →ₗ.[R] F} {x : E} : x ∈ f.domain ↔ ∃ y : F, (x, y) ∈ f.graph :=
  by
  constructor <;> intro h
  · use f ⟨x, h⟩
    exact f.mem_graph ⟨x, h⟩
  cases' h with y h
  rw [mem_graph_iff] at h
  cases' h with x' h
  simp only at h
  rw [← h.1]
  simp
#align linear_pmap.mem_domain_iff LinearPMap.mem_domain_iff

/- warning: linear_pmap.mem_domain_of_mem_graph -> LinearPMap.mem_domain_of_mem_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E} {y : F}, (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x y) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E} {y : F}, (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x y) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> (Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_domain_of_mem_graph LinearPMap.mem_domain_of_mem_graphₓ'. -/
theorem mem_domain_of_mem_graph {f : E →ₗ.[R] F} {x : E} {y : F} (h : (x, y) ∈ f.graph) :
    x ∈ f.domain := by
  rw [mem_domain_iff]
  exact ⟨y, h⟩
#align linear_pmap.mem_domain_of_mem_graph LinearPMap.mem_domain_of_mem_graph

/- warning: linear_pmap.image_iff -> LinearPMap.image_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E} {y : F} (hx : Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Iff (Eq.{succ u3} F y (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f (Subtype.mk.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) x hx))) (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x y) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {x : E} {y : F} (hx : Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)), Iff (Eq.{succ u1} F y (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (Subtype.mk.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) x hx))) (Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x y) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))
Case conversion may be inaccurate. Consider using '#align linear_pmap.image_iff LinearPMap.image_iffₓ'. -/
theorem image_iff {f : E →ₗ.[R] F} {x : E} {y : F} (hx : x ∈ f.domain) :
    y = f ⟨x, hx⟩ ↔ (x, y) ∈ f.graph := by
  rw [mem_graph_iff]
  constructor <;> intro h
  · use ⟨x, hx⟩
    simp [h]
  rcases h with ⟨⟨x', hx'⟩, ⟨h1, h2⟩⟩
  simp only [Submodule.coe_mk] at h1 h2
  simp only [← h2, h1]
#align linear_pmap.image_iff LinearPMap.image_iff

/- warning: linear_pmap.mem_range_iff -> LinearPMap.mem_range_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {y : F}, Iff (Membership.Mem.{u3, u3} F (Set.{u3} F) (Set.hasMem.{u3} F) y (Set.range.{u3, succ u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f))) (Exists.{succ u2} E (fun (x : E) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F x y) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {y : F}, Iff (Membership.mem.{u1, u1} F (Set.{u1} F) (Set.instMembershipSet.{u1} F) y (Set.range.{u1, succ u2} F (Subtype.{succ u2} E (fun (x : E) => Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (LinearPMap.toFun'.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f))) (Exists.{succ u2} E (fun (x : E) => Membership.mem.{max u1 u2, max u2 u1} (Prod.{u2, u1} E F) (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u1, max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u1} E F) (Submodule.instSetLikeSubmodule.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u1} E F x y) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_range_iff LinearPMap.mem_range_iffₓ'. -/
theorem mem_range_iff {f : E →ₗ.[R] F} {y : F} : y ∈ Set.range f ↔ ∃ x : E, (x, y) ∈ f.graph :=
  by
  constructor <;> intro h
  · rw [Set.mem_range] at h
    rcases h with ⟨⟨x, hx⟩, h⟩
    use x
    rw [← h]
    exact f.mem_graph ⟨x, hx⟩
  cases' h with x h
  rw [mem_graph_iff] at h
  cases' h with x h
  rw [Set.mem_range]
  use x
  simp only at h
  rw [h.2]
#align linear_pmap.mem_range_iff LinearPMap.mem_range_iff

/- warning: linear_pmap.mem_domain_iff_of_eq_graph -> LinearPMap.mem_domain_iff_of_eq_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall {x : E}, Iff (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{max (succ u2) (succ u1)} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (forall {x : E}, Iff (Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) (Membership.mem.{u2, u2} E (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (LinearPMap.domain.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)))
Case conversion may be inaccurate. Consider using '#align linear_pmap.mem_domain_iff_of_eq_graph LinearPMap.mem_domain_iff_of_eq_graphₓ'. -/
theorem mem_domain_iff_of_eq_graph {f g : E →ₗ.[R] F} (h : f.graph = g.graph) {x : E} :
    x ∈ f.domain ↔ x ∈ g.domain := by simp_rw [mem_domain_iff, h]
#align linear_pmap.mem_domain_iff_of_eq_graph LinearPMap.mem_domain_iff_of_eq_graph

/- warning: linear_pmap.le_of_le_graph -> LinearPMap.le_of_le_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))))) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Submodule.completeLattice.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)))))) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.le_of_le_graph LinearPMap.le_of_le_graphₓ'. -/
theorem le_of_le_graph {f g : E →ₗ.[R] F} (h : f.graph ≤ g.graph) : f ≤ g :=
  by
  constructor
  · intro x hx
    rw [mem_domain_iff] at hx⊢
    cases' hx with y hx
    use y
    exact h hx
  rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy
  rw [image_iff]
  refine' h _
  simp only [Submodule.coe_mk] at hxy
  rw [hxy] at hx
  rw [← image_iff hx]
  simp [hxy]
#align linear_pmap.le_of_le_graph LinearPMap.le_of_le_graph

/- warning: linear_pmap.le_graph_of_le -> LinearPMap.le_graph_of_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) -> (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))))) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g) -> (LE.le.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Submodule.completeLattice.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)))))) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g))
Case conversion may be inaccurate. Consider using '#align linear_pmap.le_graph_of_le LinearPMap.le_graph_of_leₓ'. -/
theorem le_graph_of_le {f g : E →ₗ.[R] F} (h : f ≤ g) : f.graph ≤ g.graph :=
  by
  intro x hx
  rw [mem_graph_iff] at hx⊢
  cases' hx with y hx
  use y
  · exact h.1 y.2
  simp only [hx, Submodule.coe_mk, eq_self_iff_true, true_and_iff]
  convert hx.2
  refine' (h.2 _).symm
  simp only [hx.1, Submodule.coe_mk]
#align linear_pmap.le_graph_of_le LinearPMap.le_graph_of_le

/- warning: linear_pmap.le_graph_iff -> LinearPMap.le_graph_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, Iff (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))))) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (LE.le.{max u2 u3} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, Iff (LE.le.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Preorder.toLE.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (PartialOrder.toPreorder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u1} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (Submodule.completeLattice.{u3, max u2 u1} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)))))) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) (LE.le.{max u2 u1} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (LinearPMap.le.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.le_graph_iff LinearPMap.le_graph_iffₓ'. -/
theorem le_graph_iff {f g : E →ₗ.[R] F} : f.graph ≤ g.graph ↔ f ≤ g :=
  ⟨le_of_le_graph, le_graph_of_le⟩
#align linear_pmap.le_graph_iff LinearPMap.le_graph_iff

/- warning: linear_pmap.eq_of_eq_graph -> LinearPMap.eq_of_eq_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (Eq.{max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u3, u2} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u1}} [_inst_4 : AddCommGroup.{u1} F] [_inst_5 : Module.{u3, u1} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)] {f : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5} {g : LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5}, (Eq.{max (succ u2) (succ u1)} (Submodule.{u3, max u1 u2} R (Prod.{u2, u1} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u1} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4)) (Prod.module.{u3, u2, u1} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u1} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f) (LinearPMap.graph.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g)) -> (Eq.{max (succ u2) (succ u1)} (LinearPMap.{u3, u2, u1} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) f g)
Case conversion may be inaccurate. Consider using '#align linear_pmap.eq_of_eq_graph LinearPMap.eq_of_eq_graphₓ'. -/
theorem eq_of_eq_graph {f g : E →ₗ.[R] F} (h : f.graph = g.graph) : f = g :=
  by
  ext
  exact mem_domain_iff_of_eq_graph h
  exact (le_of_le_graph h.le).2
#align linear_pmap.eq_of_eq_graph LinearPMap.eq_of_eq_graph

end Graph

end LinearPMap

namespace Submodule

section SubmoduleToLinearPmap

/- warning: submodule.exists_unique_from_graph -> Submodule.existsUnique_from_graph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)}, (forall {x : Prod.{u2, u3} E F}, (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) -> (forall {a : E}, (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) a (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)) -> (ExistsUnique.{succ u3} F (fun (b : F) => Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F a b) g)))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u3, u2} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {g : Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)}, (forall {x : Prod.{u1, u2} E F}, (Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u1} E (Prod.fst.{u1, u2} E F x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))))) -> (Eq.{succ u2} F (Prod.snd.{u1, u2} E F x) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))))))) -> (forall {a : E}, (Membership.mem.{u1, u1} E (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) a (Submodule.map.{u3, u3, max u1 u2, u1, max u1 u2} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u1, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Prod.{u1, u2} E F) E (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u1 u2, u1} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.fst.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) g)) -> (ExistsUnique.{succ u2} F (fun (b : F) => Membership.mem.{max u2 u1, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u1, u2} E F a b) g)))
Case conversion may be inaccurate. Consider using '#align submodule.exists_unique_from_graph Submodule.existsUnique_from_graphₓ'. -/
theorem existsUnique_from_graph {g : Submodule R (E × F)}
    (hg : ∀ {x : E × F} (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ∈ g.map (LinearMap.fst R E F)) : ∃! b : F, (a, b) ∈ g :=
  by
  refine' existsUnique_of_exists_of_unique _ _
  · convert ha
    simp
  intro y₁ y₂ hy₁ hy₂
  have hy : ((0 : E), y₁ - y₂) ∈ g := by
    convert g.sub_mem hy₁ hy₂
    exact (sub_self _).symm
  exact sub_eq_zero.mp (hg hy (by simp))
#align submodule.exists_unique_from_graph Submodule.existsUnique_from_graph

/- warning: submodule.val_from_graph -> Submodule.valFromGraph is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)}, (forall (x : Prod.{u2, u3} E F), (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) -> (forall {a : E}, (Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) a (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Submodule.valFromGraph._proof_1.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)) -> F)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {g : Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)}, (forall (x : Prod.{u2, u3} E F), (Membership.mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.instSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (Zero.toOfNat0.{u3} F (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))))))) -> (forall {a : E}, (Membership.mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) a (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)) -> F)
Case conversion may be inaccurate. Consider using '#align submodule.val_from_graph Submodule.valFromGraphₓ'. -/
/-- Auxiliary definition to unfold the existential quantifier. -/
noncomputable def valFromGraph {g : Submodule R (E × F)}
    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ∈ g.map (LinearMap.fst R E F)) : F :=
  (ExistsUnique.exists (existsUnique_from_graph hg ha)).some
#align submodule.val_from_graph Submodule.valFromGraph

/- warning: submodule.val_from_graph_mem -> Submodule.valFromGraph_mem is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] {g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)} (hg : forall (x : Prod.{u2, u3} E F), (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) {a : E} (ha : Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) a (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)), Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F a (Submodule.valFromGraph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg a ha)) g
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u3, u2} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] {g : Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)} (hg : forall (x : Prod.{u1, u2} E F), (Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u1} E (Prod.fst.{u1, u2} E F x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))))) -> (Eq.{succ u2} F (Prod.snd.{u1, u2} E F x) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))))))) {a : E} (ha : Membership.mem.{u1, u1} E (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) a (Submodule.map.{u3, u3, max u1 u2, u1, max u1 u2} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u1, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Prod.{u1, u2} E F) E (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u1 u2, u1} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.fst.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) g)), Membership.mem.{max u2 u1, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u1, u2} E F a (Submodule.valFromGraph.{u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg a ha)) g
Case conversion may be inaccurate. Consider using '#align submodule.val_from_graph_mem Submodule.valFromGraph_memₓ'. -/
theorem valFromGraph_mem {g : Submodule R (E × F)}
    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ∈ g.map (LinearMap.fst R E F)) : (a, valFromGraph hg ha) ∈ g :=
  (ExistsUnique.exists (existsUnique_from_graph hg ha)).choose_spec
#align submodule.val_from_graph_mem Submodule.valFromGraph_mem

/- warning: submodule.to_linear_pmap -> Submodule.toLinearPMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)), (forall (x : Prod.{u2, u3} E F), (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
but is expected to have type
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (g : Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)), (forall (x : Prod.{u2, u3} E F), (Membership.mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.instSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (Zero.toOfNat0.{u2} E (NegZeroClass.toZero.{u2} E (SubNegZeroMonoid.toNegZeroClass.{u2} E (SubtractionMonoid.toSubNegZeroMonoid.{u2} E (SubtractionCommMonoid.toSubtractionMonoid.{u2} E (AddCommGroup.toDivisionAddCommMonoid.{u2} E _inst_2)))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (Zero.toOfNat0.{u3} F (NegZeroClass.toZero.{u3} F (SubNegZeroMonoid.toNegZeroClass.{u3} F (SubtractionMonoid.toSubNegZeroMonoid.{u3} F (SubtractionCommMonoid.toSubtractionMonoid.{u3} F (AddCommGroup.toDivisionAddCommMonoid.{u3} F _inst_4))))))))) -> (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align submodule.to_linear_pmap Submodule.toLinearPMapₓ'. -/
/-- Define a `linear_pmap` from its graph. -/
noncomputable def toLinearPMap (g : Submodule R (E × F))
    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) : E →ₗ.[R] F
    where
  domain := g.map (LinearMap.fst R E F)
  toFun :=
    { toFun := fun x => valFromGraph hg x.2
      map_add' := fun v w =>
        by
        have hadd := (g.map (LinearMap.fst R E F)).add_mem v.2 w.2
        have hvw := val_from_graph_mem hg hadd
        have hvw' := g.add_mem (val_from_graph_mem hg v.2) (val_from_graph_mem hg w.2)
        rw [Prod.mk_add_mk] at hvw'
        exact (exists_unique_from_graph hg hadd).unique hvw hvw'
      map_smul' := fun a v =>
        by
        have hsmul := (g.map (LinearMap.fst R E F)).smul_mem a v.2
        have hav := val_from_graph_mem hg hsmul
        have hav' := g.smul_mem a (val_from_graph_mem hg v.2)
        rw [Prod.smul_mk] at hav'
        exact (exists_unique_from_graph hg hsmul).unique hav hav' }
#align submodule.to_linear_pmap Submodule.toLinearPMap

/- warning: submodule.mem_graph_to_linear_pmap -> Submodule.mem_graph_toLinearPMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (hg : forall (x : Prod.{u2, u3} E F), (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))) (x : coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)), Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u2, u3} E F (Subtype.val.{succ u2} E (fun (x : E) => Membership.Mem.{u2, u2} E (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) (SetLike.hasMem.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) x (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R (Ring.toSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1))) (Prod.{u2, u3} E F) E (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} E F) E (Ring.toSemiring.{u1} R _inst_1) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R (Ring.toSemiring.{u1} R _inst_1)))) (LinearMap.fst.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5) g)) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (fun (f : LinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) => (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3) E (Submodule.setLike.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) _inst_3)) (LinearPMap.domain.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f)) -> F) (LinearPMap.hasCoeToFun.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5) (Submodule.toLinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg) x)) g
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u3, u2} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (g : Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (hg : forall (x : Prod.{u1, u2} E F), (Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u1} E (Prod.fst.{u1, u2} E F x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))))) -> (Eq.{succ u2} F (Prod.snd.{u1, u2} E F x) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))))))) (x : Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) x (Submodule.map.{u3, u3, max u1 u2, u1, max u1 u2} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u1, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Prod.{u1, u2} E F) E (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u1 u2, u1} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.fst.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) g))), Membership.mem.{max u2 u1, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) (Prod.mk.{u1, u2} E F (Subtype.val.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Submodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3) E (Submodule.instSetLikeSubmodule.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) _inst_3)) x (Submodule.map.{u3, u3, max u1 u2, u1, max u1 u2} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R (Ring.toSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u1, u1} R R (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1))) (Prod.{u1, u2} E F) E (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u1 u2, u1} R R (Prod.{u1, u2} E F) E (Ring.toSemiring.{u3} R _inst_1) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) _inst_3 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R (Ring.toSemiring.{u3} R _inst_1)))) (LinearMap.fst.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5) g)) x) (LinearPMap.toFun'.{u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Submodule.toLinearPMap.{u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg) x)) g
Case conversion may be inaccurate. Consider using '#align submodule.mem_graph_to_linear_pmap Submodule.mem_graph_toLinearPMapₓ'. -/
theorem mem_graph_toLinearPMap (g : Submodule R (E × F))
    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0)
    (x : g.map (LinearMap.fst R E F)) : (x.val, g.toLinearPMap hg x) ∈ g :=
  valFromGraph_mem hg x.2
#align submodule.mem_graph_to_linear_pmap Submodule.mem_graph_toLinearPMap

/- warning: submodule.to_linear_pmap_graph_eq -> Submodule.toLinearPMap_graph_eq is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Ring.{u1} R] {E : Type.{u2}} [_inst_2 : AddCommGroup.{u2} E] [_inst_3 : Module.{u1, u2} R E (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2)] {F : Type.{u3}} [_inst_4 : AddCommGroup.{u3} F] [_inst_5 : Module.{u1, u3} R F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)] (g : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (hg : forall (x : Prod.{u2, u3} E F), (Membership.Mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} E F) (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (SetLike.hasMem.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (Prod.{u2, u3} E F) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u2} E (Prod.fst.{u2, u3} E F x) (OfNat.ofNat.{u2} E 0 (OfNat.mk.{u2} E 0 (Zero.zero.{u2} E (AddZeroClass.toHasZero.{u2} E (AddMonoid.toAddZeroClass.{u2} E (SubNegMonoid.toAddMonoid.{u2} E (AddGroup.toSubNegMonoid.{u2} E (AddCommGroup.toAddGroup.{u2} E _inst_2))))))))) -> (Eq.{succ u3} F (Prod.snd.{u2, u3} E F x) (OfNat.ofNat.{u3} F 0 (OfNat.mk.{u3} F 0 (Zero.zero.{u3} F (AddZeroClass.toHasZero.{u3} F (AddMonoid.toAddZeroClass.{u3} F (SubNegMonoid.toAddMonoid.{u3} F (AddGroup.toSubNegMonoid.{u3} F (AddCommGroup.toAddGroup.{u3} F _inst_4)))))))))), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} E F) (Ring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} E F (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4)) (Prod.module.{u1, u2, u3} R E F (Ring.toSemiring.{u1} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} E _inst_2) (AddCommGroup.toAddCommMonoid.{u3} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Submodule.toLinearPMap.{u1, u2, u3} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg)) g
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Ring.{u3} R] {E : Type.{u1}} [_inst_2 : AddCommGroup.{u1} E] [_inst_3 : Module.{u3, u1} R E (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2)] {F : Type.{u2}} [_inst_4 : AddCommGroup.{u2} F] [_inst_5 : Module.{u3, u2} R F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)] (g : Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (hg : forall (x : Prod.{u1, u2} E F), (Membership.mem.{max u1 u2, max u1 u2} (Prod.{u1, u2} E F) (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (Prod.{u1, u2} E F) (Submodule.instSetLikeSubmodule.{u3, max u1 u2} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5))) x g) -> (Eq.{succ u1} E (Prod.fst.{u1, u2} E F x) (OfNat.ofNat.{u1} E 0 (Zero.toOfNat0.{u1} E (NegZeroClass.toZero.{u1} E (SubNegZeroMonoid.toNegZeroClass.{u1} E (SubtractionMonoid.toSubNegZeroMonoid.{u1} E (SubtractionCommMonoid.toSubtractionMonoid.{u1} E (AddCommGroup.toDivisionAddCommMonoid.{u1} E _inst_2)))))))) -> (Eq.{succ u2} F (Prod.snd.{u1, u2} E F x) (OfNat.ofNat.{u2} F 0 (Zero.toOfNat0.{u2} F (NegZeroClass.toZero.{u2} F (SubNegZeroMonoid.toNegZeroClass.{u2} F (SubtractionMonoid.toSubNegZeroMonoid.{u2} F (SubtractionCommMonoid.toSubtractionMonoid.{u2} F (AddCommGroup.toDivisionAddCommMonoid.{u2} F _inst_4))))))))), Eq.{max (succ u1) (succ u2)} (Submodule.{u3, max u2 u1} R (Prod.{u1, u2} E F) (Ring.toSemiring.{u3} R _inst_1) (Prod.instAddCommMonoidSum.{u1, u2} E F (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4)) (Prod.module.{u3, u1, u2} R E F (Ring.toSemiring.{u3} R _inst_1) (AddCommGroup.toAddCommMonoid.{u1} E _inst_2) (AddCommGroup.toAddCommMonoid.{u2} F _inst_4) _inst_3 _inst_5)) (LinearPMap.graph.{u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (Submodule.toLinearPMap.{u3, u1, u2} R _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 g hg)) g
Case conversion may be inaccurate. Consider using '#align submodule.to_linear_pmap_graph_eq Submodule.toLinearPMap_graph_eqₓ'. -/
@[simp]
theorem toLinearPMap_graph_eq (g : Submodule R (E × F))
    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) :
    (g.toLinearPMap hg).graph = g := by
  ext
  constructor <;> intro hx
  · rw [LinearPMap.mem_graph_iff] at hx
    rcases hx with ⟨y, hx1, hx2⟩
    convert g.mem_graph_to_linear_pmap hg y
    rw [Subtype.val_eq_coe]
    exact Prod.ext hx1.symm hx2.symm
  rw [LinearPMap.mem_graph_iff]
  cases x
  have hx_fst : x_fst ∈ g.map (LinearMap.fst R E F) :=
    by
    simp only [mem_map, LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]
    exact ⟨x_snd, hx⟩
  refine' ⟨⟨x_fst, hx_fst⟩, Subtype.coe_mk x_fst hx_fst, _⟩
  exact (exists_unique_from_graph hg hx_fst).unique (val_from_graph_mem hg hx_fst) hx
#align submodule.to_linear_pmap_graph_eq Submodule.toLinearPMap_graph_eq

end SubmoduleToLinearPmap

end Submodule

