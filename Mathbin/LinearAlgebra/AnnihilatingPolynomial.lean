/-
Copyright (c) 2022 Justin Thomas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justin Thomas

! This file was ported from Lean 3 source module linear_algebra.annihilating_polynomial
! leanprover-community/mathlib commit d3e8e0a0237c10c2627bf52c246b15ff8e7df4c0
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.FieldTheory.Minpoly.Field
import Mathbin.RingTheory.PrincipalIdealDomain

/-!
# Annihilating Ideal

Given a commutative ring `R` and an `R`-algebra `A`
Every element `a : A` defines
an ideal `polynomial.ann_ideal a ⊆ R[X]`.
Simply put, this is the set of polynomials `p` where
the polynomial evaluation `p(a)` is 0.

## Special case where the ground ring is a field

In the special case that `R` is a field, we use the notation `R = 𝕜`.
Here `𝕜[X]` is a PID, so there is a polynomial `g ∈ polynomial.ann_ideal a`
which generates the ideal. We show that if this generator is
chosen to be monic, then it is the minimal polynomial of `a`,
as defined in `field_theory.minpoly`.

## Special case: endomorphism algebra

Given an `R`-module `M` (`[add_comm_group M] [module R M]`)
there are some common specializations which may be more familiar.
* Example 1: `A = M →ₗ[R] M`, the endomorphism algebra of an `R`-module M.
* Example 2: `A = n × n` matrices with entries in `R`.
-/


open Polynomial

namespace Polynomial

section Semiring

variable {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A]

variable (R)

#print Polynomial.annIdeal /-
/-- `ann_ideal R a` is the *annihilating ideal* of all `p : R[X]` such that `p(a) = 0`.

The informal notation `p(a)` stand for `polynomial.aeval a p`.
Again informally, the annihilating ideal of `a` is
`{ p ∈ R[X] | p(a) = 0 }`. This is an ideal in `R[X]`.
The formal definition uses the kernel of the aeval map. -/
noncomputable def annIdeal (a : A) : Ideal R[X] :=
  ((aeval a).toRingHom : R[X] →+* A).ker
#align polynomial.ann_ideal Polynomial.annIdeal
-/

variable {R}

/- warning: polynomial.mem_ann_ideal_iff_aeval_eq_zero -> Polynomial.mem_annIdeal_iff_aeval_eq_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {A : Type.{u2}} [_inst_1 : CommSemiring.{u1} R] [_inst_2 : Semiring.{u2} A] [_inst_3 : Algebra.{u1, u2} R A _inst_1 _inst_2] {a : A} {p : Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)}, Iff (Membership.Mem.{u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Ideal.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Submodule.setLike.{u1, u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) (Semiring.toModule.{u1} (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1))))) p (Polynomial.annIdeal.{u1, u2} R A _inst_1 _inst_2 _inst_3 a)) (Eq.{succ u2} A (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) (fun (_x : AlgHom.{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) => (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) -> A) ([anonymous].{u1, u1, u2} R (Polynomial.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) A _inst_1 (Polynomial.semiring.{u1} R (CommSemiring.toSemiring.{u1} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u1, u1} R R _inst_1 (CommSemiring.toSemiring.{u1} R _inst_1) (Algebra.id.{u1} R _inst_1)) _inst_3) (Polynomial.aeval.{u1, u2} R A _inst_1 _inst_2 _inst_3 a) p) (OfNat.ofNat.{u2} A 0 (OfNat.mk.{u2} A 0 (Zero.zero.{u2} A (MulZeroClass.toHasZero.{u2} A (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} A (Semiring.toNonAssocSemiring.{u2} A _inst_2))))))))
but is expected to have type
  forall {R : Type.{u2}} {A : Type.{u1}} [_inst_1 : CommSemiring.{u2} R] [_inst_2 : Semiring.{u1} A] [_inst_3 : Algebra.{u2, u1} R A _inst_1 _inst_2] {a : A} {p : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)}, Iff (Membership.mem.{u2, u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Ideal.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Submodule.setLike.{u2, u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Semiring.toModule.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) p (Polynomial.annIdeal.{u2, u1} R A _inst_1 _inst_2 _inst_3 a)) (Eq.{succ u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) p) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3) (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (fun (_x : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) _x) (SMulHomClass.toFunLike.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A (SMulZeroClass.toSMul.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toZero.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (DistribSMul.toSMulZeroClass.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddMonoid.toAddZeroClass.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))))) (DistribMulAction.toDistribSMul.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1))))))) (SMulZeroClass.toSMul.{u2, u1} R A (AddMonoid.toZero.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))))) (DistribSMul.toSMulZeroClass.{u2, u1} R A (AddMonoid.toAddZeroClass.{u1} A (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))))) (DistribMulAction.toDistribSMul.{u2, u1} R A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3))))) (DistribMulActionHomClass.toSMulHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (AddCommMonoid.toAddMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))))) (AddCommMonoid.toAddMonoid.{u1} A (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)))) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u1 u2, u2, u2, u1} (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3) R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2)) (Module.toDistribMulAction.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1))))) (Algebra.toModule.{u2, u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)))) (Module.toDistribMulAction.{u2, u1} R A (CommSemiring.toSemiring.{u2} R _inst_1) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} A (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_2))) (Algebra.toModule.{u2, u1} R A _inst_1 _inst_2 _inst_3)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u2, u1, max u1 u2} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3 (AlgHom.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3) (AlgHom.algHomClass.{u2, u2, u1} R (Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) A _inst_1 (Polynomial.semiring.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) _inst_2 (Polynomial.algebraOfAlgebra.{u2, u2} R R _inst_1 (CommSemiring.toSemiring.{u2} R _inst_1) (Algebra.id.{u2} R _inst_1)) _inst_3))))) (Polynomial.aeval.{u2, u1} R A _inst_1 _inst_2 _inst_3 a) p) (OfNat.ofNat.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) p) 0 (Zero.toOfNat0.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) p) (MonoidWithZero.toZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) p) (Semiring.toMonoidWithZero.{u1} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Polynomial.{u2} R (CommSemiring.toSemiring.{u2} R _inst_1)) => A) p) _inst_2)))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_ann_ideal_iff_aeval_eq_zero Polynomial.mem_annIdeal_iff_aeval_eq_zeroₓ'. -/
/-- It is useful to refer to ideal membership sometimes
 and the annihilation condition other times. -/
theorem mem_annIdeal_iff_aeval_eq_zero {a : A} {p : R[X]} : p ∈ annIdeal R a ↔ aeval a p = 0 :=
  Iff.rfl
#align polynomial.mem_ann_ideal_iff_aeval_eq_zero Polynomial.mem_annIdeal_iff_aeval_eq_zero

end Semiring

section Field

variable {𝕜 A : Type _} [Field 𝕜] [Ring A] [Algebra 𝕜 A]

variable (𝕜)

open Submodule

#print Polynomial.annIdealGenerator /-
/-- `ann_ideal_generator 𝕜 a` is the monic generator of `ann_ideal 𝕜 a`
if one exists, otherwise `0`.

Since `𝕜[X]` is a principal ideal domain there is a polynomial `g` such that
 `span 𝕜 {g} = ann_ideal a`. This picks some generator.
 We prefer the monic generator of the ideal. -/
noncomputable def annIdealGenerator (a : A) : 𝕜[X] :=
  let g := IsPrincipal.generator <| annIdeal 𝕜 a
  g * C g.leadingCoeff⁻¹
#align polynomial.ann_ideal_generator Polynomial.annIdealGenerator
-/

section

variable {𝕜}

/- warning: polynomial.ann_ideal_generator_eq_zero_iff -> Polynomial.annIdealGenerator_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] {a : A}, Iff (Eq.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) (OfNat.ofNat.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.zero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))))))) (Eq.{succ u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a) (Bot.bot.{u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Submodule.hasBot.{u1, u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Semiring.toModule.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))))
but is expected to have type
  forall {𝕜 : Type.{u2}} {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] {a : A}, Iff (Eq.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) (OfNat.ofNat.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.zero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Eq.{succ u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a) (Bot.bot.{u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Submodule.instBotSubmodule.{u2, u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Semiring.toModule.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))))
Case conversion may be inaccurate. Consider using '#align polynomial.ann_ideal_generator_eq_zero_iff Polynomial.annIdealGenerator_eq_zero_iffₓ'. -/
@[simp]
theorem annIdealGenerator_eq_zero_iff {a : A} : annIdealGenerator 𝕜 a = 0 ↔ annIdeal 𝕜 a = ⊥ := by
  simp only [ann_ideal_generator, mul_eq_zero, is_principal.eq_bot_iff_generator_eq_zero,
    Polynomial.C_eq_zero, inv_eq_zero, Polynomial.leadingCoeff_eq_zero, or_self_iff]
#align polynomial.ann_ideal_generator_eq_zero_iff Polynomial.annIdealGenerator_eq_zero_iff

end

/- warning: polynomial.span_singleton_ann_ideal_generator -> Polynomial.span_singleton_annIdealGenerator is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A), Eq.{succ u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Ideal.span.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Singleton.singleton.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Set.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Set.hasSingleton.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a))) (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A), Eq.{succ u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Ideal.span.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Singleton.singleton.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Set.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Set.instSingletonSet.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a))) (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)
Case conversion may be inaccurate. Consider using '#align polynomial.span_singleton_ann_ideal_generator Polynomial.span_singleton_annIdealGeneratorₓ'. -/
/-- `ann_ideal_generator 𝕜 a` is indeed a generator. -/
@[simp]
theorem span_singleton_annIdealGenerator (a : A) :
    Ideal.span {annIdealGenerator 𝕜 a} = annIdeal 𝕜 a :=
  by
  by_cases h : ann_ideal_generator 𝕜 a = 0
  · rw [h, ann_ideal_generator_eq_zero_iff.mp h, Set.singleton_zero, Ideal.span_zero]
  · rw [ann_ideal_generator, Ideal.span_singleton_mul_right_unit, Ideal.span_singleton_generator]
    apply polynomial.is_unit_C.mpr
    apply IsUnit.mk0
    apply inv_eq_zero.not.mpr
    apply polynomial.leading_coeff_eq_zero.not.mpr
    apply (mul_ne_zero_iff.mp h).1
#align polynomial.span_singleton_ann_ideal_generator Polynomial.span_singleton_annIdealGenerator

/- warning: polynomial.ann_ideal_generator_mem -> Polynomial.annIdealGenerator_mem is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A), Membership.Mem.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Submodule.setLike.{u1, u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Semiring.toModule.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A), Membership.mem.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Submodule.setLike.{u2, u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Semiring.toModule.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)
Case conversion may be inaccurate. Consider using '#align polynomial.ann_ideal_generator_mem Polynomial.annIdealGenerator_memₓ'. -/
/-- The annihilating ideal generator is a member of the annihilating ideal. -/
theorem annIdealGenerator_mem (a : A) : annIdealGenerator 𝕜 a ∈ annIdeal 𝕜 a :=
  Ideal.mul_mem_right _ _ (Submodule.IsPrincipal.generator_mem _)
#align polynomial.ann_ideal_generator_mem Polynomial.annIdealGenerator_mem

/- warning: polynomial.mem_iff_eq_smul_ann_ideal_generator -> Polynomial.mem_iff_eq_smul_annIdealGenerator is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] {p : Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))} (a : A), Iff (Membership.Mem.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Submodule.setLike.{u1, u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Semiring.toModule.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)) (Exists.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (fun (s : Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) => Eq.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) p (SMul.smul.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Mul.toSMul.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.mul'.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1))))) s (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a))))
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] {p : Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))} (a : A), Iff (Membership.mem.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Submodule.setLike.{u2, u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Semiring.toModule.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)) (Exists.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (fun (s : Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) => Eq.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) p (HSMul.hSMul.{u2, u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (instHSMul.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Algebra.toSMul.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.commSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))) (Polynomial.semiring.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Algebra.id.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.commSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))))) s (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a))))
Case conversion may be inaccurate. Consider using '#align polynomial.mem_iff_eq_smul_ann_ideal_generator Polynomial.mem_iff_eq_smul_annIdealGeneratorₓ'. -/
theorem mem_iff_eq_smul_annIdealGenerator {p : 𝕜[X]} (a : A) :
    p ∈ annIdeal 𝕜 a ↔ ∃ s : 𝕜[X], p = s • annIdealGenerator 𝕜 a := by
  simp_rw [@eq_comm _ p, ← mem_span_singleton, ← span_singleton_ann_ideal_generator 𝕜 a, Ideal.span]
#align polynomial.mem_iff_eq_smul_ann_ideal_generator Polynomial.mem_iff_eq_smul_annIdealGenerator

/- warning: polynomial.monic_ann_ideal_generator -> Polynomial.monic_annIdealGenerator is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A), (Ne.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) (OfNat.ofNat.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.zero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))))))) -> (Polynomial.Monic.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a))
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A), (Ne.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) (OfNat.ofNat.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.zero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) -> (Polynomial.Monic.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a))
Case conversion may be inaccurate. Consider using '#align polynomial.monic_ann_ideal_generator Polynomial.monic_annIdealGeneratorₓ'. -/
/-- The generator we chose for the annihilating ideal is monic when the ideal is non-zero. -/
theorem monic_annIdealGenerator (a : A) (hg : annIdealGenerator 𝕜 a ≠ 0) :
    Monic (annIdealGenerator 𝕜 a) :=
  monic_mul_leadingCoeff_inv (mul_ne_zero_iff.mp hg).1
#align polynomial.monic_ann_ideal_generator Polynomial.monic_annIdealGenerator

/-! We are working toward showing the generator of the annihilating ideal
in the field case is the minimal polynomial. We are going to use a uniqueness
theorem of the minimal polynomial.

This is the first condition: it must annihilate the original element `a : A`. -/


#print Polynomial.annIdealGenerator_aeval_eq_zero /-
theorem annIdealGenerator_aeval_eq_zero (a : A) : aeval a (annIdealGenerator 𝕜 a) = 0 :=
  mem_annIdeal_iff_aeval_eq_zero.mp (annIdealGenerator_mem 𝕜 a)
#align polynomial.ann_ideal_generator_aeval_eq_zero Polynomial.annIdealGenerator_aeval_eq_zero
-/

variable {𝕜}

/- warning: polynomial.mem_iff_ann_ideal_generator_dvd -> Polynomial.mem_iff_annIdealGenerator_dvd is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] {p : Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))} {a : A}, Iff (Membership.Mem.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Submodule.setLike.{u1, u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Semiring.toModule.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)) (Dvd.Dvd.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (semigroupDvd.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (SemigroupWithZero.toSemigroup.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (NonUnitalSemiring.toSemigroupWithZero.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (NonUnitalRing.toNonUnitalSemiring.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (NonUnitalCommRing.toNonUnitalRing.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (CommRing.toNonUnitalCommRing.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.commRing.{u1} 𝕜 (EuclideanDomain.toCommRing.{u1} 𝕜 (Field.toEuclideanDomain.{u1} 𝕜 _inst_1))))))))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) p)
but is expected to have type
  forall {𝕜 : Type.{u2}} {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] {p : Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))} {a : A}, Iff (Membership.mem.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Submodule.setLike.{u2, u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Semiring.toModule.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)) (Dvd.dvd.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (semigroupDvd.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (SemigroupWithZero.toSemigroup.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalSemiring.toSemigroupWithZero.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (CommRing.toNonUnitalCommRing.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.commRing.{u2} 𝕜 (EuclideanDomain.toCommRing.{u2} 𝕜 (Field.toEuclideanDomain.{u2} 𝕜 _inst_1))))))))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) p)
Case conversion may be inaccurate. Consider using '#align polynomial.mem_iff_ann_ideal_generator_dvd Polynomial.mem_iff_annIdealGenerator_dvdₓ'. -/
theorem mem_iff_annIdealGenerator_dvd {p : 𝕜[X]} {a : A} :
    p ∈ annIdeal 𝕜 a ↔ annIdealGenerator 𝕜 a ∣ p := by
  rw [← Ideal.mem_span_singleton, span_singleton_ann_ideal_generator]
#align polynomial.mem_iff_ann_ideal_generator_dvd Polynomial.mem_iff_annIdealGenerator_dvd

/- warning: polynomial.degree_ann_ideal_generator_le_of_mem -> Polynomial.degree_annIdealGenerator_le_of_mem is a dubious translation:
lean 3 declaration is
  forall {𝕜 : Type.{u1}} {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A) (p : Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))), (Membership.Mem.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (SetLike.hasMem.{u1, u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Submodule.setLike.{u1, u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) (Semiring.toModule.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)) -> (Ne.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) p (OfNat.ofNat.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (OfNat.mk.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) 0 (Zero.zero.{u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.zero.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toHasLe.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nat (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nat Nat.strictOrderedSemiring))))) (Polynomial.degree.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a)) (Polynomial.degree.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1))) p))
but is expected to have type
  forall {𝕜 : Type.{u2}} {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A) (p : Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))), (Membership.mem.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (SetLike.instMembership.{u2, u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Submodule.setLike.{u2, u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Semiring.toNonAssocSemiring.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) (Semiring.toModule.{u2} (Polynomial.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (CommSemiring.toSemiring.{u2} 𝕜 (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) p (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)) -> (Ne.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) p (OfNat.ofNat.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) 0 (Zero.toOfNat0.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.zero.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))))) -> (LE.le.{0} (WithBot.{0} Nat) (Preorder.toLE.{0} (WithBot.{0} Nat) (WithBot.preorder.{0} Nat (PartialOrder.toPreorder.{0} Nat (StrictOrderedSemiring.toPartialOrder.{0} Nat Nat.strictOrderedSemiring)))) (Polynomial.degree.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a)) (Polynomial.degree.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))) p))
Case conversion may be inaccurate. Consider using '#align polynomial.degree_ann_ideal_generator_le_of_mem Polynomial.degree_annIdealGenerator_le_of_memₓ'. -/
/-- The generator of the annihilating ideal has minimal degree among
 the non-zero members of the annihilating ideal -/
theorem degree_annIdealGenerator_le_of_mem (a : A) (p : 𝕜[X]) (hp : p ∈ annIdeal 𝕜 a)
    (hpn0 : p ≠ 0) : degree (annIdealGenerator 𝕜 a) ≤ degree p :=
  degree_le_of_dvd (mem_iff_annIdealGenerator_dvd.1 hp) hpn0
#align polynomial.degree_ann_ideal_generator_le_of_mem Polynomial.degree_annIdealGenerator_le_of_mem

variable (𝕜)

/- warning: polynomial.ann_ideal_generator_eq_minpoly -> Polynomial.annIdealGenerator_eq_minpoly is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A), Eq.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) (minpoly.{u1, u2} 𝕜 A (EuclideanDomain.toCommRing.{u1} 𝕜 (Field.toEuclideanDomain.{u1} 𝕜 _inst_1)) _inst_2 _inst_3 a)
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A), Eq.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) (minpoly.{u2, u1} 𝕜 A (EuclideanDomain.toCommRing.{u2} 𝕜 (Field.toEuclideanDomain.{u2} 𝕜 _inst_1)) _inst_2 _inst_3 a)
Case conversion may be inaccurate. Consider using '#align polynomial.ann_ideal_generator_eq_minpoly Polynomial.annIdealGenerator_eq_minpolyₓ'. -/
/-- The generator of the annihilating ideal is the minimal polynomial. -/
theorem annIdealGenerator_eq_minpoly (a : A) : annIdealGenerator 𝕜 a = minpoly 𝕜 a :=
  by
  by_cases h : ann_ideal_generator 𝕜 a = 0
  · rw [h, minpoly.eq_zero]
    rintro ⟨p, p_monic, hp : aeval a p = 0⟩
    refine' p_monic.ne_zero (ideal.mem_bot.mp _)
    simpa only [ann_ideal_generator_eq_zero_iff.mp h] using mem_ann_ideal_iff_aeval_eq_zero.mpr hp
  ·
    exact
      minpoly.unique _ _ (monic_ann_ideal_generator _ _ h) (ann_ideal_generator_aeval_eq_zero _ _)
        fun q q_monic hq =>
        degree_ann_ideal_generator_le_of_mem a q (mem_ann_ideal_iff_aeval_eq_zero.mpr hq)
          q_monic.NeZero
#align polynomial.ann_ideal_generator_eq_minpoly Polynomial.annIdealGenerator_eq_minpoly

/- warning: polynomial.monic_generator_eq_minpoly -> Polynomial.monic_generator_eq_minpoly is a dubious translation:
lean 3 declaration is
  forall (𝕜 : Type.{u1}) {A : Type.{u2}} [_inst_1 : Field.{u1} 𝕜] [_inst_2 : Ring.{u2} A] [_inst_3 : Algebra.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2)] (a : A) (p : Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))), (Polynomial.Monic.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1))) p) -> (Eq.{succ u1} (Ideal.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Ideal.span.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Polynomial.semiring.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)))) (Singleton.singleton.{u1, u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Set.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) (Set.hasSingleton.{u1} (Polynomial.{u1} 𝕜 (CommSemiring.toSemiring.{u1} 𝕜 (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1))))) p)) (Polynomial.annIdeal.{u1, u2} 𝕜 A (Semifield.toCommSemiring.{u1} 𝕜 (Field.toSemifield.{u1} 𝕜 _inst_1)) (Ring.toSemiring.{u2} A _inst_2) _inst_3 a)) -> (Eq.{succ u1} (Polynomial.{u1} 𝕜 (Ring.toSemiring.{u1} 𝕜 (DivisionRing.toRing.{u1} 𝕜 (Field.toDivisionRing.{u1} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u1, u2} 𝕜 A _inst_1 _inst_2 _inst_3 a) p)
but is expected to have type
  forall (𝕜 : Type.{u2}) {A : Type.{u1}} [_inst_1 : Field.{u2} 𝕜] [_inst_2 : Ring.{u1} A] [_inst_3 : Algebra.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2)] (a : A) (p : Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))), (Polynomial.Monic.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))) p) -> (Eq.{succ u2} (Ideal.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Ideal.span.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.semiring.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Singleton.singleton.{u2, u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Set.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) (Set.instSingletonSet.{u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1))))) p)) (Polynomial.annIdeal.{u2, u1} 𝕜 A (Semifield.toCommSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)) (Ring.toSemiring.{u1} A _inst_2) _inst_3 a)) -> (Eq.{succ u2} (Polynomial.{u2} 𝕜 (DivisionSemiring.toSemiring.{u2} 𝕜 (Semifield.toDivisionSemiring.{u2} 𝕜 (Field.toSemifield.{u2} 𝕜 _inst_1)))) (Polynomial.annIdealGenerator.{u2, u1} 𝕜 A _inst_1 _inst_2 _inst_3 a) p)
Case conversion may be inaccurate. Consider using '#align polynomial.monic_generator_eq_minpoly Polynomial.monic_generator_eq_minpolyₓ'. -/
/-- If a monic generates the annihilating ideal, it must match our choice
 of the annihilating ideal generator. -/
theorem monic_generator_eq_minpoly (a : A) (p : 𝕜[X]) (p_monic : p.Monic)
    (p_gen : Ideal.span {p} = annIdeal 𝕜 a) : annIdealGenerator 𝕜 a = p :=
  by
  by_cases h : p = 0
  · rwa [h, ann_ideal_generator_eq_zero_iff, ← p_gen, ideal.span_singleton_eq_bot.mpr]
  · rw [← span_singleton_ann_ideal_generator, Ideal.span_singleton_eq_span_singleton] at p_gen
    rw [eq_comm]
    apply eq_of_monic_of_associated p_monic _ p_gen
    · apply monic_ann_ideal_generator _ _ ((Associated.ne_zero_iff p_gen).mp h)
#align polynomial.monic_generator_eq_minpoly Polynomial.monic_generator_eq_minpoly

end Field

end Polynomial

