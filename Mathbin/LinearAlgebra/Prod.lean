/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Eric Wieser

! This file was ported from Lean 3 source module linear_algebra.prod
! leanprover-community/mathlib commit 57a30493469f1a4338a5b3237b31ad8e4f3dd661
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Span
import Mathbin.Order.PartialSups
import Mathbin.Algebra.Algebra.Prod

/-! ### Products of modules

This file defines constructors for linear maps whose domains or codomains are products.

It contains theorems relating these to each other, as well as to `submodule.prod`, `submodule.map`,
`submodule.comap`, `linear_map.range`, and `linear_map.ker`.

## Main definitions

- products in the domain:
  - `linear_map.fst`
  - `linear_map.snd`
  - `linear_map.coprod`
  - `linear_map.prod_ext`
- products in the codomain:
  - `linear_map.inl`
  - `linear_map.inr`
  - `linear_map.prod`
- products in both domain and codomain:
  - `linear_map.prod_map`
  - `linear_equiv.prod_map`
  - `linear_equiv.skew_prod`
-/


universe u v w x y z u' v' w' y'

variable {R : Type u} {K : Type u'} {M : Type v} {V : Type v'} {M₂ : Type w} {V₂ : Type w'}

variable {M₃ : Type y} {V₃ : Type y'} {M₄ : Type z} {ι : Type x}

variable {M₅ M₆ : Type _}

section Prod

namespace LinearMap

variable (S : Type _) [Semiring R] [Semiring S]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃] [AddCommMonoid M₄]

variable [AddCommMonoid M₅] [AddCommMonoid M₆]

variable [Module R M] [Module R M₂] [Module R M₃] [Module R M₄]

variable [Module R M₅] [Module R M₆]

variable (f : M →ₗ[R] M₂)

section

variable (R M M₂)

/- warning: linear_map.fst -> LinearMap.fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9
Case conversion may be inaccurate. Consider using '#align linear_map.fst LinearMap.fstₓ'. -/
/-- The first projection of a product is a linear map. -/
def fst : M × M₂ →ₗ[R] M where
  toFun := Prod.fst
  map_add' x y := rfl
  map_smul' x y := rfl
#align linear_map.fst LinearMap.fst

/- warning: linear_map.snd -> LinearMap.snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10
Case conversion may be inaccurate. Consider using '#align linear_map.snd LinearMap.sndₓ'. -/
/-- The second projection of a product is a linear map. -/
def snd : M × M₂ →ₗ[R] M₂ where
  toFun := Prod.snd
  map_add' x y := rfl
  map_smul' x y := rfl
#align linear_map.snd LinearMap.snd

end

/- warning: linear_map.fst_apply -> LinearMap.fst_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : Prod.{u2, u3} M M₂), Eq.{succ u2} M (coeFn.{max (succ (max u2 u3)) (succ u2), max (succ (max u2 u3)) (succ u2)} (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (fun (_x : LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) => (Prod.{u2, u3} M M₂) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.fst.{u2, u3} M M₂ x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : Prod.{u2, u3} M M₂), Eq.{succ u2} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M) x) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u2} (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.fst.{u2, u3} M M₂ x)
Case conversion may be inaccurate. Consider using '#align linear_map.fst_apply LinearMap.fst_applyₓ'. -/
@[simp]
theorem fst_apply (x : M × M₂) : fst R M M₂ x = x.1 :=
  rfl
#align linear_map.fst_apply LinearMap.fst_apply

/- warning: linear_map.snd_apply -> LinearMap.snd_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : Prod.{u2, u3} M M₂), Eq.{succ u3} M₂ (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) => (Prod.{u2, u3} M M₂) -> M₂) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.snd.{u2, u3} M M₂ x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : Prod.{u2, u3} M M₂), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M₂) x) (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.snd.{u2, u3} M M₂ x)
Case conversion may be inaccurate. Consider using '#align linear_map.snd_apply LinearMap.snd_applyₓ'. -/
@[simp]
theorem snd_apply (x : M × M₂) : snd R M M₂ x = x.2 :=
  rfl
#align linear_map.snd_apply LinearMap.snd_apply

/- warning: linear_map.fst_surjective -> LinearMap.fst_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Surjective.{max (succ u2) (succ u3), succ u2} (Prod.{u2, u3} M M₂) M (coeFn.{max (succ (max u2 u3)) (succ u2), max (succ (max u2 u3)) (succ u2)} (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (fun (_x : LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) => (Prod.{u2, u3} M M₂) -> M) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Surjective.{max (succ u2) (succ u3), succ u2} (Prod.{u2, u3} M M₂) M (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u2} (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.fst_surjective LinearMap.fst_surjectiveₓ'. -/
theorem fst_surjective : Function.Surjective (fst R M M₂) := fun x => ⟨(x, 0), rfl⟩
#align linear_map.fst_surjective LinearMap.fst_surjective

/- warning: linear_map.snd_surjective -> LinearMap.snd_surjective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Surjective.{max (succ u2) (succ u3), succ u3} (Prod.{u2, u3} M M₂) M₂ (coeFn.{max (succ (max u2 u3)) (succ u3), max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (fun (_x : LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) => (Prod.{u2, u3} M M₂) -> M₂) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Surjective.{max (succ u2) (succ u3), succ u3} (Prod.{u2, u3} M M₂) M₂ (FunLike.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3), succ u3} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.snd_surjective LinearMap.snd_surjectiveₓ'. -/
theorem snd_surjective : Function.Surjective (snd R M M₂) := fun x => ⟨(0, x), rfl⟩
#align linear_map.snd_surjective LinearMap.snd_surjective

/- warning: linear_map.prod -> LinearMap.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5], (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) -> (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5], (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) -> (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11))
Case conversion may be inaccurate. Consider using '#align linear_map.prod LinearMap.prodₓ'. -/
/-- The prod of two linear maps is a linear map. -/
@[simps]
def prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : M →ₗ[R] M₂ × M₃
    where
  toFun := Pi.prod f g
  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]
  map_smul' c x := by simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]
#align linear_map.prod LinearMap.prod

/- warning: linear_map.coe_prod -> LinearMap.coe_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11), Eq.{max (succ u2) (succ (max u3 u4))} (M -> (Prod.{u3, u4} M₂ M₃)) (coeFn.{max (succ u2) (succ (max u3 u4)), max (succ u2) (succ (max u3 u4))} (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11)) (fun (_x : LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11)) => M -> (Prod.{u3, u4} M₂ M₃)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g)) (Pi.prod.{u2, u3, u4} M (fun (ᾰ : M) => M₂) (fun (ᾰ : M) => M₃) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (fun (_x : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) => M -> M₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11), Eq.{max (max (succ u2) (succ u3)) (succ u4)} (forall (ᾰ : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u4} M₂ M₃) ᾰ) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), succ u2, max (succ u3) (succ u4)} (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u3, u4} M₂ M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g)) (Pi.prod.{u2, u3, u4} M (fun (ᾰ : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) ᾰ) (fun (ᾰ : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) ᾰ) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_prod LinearMap.coe_prodₓ'. -/
theorem coe_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : ⇑(f.Prod g) = Pi.prod f g :=
  rfl
#align linear_map.coe_prod LinearMap.coe_prod

#print LinearMap.fst_prod /-
@[simp]
theorem fst_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : (fst R M₂ M₃).comp (prod f g) = f := by
  ext <;> rfl
#align linear_map.fst_prod LinearMap.fst_prod
-/

#print LinearMap.snd_prod /-
@[simp]
theorem snd_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : (snd R M₂ M₃).comp (prod f g) = g := by
  ext <;> rfl
#align linear_map.snd_prod LinearMap.snd_prod
-/

/- warning: linear_map.pair_fst_snd -> LinearMap.pair_fst_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prod.{u1, max u2 u3, u2, u3} R (Prod.{u2, u3} M M₂) M M₂ _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 _inst_10 (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prod.{u1, max u2 u3, u2, u3} R (Prod.{u2, u3} M M₂) M M₂ _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 _inst_10 (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.pair_fst_snd LinearMap.pair_fst_sndₓ'. -/
@[simp]
theorem pair_fst_snd : prod (fst R M M₂) (snd R M M₂) = LinearMap.id :=
  FunLike.coe_injective Pi.prod_fst_snd
#align linear_map.pair_fst_snd LinearMap.pair_fst_snd

/- warning: linear_map.prod_equiv -> LinearMap.prodEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_15 : Module.{u5, u3} S M₂ _inst_2 _inst_4] [_inst_16 : Module.{u5, u4} S M₃ _inst_2 _inst_5] [_inst_17 : SMulCommClass.{u1, u5, u3} R S M₂ (SMulZeroClass.toHasSmul.{u1, u3} R M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (SMulWithZero.toSmulZeroClass.{u1, u3} R M₂ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)))) (SMulZeroClass.toHasSmul.{u5, u3} S M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (SMulWithZero.toSmulZeroClass.{u5, u3} S M₂ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (MulActionWithZero.toSMulWithZero.{u5, u3} S M₂ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4))) (Module.toMulActionWithZero.{u5, u3} S M₂ _inst_2 _inst_4 _inst_15))))] [_inst_18 : SMulCommClass.{u1, u5, u4} R S M₃ (SMulZeroClass.toHasSmul.{u1, u4} R M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toHasSmul.{u5, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u4} S M₃ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u4} S M₃ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u5, u4} S M₃ _inst_2 _inst_5 _inst_16))))], LinearEquiv.{u5, u5, max (max u2 u3) u2 u4, max u2 u3 u4} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (Prod.{max u2 u3, max u2 u4} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11)) (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11)) (Prod.addCommMonoid.{max u2 u3, max u2 u4} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u5, max u2 u3, max u2 u4} S (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.module.{u1, u1, u5, u2, u3} R R S M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_17) (LinearMap.module.{u1, u1, u5, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_16 _inst_18)) (LinearMap.module.{u1, u1, u5, u2, max u3 u4} R R S M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 (Prod.module.{u5, u3, u4} S M₂ M₃ _inst_2 _inst_4 _inst_5 _inst_15 _inst_16) (LinearMap.prodEquiv._proof_1.{u1, u5, u3, u4} R M₂ M₃ S _inst_1 _inst_2 _inst_4 _inst_5 _inst_10 _inst_11 _inst_15 _inst_16 _inst_17 _inst_18))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_15 : Module.{u5, u3} S M₂ _inst_2 _inst_4] [_inst_16 : Module.{u5, u4} S M₃ _inst_2 _inst_5] [_inst_17 : SMulCommClass.{u1, u5, u3} R S M₂ (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (SMulWithZero.toSMulZeroClass.{u1, u3} R M₂ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (MulActionWithZero.toSMulWithZero.{u1, u3} R M₂ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (Module.toMulActionWithZero.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)))) (SMulZeroClass.toSMul.{u5, u3} S M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (SMulWithZero.toSMulZeroClass.{u5, u3} S M₂ (MonoidWithZero.toZero.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (MulActionWithZero.toSMulWithZero.{u5, u3} S M₂ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)) (Module.toMulActionWithZero.{u5, u3} S M₂ _inst_2 _inst_4 _inst_15))))] [_inst_18 : SMulCommClass.{u1, u5, u4} R S M₃ (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u4} R M₃ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toSMul.{u5, u4} S M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u4} S M₃ (MonoidWithZero.toZero.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u4} S M₃ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u5, u4} S M₃ _inst_2 _inst_5 _inst_16))))], LinearEquiv.{u5, u5, max (max u4 u2) u3 u2, max (max u4 u3) u2} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (Prod.{max u3 u2, max u4 u2} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11)) (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11)) (Prod.instAddCommMonoidSum.{max u2 u3, max u2 u4} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u5, max u2 u3, max u2 u4} S (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, u2, u3} R R S M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_17) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_16 _inst_18)) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, u2, max u3 u4} R R S M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 (Prod.module.{u5, u3, u4} S M₂ M₃ _inst_2 _inst_4 _inst_5 _inst_15 _inst_16) (Prod.smulCommClass.{u1, u5, u3, u4} R S M₂ M₃ (MulAction.toSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribMulAction.toMulAction.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))) (MulAction.toSMul.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribMulAction.toMulAction.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11))) (MulAction.toSMul.{u5, u3} S M₂ (MonoidWithZero.toMonoid.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (DistribMulAction.toMulAction.{u5, u3} S M₂ (MonoidWithZero.toMonoid.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4) (Module.toDistribMulAction.{u5, u3} S M₂ _inst_2 _inst_4 _inst_15))) (MulAction.toSMul.{u5, u4} S M₃ (MonoidWithZero.toMonoid.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (DistribMulAction.toMulAction.{u5, u4} S M₃ (MonoidWithZero.toMonoid.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5) (Module.toDistribMulAction.{u5, u4} S M₃ _inst_2 _inst_5 _inst_16))) _inst_17 _inst_18))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_equiv LinearMap.prodEquivₓ'. -/
/-- Taking the product of two maps with the same domain is equivalent to taking the product of
their codomains.

See note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/
@[simps]
def prodEquiv [Module S M₂] [Module S M₃] [SMulCommClass R S M₂] [SMulCommClass R S M₃] :
    ((M →ₗ[R] M₂) × (M →ₗ[R] M₃)) ≃ₗ[S] M →ₗ[R] M₂ × M₃
    where
  toFun f := f.1.Prod f.2
  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)
  left_inv f := by ext <;> rfl
  right_inv f := by ext <;> rfl
  map_add' a b := rfl
  map_smul' r a := rfl
#align linear_map.prod_equiv LinearMap.prodEquiv

section

variable (R M M₂)

/- warning: linear_map.inl -> LinearMap.inl is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)
Case conversion may be inaccurate. Consider using '#align linear_map.inl LinearMap.inlₓ'. -/
/-- The left injection into a product is a linear map. -/
def inl : M →ₗ[R] M × M₂ :=
  prod LinearMap.id 0
#align linear_map.inl LinearMap.inl

/- warning: linear_map.inr -> LinearMap.inr is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)
Case conversion may be inaccurate. Consider using '#align linear_map.inr LinearMap.inrₓ'. -/
/-- The right injection into a product is a linear map. -/
def inr : M₂ →ₗ[R] M × M₂ :=
  prod 0 LinearMap.id
#align linear_map.inr LinearMap.inr

/- warning: linear_map.range_inl -> LinearMap.range_inl is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.range_inl LinearMap.range_inlₓ'. -/
theorem range_inl : range (inl R M M₂) = ker (snd R M M₂) :=
  by
  ext x
  simp only [mem_ker, mem_range]
  constructor
  · rintro ⟨y, rfl⟩
    rfl
  · intro h
    exact ⟨x.fst, Prod.ext rfl h.symm⟩
#align linear_map.range_inl LinearMap.range_inl

/- warning: linear_map.ker_snd -> LinearMap.ker_snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_snd LinearMap.ker_sndₓ'. -/
theorem ker_snd : ker (snd R M M₂) = range (inl R M M₂) :=
  Eq.symm <| range_inl R M M₂
#align linear_map.ker_snd LinearMap.ker_snd

/- warning: linear_map.range_inr -> LinearMap.range_inr is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.range_inr LinearMap.range_inrₓ'. -/
theorem range_inr : range (inr R M M₂) = ker (fst R M M₂) :=
  by
  ext x
  simp only [mem_ker, mem_range]
  constructor
  · rintro ⟨y, rfl⟩
    rfl
  · intro h
    exact ⟨x.snd, Prod.ext h.symm rfl⟩
#align linear_map.range_inr LinearMap.range_inr

/- warning: linear_map.ker_fst -> LinearMap.ker_fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.ker.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_fst LinearMap.ker_fstₓ'. -/
theorem ker_fst : ker (fst R M M₂) = range (inr R M M₂) :=
  Eq.symm <| range_inr R M M₂
#align linear_map.ker_fst LinearMap.ker_fst

end

/- warning: linear_map.coe_inl -> LinearMap.coe_inl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} ((fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M -> (Prod.{u2, u3} M M₂)) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (x : M) => Prod.mk.{u2, u3} M M₂ x (OfNat.ofNat.{u3} M₂ 0 (OfNat.mk.{u3} M₂ 0 (Zero.zero.{u3} M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (forall (a : M), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) a) (FunLike.coe.{max (succ u2) (succ u3), succ u2, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (x : M) => Prod.mk.{u2, u3} M M₂ x (OfNat.ofNat.{u3} M₂ 0 (Zero.toOfNat0.{u3} M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_inl LinearMap.coe_inlₓ'. -/
@[simp]
theorem coe_inl : (inl R M M₂ : M → M × M₂) = fun x => (x, 0) :=
  rfl
#align linear_map.coe_inl LinearMap.coe_inl

/- warning: linear_map.inl_apply -> LinearMap.inl_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : M), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} M M₂) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.mk.{u2, u3} M M₂ x (OfNat.ofNat.{u3} M₂ 0 (OfNat.mk.{u3} M₂ 0 (Zero.zero.{u3} M₂ (AddZeroClass.toHasZero.{u3} M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : M), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.mk.{u2, u3} M M₂ x (OfNat.ofNat.{u3} M₂ 0 (Zero.toOfNat0.{u3} M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_4)))))
Case conversion may be inaccurate. Consider using '#align linear_map.inl_apply LinearMap.inl_applyₓ'. -/
theorem inl_apply (x : M) : inl R M M₂ x = (x, 0) :=
  rfl
#align linear_map.inl_apply LinearMap.inl_apply

/- warning: linear_map.coe_inr -> LinearMap.coe_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} ((fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M₂ -> (Prod.{u2, u3} M M₂)) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M₂ -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Prod.mk.{u2, u3} M M₂ (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (forall (a : M₂), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) a) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Prod.mk.{u2, u3} M M₂ (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_inr LinearMap.coe_inrₓ'. -/
@[simp]
theorem coe_inr : (inr R M M₂ : M₂ → M × M₂) = Prod.mk 0 :=
  rfl
#align linear_map.coe_inr LinearMap.coe_inr

/- warning: linear_map.inr_apply -> LinearMap.inr_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : M₂), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} M M₂) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M₂ -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.mk.{u2, u3} M M₂ (OfNat.ofNat.{u2} M 0 (OfNat.mk.{u2} M 0 (Zero.zero.{u2} M (AddZeroClass.toHasZero.{u2} M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))))) x)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (x : M₂), Eq.{max (succ u2) (succ u3)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) x) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) x) (Prod.mk.{u2, u3} M M₂ (OfNat.ofNat.{u2} M 0 (Zero.toOfNat0.{u2} M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_3)))) x)
Case conversion may be inaccurate. Consider using '#align linear_map.inr_apply LinearMap.inr_applyₓ'. -/
theorem inr_apply (x : M₂) : inr R M M₂ x = (0, x) :=
  rfl
#align linear_map.inr_apply LinearMap.inr_apply

/- warning: linear_map.inl_eq_prod -> LinearMap.inl_eq_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.prod.{u1, u2, u2, u3} R M M M₂ _inst_1 _inst_3 _inst_3 _inst_4 _inst_9 _inst_9 _inst_10 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (OfNat.mk.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.zero.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.hasZero.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.prod.{u1, u2, u2, u3} R M M M₂ _inst_1 _inst_3 _inst_3 _inst_4 _inst_9 _inst_9 _inst_10 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (OfNat.ofNat.{max u3 u2} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.toOfNat0.{max u3 u2} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.instZeroLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_map.inl_eq_prod LinearMap.inl_eq_prodₓ'. -/
theorem inl_eq_prod : inl R M M₂ = prod LinearMap.id 0 :=
  rfl
#align linear_map.inl_eq_prod LinearMap.inl_eq_prod

/- warning: linear_map.inr_eq_prod -> LinearMap.inr_eq_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.prod.{u1, u3, u2, u3} R M₂ M M₂ _inst_1 _inst_4 _inst_3 _inst_4 _inst_10 _inst_9 _inst_10 (OfNat.ofNat.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (OfNat.mk.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (Zero.zero.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) (LinearMap.hasZero.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_4 _inst_3 _inst_10 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.prod.{u1, u3, u2, u3} R M₂ M M₂ _inst_1 _inst_4 _inst_3 _inst_4 _inst_10 _inst_9 _inst_10 (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (Zero.toOfNat0.{max u2 u3} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) (LinearMap.instZeroLinearMap.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_4 _inst_3 _inst_10 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.inr_eq_prod LinearMap.inr_eq_prodₓ'. -/
theorem inr_eq_prod : inr R M M₂ = prod 0 LinearMap.id :=
  rfl
#align linear_map.inr_eq_prod LinearMap.inr_eq_prod

/- warning: linear_map.inl_injective -> LinearMap.inl_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Injective.{succ u2, max (succ u2) (succ u3)} M (Prod.{u2, u3} M M₂) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Injective.{succ u2, max (succ u2) (succ u3)} M (Prod.{u2, u3} M M₂) (FunLike.coe.{max (succ u2) (succ u3), succ u2, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.inl_injective LinearMap.inl_injectiveₓ'. -/
theorem inl_injective : Function.Injective (inl R M M₂) := fun _ => by simp
#align linear_map.inl_injective LinearMap.inl_injective

/- warning: linear_map.inr_injective -> LinearMap.inr_injective is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Injective.{succ u3, max (succ u2) (succ u3)} M₂ (Prod.{u2, u3} M M₂) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) => M₂ -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Function.Injective.{succ u3, max (succ u2) (succ u3)} M₂ (Prod.{u2, u3} M M₂) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.inr_injective LinearMap.inr_injectiveₓ'. -/
theorem inr_injective : Function.Injective (inr R M M₂) := fun _ => by simp
#align linear_map.inr_injective LinearMap.inr_injective

/- warning: linear_map.coprod -> LinearMap.coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5], (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) -> (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5], (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) -> (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11)
Case conversion may be inaccurate. Consider using '#align linear_map.coprod LinearMap.coprodₓ'. -/
/-- The coprod function `λ x : M × M₂, f x.1 + g x.2` is a linear map. -/
def coprod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : M × M₂ →ₗ[R] M₃ :=
  f.comp (fst _ _ _) + g.comp (snd _ _ _)
#align linear_map.coprod LinearMap.coprod

/- warning: linear_map.coprod_apply -> LinearMap.coprod_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (x : Prod.{u2, u3} M M₂), Eq.{succ u4} M₃ (coeFn.{max (succ (max u2 u3)) (succ u4), max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (fun (_x : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) => (Prod.{u2, u3} M M₂) -> M₃) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g) x) (HAdd.hAdd.{u4, u4, u4} M₃ M₃ M₃ (instHAdd.{u4} M₃ (AddZeroClass.toHasAdd.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)))) (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u3} M M₂ x)) (coeFn.{max (succ u3) (succ u4), max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (fun (_x : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) => M₂ -> M₃) (LinearMap.hasCoeToFun.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (Prod.snd.{u2, u3} M M₂ x)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (x : Prod.{u2, u3} M M₂), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M₃) x) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u4), max (succ u2) (succ u3), succ u4} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g) x) (HAdd.hAdd.{u4, u4, u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₃) (Prod.snd.{u2, u3} M M₂ x)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) (instHAdd.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) (AddZeroClass.toAdd.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) (AddMonoid.toAddZeroClass.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) (AddCommMonoid.toAddMonoid.{u4} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) _inst_5)))) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u3} M M₂ x)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (Prod.snd.{u2, u3} M M₂ x)))
Case conversion may be inaccurate. Consider using '#align linear_map.coprod_apply LinearMap.coprod_applyₓ'. -/
@[simp]
theorem coprod_apply (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (x : M × M₂) :
    coprod f g x = f x.1 + g x.2 :=
  rfl
#align linear_map.coprod_apply LinearMap.coprod_apply

#print LinearMap.coprod_inl /-
@[simp]
theorem coprod_inl (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : (coprod f g).comp (inl R M M₂) = f := by
  ext <;> simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]
#align linear_map.coprod_inl LinearMap.coprod_inl
-/

#print LinearMap.coprod_inr /-
@[simp]
theorem coprod_inr (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : (coprod f g).comp (inr R M M₂) = g := by
  ext <;> simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]
#align linear_map.coprod_inr LinearMap.coprod_inr
-/

/- warning: linear_map.coprod_inl_inr -> LinearMap.coprod_inl_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.coprod.{u1, u2, u3, max u2 u3} R M M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_3 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.coprod.{u1, u2, u3, max u2 u3} R M M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_3 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_9 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.coprod_inl_inr LinearMap.coprod_inl_inrₓ'. -/
@[simp]
theorem coprod_inl_inr : coprod (inl R M M₂) (inr R M M₂) = LinearMap.id := by
  ext <;>
    simp only [Prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
#align linear_map.coprod_inl_inr LinearMap.coprod_inl_inr

/- warning: linear_map.comp_coprod -> LinearMap.comp_coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (g₁ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g₂ : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11), Eq.{max (succ (max u2 u3)) (succ u5)} (LinearMap.{u1, u1, max u2 u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₄ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_12) (LinearMap.comp.{u1, u1, u1, max u2 u3, u4, u5} R R R (Prod.{u2, u3} M M₂) M₃ M₄ _inst_1 _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 g₁ g₂)) (LinearMap.coprod.{u1, u2, u3, u5} R M M₂ M₄ _inst_1 _inst_3 _inst_4 _inst_6 _inst_9 _inst_10 _inst_12 (LinearMap.comp.{u1, u1, u1, u2, u4, u5} R R R M M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_6 _inst_9 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f g₁) (LinearMap.comp.{u1, u1, u1, u3, u4, u5} R R R M₂ M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f g₂))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (g₁ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g₂ : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11), Eq.{max (max (succ u2) (succ u3)) (succ u5)} (LinearMap.{u1, u1, max u2 u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₄ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_12) (LinearMap.comp.{u1, u1, u1, max u2 u3, u4, u5} R R R (Prod.{u2, u3} M M₂) M₃ M₄ _inst_1 _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 g₁ g₂)) (LinearMap.coprod.{u1, u2, u3, u5} R M M₂ M₄ _inst_1 _inst_3 _inst_4 _inst_6 _inst_9 _inst_10 _inst_12 (LinearMap.comp.{u1, u1, u1, u2, u4, u5} R R R M M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_6 _inst_9 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f g₁) (LinearMap.comp.{u1, u1, u1, u3, u4, u5} R R R M₂ M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f g₂))
Case conversion may be inaccurate. Consider using '#align linear_map.comp_coprod LinearMap.comp_coprodₓ'. -/
theorem comp_coprod (f : M₃ →ₗ[R] M₄) (g₁ : M →ₗ[R] M₃) (g₂ : M₂ →ₗ[R] M₃) :
    f.comp (g₁.coprod g₂) = (f.comp g₁).coprod (f.comp g₂) :=
  ext fun x => f.map_add (g₁ x.1) (g₂ x.2)
#align linear_map.comp_coprod LinearMap.comp_coprod

/- warning: linear_map.fst_eq_coprod -> LinearMap.fst_eq_coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ (max u2 u3)) (succ u2)} (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.coprod.{u1, u2, u3, u2} R M M₂ M _inst_1 _inst_3 _inst_4 _inst_3 _inst_9 _inst_10 _inst_9 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (OfNat.ofNat.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (OfNat.mk.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (Zero.zero.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) (LinearMap.hasZero.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_4 _inst_3 _inst_10 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_9) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.coprod.{u1, u2, u3, u2} R M M₂ M _inst_1 _inst_3 _inst_4 _inst_3 _inst_9 _inst_10 _inst_9 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (OfNat.ofNat.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) 0 (Zero.toOfNat0.{max u3 u2} (LinearMap.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M _inst_4 _inst_3 _inst_10 _inst_9) (LinearMap.instZeroLinearMap.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_4 _inst_3 _inst_10 _inst_9 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))
Case conversion may be inaccurate. Consider using '#align linear_map.fst_eq_coprod LinearMap.fst_eq_coprodₓ'. -/
theorem fst_eq_coprod : fst R M M₂ = coprod LinearMap.id 0 := by ext <;> simp
#align linear_map.fst_eq_coprod LinearMap.fst_eq_coprod

/- warning: linear_map.snd_eq_coprod -> LinearMap.snd_eq_coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ (max u2 u3)) (succ u3)} (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.coprod.{u1, u2, u3, u3} R M M₂ M₂ _inst_1 _inst_3 _inst_4 _inst_4 _inst_9 _inst_10 _inst_10 (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (OfNat.mk.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.zero.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.hasZero.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_10) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.coprod.{u1, u2, u3, u3} R M M₂ M₂ _inst_1 _inst_3 _inst_4 _inst_4 _inst_9 _inst_10 _inst_10 (OfNat.ofNat.{max u3 u2} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.toOfNat0.{max u3 u2} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.instZeroLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.snd_eq_coprod LinearMap.snd_eq_coprodₓ'. -/
theorem snd_eq_coprod : snd R M M₂ = coprod 0 LinearMap.id := by ext <;> simp
#align linear_map.snd_eq_coprod LinearMap.snd_eq_coprod

/- warning: linear_map.coprod_comp_prod -> LinearMap.coprod_comp_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (f' : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g' : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11), Eq.{max (succ u2) (succ u5)} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.comp.{u1, u1, u1, u2, max u3 u4, u5} R R R M (Prod.{u3, u4} M₂ M₃) M₄ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_6 _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u3, u4, u5} R M₂ M₃ M₄ _inst_1 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 f g) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f' g')) (HAdd.hAdd.{max u2 u5, max u2 u5, max u2 u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (instHAdd.{max u2 u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.hasAdd.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_3 _inst_6 _inst_9 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.comp.{u1, u1, u1, u2, u3, u5} R R R M M₂ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_4 _inst_6 _inst_9 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f f') (LinearMap.comp.{u1, u1, u1, u2, u4, u5} R R R M M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_6 _inst_9 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g g'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (f' : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g' : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11), Eq.{max (succ u2) (succ u5)} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.comp.{u1, u1, u1, u2, max u3 u4, u5} R R R M (Prod.{u3, u4} M₂ M₃) M₄ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_4 _inst_5) _inst_6 _inst_9 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_4 _inst_5 _inst_10 _inst_11) _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u3, u4, u5} R M₂ M₃ M₄ _inst_1 _inst_4 _inst_5 _inst_6 _inst_10 _inst_11 _inst_12 f g) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f' g')) (HAdd.hAdd.{max u2 u5, max u2 u5, max u2 u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (instHAdd.{max u2 u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_3 _inst_6 _inst_9 _inst_12) (LinearMap.instAddLinearMap.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_3 _inst_6 _inst_9 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.comp.{u1, u1, u1, u2, u3, u5} R R R M M₂ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_4 _inst_6 _inst_9 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f f') (LinearMap.comp.{u1, u1, u1, u2, u4, u5} R R R M M₃ M₄ _inst_1 _inst_1 _inst_1 _inst_3 _inst_5 _inst_6 _inst_9 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g g'))
Case conversion may be inaccurate. Consider using '#align linear_map.coprod_comp_prod LinearMap.coprod_comp_prodₓ'. -/
@[simp]
theorem coprod_comp_prod (f : M₂ →ₗ[R] M₄) (g : M₃ →ₗ[R] M₄) (f' : M →ₗ[R] M₂) (g' : M →ₗ[R] M₃) :
    (f.coprod g).comp (f'.Prod g') = f.comp f' + g.comp g' :=
  rfl
#align linear_map.coprod_comp_prod LinearMap.coprod_comp_prod

/- warning: linear_map.coprod_map_prod -> LinearMap.coprod_map_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (S : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_9) (S' : Submodule.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Submodule.map.{u1, u1, max u2 u3, u4, max (max u2 u3) u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_3 _inst_9 S M₂ _inst_4 _inst_10 S')) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11))))) (Submodule.map.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f S) (Submodule.map.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g S'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (S : Submodule.{u1, u2} R M _inst_1 _inst_3 _inst_9) (S' : Submodule.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Submodule.map.{u1, u1, max u2 u3, u4, max (max u4 u3) u2} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 f g) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_3 _inst_9 S M₂ _inst_4 _inst_10 S')) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11))))) (Submodule.map.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f S) (Submodule.map.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g S'))
Case conversion may be inaccurate. Consider using '#align linear_map.coprod_map_prod LinearMap.coprod_map_prodₓ'. -/
@[simp]
theorem coprod_map_prod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (S : Submodule R M)
    (S' : Submodule R M₂) : (Submodule.prod S S').map (LinearMap.coprod f g) = S.map f ⊔ S'.map g :=
  SetLike.coe_injective <|
    by
    simp only [LinearMap.coprod_apply, Submodule.coe_sup, Submodule.map_coe]
    rw [← Set.image2_add, Set.image2_image_left, Set.image2_image_right]
    exact Set.image_prod fun m m₂ => f m + g m₂
#align linear_map.coprod_map_prod LinearMap.coprod_map_prod

/- warning: linear_map.coprod_equiv -> LinearMap.coprodEquiv is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_15 : Module.{u5, u4} S M₃ _inst_2 _inst_5] [_inst_16 : SMulCommClass.{u1, u5, u4} R S M₃ (SMulZeroClass.toHasSmul.{u1, u4} R M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toHasSmul.{u5, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u5, u4} S M₃ (MulZeroClass.toHasZero.{u5} S (MulZeroOneClass.toMulZeroClass.{u5} S (MonoidWithZero.toMulZeroOneClass.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u5, u4} S M₃ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u5, u4} S M₃ _inst_2 _inst_5 _inst_15))))], LinearEquiv.{u5, u5, max (max u2 u4) u3 u4, max (max u2 u3) u4} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (Prod.{max u2 u4, max u3 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11)) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (Prod.addCommMonoid.{max u2 u4, max u3 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u5, max u2 u4, max u3 u4} S (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.module.{u1, u1, u5, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16) (LinearMap.module.{u1, u1, u5, u3, u4} R R S M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16)) (LinearMap.module.{u1, u1, u5, max u2 u3, u4} R R S (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} (S : Type.{u5}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u5} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_15 : Module.{u5, u4} S M₃ _inst_2 _inst_5] [_inst_16 : SMulCommClass.{u1, u5, u4} R S M₃ (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u4} R M₃ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toSMul.{u5, u4} S M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u5, u4} S M₃ (MonoidWithZero.toZero.{u5} S (Semiring.toMonoidWithZero.{u5} S _inst_2)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u5, u4} S M₃ (Semiring.toMonoidWithZero.{u5} S _inst_2) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u5, u4} S M₃ _inst_2 _inst_5 _inst_15))))], LinearEquiv.{u5, u5, max (max u4 u3) u4 u2, max u4 u3 u2} S S _inst_2 _inst_2 (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHom.id.{u5} S (Semiring.toNonAssocSemiring.{u5} S _inst_2)) (RingHomInvPair.ids.{u5} S _inst_2) (RingHomInvPair.ids.{u5} S _inst_2) (Prod.{max u4 u2, max u4 u3} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11)) (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) (Prod.instAddCommMonoidSum.{max u2 u4, max u3 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u5, max u2 u4, max u3 u4} S (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, u3, u4} R R S M₂ M₃ _inst_1 _inst_1 _inst_4 _inst_5 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16)) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u5, max u2 u3, u4} R R S (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_16)
Case conversion may be inaccurate. Consider using '#align linear_map.coprod_equiv LinearMap.coprodEquivₓ'. -/
/-- Taking the product of two maps with the same codomain is equivalent to taking the product of
their domains.

See note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/
@[simps]
def coprodEquiv [Module S M₃] [SMulCommClass R S M₃] :
    ((M →ₗ[R] M₃) × (M₂ →ₗ[R] M₃)) ≃ₗ[S] M × M₂ →ₗ[R] M₃
    where
  toFun f := f.1.coprod f.2
  invFun f := (f.comp (inl _ _ _), f.comp (inr _ _ _))
  left_inv f := by simp only [Prod.mk.eta, coprod_inl, coprod_inr]
  right_inv f := by simp only [← comp_coprod, comp_id, coprod_inl_inr]
  map_add' a b := by
    ext
    simp only [Prod.snd_add, add_apply, coprod_apply, Prod.fst_add, add_add_add_comm]
  map_smul' r a := by
    dsimp
    ext
    simp only [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]
#align linear_map.coprod_equiv LinearMap.coprodEquiv

/- warning: linear_map.prod_ext_iff -> LinearMap.prod_ext_iff is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] {f : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11} {g : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11}, Iff (Eq.{max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) f g) (And (Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] {f : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11} {g : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11}, Iff (Eq.{max (max (succ u2) (succ u3)) (succ u4)} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) f g) (And (Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_ext_iff LinearMap.prod_ext_iffₓ'. -/
theorem prod_ext_iff {f g : M × M₂ →ₗ[R] M₃} :
    f = g ↔ f.comp (inl _ _ _) = g.comp (inl _ _ _) ∧ f.comp (inr _ _ _) = g.comp (inr _ _ _) :=
  (coprodEquiv ℕ).symm.Injective.eq_iff.symm.trans Prod.ext_iff
#align linear_map.prod_ext_iff LinearMap.prod_ext_iff

/- warning: linear_map.prod_ext -> LinearMap.prod_ext is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] {f : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11} {g : LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11}, (Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) -> (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.right_ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) -> (Eq.{max (succ (max u2 u3)) (succ u4)} (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) f g)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] {f : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11} {g : LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11}, (Eq.{max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u2, max u2 u3, u4} R R R M (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_9 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) -> (Eq.{max (succ u3) (succ u4)} (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.comp.{u1, u1, u1, u3, max u2 u3, u4} R R R M₂ (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 _inst_1 _inst_4 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 _inst_10 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) -> (Eq.{max (max (succ u2) (succ u3)) (succ u4)} (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) _inst_11) f g)
Case conversion may be inaccurate. Consider using '#align linear_map.prod_ext LinearMap.prod_extₓ'. -/
/--
Split equality of linear maps from a product into linear maps over each component, to allow `ext`
to apply lemmas specific to `M →ₗ M₃` and `M₂ →ₗ M₃`.

See note [partially-applied ext lemmas]. -/
@[ext]
theorem prod_ext {f g : M × M₂ →ₗ[R] M₃} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))
    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g :=
  prod_ext_iff.2 ⟨hl, hr⟩
#align linear_map.prod_ext LinearMap.prod_ext

/- warning: linear_map.prod_map -> LinearMap.prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6], (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) -> (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6], (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) -> (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) -> (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map LinearMap.prodMapₓ'. -/
/-- `prod.map` of two linear maps. -/
def prodMap (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) : M × M₂ →ₗ[R] M₃ × M₄ :=
  (f.comp (fst R M M₂)).Prod (g.comp (snd R M M₂))
#align linear_map.prod_map LinearMap.prodMap

/- warning: linear_map.coe_prod_map -> LinearMap.coe_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (succ (max u2 u3)) (succ (max u4 u5))} ((Prod.{u2, u3} M M₂) -> (Prod.{u4, u5} M₃ M₄)) (coeFn.{max (succ (max u2 u3)) (succ (max u4 u5)), max (succ (max u2 u3)) (succ (max u4 u5))} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (fun (_x : LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) => (Prod.{u2, u3} M M₂) -> (Prod.{u4, u5} M₃ M₄)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g)) (Prod.map.{u2, u4, u3, u5} M M₃ M₂ M₄ (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (coeFn.{max (succ u3) (succ u5), max (succ u3) (succ u5)} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) => M₂ -> M₄) (LinearMap.hasCoeToFun.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5)} (forall (ᾰ : Prod.{u2, u3} M M₂), (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => Prod.{u4, u5} M₃ M₄) ᾰ) (FunLike.coe.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5), max (succ u2) (succ u3), max (succ u4) (succ u5)} (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => Prod.{u4, u5} M₃ M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g)) (Prod.map.{u2, u4, u3, u5} M M₃ M₂ M₄ (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (FunLike.coe.{max (succ u3) (succ u5), succ u3, succ u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align linear_map.coe_prod_map LinearMap.coe_prodMapₓ'. -/
theorem coe_prodMap (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) : ⇑(f.Prod_map g) = Prod.map f g :=
  rfl
#align linear_map.coe_prod_map LinearMap.coe_prodMap

/- warning: linear_map.prod_map_apply -> LinearMap.prodMap_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (x : Prod.{u2, u3} M M₂), Eq.{max (succ u4) (succ u5)} (Prod.{u4, u5} M₃ M₄) (coeFn.{max (succ (max u2 u3)) (succ (max u4 u5)), max (succ (max u2 u3)) (succ (max u4 u5))} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (fun (_x : LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) => (Prod.{u2, u3} M M₂) -> (Prod.{u4, u5} M₃ M₄)) (LinearMap.hasCoeToFun.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g) x) (Prod.mk.{u4, u5} M₃ M₄ (coeFn.{max (succ u2) (succ u4), max (succ u2) (succ u4)} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (fun (_x : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) => M -> M₃) (LinearMap.hasCoeToFun.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u3} M M₂ x)) (coeFn.{max (succ u3) (succ u5), max (succ u3) (succ u5)} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (fun (_x : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) => M₂ -> M₄) (LinearMap.hasCoeToFun.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (Prod.snd.{u2, u3} M M₂ x)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (x : Prod.{u2, u3} M M₂), Eq.{max (succ u4) (succ u5)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => Prod.{u4, u5} M₃ M₄) x) (FunLike.coe.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5), max (succ u2) (succ u3), max (succ u4) (succ u5)} (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (Prod.{u2, u3} M M₂) (fun (_x : Prod.{u2, u3} M M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : Prod.{u2, u3} M M₂) => Prod.{u4, u5} M₃ M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g) x) (Prod.mk.{u4, u5} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) (Prod.fst.{u2, u3} M M₂ x)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₄) (Prod.snd.{u2, u3} M M₂ x)) (FunLike.coe.{max (succ u2) (succ u4), succ u2, succ u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₃) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u3} M M₂ x)) (FunLike.coe.{max (succ u3) (succ u5), succ u3, succ u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g (Prod.snd.{u2, u3} M M₂ x)))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_apply LinearMap.prodMap_applyₓ'. -/
@[simp]
theorem prodMap_apply (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) (x) : f.Prod_map g x = (f x.1, g x.2) :=
  rfl
#align linear_map.prod_map_apply LinearMap.prodMap_apply

/- warning: linear_map.prod_map_comap_prod -> LinearMap.prodMap_comap_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (S : Submodule.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10) (S' : Submodule.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12), Eq.{succ (max u2 u4)} (Submodule.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11)) (Submodule.comap.{u1, u1, max u2 u4, max u3 u5, max (max u2 u4) u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 f g) (Submodule.prod.{u1, u3, u5} R M₂ _inst_1 _inst_4 _inst_10 S M₄ _inst_6 _inst_12 S')) (Submodule.prod.{u1, u2, u4} R M _inst_1 _inst_3 _inst_9 (Submodule.comap.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f S) M₃ _inst_5 _inst_11 (Submodule.comap.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.semilinearMapClass.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g S'))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (S : Submodule.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10) (S' : Submodule.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12), Eq.{max (succ u2) (succ u4)} (Submodule.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11)) (Submodule.comap.{u1, u1, max u2 u4, max u3 u5, max (max (max u5 u3) u4) u2} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 f g) (Submodule.prod.{u1, u3, u5} R M₂ _inst_1 _inst_4 _inst_10 S M₄ _inst_6 _inst_12 S')) (Submodule.prod.{u1, u2, u4} R M _inst_1 _inst_3 _inst_9 (Submodule.comap.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f S) M₃ _inst_5 _inst_11 (Submodule.comap.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g S'))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_comap_prod LinearMap.prodMap_comap_prodₓ'. -/
theorem prodMap_comap_prod (f : M →ₗ[R] M₂) (g : M₃ →ₗ[R] M₄) (S : Submodule R M₂)
    (S' : Submodule R M₄) :
    (Submodule.prod S S').comap (LinearMap.prodMap f g) = (S.comap f).Prod (S'.comap g) :=
  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _
#align linear_map.prod_map_comap_prod LinearMap.prodMap_comap_prod

/- warning: linear_map.ker_prod_map -> LinearMap.ker_prodMap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{succ (max u2 u4)} (Submodule.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11)) (LinearMap.ker.{u1, u1, max u2 u4, max u3 u5, max (max u2 u4) u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.semilinearMapClass.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 f g)) (Submodule.prod.{u1, u2, u4} R M _inst_1 _inst_3 _inst_9 (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) M₃ _inst_5 _inst_11 (LinearMap.ker.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.semilinearMapClass.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (g : LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12), Eq.{max (succ u2) (succ u4)} (Submodule.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11)) (LinearMap.ker.{u1, u1, max u2 u4, max u3 u5, max (max (max u5 u3) u4) u2} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 f g)) (Submodule.prod.{u1, u2, u4} R M _inst_1 _inst_3 _inst_9 (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) M₃ _inst_5 _inst_11 (LinearMap.ker.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_prod_map LinearMap.ker_prodMapₓ'. -/
theorem ker_prodMap (f : M →ₗ[R] M₂) (g : M₃ →ₗ[R] M₄) :
    (LinearMap.prodMap f g).ker = Submodule.prod f.ker g.ker :=
  by
  dsimp only [ker]
  rw [← prod_map_comap_prod, Submodule.prod_bot]
#align linear_map.ker_prod_map LinearMap.ker_prodMap

/- warning: linear_map.prod_map_id -> LinearMap.prodMap_id is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (LinearMap.id.{u1, u2} R M _inst_1 _inst_3 _inst_9) (LinearMap.id.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)) (LinearMap.id.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_id LinearMap.prodMap_idₓ'. -/
@[simp]
theorem prodMap_id : (id : M →ₗ[R] M).Prod_map (id : M₂ →ₗ[R] M₂) = id :=
  LinearMap.ext fun _ => Prod.mk.eta
#align linear_map.prod_map_id LinearMap.prodMap_id

/- warning: linear_map.prod_map_one -> LinearMap.prodMap_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{succ (max u2 u3)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) 1 (OfNat.mk.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) 1 (One.one.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.module.End.hasOne.{u1, u2} R M _inst_1 _inst_3 _inst_9)))) (OfNat.ofNat.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) 1 (OfNat.mk.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) 1 (One.one.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.module.End.hasOne.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))))) (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) 1 (OfNat.mk.{max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) 1 (One.one.{max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.module.End.hasOne.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) 1 (One.toOfNat1.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.instOneEnd.{u1, u2} R M _inst_1 _inst_3 _inst_9))) (OfNat.ofNat.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) 1 (One.toOfNat1.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.instOneEnd.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)))) (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) 1 (One.toOfNat1.{max u2 u3} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instOneEnd.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_one LinearMap.prodMap_oneₓ'. -/
@[simp]
theorem prodMap_one : (1 : M →ₗ[R] M).Prod_map (1 : M₂ →ₗ[R] M₂) = 1 :=
  LinearMap.ext fun _ => Prod.mk.eta
#align linear_map.prod_map_one LinearMap.prodMap_one

/- warning: linear_map.prod_map_comp -> LinearMap.prodMap_comp is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} {M₅ : Type.{u6}} {M₆ : Type.{u7}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_7 : AddCommMonoid.{u6} M₅] [_inst_8 : AddCommMonoid.{u7} M₆] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] [_inst_13 : Module.{u1, u6} R M₅ _inst_1 _inst_7] [_inst_14 : Module.{u1, u7} R M₆ _inst_1 _inst_8] (f₁₂ : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (f₂₃ : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (g₁₂ : LinearMap.{u1, u1, u5, u6} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₄ M₅ _inst_6 _inst_7 _inst_12 _inst_13) (g₂₃ : LinearMap.{u1, u1, u6, u7} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₅ M₆ _inst_7 _inst_8 _inst_13 _inst_14), Eq.{max (succ (max u2 u5)) (succ (max u4 u7))} (LinearMap.{u1, u1, max u2 u5, max u4 u7} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u5} M M₄) (Prod.{u4, u7} M₃ M₆) (Prod.addCommMonoid.{u2, u5} M M₄ _inst_3 _inst_6) (Prod.addCommMonoid.{u4, u7} M₃ M₆ _inst_5 _inst_8) (Prod.module.{u1, u2, u5} R M M₄ _inst_1 _inst_3 _inst_6 _inst_9 _inst_12) (Prod.module.{u1, u4, u7} R M₃ M₆ _inst_1 _inst_5 _inst_8 _inst_11 _inst_14)) (LinearMap.comp.{u1, u1, u1, max u2 u5, max u3 u6, max u4 u7} R R R (Prod.{u2, u5} M M₄) (Prod.{u3, u6} M₂ M₅) (Prod.{u4, u7} M₃ M₆) _inst_1 _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u5} M M₄ _inst_3 _inst_6) (Prod.addCommMonoid.{u3, u6} M₂ M₅ _inst_4 _inst_7) (Prod.addCommMonoid.{u4, u7} M₃ M₆ _inst_5 _inst_8) (Prod.module.{u1, u2, u5} R M M₄ _inst_1 _inst_3 _inst_6 _inst_9 _inst_12) (Prod.module.{u1, u3, u6} R M₂ M₅ _inst_1 _inst_4 _inst_7 _inst_10 _inst_13) (Prod.module.{u1, u4, u7} R M₃ M₆ _inst_1 _inst_5 _inst_8 _inst_11 _inst_14) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prodMap.{u1, u3, u6, u4, u7} R M₂ M₅ M₃ M₆ _inst_1 _inst_4 _inst_7 _inst_5 _inst_8 _inst_10 _inst_13 _inst_11 _inst_14 f₂₃ g₂₃) (LinearMap.prodMap.{u1, u2, u5, u3, u6} R M M₄ M₂ M₅ _inst_1 _inst_3 _inst_6 _inst_4 _inst_7 _inst_9 _inst_12 _inst_10 _inst_13 f₁₂ g₁₂)) (LinearMap.prodMap.{u1, u2, u5, u4, u7} R M M₄ M₃ M₆ _inst_1 _inst_3 _inst_6 _inst_5 _inst_8 _inst_9 _inst_12 _inst_11 _inst_14 (LinearMap.comp.{u1, u1, u1, u2, u3, u4} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f₂₃ f₁₂) (LinearMap.comp.{u1, u1, u1, u5, u6, u7} R R R M₄ M₅ M₆ _inst_1 _inst_1 _inst_1 _inst_6 _inst_7 _inst_8 _inst_12 _inst_13 _inst_14 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomCompTriple.ids.{u1, u1} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g₂₃ g₁₂))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u4}} {M₂ : Type.{u5}} {M₃ : Type.{u6}} {M₄ : Type.{u7}} {M₅ : Type.{u2}} {M₆ : Type.{u1}} [_inst_1 : Semiring.{u3} R] [_inst_3 : AddCommMonoid.{u4} M] [_inst_4 : AddCommMonoid.{u5} M₂] [_inst_5 : AddCommMonoid.{u6} M₃] [_inst_6 : AddCommMonoid.{u7} M₄] [_inst_7 : AddCommMonoid.{u2} M₅] [_inst_8 : AddCommMonoid.{u1} M₆] [_inst_9 : Module.{u3, u4} R M _inst_1 _inst_3] [_inst_10 : Module.{u3, u5} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u3, u6} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u3, u7} R M₄ _inst_1 _inst_6] [_inst_13 : Module.{u3, u2} R M₅ _inst_1 _inst_7] [_inst_14 : Module.{u3, u1} R M₆ _inst_1 _inst_8] (f₁₂ : LinearMap.{u3, u3, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (f₂₃ : LinearMap.{u3, u3, u5, u6} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ _inst_4 _inst_5 _inst_10 _inst_11) (g₁₂ : LinearMap.{u3, u3, u7, u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₄ M₅ _inst_6 _inst_7 _inst_12 _inst_13) (g₂₃ : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₅ M₆ _inst_7 _inst_8 _inst_13 _inst_14), Eq.{max (max (max (succ u4) (succ u6)) (succ u7)) (succ u1)} (LinearMap.{u3, u3, max u4 u7, max u6 u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Prod.{u4, u7} M M₄) (Prod.{u6, u1} M₃ M₆) (Prod.instAddCommMonoidSum.{u4, u7} M M₄ _inst_3 _inst_6) (Prod.instAddCommMonoidSum.{u6, u1} M₃ M₆ _inst_5 _inst_8) (Prod.module.{u3, u4, u7} R M M₄ _inst_1 _inst_3 _inst_6 _inst_9 _inst_12) (Prod.module.{u3, u6, u1} R M₃ M₆ _inst_1 _inst_5 _inst_8 _inst_11 _inst_14)) (LinearMap.comp.{u3, u3, u3, max u4 u7, max u5 u2, max u6 u1} R R R (Prod.{u4, u7} M M₄) (Prod.{u5, u2} M₂ M₅) (Prod.{u6, u1} M₃ M₆) _inst_1 _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u4, u7} M M₄ _inst_3 _inst_6) (Prod.instAddCommMonoidSum.{u5, u2} M₂ M₅ _inst_4 _inst_7) (Prod.instAddCommMonoidSum.{u6, u1} M₃ M₆ _inst_5 _inst_8) (Prod.module.{u3, u4, u7} R M M₄ _inst_1 _inst_3 _inst_6 _inst_9 _inst_12) (Prod.module.{u3, u5, u2} R M₂ M₅ _inst_1 _inst_4 _inst_7 _inst_10 _inst_13) (Prod.module.{u3, u6, u1} R M₃ M₆ _inst_1 _inst_5 _inst_8 _inst_11 _inst_14) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.prodMap.{u3, u5, u2, u6, u1} R M₂ M₅ M₃ M₆ _inst_1 _inst_4 _inst_7 _inst_5 _inst_8 _inst_10 _inst_13 _inst_11 _inst_14 f₂₃ g₂₃) (LinearMap.prodMap.{u3, u4, u7, u5, u2} R M M₄ M₂ M₅ _inst_1 _inst_3 _inst_6 _inst_4 _inst_7 _inst_9 _inst_12 _inst_10 _inst_13 f₁₂ g₁₂)) (LinearMap.prodMap.{u3, u4, u7, u6, u1} R M M₄ M₃ M₆ _inst_1 _inst_3 _inst_6 _inst_5 _inst_8 _inst_9 _inst_12 _inst_11 _inst_14 (LinearMap.comp.{u3, u3, u3, u4, u5, u6} R R R M M₂ M₃ _inst_1 _inst_1 _inst_1 _inst_3 _inst_4 _inst_5 _inst_9 _inst_10 _inst_11 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f₂₃ f₁₂) (LinearMap.comp.{u3, u3, u3, u7, u2, u1} R R R M₄ M₅ M₆ _inst_1 _inst_1 _inst_1 _inst_6 _inst_7 _inst_8 _inst_12 _inst_13 _inst_14 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (RingHomCompTriple.ids.{u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) g₂₃ g₁₂))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_comp LinearMap.prodMap_compₓ'. -/
theorem prodMap_comp (f₁₂ : M →ₗ[R] M₂) (f₂₃ : M₂ →ₗ[R] M₃) (g₁₂ : M₄ →ₗ[R] M₅)
    (g₂₃ : M₅ →ₗ[R] M₆) :
    f₂₃.Prod_map g₂₃ ∘ₗ f₁₂.Prod_map g₁₂ = (f₂₃ ∘ₗ f₁₂).Prod_map (g₂₃ ∘ₗ g₁₂) :=
  rfl
#align linear_map.prod_map_comp LinearMap.prodMap_comp

/- warning: linear_map.prod_map_mul -> LinearMap.prodMap_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (f₁₂ : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (f₂₃ : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (g₁₂ : LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (g₂₃ : LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10), Eq.{succ (max u2 u3)} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (instHMul.{max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.module.End.hasMul.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 f₂₃ g₂₃) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 f₁₂ g₁₂)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.module.End.hasMul.{u1, u2} R M _inst_1 _inst_3 _inst_9)) f₂₃ f₁₂) (HMul.hMul.{u3, u3, u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (instHMul.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.module.End.hasMul.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)) g₂₃ g₁₂))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] (f₁₂ : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (f₂₃ : LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (g₁₂ : LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (g₂₃ : LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10), Eq.{max (succ u2) (succ u3)} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (instHMul.{max u2 u3} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (LinearMap.instMulEnd.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10))) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 f₂₃ g₂₃) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 f₁₂ g₁₂)) (LinearMap.prodMap.{u1, u2, u3, u2, u3} R M M₂ M M₂ _inst_1 _inst_3 _inst_4 _inst_3 _inst_4 _inst_9 _inst_10 _inst_9 _inst_10 (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.instMulEnd.{u1, u2} R M _inst_1 _inst_3 _inst_9)) f₂₃ f₁₂) (HMul.hMul.{u3, u3, u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (instHMul.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (LinearMap.instMulEnd.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10)) g₂₃ g₁₂))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_mul LinearMap.prodMap_mulₓ'. -/
theorem prodMap_mul (f₁₂ : M →ₗ[R] M) (f₂₃ : M →ₗ[R] M) (g₁₂ : M₂ →ₗ[R] M₂) (g₂₃ : M₂ →ₗ[R] M₂) :
    f₂₃.Prod_map g₂₃ * f₁₂.Prod_map g₁₂ = (f₂₃ * f₁₂).Prod_map (g₂₃ * g₁₂) :=
  rfl
#align linear_map.prod_map_mul LinearMap.prodMap_mul

/- warning: linear_map.prod_map_add -> LinearMap.prodMap_add is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f₁ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (f₂ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g₁ : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (g₂ : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (succ (max u2 u3)) (succ (max u4 u5))} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 (HAdd.hAdd.{max u2 u4, max u2 u4, max u2 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (instHAdd.{max u2 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.hasAdd.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) f₁ f₂) (HAdd.hAdd.{max u3 u5, max u3 u5, max u3 u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u3 u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasAdd.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) g₁ g₂)) (HAdd.hAdd.{max (max u2 u3) u4 u5, max (max u2 u3) u4 u5, max (max u2 u3) u4 u5} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (instHAdd.{max (max u2 u3) u4 u5} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.hasAdd.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f₁ g₁) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f₂ g₂))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] (f₁ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (f₂ : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g₁ : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (g₂ : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5)} (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 (HAdd.hAdd.{max u2 u4, max u2 u4, max u2 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (instHAdd.{max u2 u4} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.instAddLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) f₁ f₂) (HAdd.hAdd.{max u3 u5, max u3 u5, max u3 u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (instHAdd.{max u3 u5} (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instAddLinearMap.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) g₁ g₂)) (HAdd.hAdd.{max (max (max u2 u3) u4) u5, max (max (max u2 u3) u4) u5, max (max (max u2 u3) u4) u5} (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (instHAdd.{max (max (max u2 u3) u4) u5} (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.instAddLinearMap.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f₁ g₁) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f₂ g₂))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_add LinearMap.prodMap_addₓ'. -/
theorem prodMap_add (f₁ : M →ₗ[R] M₃) (f₂ : M →ₗ[R] M₃) (g₁ : M₂ →ₗ[R] M₄) (g₂ : M₂ →ₗ[R] M₄) :
    (f₁ + f₂).Prod_map (g₁ + g₂) = f₁.Prod_map g₁ + f₂.Prod_map g₂ :=
  rfl
#align linear_map.prod_map_add LinearMap.prodMap_add

/- warning: linear_map.prod_map_zero -> LinearMap.prodMap_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6], Eq.{max (succ (max u2 u4)) (succ (max u3 u5))} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (OfNat.mk.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.zero.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.hasZero.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{max u4 u5} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) 0 (OfNat.mk.{max u4 u5} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) 0 (Zero.zero.{max u4 u5} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.hasZero.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))) (OfNat.ofNat.{max (max u2 u4) u3 u5} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) 0 (OfNat.mk.{max (max u2 u4) u3 u5} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) 0 (Zero.zero.{max (max u2 u4) u3 u5} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.hasZero.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6], Eq.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5)} (LinearMap.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_3 _inst_5 _inst_4 _inst_6 _inst_9 _inst_11 _inst_10 _inst_12 (OfNat.ofNat.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) 0 (Zero.toOfNat0.{max u2 u3} (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_3 _inst_4 _inst_9 _inst_10) (LinearMap.instZeroLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_3 _inst_4 _inst_9 _inst_10 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))))) (OfNat.ofNat.{max u4 u5} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) 0 (Zero.toOfNat0.{max u4 u5} (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_5 _inst_6 _inst_11 _inst_12) (LinearMap.instZeroLinearMap.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_5 _inst_6 _inst_11 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))) (OfNat.ofNat.{max (max (max u2 u3) u4) u5} (LinearMap.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) 0 (Zero.toOfNat0.{max (max (max u2 u3) u4) u5} (LinearMap.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.instZeroLinearMap.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_4 _inst_6) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_3 _inst_5 _inst_9 _inst_11) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_4 _inst_6 _inst_10 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_zero LinearMap.prodMap_zeroₓ'. -/
@[simp]
theorem prodMap_zero : (0 : M →ₗ[R] M₂).Prod_map (0 : M₃ →ₗ[R] M₄) = 0 :=
  rfl
#align linear_map.prod_map_zero LinearMap.prodMap_zero

/- warning: linear_map.prod_map_smul -> LinearMap.prodMap_smul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} (S : Type.{u6}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u6} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] [_inst_15 : Module.{u6, u4} S M₃ _inst_2 _inst_5] [_inst_16 : Module.{u6, u5} S M₄ _inst_2 _inst_6] [_inst_17 : SMulCommClass.{u1, u6, u4} R S M₃ (SMulZeroClass.toHasSmul.{u1, u4} R M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toHasSmul.{u6, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u6, u4} S M₃ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u6, u4} S M₃ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15))))] [_inst_18 : SMulCommClass.{u1, u6, u5} R S M₄ (SMulZeroClass.toHasSmul.{u1, u5} R M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u5} R M₄ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u5} R M₄ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12)))) (SMulZeroClass.toHasSmul.{u6, u5} S M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u6, u5} S M₄ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u6, u5} S M₄ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16))))] (s : S) (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (succ (max u2 u3)) (succ (max u4 u5))} (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 (SMul.smul.{u6, max u2 u4} S (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.hasSmul.{u1, u1, u6, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (Module.toDistribMulAction.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15) _inst_17) s f) (SMul.smul.{u6, max u3 u5} S (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.hasSmul.{u1, u1, u6, u3, u5} R R S M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (Module.toDistribMulAction.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16) _inst_18) s g)) (SMul.smul.{u6, max (max u2 u3) u4 u5} S (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.hasSmul.{u1, u1, u6, max u2 u3, max u4 u5} R R S (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (Prod.distribMulAction.{u6, u4, u5} S M₃ M₄ (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5) (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6) (Module.toDistribMulAction.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15) (Module.toDistribMulAction.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16)) (Prod.sMulCommClass.{u1, u6, u4, u5} R S M₃ M₄ (SMulZeroClass.toHasSmul.{u1, u4} R M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toHasSmul.{u1, u5} R M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u5} R M₄ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u5} R M₄ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12)))) (SMulZeroClass.toHasSmul.{u6, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u6, u4} S M₃ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u6, u4} S M₃ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15)))) (SMulZeroClass.toHasSmul.{u6, u5} S M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u6, u5} S M₄ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u6, u5} S M₄ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16)))) _inst_17 _inst_18)) s (LinearMap.prodMap.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g))
but is expected to have type
  forall {R : Type.{u2}} {M : Type.{u3}} {M₂ : Type.{u4}} {M₃ : Type.{u5}} {M₄ : Type.{u6}} (S : Type.{u1}) [_inst_1 : Semiring.{u2} R] [_inst_2 : Semiring.{u1} S] [_inst_3 : AddCommMonoid.{u3} M] [_inst_4 : AddCommMonoid.{u4} M₂] [_inst_5 : AddCommMonoid.{u5} M₃] [_inst_6 : AddCommMonoid.{u6} M₄] [_inst_9 : Module.{u2, u3} R M _inst_1 _inst_3] [_inst_10 : Module.{u2, u4} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u2, u5} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u2, u6} R M₄ _inst_1 _inst_6] [_inst_15 : Module.{u1, u5} S M₃ _inst_2 _inst_5] [_inst_16 : Module.{u1, u6} S M₄ _inst_2 _inst_6] [_inst_17 : SMulCommClass.{u2, u1, u5} R S M₃ (SMulZeroClass.toSMul.{u2, u5} R M₃ (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u2, u5} R M₃ (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u2, u5} R M₃ (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (Module.toMulActionWithZero.{u2, u5} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toSMul.{u1, u5} S M₃ (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u5} S M₃ (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u5} S M₃ (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u5} M₃ (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5)) (Module.toMulActionWithZero.{u1, u5} S M₃ _inst_2 _inst_5 _inst_15))))] [_inst_18 : SMulCommClass.{u2, u1, u6} R S M₄ (SMulZeroClass.toSMul.{u2, u6} R M₄ (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (SMulWithZero.toSMulZeroClass.{u2, u6} R M₄ (MonoidWithZero.toZero.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (MulActionWithZero.toSMulWithZero.{u2, u6} R M₄ (Semiring.toMonoidWithZero.{u2} R _inst_1) (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (Module.toMulActionWithZero.{u2, u6} R M₄ _inst_1 _inst_6 _inst_12)))) (SMulZeroClass.toSMul.{u1, u6} S M₄ (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u6} S M₄ (MonoidWithZero.toZero.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u6} S M₄ (Semiring.toMonoidWithZero.{u1} S _inst_2) (AddMonoid.toZero.{u6} M₄ (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6)) (Module.toMulActionWithZero.{u1, u6} S M₄ _inst_2 _inst_6 _inst_16))))] (s : S) (f : LinearMap.{u2, u2, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (g : LinearMap.{u2, u2, u4, u6} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12), Eq.{max (max (max (succ u3) (succ u4)) (succ u5)) (succ u6)} (LinearMap.{u2, u2, max u4 u3, max u6 u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Prod.{u3, u4} M M₂) (Prod.{u5, u6} M₃ M₄) (Prod.instAddCommMonoidSum.{u3, u4} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u5, u6} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u2, u3, u4} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u2, u5, u6} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.prodMap.{u2, u3, u4, u5, u6} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 (HSMul.hSMul.{u1, max u3 u5, max u3 u5} S (LinearMap.{u2, u2, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u2, u2, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (instHSMul.{u1, max u3 u5} S (LinearMap.{u2, u2, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.instSMulLinearMap.{u2, u2, u1, u3, u5} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (Module.toDistribMulAction.{u1, u5} S M₃ _inst_2 _inst_5 _inst_15) _inst_17)) s f) (HSMul.hSMul.{u1, max u4 u6, max u4 u6} S (LinearMap.{u2, u2, u4, u6} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.{u2, u2, u4, u6} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (instHSMul.{u1, max u4 u6} S (LinearMap.{u2, u2, u4, u6} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.instSMulLinearMap.{u2, u2, u1, u4, u6} R R S M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (Module.toDistribMulAction.{u1, u6} S M₄ _inst_2 _inst_6 _inst_16) _inst_18)) s g)) (HSMul.hSMul.{u1, max (max (max u6 u5) u4) u3, max (max (max u3 u4) u5) u6} S (LinearMap.{u2, u2, max u4 u3, max u6 u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Prod.{u3, u4} M M₂) (Prod.{u5, u6} M₃ M₄) (Prod.instAddCommMonoidSum.{u3, u4} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u5, u6} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u2, u3, u4} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u2, u5, u6} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.{u2, u2, max u4 u3, max u6 u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Prod.{u3, u4} M M₂) (Prod.{u5, u6} M₃ M₄) (Prod.instAddCommMonoidSum.{u3, u4} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u5, u6} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u2, u3, u4} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u2, u5, u6} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (instHSMul.{u1, max (max (max u3 u4) u5) u6} S (LinearMap.{u2, u2, max u4 u3, max u6 u5} R R _inst_1 _inst_1 (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (Prod.{u3, u4} M M₂) (Prod.{u5, u6} M₃ M₄) (Prod.instAddCommMonoidSum.{u3, u4} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u5, u6} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u2, u3, u4} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u2, u5, u6} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (LinearMap.instSMulLinearMap.{u2, u2, u1, max u3 u4, max u5 u6} R R S (Prod.{u3, u4} M M₂) (Prod.{u5, u6} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u5, u6} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u2, u3, u4} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u2, u5, u6} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u2} R (Semiring.toNonAssocSemiring.{u2} R _inst_1)) (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (Prod.distribMulAction.{u1, u5, u6} S M₃ M₄ (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5) (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6) (Module.toDistribMulAction.{u1, u5} S M₃ _inst_2 _inst_5 _inst_15) (Module.toDistribMulAction.{u1, u6} S M₄ _inst_2 _inst_6 _inst_16)) (Prod.smulCommClass.{u2, u1, u5, u6} R S M₃ M₄ (MulAction.toSMul.{u2, u5} R M₃ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (DistribMulAction.toMulAction.{u2, u5} R M₃ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5) (Module.toDistribMulAction.{u2, u5} R M₃ _inst_1 _inst_5 _inst_11))) (MulAction.toSMul.{u2, u6} R M₄ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (DistribMulAction.toMulAction.{u2, u6} R M₄ (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R _inst_1)) (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6) (Module.toDistribMulAction.{u2, u6} R M₄ _inst_1 _inst_6 _inst_12))) (MulAction.toSMul.{u1, u5} S M₃ (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (DistribMulAction.toMulAction.{u1, u5} S M₃ (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{u5} M₃ _inst_5) (Module.toDistribMulAction.{u1, u5} S M₃ _inst_2 _inst_5 _inst_15))) (MulAction.toSMul.{u1, u6} S M₄ (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (DistribMulAction.toMulAction.{u1, u6} S M₄ (MonoidWithZero.toMonoid.{u1} S (Semiring.toMonoidWithZero.{u1} S _inst_2)) (AddCommMonoid.toAddMonoid.{u6} M₄ _inst_6) (Module.toDistribMulAction.{u1, u6} S M₄ _inst_2 _inst_6 _inst_16))) _inst_17 _inst_18))) s (LinearMap.prodMap.{u2, u3, u4, u5, u6} R M M₂ M₃ M₄ _inst_1 _inst_3 _inst_4 _inst_5 _inst_6 _inst_9 _inst_10 _inst_11 _inst_12 f g))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_smul LinearMap.prodMap_smulₓ'. -/
@[simp]
theorem prodMap_smul [Module S M₃] [Module S M₄] [SMulCommClass R S M₃] [SMulCommClass R S M₄]
    (s : S) (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) : prodMap (s • f) (s • g) = s • prodMap f g :=
  rfl
#align linear_map.prod_map_smul LinearMap.prodMap_smul

variable (R M M₂ M₃ M₄)

/- warning: linear_map.prod_map_linear -> LinearMap.prodMapLinear is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) (M₃ : Type.{u4}) (M₄ : Type.{u5}) (S : Type.{u6}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u6} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] [_inst_15 : Module.{u6, u4} S M₃ _inst_2 _inst_5] [_inst_16 : Module.{u6, u5} S M₄ _inst_2 _inst_6] [_inst_17 : SMulCommClass.{u1, u6, u4} R S M₃ (SMulZeroClass.toHasSmul.{u1, u4} R M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u1, u4} R M₃ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toHasSmul.{u6, u4} S M₃ (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (SMulWithZero.toSmulZeroClass.{u6, u4} S M₃ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (MulActionWithZero.toSMulWithZero.{u6, u4} S M₃ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u4} M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5))) (Module.toMulActionWithZero.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15))))] [_inst_18 : SMulCommClass.{u1, u6, u5} R S M₄ (SMulZeroClass.toHasSmul.{u1, u5} R M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u1, u5} R M₄ (MulZeroClass.toHasZero.{u1} R (MulZeroOneClass.toMulZeroClass.{u1} R (MonoidWithZero.toMulZeroOneClass.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u1, u5} R M₄ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12)))) (SMulZeroClass.toHasSmul.{u6, u5} S M₄ (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (SMulWithZero.toSmulZeroClass.{u6, u5} S M₄ (MulZeroClass.toHasZero.{u6} S (MulZeroOneClass.toMulZeroClass.{u6} S (MonoidWithZero.toMulZeroOneClass.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)))) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (MulActionWithZero.toSMulWithZero.{u6, u5} S M₄ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddZeroClass.toHasZero.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6))) (Module.toMulActionWithZero.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16))))], LinearMap.{u6, u6, max (max u2 u4) u3 u5, max (max u2 u3) u4 u5} S S _inst_2 _inst_2 (RingHom.id.{u6} S (Semiring.toNonAssocSemiring.{u6} S _inst_2)) (Prod.{max u2 u4, max u3 u5} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.{u1, u1, max u2 u3, max u4 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (Prod.addCommMonoid.{max u2 u4, max u3 u5} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u6, max u2 u4, max u3 u5} S (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.module.{u1, u1, u6, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_17) (LinearMap.module.{u1, u1, u6, u3, u5} R R S M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_16 _inst_18)) (LinearMap.module.{u1, u1, u6, max u2 u3, max u4 u5} R R S (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 (Prod.module.{u6, u4, u5} S M₃ M₄ _inst_2 _inst_5 _inst_6 _inst_15 _inst_16) (LinearMap.prodMapLinear._proof_1.{u1, u6, u4, u5} R M₃ M₄ S _inst_1 _inst_2 _inst_5 _inst_6 _inst_11 _inst_12 _inst_15 _inst_16 _inst_17 _inst_18))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) (M₃ : Type.{u4}) (M₄ : Type.{u5}) (S : Type.{u6}) [_inst_1 : Semiring.{u1} R] [_inst_2 : Semiring.{u6} S] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_5 : AddCommMonoid.{u4} M₃] [_inst_6 : AddCommMonoid.{u5} M₄] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4] [_inst_11 : Module.{u1, u4} R M₃ _inst_1 _inst_5] [_inst_12 : Module.{u1, u5} R M₄ _inst_1 _inst_6] [_inst_15 : Module.{u6, u4} S M₃ _inst_2 _inst_5] [_inst_16 : Module.{u6, u5} S M₄ _inst_2 _inst_6] [_inst_17 : SMulCommClass.{u1, u6, u4} R S M₃ (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u1, u4} R M₃ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u1, u4} R M₃ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11)))) (SMulZeroClass.toSMul.{u6, u4} S M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (SMulWithZero.toSMulZeroClass.{u6, u4} S M₃ (MonoidWithZero.toZero.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (MulActionWithZero.toSMulWithZero.{u6, u4} S M₃ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5)) (Module.toMulActionWithZero.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15))))] [_inst_18 : SMulCommClass.{u1, u6, u5} R S M₄ (SMulZeroClass.toSMul.{u1, u5} R M₄ (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (SMulWithZero.toSMulZeroClass.{u1, u5} R M₄ (MonoidWithZero.toZero.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (MulActionWithZero.toSMulWithZero.{u1, u5} R M₄ (Semiring.toMonoidWithZero.{u1} R _inst_1) (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (Module.toMulActionWithZero.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12)))) (SMulZeroClass.toSMul.{u6, u5} S M₄ (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (SMulWithZero.toSMulZeroClass.{u6, u5} S M₄ (MonoidWithZero.toZero.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (MulActionWithZero.toSMulWithZero.{u6, u5} S M₄ (Semiring.toMonoidWithZero.{u6} S _inst_2) (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6)) (Module.toMulActionWithZero.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16))))], LinearMap.{u6, u6, max (max u5 u3) u4 u2, max (max u5 u4) u3 u2} S S _inst_2 _inst_2 (RingHom.id.{u6} S (Semiring.toNonAssocSemiring.{u6} S _inst_2)) (Prod.{max u4 u2, max u5 u3} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12)) (LinearMap.{u1, u1, max u3 u2, max u5 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12)) (Prod.instAddCommMonoidSum.{max u2 u4, max u3 u5} (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)))) (LinearMap.addCommMonoid.{u1, u1, max u2 u3, max u4 u5} R R (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (Prod.module.{u6, max u2 u4, max u3 u5} S (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_3 _inst_5 _inst_9 _inst_11) (LinearMap.{u1, u1, u3, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₄ _inst_4 _inst_6 _inst_10 _inst_12) _inst_2 (LinearMap.addCommMonoid.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.addCommMonoid.{u1, u1, u3, u5} R R M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u6, u2, u4} R R S M M₃ _inst_1 _inst_1 _inst_3 _inst_5 _inst_9 _inst_11 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_15 _inst_17) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u6, u3, u5} R R S M₂ M₄ _inst_1 _inst_1 _inst_4 _inst_6 _inst_10 _inst_12 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 _inst_16 _inst_18)) (LinearMap.instModuleLinearMapAddCommMonoid.{u1, u1, u6, max u2 u3, max u4 u5} R R S (Prod.{u2, u3} M M₂) (Prod.{u4, u5} M₃ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u4, u5} M₃ M₄ _inst_5 _inst_6) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u4, u5} R M₃ M₄ _inst_1 _inst_5 _inst_6 _inst_11 _inst_12) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) _inst_2 (Prod.module.{u6, u4, u5} S M₃ M₄ _inst_2 _inst_5 _inst_6 _inst_15 _inst_16) (Prod.smulCommClass.{u1, u6, u4, u5} R S M₃ M₄ (MulAction.toSMul.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribMulAction.toMulAction.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_5 _inst_11))) (MulAction.toSMul.{u1, u5} R M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (DistribMulAction.toMulAction.{u1, u5} R M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 _inst_6 _inst_12))) (MulAction.toSMul.{u6, u4} S M₃ (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (DistribMulAction.toMulAction.{u6, u4} S M₃ (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_5) (Module.toDistribMulAction.{u6, u4} S M₃ _inst_2 _inst_5 _inst_15))) (MulAction.toSMul.{u6, u5} S M₄ (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (DistribMulAction.toMulAction.{u6, u5} S M₄ (MonoidWithZero.toMonoid.{u6} S (Semiring.toMonoidWithZero.{u6} S _inst_2)) (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_6) (Module.toDistribMulAction.{u6, u5} S M₄ _inst_2 _inst_6 _inst_16))) _inst_17 _inst_18))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_linear LinearMap.prodMapLinearₓ'. -/
/-- `linear_map.prod_map` as a `linear_map` -/
@[simps]
def prodMapLinear [Module S M₃] [Module S M₄] [SMulCommClass R S M₃] [SMulCommClass R S M₄] :
    (M →ₗ[R] M₃) × (M₂ →ₗ[R] M₄) →ₗ[S] M × M₂ →ₗ[R] M₃ × M₄
    where
  toFun f := prodMap f.1 f.2
  map_add' _ _ := rfl
  map_smul' _ _ := rfl
#align linear_map.prod_map_linear LinearMap.prodMapLinear

/- warning: linear_map.prod_map_ring_hom -> LinearMap.prodMapRingHom is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], RingHom.{max u2 u3, max u2 u3} (Prod.{u2, u3} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10)) (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Prod.nonAssocSemiring.{u2, u3} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (Semiring.toNonAssocSemiring.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_3 _inst_9)) (Semiring.toNonAssocSemiring.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (Module.End.semiring.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))) (Semiring.toNonAssocSemiring.{max u2 u3} (LinearMap.{u1, u1, max u2 u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Module.End.semiring.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_3 : AddCommMonoid.{u2} M] [_inst_4 : AddCommMonoid.{u3} M₂] [_inst_9 : Module.{u1, u2} R M _inst_1 _inst_3] [_inst_10 : Module.{u1, u3} R M₂ _inst_1 _inst_4], RingHom.{max u3 u2, max u3 u2} (Prod.{u2, u3} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10)) (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Prod.instNonAssocSemiringProd.{u2, u3} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (Semiring.toNonAssocSemiring.{u2} (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M _inst_3 _inst_3 _inst_9 _inst_9) (Module.End.semiring.{u1, u2} R M _inst_1 _inst_3 _inst_9)) (Semiring.toNonAssocSemiring.{u3} (LinearMap.{u1, u1, u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₂ _inst_4 _inst_4 _inst_10 _inst_10) (Module.End.semiring.{u1, u3} R M₂ _inst_1 _inst_4 _inst_10))) (Semiring.toNonAssocSemiring.{max u2 u3} (LinearMap.{u1, u1, max u3 u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) (Prod.{u2, u3} M M₂) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)) (Module.End.semiring.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_3 _inst_4) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_3 _inst_4 _inst_9 _inst_10)))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_ring_hom LinearMap.prodMapRingHomₓ'. -/
/-- `linear_map.prod_map` as a `ring_hom` -/
@[simps]
def prodMapRingHom : (M →ₗ[R] M) × (M₂ →ₗ[R] M₂) →+* M × M₂ →ₗ[R] M × M₂
    where
  toFun f := prodMap f.1 f.2
  map_one' := prodMap_one
  map_zero' := rfl
  map_add' _ _ := rfl
  map_mul' _ _ := rfl
#align linear_map.prod_map_ring_hom LinearMap.prodMapRingHom

variable {R M M₂ M₃ M₄}

section map_mul

variable {A : Type _} [NonUnitalNonAssocSemiring A] [Module R A]

variable {B : Type _} [NonUnitalNonAssocSemiring B] [Module R B]

/- warning: linear_map.inl_map_mul -> LinearMap.inl_map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {A : Type.{u2}} [_inst_15 : NonUnitalNonAssocSemiring.{u2} A] [_inst_16 : Module.{u1, u2} R A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15)] {B : Type.{u3}} [_inst_17 : NonUnitalNonAssocSemiring.{u3} B] [_inst_18 : Module.{u1, u3} R B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)] (a₁ : A) (a₂ : A), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} A B) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => A -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R A (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A _inst_15))) a₁ a₂)) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (Prod.{u2, u3} A B) (Prod.{u2, u3} A B) (Prod.{u2, u3} A B) (instHMul.{max u2 u3} (Prod.{u2, u3} A B) (Prod.hasMul.{u2, u3} A B (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A _inst_15)) (Distrib.toHasMul.{u3} B (NonUnitalNonAssocSemiring.toDistrib.{u3} B _inst_17)))) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => A -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R A (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) a₁) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) A (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => A -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R A (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_16 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) a₂))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] {A : Type.{u2}} [_inst_15 : NonUnitalNonAssocSemiring.{u2} A] [_inst_16 : Module.{u3, u2} R A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15)] {B : Type.{u1}} [_inst_17 : NonUnitalNonAssocSemiring.{u1} B] [_inst_18 : Module.{u3, u1} R B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)] (a₁ : A) (a₂ : A), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A _inst_15)) a₁ a₂)) (FunLike.coe.{max (succ u2) (succ u1), succ u2, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) A (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u2 u1} R R A (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inl.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (HMul.hMul.{u2, u2, u2} A A A (instHMul.{u2} A (NonUnitalNonAssocSemiring.toMul.{u2} A _inst_15)) a₁ a₂)) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) a₁) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) a₂) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) a₁) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) a₁) (Prod.instMulProd.{u2, u1} A B (NonUnitalNonAssocSemiring.toMul.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toMul.{u1} B _inst_17))) (FunLike.coe.{max (succ u2) (succ u1), succ u2, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) A (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u2 u1} R R A (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inl.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) a₁) (FunLike.coe.{max (succ u2) (succ u1), succ u2, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u2, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) A (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) A (fun (_x : A) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : A) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u2, max u2 u1} R R A (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_16 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inl.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) a₂))
Case conversion may be inaccurate. Consider using '#align linear_map.inl_map_mul LinearMap.inl_map_mulₓ'. -/
theorem inl_map_mul (a₁ a₂ : A) :
    LinearMap.inl R A B (a₁ * a₂) = LinearMap.inl R A B a₁ * LinearMap.inl R A B a₂ :=
  Prod.ext rfl (by simp)
#align linear_map.inl_map_mul LinearMap.inl_map_mul

/- warning: linear_map.inr_map_mul -> LinearMap.inr_map_mul is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_1 : Semiring.{u1} R] {A : Type.{u2}} [_inst_15 : NonUnitalNonAssocSemiring.{u2} A] [_inst_16 : Module.{u1, u2} R A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15)] {B : Type.{u3}} [_inst_17 : NonUnitalNonAssocSemiring.{u3} B] [_inst_18 : Module.{u1, u3} R B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)] (b₁ : B) (b₂ : B), Eq.{max (succ u2) (succ u3)} (Prod.{u2, u3} A B) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => B -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R B (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (HMul.hMul.{u3, u3, u3} B B B (instHMul.{u3} B (Distrib.toHasMul.{u3} B (NonUnitalNonAssocSemiring.toDistrib.{u3} B _inst_17))) b₁ b₂)) (HMul.hMul.{max u2 u3, max u2 u3, max u2 u3} (Prod.{u2, u3} A B) (Prod.{u2, u3} A B) (Prod.{u2, u3} A B) (instHMul.{max u2 u3} (Prod.{u2, u3} A B) (Prod.hasMul.{u2, u3} A B (Distrib.toHasMul.{u2} A (NonUnitalNonAssocSemiring.toDistrib.{u2} A _inst_15)) (Distrib.toHasMul.{u3} B (NonUnitalNonAssocSemiring.toDistrib.{u3} B _inst_17)))) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => B -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R B (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) b₁) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) B (Prod.{u2, u3} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18)) => B -> (Prod.{u2, u3} A B)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R B (Prod.{u2, u3} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) (Prod.addCommMonoid.{u2, u3} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17)) _inst_18 (Prod.module.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} B _inst_17) _inst_16 _inst_18) b₂))
but is expected to have type
  forall {R : Type.{u3}} [_inst_1 : Semiring.{u3} R] {A : Type.{u2}} [_inst_15 : NonUnitalNonAssocSemiring.{u2} A] [_inst_16 : Module.{u3, u2} R A _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15)] {B : Type.{u1}} [_inst_17 : NonUnitalNonAssocSemiring.{u1} B] [_inst_18 : Module.{u3, u1} R B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)] (b₁ : B) (b₂ : B), Eq.{max (succ u2) (succ u1)} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) (HMul.hMul.{u1, u1, u1} B B B (instHMul.{u1} B (NonUnitalNonAssocSemiring.toMul.{u1} B _inst_17)) b₁ b₂)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u1, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) B (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u1, max u2 u1} R R B (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inr.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (HMul.hMul.{u1, u1, u1} B B B (instHMul.{u1} B (NonUnitalNonAssocSemiring.toMul.{u1} B _inst_17)) b₁ b₂)) (HMul.hMul.{max u2 u1, max u2 u1, max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) b₁) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) b₂) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) b₁) (instHMul.{max u2 u1} ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) b₁) (Prod.instMulProd.{u2, u1} A B (NonUnitalNonAssocSemiring.toMul.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toMul.{u1} B _inst_17))) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u1, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) B (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u1, max u2 u1} R R B (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inr.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) b₁) (FunLike.coe.{max (succ u2) (succ u1), succ u1, max (succ u2) (succ u1)} (LinearMap.{u3, u3, u1, max u1 u2} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) B (Prod.{u2, u1} A B) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18)) B (fun (_x : B) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : B) => Prod.{u2, u1} A B) _x) (LinearMap.instFunLikeLinearMap.{u3, u3, u1, max u2 u1} R R B (Prod.{u2, u1} A B) _inst_1 _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) (Prod.instAddCommMonoidSum.{u2, u1} A B (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17)) _inst_18 (Prod.module.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.inr.{u3, u2, u1} R A B _inst_1 (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} A _inst_15) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} B _inst_17) _inst_16 _inst_18) b₂))
Case conversion may be inaccurate. Consider using '#align linear_map.inr_map_mul LinearMap.inr_map_mulₓ'. -/
theorem inr_map_mul (b₁ b₂ : B) :
    LinearMap.inr R A B (b₁ * b₂) = LinearMap.inr R A B b₁ * LinearMap.inr R A B b₂ :=
  Prod.ext (by simp) rfl
#align linear_map.inr_map_mul LinearMap.inr_map_mul

end map_mul

end LinearMap

end Prod

namespace LinearMap

variable (R M M₂)

variable [CommSemiring R]

variable [AddCommMonoid M] [AddCommMonoid M₂]

variable [Module R M] [Module R M₂]

/- warning: linear_map.prod_map_alg_hom -> LinearMap.prodMapAlgHom is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3], AlgHom.{u1, max u2 u3, max u2 u3} R (Prod.{u2, u3} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5)) (Module.End.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) (CommSemiring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5)) _inst_1 (Prod.semiring.{u2, u3} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5)) (Module.End.semiring.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) (CommSemiring.toSemiring.{u1} R _inst_1) (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.algebra.{u1, u2, u3} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.algebra.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) (Module.End.algebra.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (Module.End.algebra.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : CommSemiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2] [_inst_5 : Module.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3], AlgHom.{u1, max u3 u2, max u3 u2} R (Prod.{u2, u3} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5)) (Module.End.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) (CommSemiring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5)) _inst_1 (Prod.instSemiringProd.{u2, u3} (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5)) (Module.End.semiring.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) (CommSemiring.toSemiring.{u1} R _inst_1) (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.algebra.{u1, u2, u3} R (Module.End.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.End.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) _inst_1 (Module.End.semiring.{u1, u2} R M (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_4) (Module.instAlgebraEndToSemiringSemiring.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Module.End.semiring.{u1, u3} R M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_3 _inst_5) (Module.instAlgebraEndToSemiringSemiring.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)) (Module.instAlgebraEndToSemiringSemiring.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ (CommSemiring.toSemiring.{u1} R _inst_1) _inst_2 _inst_3 _inst_4 _inst_5))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_map_alg_hom LinearMap.prodMapAlgHomₓ'. -/
/-- `linear_map.prod_map` as an `algebra_hom` -/
@[simps]
def prodMapAlgHom : Module.End R M × Module.End R M₂ →ₐ[R] Module.End R (M × M₂) :=
  { prodMapRingHom R M M₂ with commutes' := fun _ => rfl }
#align linear_map.prod_map_alg_hom LinearMap.prodMapAlgHom

end LinearMap

namespace LinearMap

open Submodule

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃] [AddCommMonoid M₄]
  [Module R M] [Module R M₂] [Module R M₃] [Module R M₄]

/- warning: linear_map.range_coprod -> LinearMap.range_coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (LinearMap.range.{u1, u1, max u2 u3, u4, max (max u2 u3) u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8))))) (LinearMap.range.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) f) (LinearMap.range.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (LinearMap.range.{u1, u1, max u2 u3, u4, max (max u2 u4) u3} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8))))) (LinearMap.range.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) f) (LinearMap.range.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) g))
Case conversion may be inaccurate. Consider using '#align linear_map.range_coprod LinearMap.range_coprodₓ'. -/
theorem range_coprod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : (f.coprod g).range = f.range ⊔ g.range :=
  Submodule.ext fun x => by simp [mem_sup]
#align linear_map.range_coprod LinearMap.range_coprod

/- warning: linear_map.is_compl_range_inl_inr -> LinearMap.isCompl_range_inl_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], IsCompl.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (CompleteLattice.toBoundedOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], IsCompl.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))) (CompleteLattice.toBoundedOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))
Case conversion may be inaccurate. Consider using '#align linear_map.is_compl_range_inl_inr LinearMap.isCompl_range_inl_inrₓ'. -/
theorem isCompl_range_inl_inr : IsCompl (inl R M M₂).range (inr R M M₂).range :=
  by
  constructor
  · rw [disjoint_def]
    rintro ⟨_, _⟩ ⟨x, hx⟩ ⟨y, hy⟩
    simp only [Prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy⊢
    exact ⟨hy.1.symm, hx.2.symm⟩
  · rw [codisjoint_iff_le_sup]
    rintro ⟨x, y⟩ -
    simp only [mem_sup, mem_range, exists_prop]
    refine' ⟨(x, 0), ⟨x, rfl⟩, (0, y), ⟨y, rfl⟩, _⟩
    simp
#align linear_map.is_compl_range_inl_inr LinearMap.isCompl_range_inl_inr

/- warning: linear_map.sup_range_inl_inr -> LinearMap.sup_range_inl_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))))) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.hasTop.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))))) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.instTopSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))
Case conversion may be inaccurate. Consider using '#align linear_map.sup_range_inl_inr LinearMap.sup_range_inl_inrₓ'. -/
theorem sup_range_inl_inr : (inl R M M₂).range ⊔ (inr R M M₂).range = ⊤ :=
  IsCompl.sup_eq_top isCompl_range_inl_inr
#align linear_map.sup_range_inl_inr LinearMap.sup_range_inl_inr

/- warning: linear_map.disjoint_inl_inr -> LinearMap.disjoint_inl_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Disjoint.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))) (Submodule.orderBot.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Disjoint.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.range.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7))
Case conversion may be inaccurate. Consider using '#align linear_map.disjoint_inl_inr LinearMap.disjoint_inl_inrₓ'. -/
theorem disjoint_inl_inr : Disjoint (inl R M M₂).range (inr R M M₂).range := by
  simp (config := { contextual := true }) [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0] <;> intros <;>
    rfl
#align linear_map.disjoint_inl_inr LinearMap.disjoint_inl_inr

/- warning: linear_map.map_coprod_prod -> LinearMap.map_coprod_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.map.{u1, u1, max u2 u3, u4, max (max u2 u3) u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q)) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8))))) (Submodule.map.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f p) (Submodule.map.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g q))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{succ u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.map.{u1, u1, max u2 u3, u4, max (max u4 u3) u2} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q)) (HasSup.sup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (SemilatticeSup.toHasSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Lattice.toSemilatticeSup.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (ConditionallyCompleteLattice.toLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (CompleteLattice.toConditionallyCompleteLattice.{u4} (Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8) (Submodule.completeLattice.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8))))) (Submodule.map.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f p) (Submodule.map.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ _inst_3 _inst_4 _inst_7 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 _inst_3 _inst_4 _inst_7 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g q))
Case conversion may be inaccurate. Consider using '#align linear_map.map_coprod_prod LinearMap.map_coprod_prodₓ'. -/
theorem map_coprod_prod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (p : Submodule R M)
    (q : Submodule R M₂) : map (coprod f g) (p.Prod q) = map f p ⊔ map g q :=
  by
  refine' le_antisymm _ (sup_le (map_le_iff_le_comap.2 _) (map_le_iff_le_comap.2 _))
  · rw [SetLike.le_def]
    rintro _ ⟨x, ⟨h₁, h₂⟩, rfl⟩
    exact mem_sup.2 ⟨_, ⟨_, h₁, rfl⟩, _, ⟨_, h₂, rfl⟩, rfl⟩
  · exact fun x hx => ⟨(x, 0), by simp [hx]⟩
  · exact fun x hx => ⟨(0, x), by simp [hx]⟩
#align linear_map.map_coprod_prod LinearMap.map_coprod_prod

/- warning: linear_map.comap_prod_prod -> LinearMap.comap_prod_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (p : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7) (q : Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.comap.{u1, u1, u2, max u3 u4, max u2 u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) (Submodule.prod.{u1, u3, u4} R M₂ _inst_1 _inst_3 _inst_7 p M₃ _inst_4 _inst_8 q)) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.comap.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f p) (Submodule.comap.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g q))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (p : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7) (q : Submodule.{u1, u4} R M₃ _inst_1 _inst_4 _inst_8), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.comap.{u1, u1, u2, max u3 u4, max (max u4 u3) u2} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g) (Submodule.prod.{u1, u3, u4} R M₂ _inst_1 _inst_3 _inst_7 p M₃ _inst_4 _inst_8 q)) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.instHasInfSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.comap.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f p) (Submodule.comap.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g q))
Case conversion may be inaccurate. Consider using '#align linear_map.comap_prod_prod LinearMap.comap_prod_prodₓ'. -/
theorem comap_prod_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) (p : Submodule R M₂)
    (q : Submodule R M₃) : comap (prod f g) (p.Prod q) = comap f p ⊓ comap g q :=
  Submodule.ext fun x => Iff.rfl
#align linear_map.comap_prod_prod LinearMap.comap_prod_prod

/- warning: linear_map.prod_eq_inf_comap -> LinearMap.prod_eq_inf_comap is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q) (HasInf.inf.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.hasInf.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.comap.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) p) (Submodule.comap.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) q))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q) (HasInf.inf.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.instHasInfSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.comap.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_6 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) p) (Submodule.comap.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) q))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_eq_inf_comap LinearMap.prod_eq_inf_comapₓ'. -/
theorem prod_eq_inf_comap (p : Submodule R M) (q : Submodule R M₂) :
    p.Prod q = p.comap (LinearMap.fst R M M₂) ⊓ q.comap (LinearMap.snd R M M₂) :=
  Submodule.ext fun x => Iff.rfl
#align linear_map.prod_eq_inf_comap LinearMap.prod_eq_inf_comap

/- warning: linear_map.prod_eq_sup_map -> LinearMap.prod_eq_sup_map is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))))) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) p) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) q))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 p M₂ _inst_3 _inst_7 q) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)))))) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) p) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) q))
Case conversion may be inaccurate. Consider using '#align linear_map.prod_eq_sup_map LinearMap.prod_eq_sup_mapₓ'. -/
theorem prod_eq_sup_map (p : Submodule R M) (q : Submodule R M₂) :
    p.Prod q = p.map (LinearMap.inl R M M₂) ⊔ q.map (LinearMap.inr R M M₂) := by
  rw [← map_coprod_prod, coprod_inl_inr, map_id]
#align linear_map.prod_eq_sup_map LinearMap.prod_eq_sup_map

/- warning: linear_map.span_inl_union_inr -> LinearMap.span_inl_union_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {s : Set.{u2} M} {t : Set.{u3} M₂}, Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.span.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M₂)) (Set.hasUnion.{max u2 u3} (Prod.{u2, u3} M M₂)) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M₂) (coeFn.{max (succ u2) (succ (max u2 u3)), max (succ u2) (succ (max u2 u3))} (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (fun (_x : LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) => M -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) s) (Set.image.{u3, max u2 u3} M₂ (Prod.{u2, u3} M M₂) (coeFn.{max (succ u3) (succ (max u2 u3)), max (succ u3) (succ (max u2 u3))} (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (fun (_x : LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) => M₂ -> (Prod.{u2, u3} M M₂)) (LinearMap.hasCoeToFun.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) t))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_6 s) M₂ _inst_3 _inst_7 (Submodule.span.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7 t))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {s : Set.{u2} M} {t : Set.{u3} M₂}, Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) (Submodule.span.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (Union.union.{max u2 u3} (Set.{max u2 u3} (Prod.{u2, u3} M M₂)) (Set.instUnionSet.{max u2 u3} (Prod.{u2, u3} M M₂)) (Set.image.{u2, max u2 u3} M (Prod.{u2, u3} M M₂) (FunLike.coe.{max (succ u2) (succ u3), succ u2, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_6 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) s) (Set.image.{u3, max u2 u3} M₂ (Prod.{u2, u3} M M₂) (FunLike.coe.{max (succ u2) (succ u3), succ u3, max (succ u2) (succ u3)} (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M₂) => Prod.{u2, u3} M M₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_7 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_6 _inst_7)) t))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 (Submodule.span.{u1, u2} R M _inst_1 _inst_2 _inst_6 s) M₂ _inst_3 _inst_7 (Submodule.span.{u1, u3} R M₂ _inst_1 _inst_3 _inst_7 t))
Case conversion may be inaccurate. Consider using '#align linear_map.span_inl_union_inr LinearMap.span_inl_union_inrₓ'. -/
theorem span_inl_union_inr {s : Set M} {t : Set M₂} :
    span R (inl R M M₂ '' s ∪ inr R M M₂ '' t) = (span R s).Prod (span R t) := by
  rw [span_union, prod_eq_sup_map, ← span_image, ← span_image]
#align linear_map.span_inl_union_inr LinearMap.span_inl_union_inr

/- warning: linear_map.ker_prod -> LinearMap.ker_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (LinearMap.ker.{u1, u1, u2, max u3 u4, max u2 u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.hasInf.{u1, u2} R M _inst_1 _inst_2 _inst_6) (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (LinearMap.ker.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (LinearMap.ker.{u1, u1, u2, max u3 u4, max (max u4 u3) u2} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (HasInf.inf.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (Submodule.instHasInfSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_6) (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) (LinearMap.ker.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_prod LinearMap.ker_prodₓ'. -/
@[simp]
theorem ker_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : ker (prod f g) = ker f ⊓ ker g := by
  rw [ker, ← prod_bot, comap_prod_prod] <;> rfl
#align linear_map.ker_prod LinearMap.ker_prod

/- warning: linear_map.range_prod_le -> LinearMap.range_prod_le is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8), LE.le.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (Preorder.toLE.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (PartialOrder.toPreorder.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (SetLike.partialOrder.{max u3 u4, max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (Prod.{u3, u4} M₂ M₃) (Submodule.setLike.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8))))) (LinearMap.range.{u1, u1, u2, max u3 u4, max u2 u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (Submodule.prod.{u1, u3, u4} R M₂ _inst_1 _inst_3 _inst_7 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) f) M₃ _inst_4 _inst_8 (LinearMap.range.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) g))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_7 : Module.{u1, u3} R M₂ _inst_1 _inst_3] [_inst_8 : Module.{u1, u4} R M₃ _inst_1 _inst_4] (f : LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (g : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8), LE.le.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (Preorder.toLE.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (PartialOrder.toPreorder.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (OmegaCompletePartialOrder.toPartialOrder.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (CompleteLattice.instOmegaCompletePartialOrder.{max u3 u4} (Submodule.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (Submodule.completeLattice.{u1, max u3 u4} R (Prod.{u3, u4} M₂ M₃) _inst_1 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)))))) (LinearMap.range.{u1, u1, u2, max u3 u4, max (max u4 u3) u2} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u4 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u3, u4} M₂ M₃) _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u3 u4} R R M (Prod.{u3, u4} M₂ M₃) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u3, u4} M₂ M₃ _inst_3 _inst_4) _inst_6 (Prod.module.{u1, u3, u4} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_7 _inst_8) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.prod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_6 _inst_7 _inst_8 f g)) (Submodule.prod.{u1, u3, u4} R M₂ _inst_1 _inst_3 _inst_7 (LinearMap.range.{u1, u1, u2, u3, max u2 u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 _inst_6 _inst_7) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 _inst_6 _inst_7 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) f) M₃ _inst_4 _inst_8 (LinearMap.range.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 _inst_4 _inst_6 _inst_8) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 _inst_4 _inst_6 _inst_8 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) g))
Case conversion may be inaccurate. Consider using '#align linear_map.range_prod_le LinearMap.range_prod_leₓ'. -/
theorem range_prod_le (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) :
    range (prod f g) ≤ (range f).Prod (range g) :=
  by
  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp]
  rintro _ x rfl
  exact ⟨⟨x, rfl⟩, ⟨x, rfl⟩⟩
#align linear_map.range_prod_le LinearMap.range_prod_le

/- warning: linear_map.ker_prod_ker_le_ker_coprod -> LinearMap.ker_prod_ker_le_ker_coprod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] {M₂ : Type.{u3}} [_inst_10 : AddCommGroup.{u3} M₂] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)] {M₃ : Type.{u4}} [_inst_12 : AddCommGroup.{u4} M₃] [_inst_13 : Module.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12)] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13), LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 (LinearMap.ker.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) M₂ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_11 (LinearMap.ker.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g)) (LinearMap.ker.{u1, u1, max u2 u3, u4, max (max u2 u3) u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_11 _inst_13 f g))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_6 : Module.{u3, u4} R M _inst_1 _inst_2] {M₂ : Type.{u2}} [_inst_10 : AddCommGroup.{u2} M₂] [_inst_11 : Module.{u3, u2} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)] {M₃ : Type.{u1}} [_inst_12 : AddCommGroup.{u1} M₃] [_inst_13 : Module.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12)] (f : LinearMap.{u3, u3, u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13) (g : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13), LE.le.{max u4 u2} (Submodule.{u3, max u2 u4} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (Preorder.toLE.{max u4 u2} (Submodule.{u3, max u2 u4} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (PartialOrder.toPreorder.{max u4 u2} (Submodule.{u3, max u2 u4} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (OmegaCompletePartialOrder.toPartialOrder.{max u4 u2} (Submodule.{u3, max u2 u4} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (CompleteLattice.instOmegaCompletePartialOrder.{max u4 u2} (Submodule.{u3, max u2 u4} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (Submodule.completeLattice.{u3, max u4 u2} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)))))) (Submodule.prod.{u3, u4, u2} R M _inst_1 _inst_2 _inst_6 (LinearMap.ker.{u3, u3, u4, u1, max u4 u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u4, u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_11 (LinearMap.ker.{u3, u3, u2, u1, max u2 u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) g)) (LinearMap.ker.{u3, u3, max u4 u2, u1, max (max u4 u1) u2} R R (Prod.{u4, u2} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Prod.{u4, u2} M M₂) M₃ (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u4 u2, u1} R R (Prod.{u4, u2} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.coprod.{u3, u4, u2, u1} R M M₂ M₃ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_11 _inst_13 f g))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_prod_ker_le_ker_coprod LinearMap.ker_prod_ker_le_ker_coprodₓ'. -/
theorem ker_prod_ker_le_ker_coprod {M₂ : Type _} [AddCommGroup M₂] [Module R M₂] {M₃ : Type _}
    [AddCommGroup M₃] [Module R M₃] (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) :
    (ker f).Prod (ker g) ≤ ker (f.coprod g) :=
  by
  rintro ⟨y, z⟩
  simp (config := { contextual := true })
#align linear_map.ker_prod_ker_le_ker_coprod LinearMap.ker_prod_ker_le_ker_coprod

/- warning: linear_map.ker_coprod_of_disjoint_range -> LinearMap.ker_coprod_of_disjoint_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_6 : Module.{u1, u2} R M _inst_1 _inst_2] {M₂ : Type.{u3}} [_inst_10 : AddCommGroup.{u3} M₂] [_inst_11 : Module.{u1, u3} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)] {M₃ : Type.{u4}} [_inst_12 : AddCommGroup.{u4} M₃] [_inst_13 : Module.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12)] (f : LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13) (g : LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13), (Disjoint.{u4} (Submodule.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_13) (SetLike.partialOrder.{u4, u4} (Submodule.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_13) M₃ (Submodule.setLike.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_13)) (Submodule.orderBot.{u1, u4} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_13) (LinearMap.range.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) f) (LinearMap.range.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) g)) -> (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11)) (LinearMap.ker.{u1, u1, max u2 u3, u4, max (max u2 u3) u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₃ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u4} R R (Prod.{u2, u3} M M₂) M₃ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.coprod.{u1, u2, u3, u4} R M M₂ M₃ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_11 _inst_13 f g)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_6 (LinearMap.ker.{u1, u1, u2, u4, max u2 u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u2, u4} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f) M₂ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) _inst_11 (LinearMap.ker.{u1, u1, u3, u4, max u3 u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.semilinearMapClass.{u1, u1, u3, u4} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u3} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u4} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) g)))
but is expected to have type
  forall {R : Type.{u3}} {M : Type.{u4}} [_inst_1 : Semiring.{u3} R] [_inst_2 : AddCommMonoid.{u4} M] [_inst_6 : Module.{u3, u4} R M _inst_1 _inst_2] {M₂ : Type.{u2}} [_inst_10 : AddCommGroup.{u2} M₂] [_inst_11 : Module.{u3, u2} R M₂ _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)] {M₃ : Type.{u1}} [_inst_12 : AddCommGroup.{u1} M₃] [_inst_13 : Module.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12)] (f : LinearMap.{u3, u3, u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13) (g : LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13), (Disjoint.{u1} (Submodule.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_13) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_13) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_13) (Submodule.completeLattice.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_13))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderInstSetLikeSubmodule.{u3, u1} R M₃ _inst_1 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_13) (LinearMap.range.{u3, u3, u4, u1, max u4 u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u4, u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) f) (LinearMap.range.{u3, u3, u2, u1, max u2 u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (RingHomSurjective.ids.{u3} R _inst_1) g)) -> (Eq.{max (succ u4) (succ u2)} (Submodule.{u3, max u4 u2} R (Prod.{u4, u2} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11)) (LinearMap.ker.{u3, u3, max u4 u2, u1, max (max u4 u1) u2} R R (Prod.{u4, u2} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, max u2 u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (Prod.{u4, u2} M M₂) M₃ (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, max u4 u2, u1} R R (Prod.{u4, u2} M M₂) M₃ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u4, u2} M M₂ _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10)) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) (Prod.module.{u3, u4, u2} R M M₂ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_6 _inst_11) _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) (LinearMap.coprod.{u3, u4, u2, u1} R M M₂ M₃ _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_11 _inst_13 f g)) (Submodule.prod.{u3, u4, u2} R M _inst_1 _inst_2 _inst_6 (LinearMap.ker.{u3, u3, u4, u1, max u4 u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u4, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M M₃ _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u4, u1} R R M M₃ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_6 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) f) M₂ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) _inst_11 (LinearMap.ker.{u3, u3, u2, u1, max u2 u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) (LinearMap.{u3, u3, u2, u1} R R _inst_1 _inst_1 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1)) M₂ M₃ (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13) (LinearMap.instSemilinearMapClassLinearMap.{u3, u3, u2, u1} R R M₂ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u2} M₂ _inst_10) (AddCommGroup.toAddCommMonoid.{u1} M₃ _inst_12) _inst_11 _inst_13 (RingHom.id.{u3} R (Semiring.toNonAssocSemiring.{u3} R _inst_1))) g)))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_coprod_of_disjoint_range LinearMap.ker_coprod_of_disjoint_rangeₓ'. -/
theorem ker_coprod_of_disjoint_range {M₂ : Type _} [AddCommGroup M₂] [Module R M₂] {M₃ : Type _}
    [AddCommGroup M₃] [Module R M₃] (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃)
    (hd : Disjoint f.range g.range) : ker (f.coprod g) = (ker f).Prod (ker g) :=
  by
  apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)
  rintro ⟨y, z⟩ h
  simp only [mem_ker, mem_prod, coprod_apply] at h⊢
  have : f y ∈ f.range ⊓ g.range :=
    by
    simp only [true_and_iff, mem_range, mem_inf, exists_apply_eq_apply]
    use -z
    rwa [eq_comm, map_neg, ← sub_eq_zero, sub_neg_eq_add]
  rw [hd.eq_bot, mem_bot] at this
  rw [this] at h
  simpa [this] using h
#align linear_map.ker_coprod_of_disjoint_range LinearMap.ker_coprod_of_disjoint_range

end LinearMap

namespace Submodule

open LinearMap

variable [Semiring R]

variable [AddCommMonoid M] [AddCommMonoid M₂]

variable [Module R M] [Module R M₂]

/- warning: submodule.sup_eq_range -> Submodule.sup_eq_range is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) p q) (LinearMap.range.{u1, u1, u2, u2, u2} R R (Prod.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q)) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q)) M (Prod.addCommMonoid.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} R R (Prod.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q)) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u2} (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.coprod.{u1, u2, u2, u2} R (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) p) (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)) q) M _inst_1 (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.addCommMonoid.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) _inst_2 (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.module.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) _inst_4 (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (HasSup.sup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) p q) (LinearMap.range.{u1, u1, u2, u2, u2} R R (Prod.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q))) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q))) M (Prod.instAddCommMonoidSum.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, u2} R R (Prod.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q))) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u2} (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_2 (Prod.module.{u1, u2, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.coprod.{u1, u2, u2, u2} R (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x p)) (Subtype.{succ u2} M (fun (x : M) => Membership.mem.{u2, u2} M (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.instSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) x q)) M _inst_1 (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4 q) _inst_4 (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 _inst_4 p) (Submodule.subtype.{u1, u2} R M _inst_1 _inst_2 _inst_4 q)))
Case conversion may be inaccurate. Consider using '#align submodule.sup_eq_range Submodule.sup_eq_rangeₓ'. -/
theorem sup_eq_range (p q : Submodule R M) : p ⊔ q = (p.Subtype.coprod q.Subtype).range :=
  Submodule.ext fun x => by simp [Submodule.mem_sup, SetLike.exists]
#align submodule.sup_eq_range Submodule.sup_eq_range

variable (p : Submodule R M) (q : Submodule R M₂)

/- warning: submodule.map_inl -> Submodule.map_inl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasBot.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)))
Case conversion may be inaccurate. Consider using '#align submodule.map_inl Submodule.map_inlₓ'. -/
@[simp]
theorem map_inl : p.map (inl R M M₂) = prod p ⊥ :=
  by
  ext ⟨x, y⟩
  simp only [and_left_comm, eq_comm, mem_map, Prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left',
    mem_prod]
#align submodule.map_inl Submodule.map_inl

/- warning: submodule.map_inr -> Submodule.map_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_4)) M₂ _inst_3 _inst_5 q)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) M₂ _inst_3 _inst_5 q)
Case conversion may be inaccurate. Consider using '#align submodule.map_inr Submodule.map_inrₓ'. -/
@[simp]
theorem map_inr : q.map (inr R M M₂) = prod ⊥ q := by ext ⟨x, y⟩ <;> simp [and_left_comm, eq_comm]
#align submodule.map_inr Submodule.map_inr

/- warning: submodule.comap_fst -> Submodule.comap_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.comap.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasTop.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.comap.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)))
Case conversion may be inaccurate. Consider using '#align submodule.comap_fst Submodule.comap_fstₓ'. -/
@[simp]
theorem comap_fst : p.comap (fst R M M₂) = prod p ⊤ := by ext ⟨x, y⟩ <;> simp
#align submodule.comap_fst Submodule.comap_fst

/- warning: submodule.comap_snd -> Submodule.comap_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.comap.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_4)) M₂ _inst_3 _inst_5 q)
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.comap.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4)) M₂ _inst_3 _inst_5 q)
Case conversion may be inaccurate. Consider using '#align submodule.comap_snd Submodule.comap_sndₓ'. -/
@[simp]
theorem comap_snd : q.comap (snd R M M₂) = prod ⊤ q := by ext ⟨x, y⟩ <;> simp
#align submodule.comap_snd Submodule.comap_snd

/- warning: submodule.prod_comap_inl -> Submodule.prod_comap_inl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.comap.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) p
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.comap.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) p
Case conversion may be inaccurate. Consider using '#align submodule.prod_comap_inl Submodule.prod_comap_inlₓ'. -/
@[simp]
theorem prod_comap_inl : (prod p q).comap (inl R M M₂) = p := by ext <;> simp
#align submodule.prod_comap_inl Submodule.prod_comap_inl

/- warning: submodule.prod_comap_inr -> Submodule.prod_comap_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.comap.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) q
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.comap.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) q
Case conversion may be inaccurate. Consider using '#align submodule.prod_comap_inr Submodule.prod_comap_inrₓ'. -/
@[simp]
theorem prod_comap_inr : (prod p q).comap (inr R M M₂) = q := by ext <;> simp
#align submodule.prod_comap_inr Submodule.prod_comap_inr

/- warning: submodule.prod_map_fst -> Submodule.prod_map_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) p
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) p
Case conversion may be inaccurate. Consider using '#align submodule.prod_map_fst Submodule.prod_map_fstₓ'. -/
@[simp]
theorem prod_map_fst : (prod p q).map (fst R M M₂) = p := by
  ext x <;> simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ q)]
#align submodule.prod_map_fst Submodule.prod_map_fst

/- warning: submodule.prod_map_snd -> Submodule.prod_map_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) q
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] (p : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (q : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5), Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p M₂ _inst_3 _inst_5 q)) q
Case conversion may be inaccurate. Consider using '#align submodule.prod_map_snd Submodule.prod_map_sndₓ'. -/
@[simp]
theorem prod_map_snd : (prod p q).map (snd R M M₂) = q := by
  ext x <;> simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ p)]
#align submodule.prod_map_snd Submodule.prod_map_snd

/- warning: submodule.ker_inl -> Submodule.ker_inl is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.ker.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.ker.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.ker_inl Submodule.ker_inlₓ'. -/
@[simp]
theorem ker_inl : (inl R M M₂).ker = ⊥ := by rw [ker, ← prod_bot, prod_comap_inl]
#align submodule.ker_inl Submodule.ker_inl

/- warning: submodule.ker_inr -> Submodule.ker_inr is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (LinearMap.ker.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasBot.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (LinearMap.ker.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.ker_inr Submodule.ker_inrₓ'. -/
@[simp]
theorem ker_inr : (inr R M M₂).ker = ⊥ := by rw [ker, ← prod_bot, prod_comap_inr]
#align submodule.ker_inr Submodule.ker_inr

/- warning: submodule.range_fst -> Submodule.range_fst is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.range.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_4))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (LinearMap.range.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.range_fst Submodule.range_fstₓ'. -/
@[simp]
theorem range_fst : (fst R M M₂).range = ⊤ := by rw [range_eq_map, ← prod_top, prod_map_fst]
#align submodule.range_fst Submodule.range_fst

/- warning: submodule.range_snd -> Submodule.range_snd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (LinearMap.range.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasTop.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (LinearMap.range.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.range_snd Submodule.range_sndₓ'. -/
@[simp]
theorem range_snd : (snd R M M₂).range = ⊤ := by rw [range_eq_map, ← prod_top, prod_map_snd]
#align submodule.range_snd Submodule.range_snd

variable (R M M₂)

/- warning: submodule.fst -> Submodule.fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align submodule.fst Submodule.fstₓ'. -/
/-- `M` as a submodule of `M × N`. -/
def fst : Submodule R (M × M₂) :=
  (⊥ : Submodule R M₂).comap (LinearMap.snd R M M₂)
#align submodule.fst Submodule.fst

/- warning: submodule.fst_equiv -> Submodule.fstEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], LinearEquiv.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) M (Submodule.addCommMonoid.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_2 (Submodule.module.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_4
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], LinearEquiv.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Subtype.{succ (max u2 u3)} (Prod.{u2, u3} M M₂) (fun (x : Prod.{u2, u3} M M₂) => Membership.mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} M M₂) (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.instSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) x (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) M (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_2 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_4
Case conversion may be inaccurate. Consider using '#align submodule.fst_equiv Submodule.fstEquivₓ'. -/
/-- `M` as a submodule of `M × N` is isomorphic to `M`. -/
@[simps]
def fstEquiv : Submodule.fst R M M₂ ≃ₗ[R] M
    where
  toFun x := x.1.1
  invFun m := ⟨⟨m, 0⟩, by tidy⟩
  map_add' := by simp
  map_smul' := by simp
  left_inv := by tidy
  right_inv := by tidy
#align submodule.fst_equiv Submodule.fstEquiv

/- warning: submodule.fst_map_fst -> Submodule.fst_map_fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_4))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.fst_map_fst Submodule.fst_map_fstₓ'. -/
theorem fst_map_fst : (Submodule.fst R M M₂).map (LinearMap.fst R M M₂) = ⊤ := by tidy
#align submodule.fst_map_fst Submodule.fst_map_fst

/- warning: submodule.fst_map_snd -> Submodule.fst_map_snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasBot.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.fst_map_snd Submodule.fst_map_sndₓ'. -/
theorem fst_map_snd : (Submodule.fst R M M₂).map (LinearMap.snd R M M₂) = ⊥ :=
  by
  tidy
  exact 0
#align submodule.fst_map_snd Submodule.fst_map_snd

/- warning: submodule.snd -> Submodule.snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align submodule.snd Submodule.sndₓ'. -/
/-- `N` as a submodule of `M × N`. -/
def snd : Submodule R (M × M₂) :=
  (⊥ : Submodule R M).comap (LinearMap.fst R M M₂)
#align submodule.snd Submodule.snd

/- warning: submodule.snd_equiv -> Submodule.sndEquiv is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], LinearEquiv.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (coeSort.{succ (max u2 u3), succ (succ (max u2 u3))} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) Type.{max u2 u3} (SetLike.hasCoeToSort.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) M₂ (Submodule.addCommMonoid.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_3 (Submodule.module.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_5
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], LinearEquiv.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Subtype.{succ (max u2 u3)} (Prod.{u2, u3} M M₂) (fun (x : Prod.{u2, u3} M M₂) => Membership.mem.{max u2 u3, max u2 u3} (Prod.{u2, u3} M M₂) (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.instMembership.{max u2 u3, max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.instSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) x (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))) M₂ (Submodule.instAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_3 (Submodule.instModuleSubtypeMemSubmoduleInstMembershipInstSetLikeSubmoduleInstAddCommMonoidSubtypeMemSubmoduleInstMembershipInstSetLikeSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) _inst_5
Case conversion may be inaccurate. Consider using '#align submodule.snd_equiv Submodule.sndEquivₓ'. -/
/-- `N` as a submodule of `M × N` is isomorphic to `N`. -/
@[simps]
def sndEquiv : Submodule.snd R M M₂ ≃ₗ[R] M₂
    where
  toFun x := x.1.2
  invFun n := ⟨⟨0, n⟩, by tidy⟩
  map_add' := by simp
  map_smul' := by simp
  left_inv := by tidy
  right_inv := by tidy
#align submodule.snd_equiv Submodule.sndEquiv

/- warning: submodule.snd_map_fst -> Submodule.snd_map_fst is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_4))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))
Case conversion may be inaccurate. Consider using '#align submodule.snd_map_fst Submodule.snd_map_fstₓ'. -/
theorem snd_map_fst : (Submodule.snd R M M₂).map (LinearMap.fst R M M₂) = ⊥ :=
  by
  tidy
  exact 0
#align submodule.snd_map_fst Submodule.snd_map_fst

/- warning: submodule.snd_map_snd -> Submodule.snd_map_snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasTop.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))
Case conversion may be inaccurate. Consider using '#align submodule.snd_map_snd Submodule.snd_map_sndₓ'. -/
theorem snd_map_snd : (Submodule.snd R M M₂).map (LinearMap.snd R M M₂) = ⊤ := by tidy
#align submodule.snd_map_snd Submodule.snd_map_snd

/- warning: submodule.fst_sup_snd -> Submodule.fst_sup_snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.hasTop.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (HasSup.sup.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SemilatticeSup.toHasSup.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Lattice.toSemilatticeSup.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (ConditionallyCompleteLattice.toLattice.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.toConditionallyCompleteLattice.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Top.top.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.instTopSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))
Case conversion may be inaccurate. Consider using '#align submodule.fst_sup_snd Submodule.fst_sup_sndₓ'. -/
theorem fst_sup_snd : Submodule.fst R M M₂ ⊔ Submodule.snd R M M₂ = ⊤ :=
  by
  rw [eq_top_iff]
  rintro ⟨m, n⟩ -
  rw [show (m, n) = (m, 0) + (0, n) by simp]
  apply Submodule.add_mem (Submodule.fst R M M₂ ⊔ Submodule.snd R M M₂)
  · exact Submodule.mem_sup_left (submodule.mem_comap.mpr (by simp))
  · exact Submodule.mem_sup_right (submodule.mem_comap.mpr (by simp))
#align submodule.fst_sup_snd Submodule.fst_sup_snd

/- warning: submodule.fst_inf_snd -> Submodule.fst_inf_snd is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (HasInf.inf.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.hasInf.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.hasBot.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3], Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (HasInf.inf.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.instHasInfSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Submodule.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Bot.bot.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.instBotSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))
Case conversion may be inaccurate. Consider using '#align submodule.fst_inf_snd Submodule.fst_inf_sndₓ'. -/
theorem fst_inf_snd : Submodule.fst R M M₂ ⊓ Submodule.snd R M M₂ = ⊥ := by tidy
#align submodule.fst_inf_snd Submodule.fst_inf_snd

/- warning: submodule.le_prod_iff -> Submodule.le_prod_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5} {q : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)}, Iff (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))))) q (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂)) (And (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (SetLike.partialOrder.{u2, u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) M (Submodule.setLike.{u1, u2} R M _inst_1 _inst_2 _inst_4)))) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) p₁) (LE.le.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (SetLike.partialOrder.{u3, u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) M₂ (Submodule.setLike.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5)))) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u2 u3, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.semilinearMapClass.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) p₂))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5} {q : Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)}, Iff (LE.le.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) q (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂)) (And (LE.le.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Preorder.toLE.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.completeLattice.{u1, u2} R M _inst_1 _inst_2 _inst_4))))) (Submodule.map.{u1, u1, max u2 u3, u2, max u2 u3} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u2} R R (Prod.{u2, u3} M M₂) M _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_2 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_4 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.fst.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) p₁) (LE.le.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Preorder.toLE.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.completeLattice.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))))) (Submodule.map.{u1, u1, max u2 u3, u3, max u2 u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, max u3 u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u3} M M₂) M₂ (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, max u2 u3, u3} R R (Prod.{u2, u3} M M₂) M₂ _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_3 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) _inst_5 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.snd.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) q) p₂))
Case conversion may be inaccurate. Consider using '#align submodule.le_prod_iff Submodule.le_prod_iffₓ'. -/
theorem le_prod_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} {q : Submodule R (M × M₂)} :
    q ≤ p₁.Prod p₂ ↔ map (LinearMap.fst R M M₂) q ≤ p₁ ∧ map (LinearMap.snd R M M₂) q ≤ p₂ :=
  by
  constructor
  · intro h
    constructor
    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩
      exact (h hy1).1
    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩
      exact (h hy1).2
  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h
    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩
#align submodule.le_prod_iff Submodule.le_prod_iff

/- warning: submodule.prod_le_iff -> Submodule.prod_le_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5} {q : Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)}, Iff (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) q) (And (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))))) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p₁) q) (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (SetLike.partialOrder.{max u2 u3, max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Prod.{u2, u3} M M₂) (Submodule.setLike.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5))))) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.semilinearMapClass.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p₂) q))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5} {q : Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)}, Iff (LE.le.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) q) (And (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) (Submodule.map.{u1, u1, u2, max u2 u3, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u2, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M (Prod.{u2, u3} M M₂) _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u2, max u2 u3} R R M (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_2 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_4 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inl.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p₁) q) (LE.le.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Preorder.toLE.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (PartialOrder.toPreorder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (OmegaCompletePartialOrder.toPartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (CompleteLattice.instOmegaCompletePartialOrder.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.completeLattice.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))))) (Submodule.map.{u1, u1, u3, max u2 u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomSurjective.ids.{u1} R _inst_1) (LinearMap.{u1, u1, u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₂ (Prod.{u2, u3} M M₂) _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (LinearMap.instSemilinearMapClassLinearMap.{u1, u1, u3, max u2 u3} R R M₂ (Prod.{u2, u3} M M₂) _inst_1 _inst_1 _inst_3 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) _inst_5 (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) (LinearMap.inr.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) p₂) q))
Case conversion may be inaccurate. Consider using '#align submodule.prod_le_iff Submodule.prod_le_iffₓ'. -/
theorem prod_le_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} {q : Submodule R (M × M₂)} :
    p₁.Prod p₂ ≤ q ↔ map (LinearMap.inl R M M₂) p₁ ≤ q ∧ map (LinearMap.inr R M M₂) p₂ ≤ q :=
  by
  constructor
  · intro h
    constructor
    · rintro _ ⟨x, hx, rfl⟩
      apply h
      exact ⟨hx, zero_mem p₂⟩
    · rintro _ ⟨x, hx, rfl⟩
      apply h
      exact ⟨zero_mem p₁, hx⟩
  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ ⟨h1, h2⟩
    have h1' : (LinearMap.inl R _ _) x1 ∈ q := by
      apply hH
      simpa using h1
    have h2' : (LinearMap.inr R _ _) x2 ∈ q := by
      apply hK
      simpa using h2
    simpa using add_mem h1' h2'
#align submodule.prod_le_iff Submodule.prod_le_iff

/- warning: submodule.prod_eq_bot_iff -> Submodule.prod_eq_bot_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5}, Iff (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) (Bot.bot.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.hasBot.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) (And (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) p₁ (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasBot.{u1, u2} R M _inst_1 _inst_2 _inst_4))) (Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) p₂ (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasBot.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5}, Iff (Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) (Bot.bot.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.instBotSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) (And (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) p₁ (Bot.bot.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instBotSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))) (Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) p₂ (Bot.bot.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instBotSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))))
Case conversion may be inaccurate. Consider using '#align submodule.prod_eq_bot_iff Submodule.prod_eq_bot_iffₓ'. -/
theorem prod_eq_bot_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} :
    p₁.Prod p₂ = ⊥ ↔ p₁ = ⊥ ∧ p₂ = ⊥ := by
  simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot, ker_inl, ker_inr]
#align submodule.prod_eq_bot_iff Submodule.prod_eq_bot_iff

/- warning: submodule.prod_eq_top_iff -> Submodule.prod_eq_top_iff is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5}, Iff (Eq.{succ (max u2 u3)} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) (Top.top.{max u2 u3} (Submodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.hasTop.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.addCommMonoid.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) (And (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) p₁ (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.hasTop.{u1, u2} R M _inst_1 _inst_2 _inst_4))) (Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) p₂ (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.hasTop.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))))
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (M₂ : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R M₂ _inst_1 _inst_3] {p₁ : Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4} {p₂ : Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5}, Iff (Eq.{max (succ u2) (succ u3)} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.prod.{u1, u2, u3} R M _inst_1 _inst_2 _inst_4 p₁ M₂ _inst_3 _inst_5 p₂) (Top.top.{max u2 u3} (Submodule.{u1, max u3 u2} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (Submodule.instTopSubmodule.{u1, max u2 u3} R (Prod.{u2, u3} M M₂) _inst_1 (Prod.instAddCommMonoidSum.{u2, u3} M M₂ _inst_2 _inst_3) (Prod.module.{u1, u2, u3} R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)))) (And (Eq.{succ u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) p₁ (Top.top.{u2} (Submodule.{u1, u2} R M _inst_1 _inst_2 _inst_4) (Submodule.instTopSubmodule.{u1, u2} R M _inst_1 _inst_2 _inst_4))) (Eq.{succ u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) p₂ (Top.top.{u3} (Submodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5) (Submodule.instTopSubmodule.{u1, u3} R M₂ _inst_1 _inst_3 _inst_5))))
Case conversion may be inaccurate. Consider using '#align submodule.prod_eq_top_iff Submodule.prod_eq_top_iffₓ'. -/
theorem prod_eq_top_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} :
    p₁.Prod p₂ = ⊤ ↔ p₁ = ⊤ ∧ p₂ = ⊤ := by
  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, map_top, range_fst, range_snd]
#align submodule.prod_eq_top_iff Submodule.prod_eq_top_iff

end Submodule

namespace LinearEquiv

/- warning: linear_equiv.prod_comm -> LinearEquiv.prodComm is a dubious translation:
lean 3 declaration is
  forall (R : Type.{u1}) (M : Type.{u2}) (N : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} N] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R N _inst_1 _inst_3], LinearEquiv.{u1, u1, max u2 u3, max u3 u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u3} M N) (Prod.{u3, u2} N M) (Prod.addCommMonoid.{u2, u3} M N _inst_2 _inst_3) (Prod.addCommMonoid.{u3, u2} N M _inst_3 _inst_2) (Prod.module.{u1, u2, u3} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Prod.module.{u1, u3, u2} R N M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4)
but is expected to have type
  forall (R : Type.{u1}) (M : Type.{u2}) (N : Type.{u3}) [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} N] [_inst_4 : Module.{u1, u2} R M _inst_1 _inst_2] [_inst_5 : Module.{u1, u3} R N _inst_1 _inst_3], LinearEquiv.{u1, u1, max u3 u2, max u2 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u3} M N) (Prod.{u3, u2} N M) (Prod.instAddCommMonoidSum.{u2, u3} M N _inst_2 _inst_3) (Prod.instAddCommMonoidSum.{u3, u2} N M _inst_3 _inst_2) (Prod.module.{u1, u2, u3} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (Prod.module.{u1, u3, u2} R N M _inst_1 _inst_3 _inst_2 _inst_5 _inst_4)
Case conversion may be inaccurate. Consider using '#align linear_equiv.prod_comm LinearEquiv.prodCommₓ'. -/
/-- Product of modules is commutative up to linear isomorphism. -/
@[simps apply]
def prodComm (R M N : Type _) [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M]
    [Module R N] : (M × N) ≃ₗ[R] N × M :=
  { AddEquiv.prodComm with
    toFun := Prod.swap
    map_smul' := fun r ⟨m, n⟩ => rfl }
#align linear_equiv.prod_comm LinearEquiv.prodComm

section

variable [Semiring R]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃] [AddCommMonoid M₄]

variable {module_M : Module R M} {module_M₂ : Module R M₂}

variable {module_M₃ : Module R M₃} {module_M₄ : Module R M₄}

variable (e₁ : M ≃ₗ[R] M₂) (e₂ : M₃ ≃ₗ[R] M₄)

/- warning: linear_equiv.prod -> LinearEquiv.prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5}, (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) -> (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) -> (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5}, (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) -> (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) -> (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄))
Case conversion may be inaccurate. Consider using '#align linear_equiv.prod LinearEquiv.prodₓ'. -/
/-- Product of linear equivalences; the maps come from `equiv.prod_congr`. -/
protected def prod : (M × M₃) ≃ₗ[R] M₂ × M₄ :=
  { e₁.toAddEquiv.prodCongr e₂.toAddEquiv with
    map_smul' := fun c x => Prod.ext (e₁.map_smulₛₗ c _) (e₂.map_smulₛₗ c _) }
#align linear_equiv.prod LinearEquiv.prod

/- warning: linear_equiv.prod_symm -> LinearEquiv.prod_symm is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄), Eq.{max (succ (max u3 u5)) (succ (max u2 u4))} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (LinearEquiv.symm.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂)) (LinearEquiv.prod.{u1, u3, u2, u5, u4} R M₂ M M₄ M₃ _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 module_M₂ module_M module_M₄ module_M₃ (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (LinearEquiv.symm.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₂))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄), Eq.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5)} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (LinearEquiv.symm.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂)) (LinearEquiv.prod.{u1, u3, u2, u5, u4} R M₂ M M₄ M₃ _inst_1 _inst_3 _inst_2 _inst_5 _inst_4 module_M₂ module_M module_M₄ module_M₃ (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (LinearEquiv.symm.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₂))
Case conversion may be inaccurate. Consider using '#align linear_equiv.prod_symm LinearEquiv.prod_symmₓ'. -/
theorem prod_symm : (e₁.Prod e₂).symm = e₁.symm.Prod e₂.symm :=
  rfl
#align linear_equiv.prod_symm LinearEquiv.prod_symm

/- warning: linear_equiv.prod_apply -> LinearEquiv.prod_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (p : Prod.{u2, u4} M M₃), Eq.{max (succ u3) (succ u5)} (Prod.{u3, u5} M₂ M₄) (coeFn.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (fun (_x : LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) => (Prod.{u2, u4} M M₃) -> (Prod.{u3, u5} M₂ M₄)) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂) p) (Prod.mk.{u3, u5} M₂ M₄ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (fun (_x : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) e₁ (Prod.fst.{u2, u4} M M₃ p)) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (fun (_x : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) => M₃ -> M₄) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) e₂ (Prod.snd.{u2, u4} M M₃ p)))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (p : Prod.{u2, u4} M M₃), Eq.{max (succ u3) (succ u5)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u2, u4} M M₃) => Prod.{u3, u5} M₂ M₄) p) (FunLike.coe.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5), max (succ u2) (succ u4), max (succ u3) (succ u5)} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (Prod.{u2, u4} M M₃) (fun (_x : Prod.{u2, u4} M M₃) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u2, u4} M M₃) => Prod.{u3, u5} M₂ M₄) _x) (SMulHomClass.toFunLike.{max (max (max u2 u3) u4) u5, u1, max u2 u4, max u3 u5} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (SMulZeroClass.toSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toZero.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribSMul.toSMulZeroClass.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toAddZeroClass.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribMulAction.toDistribSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃))))) (SMulZeroClass.toSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toZero.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5))) (DistribSMul.toSMulZeroClass.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toAddZeroClass.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5))) (DistribMulAction.toDistribSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5)) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u3) u4) u5, u1, max u2 u4, max u3 u5} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5)) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (SemilinearMapClass.distribMulActionHomClass.{u1, max u2 u4, max u3 u5, max (max (max u2 u3) u4) u5} R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u2 u4, max u3 u5, max (max (max u2 u3) u4) u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂) p) (Prod.mk.{u3, u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) (Prod.fst.{u2, u4} M M₃ p)) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ p)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) R M M₂ (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, max u2 u3} R M M₂ (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) _inst_1 _inst_2 _inst_3 module_M module_M₂ (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u3, max u2 u3} R R M M₂ (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) e₁ (Prod.fst.{u2, u4} M M₃ p)) (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) M₃ (fun (_x : M₃) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) _x) (SMulHomClass.toFunLike.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) R M₃ M₄ (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u4} R M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribMulAction.toDistribSMul.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃)))) (SMulZeroClass.toSMul.{u1, u5} R M₄ (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_5)) (DistribSMul.toSMulZeroClass.{u1, u5} R M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_5)) (DistribMulAction.toDistribSMul.{u1, u5} R M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_5) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 _inst_5 module_M₄)))) (DistribMulActionHomClass.toSMulHomClass.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) R M₃ M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (AddCommMonoid.toAddMonoid.{u5} M₄ _inst_5) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 _inst_5 module_M₄) (SemilinearMapClass.distribMulActionHomClass.{u1, u4, u5, max u4 u5} R M₃ M₄ (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) e₂ (Prod.snd.{u2, u4} M M₃ p)))
Case conversion may be inaccurate. Consider using '#align linear_equiv.prod_apply LinearEquiv.prod_applyₓ'. -/
@[simp]
theorem prod_apply (p) : e₁.Prod e₂ p = (e₁ p.1, e₂ p.2) :=
  rfl
#align linear_equiv.prod_apply LinearEquiv.prod_apply

/- warning: linear_equiv.coe_prod -> LinearEquiv.coe_prod is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄), Eq.{max (succ (max u2 u4)) (succ (max u3 u5))} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) ((fun (a : Sort.{max (succ (max u2 u4)) (succ (max u3 u5))}) (b : Sort.{max (succ (max u2 u4)) (succ (max u3 u5))}) [self : HasLiftT.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} a b] => self.0) (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (HasLiftT.mk.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (CoeTCₓ.coe.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (coeBase.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearEquiv.LinearMap.hasCoe.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂)) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 module_M module_M₃ module_M₂ module_M₄ ((fun (a : Sort.{max (succ u2) (succ u3)}) (b : Sort.{max (succ u2) (succ u3)}) [self : HasLiftT.{max (succ u2) (succ u3), max (succ u2) (succ u3)} a b] => self.0) (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 module_M module_M₂) (HasLiftT.mk.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 module_M module_M₂) (CoeTCₓ.coe.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 module_M module_M₂) (coeBase.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (LinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₂ _inst_2 _inst_3 module_M module_M₂) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) e₁) ((fun (a : Sort.{max (succ u4) (succ u5)}) (b : Sort.{max (succ u4) (succ u5)}) [self : HasLiftT.{max (succ u4) (succ u5), max (succ u4) (succ u5)} a b] => self.0) (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (HasLiftT.mk.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (CoeTCₓ.coe.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (coeBase.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (LinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 _inst_5 module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1))))) e₂))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommMonoid.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 _inst_5} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄), Eq.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5)} (LinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄)) (LinearEquiv.toLinearMap.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 _inst_5) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 _inst_5 module_M₂ module_M₄) (LinearEquiv.prod.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂)) (LinearMap.prodMap.{u1, u2, u4, u3, u5} R M M₃ M₂ M₄ _inst_1 _inst_2 _inst_4 _inst_3 _inst_5 module_M module_M₃ module_M₂ module_M₄ (LinearEquiv.toLinearMap.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂ e₁) (LinearEquiv.toLinearMap.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 _inst_5 module_M₃ module_M₄ e₂))
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_prod LinearEquiv.coe_prodₓ'. -/
@[simp, norm_cast]
theorem coe_prod :
    (e₁.Prod e₂ : M × M₃ →ₗ[R] M₂ × M₄) = (e₁ : M →ₗ[R] M₂).Prod_map (e₂ : M₃ →ₗ[R] M₄) :=
  rfl
#align linear_equiv.coe_prod LinearEquiv.coe_prod

end

section

variable [Semiring R]

variable [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃] [AddCommGroup M₄]

variable {module_M : Module R M} {module_M₂ : Module R M₂}

variable {module_M₃ : Module R M₃} {module_M₄ : Module R M₄}

variable (e₁ : M ≃ₗ[R] M₂) (e₂ : M₃ ≃ₗ[R] M₄)

/- warning: linear_equiv.skew_prod -> LinearEquiv.skewProd is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)}, (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) -> (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) -> (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) -> (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)}, (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) -> (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) -> (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) -> (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄))
Case conversion may be inaccurate. Consider using '#align linear_equiv.skew_prod LinearEquiv.skewProdₓ'. -/
/-- Equivalence given by a block lower diagonal matrix. `e₁` and `e₂` are diagonal square blocks,
  and `f` is a rectangular block below the diagonal. -/
protected def skewProd (f : M →ₗ[R] M₄) : (M × M₃) ≃ₗ[R] M₂ × M₄ :=
  {
    ((e₁ : M →ₗ[R] M₂).comp (LinearMap.fst R M M₃)).Prod
      ((e₂ : M₃ →ₗ[R] M₄).comp (LinearMap.snd R M M₃) +
        f.comp
          (LinearMap.fst R M
            M₃)) with
    invFun := fun p : M₂ × M₄ => (e₁.symm p.1, e₂.symm (p.2 - f (e₁.symm p.1)))
    left_inv := fun p => by simp
    right_inv := fun p => by simp }
#align linear_equiv.skew_prod LinearEquiv.skewProd

/- warning: linear_equiv.skew_prod_apply -> LinearEquiv.skewProd_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) (f : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (x : Prod.{u2, u4} M M₃), Eq.{max (succ u3) (succ u5)} (Prod.{u3, u5} M₂ M₄) (coeFn.{max (succ (max u2 u4)) (succ (max u3 u5)), max (succ (max u2 u4)) (succ (max u3 u5))} (LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) (fun (_x : LinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) => (Prod.{u2, u4} M M₃) -> (Prod.{u3, u5} M₂ M₄)) (LinearEquiv.hasCoeToFun.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.skewProd.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂ f) x) (Prod.mk.{u3, u5} M₂ M₄ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (fun (_x : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) => M -> M₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) e₁ (Prod.fst.{u2, u4} M M₃ x)) (HAdd.hAdd.{u5, u5, u5} M₄ M₄ M₄ (instHAdd.{u5} M₄ (AddZeroClass.toHasAdd.{u5} M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (SubNegMonoid.toAddMonoid.{u5} M₄ (AddGroup.toSubNegMonoid.{u5} M₄ (AddCommGroup.toAddGroup.{u5} M₄ _inst_5)))))) (coeFn.{max (succ u4) (succ u5), max (succ u4) (succ u5)} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) (fun (_x : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) => M₃ -> M₄) (LinearEquiv.hasCoeToFun.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) e₂ (Prod.snd.{u2, u4} M M₃ x)) (coeFn.{max (succ u2) (succ u5), max (succ u2) (succ u5)} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (fun (_x : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) => M -> M₄) (LinearMap.hasCoeToFun.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u4} M M₃ x))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) (f : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (x : Prod.{u2, u4} M M₃), Eq.{max (succ u3) (succ u5)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u2, u4} M M₃) => Prod.{u3, u5} M₂ M₄) x) (FunLike.coe.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5), max (succ u2) (succ u4), max (succ u3) (succ u5)} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) (Prod.{u2, u4} M M₃) (fun (_x : Prod.{u2, u4} M M₃) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u2, u4} M M₃) => Prod.{u3, u5} M₂ M₄) _x) (SMulHomClass.toFunLike.{max (max (max u2 u3) u4) u5, u1, max u2 u4, max u3 u5} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (SMulZeroClass.toSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toZero.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribSMul.toSMulZeroClass.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toAddZeroClass.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribMulAction.toDistribSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃))))) (SMulZeroClass.toSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toZero.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)))) (DistribSMul.toSMulZeroClass.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toAddZeroClass.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)))) (DistribMulAction.toDistribSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u3) u4) u5, u1, max u2 u4, max u3 u5} (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) (SemilinearMapClass.distribMulActionHomClass.{u1, max u2 u4, max u3 u5, max (max (max u2 u3) u4) u5} R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u2 u4, max u3 u5, max (max (max u2 u3) u4) u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (LinearEquiv.{u1, u1, max u4 u2, max u5 u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.skewProd.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂ f) x) (Prod.mk.{u3, u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) (Prod.fst.{u2, u4} M M₃ x)) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M) => M₂) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) R M M₂ (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) R M M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, max u2 u3} R M M₂ (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) _inst_1 _inst_2 _inst_3 module_M module_M₂ (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u3, max u2 u3} R R M M₂ (LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) e₁ (Prod.fst.{u2, u4} M M₃ x)) (HAdd.hAdd.{u5, u5, u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) (Prod.fst.{u2, u4} M M₃ x)) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (instHAdd.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (AddZeroClass.toAdd.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (AddMonoid.toAddZeroClass.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (SubNegMonoid.toAddMonoid.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (AddGroup.toSubNegMonoid.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) (AddCommGroup.toAddGroup.{u5} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) (Prod.snd.{u2, u4} M M₃ x)) _inst_5)))))) (FunLike.coe.{max (succ u4) (succ u5), succ u4, succ u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) M₃ (fun (_x : M₃) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₃) => M₄) _x) (SMulHomClass.toFunLike.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) R M₃ M₄ (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u4} R M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribMulAction.toDistribSMul.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃)))) (SMulZeroClass.toSMul.{u1, u5} R M₄ (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (DistribSMul.toSMulZeroClass.{u1, u5} R M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (DistribMulAction.toDistribSMul.{u1, u5} R M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₄)))) (DistribMulActionHomClass.toSMulHomClass.{max u4 u5, u1, u4, u5} (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) R M₃ M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₄) (SemilinearMapClass.distribMulActionHomClass.{u1, u4, u5, max u4 u5} R M₃ M₄ (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u4, u5, max u4 u5} R R M₃ M₄ (LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) _inst_1 _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) e₂ (Prod.snd.{u2, u4} M M₃ x)) (FunLike.coe.{max (succ u2) (succ u5), succ u2, succ u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (Prod.fst.{u2, u4} M M₃ x))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.skew_prod_apply LinearEquiv.skewProd_applyₓ'. -/
@[simp]
theorem skewProd_apply (f : M →ₗ[R] M₄) (x) : e₁.skewProd e₂ f x = (e₁ x.1, e₂ x.2 + f x.1) :=
  rfl
#align linear_equiv.skew_prod_apply LinearEquiv.skewProd_apply

/- warning: linear_equiv.skew_prod_symm_apply -> LinearEquiv.skewProd_symm_apply is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) (f : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (x : Prod.{u3, u5} M₂ M₄), Eq.{max (succ u2) (succ u4)} (Prod.{u2, u4} M M₃) (coeFn.{max (succ (max u3 u5)) (succ (max u2 u4)), max (succ (max u3 u5)) (succ (max u2 u4))} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (fun (_x : LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) => (Prod.{u3, u5} M₂ M₄) -> (Prod.{u2, u4} M M₃)) (LinearEquiv.hasCoeToFun.{u1, u1, max u3 u5, max u2 u4} R R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) _inst_1 _inst_1 (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.addCommMonoid.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.addCommMonoid.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.skewProd.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂ f)) x) (Prod.mk.{u2, u4} M M₃ (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) (fun (_x : LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x)) (coeFn.{max (succ u5) (succ u4), max (succ u5) (succ u4)} (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) (fun (_x : LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) => M₄ -> M₃) (LinearEquiv.hasCoeToFun.{u1, u1, u5, u4} R R M₄ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₂) (HSub.hSub.{u5, u5, u5} M₄ M₄ M₄ (instHSub.{u5} M₄ (SubNegMonoid.toHasSub.{u5} M₄ (AddGroup.toSubNegMonoid.{u5} M₄ (AddCommGroup.toAddGroup.{u5} M₄ _inst_5)))) (Prod.snd.{u3, u5} M₂ M₄ x) (coeFn.{max (succ u2) (succ u5), max (succ u2) (succ u5)} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (fun (_x : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) => M -> M₄) (LinearMap.hasCoeToFun.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) (fun (_x : LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) => M₂ -> M) (LinearEquiv.hasCoeToFun.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x))))))
but is expected to have type
  forall {R : Type.{u1}} {M : Type.{u2}} {M₂ : Type.{u3}} {M₃ : Type.{u4}} {M₄ : Type.{u5}} [_inst_1 : Semiring.{u1} R] [_inst_2 : AddCommMonoid.{u2} M] [_inst_3 : AddCommMonoid.{u3} M₂] [_inst_4 : AddCommMonoid.{u4} M₃] [_inst_5 : AddCommGroup.{u5} M₄] {module_M : Module.{u1, u2} R M _inst_1 _inst_2} {module_M₂ : Module.{u1, u3} R M₂ _inst_1 _inst_3} {module_M₃ : Module.{u1, u4} R M₃ _inst_1 _inst_4} {module_M₄ : Module.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)} (e₁ : LinearEquiv.{u1, u1, u2, u3} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M M₂ _inst_2 _inst_3 module_M module_M₂) (e₂ : LinearEquiv.{u1, u1, u4, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₃ M₄ _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄) (f : LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) (x : Prod.{u3, u5} M₂ M₄), Eq.{max (succ u2) (succ u4)} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u3, u5} M₂ M₄) => Prod.{u2, u4} M M₃) x) (FunLike.coe.{max (max (max (succ u2) (succ u3)) (succ u4)) (succ u5), max (succ u3) (succ u5), max (succ u2) (succ u4)} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (Prod.{u3, u5} M₂ M₄) (fun (_x : Prod.{u3, u5} M₂ M₄) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Prod.{u3, u5} M₂ M₄) => Prod.{u2, u4} M M₃) _x) (SMulHomClass.toFunLike.{max (max (max u2 u3) u4) u5, u1, max u3 u5, max u2 u4} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (SMulZeroClass.toSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toZero.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)))) (DistribSMul.toSMulZeroClass.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (AddMonoid.toAddZeroClass.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)))) (DistribMulAction.toDistribSMul.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄))))) (SMulZeroClass.toSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toZero.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribSMul.toSMulZeroClass.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (AddMonoid.toAddZeroClass.{max u2 u4} (Prod.{u2, u4} M M₃) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4))) (DistribMulAction.toDistribSMul.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃))))) (DistribMulActionHomClass.toSMulHomClass.{max (max (max u2 u3) u4) u5, u1, max u3 u5, max u2 u4} (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{max u3 u5} (Prod.{u3, u5} M₂ M₄) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (AddCommMonoid.toAddMonoid.{max u2 u4} (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4)) (Module.toDistribMulAction.{u1, max u3 u5} R (Prod.{u3, u5} M₂ M₄) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄)) (Module.toDistribMulAction.{u1, max u2 u4} R (Prod.{u2, u4} M M₃) _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) (SemilinearMapClass.distribMulActionHomClass.{u1, max u3 u5, max u2 u4, max (max (max u2 u3) u4) u5} R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, max u3 u5, max u2 u4, max (max (max u2 u3) u4) u5} R R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (LinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃)) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, max u3 u5, max u2 u4} R R (Prod.{u3, u5} M₂ M₄) (Prod.{u2, u4} M M₃) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, max u2 u4, max u3 u5} R R (Prod.{u2, u4} M M₃) (Prod.{u3, u5} M₂ M₄) _inst_1 _inst_1 (Prod.instAddCommMonoidSum.{u2, u4} M M₃ _inst_2 _inst_4) (Prod.instAddCommMonoidSum.{u3, u5} M₂ M₄ _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Prod.module.{u1, u2, u4} R M M₃ _inst_1 _inst_2 _inst_4 module_M module_M₃) (Prod.module.{u1, u3, u5} R M₂ M₄ _inst_1 _inst_3 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₂ module_M₄) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.skewProd.{u1, u2, u3, u4, u5} R M M₂ M₃ M₄ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 module_M module_M₂ module_M₃ module_M₄ e₁ e₂ f)) x) (Prod.mk.{u2, u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) (Prod.fst.{u3, u5} M₂ M₄ x)) ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₄) => M₃) (HSub.hSub.{u5, u5, u5} M₄ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) M₂ (fun (a : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) a) (SMulHomClass.toFunLike.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (SemilinearMapClass.distribMulActionHomClass.{u1, u3, u2, max u2 u3} R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_3 _inst_2 module_M₂ module_M (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u3, u2, max u2 u3} R R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x))) M₄ (instHSub.{u5} M₄ (SubNegMonoid.toSub.{u5} M₄ (AddGroup.toSubNegMonoid.{u5} M₄ (AddCommGroup.toAddGroup.{u5} M₄ _inst_5)))) (Prod.snd.{u3, u5} M₂ M₄ x) (FunLike.coe.{max (succ u2) (succ u5), succ u2, succ u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) M (fun (a : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) a) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) M₂ (fun (a : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) a) (SMulHomClass.toFunLike.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (SemilinearMapClass.distribMulActionHomClass.{u1, u3, u2, max u2 u3} R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_3 _inst_2 module_M₂ module_M (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u3, u2, max u2 u3} R R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x))))) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (SemilinearMapClass.distribMulActionHomClass.{u1, u3, u2, max u2 u3} R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_3 _inst_2 module_M₂ module_M (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u3, u2, max u2 u3} R R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x)) (FunLike.coe.{max (succ u4) (succ u5), succ u5, succ u4} (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) M₄ (fun (_x : M₄) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₄) => M₃) _x) (SMulHomClass.toFunLike.{max u4 u5, u1, u5, u4} (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) R M₄ M₃ (SMulZeroClass.toSMul.{u1, u5} R M₄ (AddMonoid.toZero.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (DistribSMul.toSMulZeroClass.{u1, u5} R M₄ (AddMonoid.toAddZeroClass.{u5} M₄ (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5))) (DistribMulAction.toDistribSMul.{u1, u5} R M₄ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₄)))) (SMulZeroClass.toSMul.{u1, u4} R M₃ (AddMonoid.toZero.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribSMul.toSMulZeroClass.{u1, u4} R M₃ (AddMonoid.toAddZeroClass.{u4} M₃ (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4)) (DistribMulAction.toDistribSMul.{u1, u4} R M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃)))) (DistribMulActionHomClass.toSMulHomClass.{max u4 u5, u1, u5, u4} (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) R M₄ M₃ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u5} M₄ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5)) (AddCommMonoid.toAddMonoid.{u4} M₃ _inst_4) (Module.toDistribMulAction.{u1, u5} R M₄ _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₄) (Module.toDistribMulAction.{u1, u4} R M₃ _inst_1 _inst_4 module_M₃) (SemilinearMapClass.distribMulActionHomClass.{u1, u5, u4, max u4 u5} R M₄ M₃ (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃ (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u5, u4, max u4 u5} R R M₄ M₃ (LinearEquiv.{u1, u1, u5, u4} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₄ M₃ (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃) _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u5, u4} R R M₄ M₃ _inst_1 _inst_1 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) _inst_4 module_M₄ module_M₃ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u4, u5} R R M₃ M₄ _inst_1 _inst_1 _inst_4 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M₃ module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₂) (HSub.hSub.{u5, u5, u5} M₄ ((fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) M₂ (fun (a : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) a) (SMulHomClass.toFunLike.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (SemilinearMapClass.distribMulActionHomClass.{u1, u3, u2, max u2 u3} R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_3 _inst_2 module_M₂ module_M (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u3, u2, max u2 u3} R R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x))) M₄ (instHSub.{u5} M₄ (SubNegMonoid.toSub.{u5} M₄ (AddGroup.toSubNegMonoid.{u5} M₄ (AddCommGroup.toAddGroup.{u5} M₄ _inst_5)))) (Prod.snd.{u3, u5} M₂ M₄ x) (FunLike.coe.{max (succ u2) (succ u5), succ u2, succ u5} (LinearMap.{u1, u1, u2, u5} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) M M₄ _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄) M (fun (_x : M) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6178 : M) => M₄) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u5} R R M M₄ _inst_1 _inst_1 _inst_2 (AddCommGroup.toAddCommMonoid.{u5} M₄ _inst_5) module_M module_M₄ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1))) f (FunLike.coe.{max (succ u2) (succ u3), succ u3, succ u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) M₂ (fun (_x : M₂) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : M₂) => M) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (SMulZeroClass.toSMul.{u1, u3} R M₂ (AddMonoid.toZero.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribSMul.toSMulZeroClass.{u1, u3} R M₂ (AddMonoid.toAddZeroClass.{u3} M₂ (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3)) (DistribMulAction.toDistribSMul.{u1, u3} R M₂ (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂)))) (SMulZeroClass.toSMul.{u1, u2} R M (AddMonoid.toZero.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribSMul.toSMulZeroClass.{u1, u2} R M (AddMonoid.toAddZeroClass.{u2} M (AddCommMonoid.toAddMonoid.{u2} M _inst_2)) (DistribMulAction.toDistribSMul.{u1, u2} R M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u3, u2} (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) R M₂ M (MonoidWithZero.toMonoid.{u1} R (Semiring.toMonoidWithZero.{u1} R _inst_1)) (AddCommMonoid.toAddMonoid.{u3} M₂ _inst_3) (AddCommMonoid.toAddMonoid.{u2} M _inst_2) (Module.toDistribMulAction.{u1, u3} R M₂ _inst_1 _inst_3 module_M₂) (Module.toDistribMulAction.{u1, u2} R M _inst_1 _inst_2 module_M) (SemilinearMapClass.distribMulActionHomClass.{u1, u3, u2, max u2 u3} R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_3 _inst_2 module_M₂ module_M (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u3, u2, max u2 u3} R R M₂ M (LinearEquiv.{u1, u1, u3, u2} R R _inst_1 _inst_1 (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) M₂ M _inst_3 _inst_2 module_M₂ module_M) _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u3, u2} R R M₂ M _inst_1 _inst_1 _inst_3 _inst_2 module_M₂ module_M (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1)))))) (LinearEquiv.symm.{u1, u1, u2, u3} R R M M₂ _inst_1 _inst_1 _inst_2 _inst_3 module_M module_M₂ (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHom.id.{u1} R (Semiring.toNonAssocSemiring.{u1} R _inst_1)) (RingHomInvPair.ids.{u1} R _inst_1) (RingHomInvPair.ids.{u1} R _inst_1) e₁) (Prod.fst.{u3, u5} M₂ M₄ x))))))
Case conversion may be inaccurate. Consider using '#align linear_equiv.skew_prod_symm_apply LinearEquiv.skewProd_symm_applyₓ'. -/
@[simp]
theorem skewProd_symm_apply (f : M →ₗ[R] M₄) (x) :
    (e₁.skewProd e₂ f).symm x = (e₁.symm x.1, e₂.symm (x.2 - f (e₁.symm x.1))) :=
  rfl
#align linear_equiv.skew_prod_symm_apply LinearEquiv.skewProd_symm_apply

end

end LinearEquiv

namespace LinearMap

open Submodule

variable [Ring R]

variable [AddCommGroup M] [AddCommGroup M₂] [AddCommGroup M₃]

variable [Module R M] [Module R M₂] [Module R M₃]

#print LinearMap.range_prod_eq /-
/-- If the union of the kernels `ker f` and `ker g` spans the domain, then the range of
`prod f g` is equal to the product of `range f` and `range g`. -/
theorem range_prod_eq {f : M →ₗ[R] M₂} {g : M →ₗ[R] M₃} (h : ker f ⊔ ker g = ⊤) :
    range (prod f g) = (range f).Prod (range g) :=
  by
  refine' le_antisymm (f.range_prod_le g) _
  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp, and_imp,
    Prod.forall, Pi.prod]
  rintro _ _ x rfl y rfl
  simp only [Prod.mk.inj_iff, ← sub_mem_ker_iff]
  have : y - x ∈ ker f ⊔ ker g := by simp only [h, mem_top]
  rcases mem_sup.1 this with ⟨x', hx', y', hy', H⟩
  refine' ⟨x' + x, _, _⟩
  · simp only [mem_ker.mp hx', map_add, zero_add]
  · simp [← eq_sub_iff_add_eq.1 H, map_add, add_left_inj, self_eq_add_right, mem_ker.mp hy']
#align linear_map.range_prod_eq LinearMap.range_prod_eq
-/

end LinearMap

namespace LinearMap

/-!
## Tunnels and tailings

Some preliminary work for establishing the strong rank condition for noetherian rings.

Given a morphism `f : M × N →ₗ[R] M` which is `i : injective f`,
we can find an infinite decreasing `tunnel f i n` of copies of `M` inside `M`,
and sitting beside these, an infinite sequence of copies of `N`.

We picturesquely name these as `tailing f i n` for each individual copy of `N`,
and `tailings f i n` for the supremum of the first `n+1` copies:
they are the pieces left behind, sitting inside the tunnel.

By construction, each `tailing f i (n+1)` is disjoint from `tailings f i n`;
later, when we assume `M` is noetherian, this implies that `N` must be trivial,
and establishes the strong rank condition for any left-noetherian ring.
-/


section Tunnel

-- (This doesn't work over a semiring: we need to use that `submodule R M` is a modular lattice,
-- which requires cancellation.)
variable [Ring R]

variable {N : Type _} [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]

open Function

#print LinearMap.tunnelAux /-
/-- An auxiliary construction for `tunnel`.
The composition of `f`, followed by the isomorphism back to `K`,
followed by the inclusion of this submodule back into `M`. -/
def tunnelAux (f : M × N →ₗ[R] M) (Kφ : ΣK : Submodule R M, K ≃ₗ[R] M) : M × N →ₗ[R] M :=
  (Kφ.1.Subtype.comp Kφ.2.symm.toLinearMap).comp f
#align linear_map.tunnel_aux LinearMap.tunnelAux
-/

#print LinearMap.tunnelAux_injective /-
theorem tunnelAux_injective (f : M × N →ₗ[R] M) (i : Injective f)
    (Kφ : ΣK : Submodule R M, K ≃ₗ[R] M) : Injective (tunnelAux f Kφ) :=
  (Subtype.val_injective.comp Kφ.2.symm.Injective).comp i
#align linear_map.tunnel_aux_injective LinearMap.tunnelAux_injective
-/

noncomputable section

-- Even though we have `noncomputable theory`,
-- we get an error without another `noncomputable` here.
/-- Auxiliary definition for `tunnel`. -/
noncomputable def tunnel' (f : M × N →ₗ[R] M) (i : Injective f) : ℕ → ΣK : Submodule R M, K ≃ₗ[R] M
  | 0 => ⟨⊤, LinearEquiv.ofTop ⊤ rfl⟩
  | n + 1 =>
    ⟨(Submodule.fst R M N).map (tunnelAux f (tunnel' n)),
      ((Submodule.fst R M N).equivMapOfInjective _ (tunnelAux_injective f i (tunnel' n))).symm.trans
        (Submodule.fstEquiv R M N)⟩
#align linear_map.tunnel' LinearMap.tunnel'ₓ

#print LinearMap.tunnel /-
/-- Give an injective map `f : M × N →ₗ[R] M` we can find a nested sequence of submodules
all isomorphic to `M`.
-/
def tunnel (f : M × N →ₗ[R] M) (i : Injective f) : ℕ →o (Submodule R M)ᵒᵈ :=
  ⟨fun n => OrderDual.toDual (tunnel' f i n).1,
    monotone_nat_of_le_succ fun n => by
      dsimp [tunnel', tunnel_aux]
      rw [Submodule.map_comp, Submodule.map_comp]
      apply Submodule.map_subtype_le⟩
#align linear_map.tunnel LinearMap.tunnel
-/

#print LinearMap.tailing /-
/-- Give an injective map `f : M × N →ₗ[R] M` we can find a sequence of submodules
all isomorphic to `N`.
-/
def tailing (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) : Submodule R M :=
  (Submodule.snd R M N).map (tunnelAux f (tunnel' f i n))
#align linear_map.tailing LinearMap.tailing
-/

#print LinearMap.tailingLinearEquiv /-
/-- Each `tailing f i n` is a copy of `N`. -/
def tailingLinearEquiv (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) : tailing f i n ≃ₗ[R] N :=
  ((Submodule.snd R M N).equivMapOfInjective _ (tunnelAux_injective f i (tunnel' f i n))).symm.trans
    (Submodule.sndEquiv R M N)
#align linear_map.tailing_linear_equiv LinearMap.tailingLinearEquiv
-/

#print LinearMap.tailing_le_tunnel /-
theorem tailing_le_tunnel (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    tailing f i n ≤ (tunnel f i n).ofDual :=
  by
  dsimp [tailing, tunnel_aux]
  rw [Submodule.map_comp, Submodule.map_comp]
  apply Submodule.map_subtype_le
#align linear_map.tailing_le_tunnel LinearMap.tailing_le_tunnel
-/

#print LinearMap.tailing_disjoint_tunnel_succ /-
theorem tailing_disjoint_tunnel_succ (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    Disjoint (tailing f i n) (tunnel f i (n + 1)).ofDual :=
  by
  rw [disjoint_iff]
  dsimp [tailing, tunnel, tunnel']
  rw [Submodule.map_inf_eq_map_inf_comap,
    Submodule.comap_map_eq_of_injective (tunnel_aux_injective _ i _), inf_comm,
    Submodule.fst_inf_snd, Submodule.map_bot]
#align linear_map.tailing_disjoint_tunnel_succ LinearMap.tailing_disjoint_tunnel_succ
-/

#print LinearMap.tailing_sup_tunnel_succ_le_tunnel /-
theorem tailing_sup_tunnel_succ_le_tunnel (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    tailing f i n ⊔ (tunnel f i (n + 1)).ofDual ≤ (tunnel f i n).ofDual :=
  by
  dsimp [tailing, tunnel, tunnel', tunnel_aux]
  rw [← Submodule.map_sup, sup_comm, Submodule.fst_sup_snd, Submodule.map_comp, Submodule.map_comp]
  apply Submodule.map_subtype_le
#align linear_map.tailing_sup_tunnel_succ_le_tunnel LinearMap.tailing_sup_tunnel_succ_le_tunnel
-/

#print LinearMap.tailings /-
/-- The supremum of all the copies of `N` found inside the tunnel. -/
def tailings (f : M × N →ₗ[R] M) (i : Injective f) : ℕ → Submodule R M :=
  partialSups (tailing f i)
#align linear_map.tailings LinearMap.tailings
-/

#print LinearMap.tailings_zero /-
@[simp]
theorem tailings_zero (f : M × N →ₗ[R] M) (i : Injective f) : tailings f i 0 = tailing f i 0 := by
  simp [tailings]
#align linear_map.tailings_zero LinearMap.tailings_zero
-/

#print LinearMap.tailings_succ /-
@[simp]
theorem tailings_succ (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    tailings f i (n + 1) = tailings f i n ⊔ tailing f i (n + 1) := by simp [tailings]
#align linear_map.tailings_succ LinearMap.tailings_succ
-/

#print LinearMap.tailings_disjoint_tunnel /-
theorem tailings_disjoint_tunnel (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    Disjoint (tailings f i n) (tunnel f i (n + 1)).ofDual :=
  by
  induction' n with n ih
  · simp only [tailings_zero]
    apply tailing_disjoint_tunnel_succ
  · simp only [tailings_succ]
    refine' Disjoint.disjoint_sup_left_of_disjoint_sup_right _ _
    apply tailing_disjoint_tunnel_succ
    apply Disjoint.mono_right _ ih
    apply tailing_sup_tunnel_succ_le_tunnel
#align linear_map.tailings_disjoint_tunnel LinearMap.tailings_disjoint_tunnel
-/

#print LinearMap.tailings_disjoint_tailing /-
theorem tailings_disjoint_tailing (f : M × N →ₗ[R] M) (i : Injective f) (n : ℕ) :
    Disjoint (tailings f i n) (tailing f i (n + 1)) :=
  Disjoint.mono_right (tailing_le_tunnel f i _) (tailings_disjoint_tunnel f i _)
#align linear_map.tailings_disjoint_tailing LinearMap.tailings_disjoint_tailing
-/

end Tunnel

section Graph

variable [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [AddCommGroup M₃] [AddCommGroup M₄]
  [Module R M] [Module R M₂] [Module R M₃] [Module R M₄] (f : M →ₗ[R] M₂) (g : M₃ →ₗ[R] M₄)

#print LinearMap.graph /-
/-- Graph of a linear map. -/
def graph : Submodule R (M × M₂)
    where
  carrier := { p | p.2 = f p.1 }
  add_mem' a b (ha : _ = _) (hb : _ = _) :=
    by
    change _ + _ = f (_ + _)
    rw [map_add, ha, hb]
  zero_mem' := Eq.symm (map_zero f)
  smul_mem' c x (hx : _ = _) := by
    change _ • _ = f (_ • _)
    rw [map_smul, hx]
#align linear_map.graph LinearMap.graph
-/

#print LinearMap.mem_graph_iff /-
@[simp]
theorem mem_graph_iff (x : M × M₂) : x ∈ f.graph ↔ x.2 = f x.1 :=
  Iff.rfl
#align linear_map.mem_graph_iff LinearMap.mem_graph_iff
-/

#print LinearMap.graph_eq_ker_coprod /-
theorem graph_eq_ker_coprod : g.graph = ((-g).coprod LinearMap.id).ker :=
  by
  ext x
  change _ = _ ↔ -g x.1 + x.2 = _
  rw [add_comm, add_neg_eq_zero]
#align linear_map.graph_eq_ker_coprod LinearMap.graph_eq_ker_coprod
-/

#print LinearMap.graph_eq_range_prod /-
theorem graph_eq_range_prod : f.graph = (LinearMap.id.Prod f).range :=
  by
  ext x
  exact ⟨fun hx => ⟨x.1, Prod.ext rfl hx.symm⟩, fun ⟨u, hu⟩ => hu ▸ rfl⟩
#align linear_map.graph_eq_range_prod LinearMap.graph_eq_range_prod
-/

end Graph

end LinearMap

