/-
Copyright (c) 2019 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes

! This file was ported from Lean 3 source module linear_algebra.finite_dimensional
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Algebra.Subalgebra.Basic
import Mathbin.FieldTheory.Finiteness
import Mathbin.LinearAlgebra.FreeModule.Finite.Rank
import Mathbin.Tactic.IntervalCases

/-!
# Finite dimensional vector spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Definition and basic properties of finite dimensional vector spaces, of their dimensions, and
of linear maps on such spaces.

## Main definitions

Assume `V` is a vector space over a division ring `K`. There are (at least) three equivalent
definitions of finite-dimensionality of `V`:

- it admits a finite basis.
- it is finitely generated.
- it is noetherian, i.e., every subspace is finitely generated.

We introduce a typeclass `finite_dimensional K V` capturing this property. For ease of transfer of
proof, it is defined using the second point of view, i.e., as `finite`. However, we prove
that all these points of view are equivalent, with the following lemmas
(in the namespace `finite_dimensional`):

- `fintype_basis_index` states that a finite-dimensional
  vector space has a finite basis
- `finite_dimensional.fin_basis` and `finite_dimensional.fin_basis_of_finrank_eq`
  are bases for finite dimensional vector spaces, where the index type
  is `fin`
- `of_fintype_basis` states that the existence of a basis indexed by a
  finite type implies finite-dimensionality
- `of_finite_basis` states that the existence of a basis indexed by a
  finite set implies finite-dimensionality
- `is_noetherian.iff_fg` states that the space is finite-dimensional if and only if
  it is noetherian

We make use of `finrank`, the dimension of a finite dimensional space, returning a `nat`, as
opposed to `module.rank`, which returns a `cardinal`. When the space has infinite dimension, its
`finrank` is by convention set to `0`. `finrank` is not defined using `finite_dimensional`.
For basic results that do not need the `finite_dimensional` class, import `linear_algebra.finrank`.

Preservation of finite-dimensionality and formulas for the dimension are given for
- submodules
- quotients (for the dimension of a quotient, see `finrank_quotient_add_finrank`)
- linear equivs, in `linear_equiv.finite_dimensional`
- image under a linear map (the rank-nullity formula is in `finrank_range_add_finrank_ker`)

Basic properties of linear maps of a finite-dimensional vector space are given. Notably, the
equivalence of injectivity and surjectivity is proved in `linear_map.injective_iff_surjective`,
and the equivalence between left-inverse and right-inverse in `linear_map.mul_eq_one_comm`
and `linear_map.comp_eq_id_comm`.

## Implementation notes

Most results are deduced from the corresponding results for the general dimension (as a cardinal),
in `dimension.lean`. Not all results have been ported yet.

You should not assume that there has been any effort to state lemmas as generally as possible.

One of the characterizations of finite-dimensionality is in terms of finite generation. This
property is currently defined only for submodules, so we express it through the fact that the
maximal submodule (which, as a set, coincides with the whole space) is finitely generated. This is
not very convenient to use, although there are some helper functions. However, this becomes very
convenient when speaking of submodules which are finite-dimensional, as this notion coincides with
the fact that the submodule is finitely generated (as a submodule of the whole space). This
equivalence is proved in `submodule.fg_iff_finite_dimensional`.
-/


universe u v v' w

open Classical Cardinal

open Cardinal Submodule Module Function

#print FiniteDimensional /-
/-- `finite_dimensional` vector spaces are defined to be finite modules.
Use `finite_dimensional.of_fintype_basis` to prove finite dimension from another definition. -/
@[reducible]
def FiniteDimensional (K V : Type _) [DivisionRing K] [AddCommGroup V] [Module K V] :=
  Module.Finite K V
#align finite_dimensional FiniteDimensional
-/

variable {K : Type u} {V : Type v}

namespace FiniteDimensional

open IsNoetherian

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

/- warning: finite_dimensional.of_injective -> FiniteDimensional.of_injective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Injective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) -> (forall [_inst_6 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Injective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) -> (forall [_inst_6 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.of_injective FiniteDimensional.of_injectiveₓ'. -/
/-- If the codomain of an injective linear map is finite dimensional, the domain must be as well. -/
theorem of_injective (f : V →ₗ[K] V₂) (w : Function.Injective f) [FiniteDimensional K V₂] :
    FiniteDimensional K V :=
  have : IsNoetherian K V₂ := IsNoetherian.iff_fg.mpr ‹_›
  Module.Finite.of_injective f w
#align finite_dimensional.of_injective FiniteDimensional.of_injective

/- warning: finite_dimensional.of_surjective -> FiniteDimensional.of_surjective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Surjective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) -> (forall [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] (f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Surjective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) -> (forall [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.of_surjective FiniteDimensional.of_surjectiveₓ'. -/
/-- If the domain of a surjective linear map is finite dimensional, the codomain must be as well. -/
theorem of_surjective (f : V →ₗ[K] V₂) (w : Function.Surjective f) [FiniteDimensional K V] :
    FiniteDimensional K V₂ :=
  Module.Finite.of_surjective f w
#align finite_dimensional.of_surjective FiniteDimensional.of_surjective

variable (K V)

#print FiniteDimensional.finiteDimensional_pi /-
instance finiteDimensional_pi {ι : Type _} [Finite ι] : FiniteDimensional K (ι → K) :=
  iff_fg.1 isNoetherian_pi
#align finite_dimensional.finite_dimensional_pi FiniteDimensional.finiteDimensional_pi
-/

#print FiniteDimensional.finiteDimensional_pi' /-
instance finiteDimensional_pi' {ι : Type _} [Finite ι] (M : ι → Type _) [∀ i, AddCommGroup (M i)]
    [∀ i, Module K (M i)] [I : ∀ i, FiniteDimensional K (M i)] : FiniteDimensional K (∀ i, M i) :=
  haveI : ∀ i : ι, IsNoetherian K (M i) := fun i => iff_fg.2 (I i)
  iff_fg.1 isNoetherian_pi
#align finite_dimensional.finite_dimensional_pi' FiniteDimensional.finiteDimensional_pi'
-/

#print FiniteDimensional.fintypeOfFintype /-
/-- A finite dimensional vector space over a finite field is finite -/
noncomputable def fintypeOfFintype [Fintype K] [FiniteDimensional K V] : Fintype V :=
  Module.fintypeOfFintype (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance))
#align finite_dimensional.fintype_of_fintype FiniteDimensional.fintypeOfFintype
-/

#print FiniteDimensional.finite_of_finite /-
theorem finite_of_finite [Finite K] [FiniteDimensional K V] : Finite V :=
  by
  cases nonempty_fintype K
  haveI := fintype_of_fintype K V
  infer_instance
#align finite_dimensional.finite_of_finite FiniteDimensional.finite_of_finite
-/

variable {K V}

#print FiniteDimensional.of_fintype_basis /-
/-- If a vector space has a finite basis, then it is finite-dimensional. -/
theorem of_fintype_basis {ι : Type w} [Finite ι] (h : Basis ι K V) : FiniteDimensional K V :=
  by
  cases nonempty_fintype ι
  exact
    ⟨⟨finset.univ.image h, by
        convert h.span_eq
        simp⟩⟩
#align finite_dimensional.of_fintype_basis FiniteDimensional.of_fintype_basis
-/

#print FiniteDimensional.fintypeBasisIndex /-
/-- If a vector space is `finite_dimensional`, all bases are indexed by a finite type -/
noncomputable def fintypeBasisIndex {ι : Type _} [FiniteDimensional K V] (b : Basis ι K V) :
    Fintype ι :=
  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance
  IsNoetherian.fintypeBasisIndex b
#align finite_dimensional.fintype_basis_index FiniteDimensional.fintypeBasisIndex
-/

/-- If a vector space is `finite_dimensional`, `basis.of_vector_space` is indexed by
  a finite type.-/
noncomputable instance [FiniteDimensional K V] : Fintype (Basis.ofVectorSpaceIndex K V) :=
  by
  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance
  infer_instance

#print FiniteDimensional.of_finite_basis /-
/-- If a vector space has a basis indexed by elements of a finite set, then it is
finite-dimensional. -/
theorem of_finite_basis {ι : Type w} {s : Set ι} (h : Basis s K V) (hs : Set.Finite s) :
    FiniteDimensional K V :=
  haveI := hs.fintype
  of_fintype_basis h
#align finite_dimensional.of_finite_basis FiniteDimensional.of_finite_basis
-/

#print FiniteDimensional.finiteDimensional_submodule /-
/-- A subspace of a finite-dimensional space is also finite-dimensional. -/
instance finiteDimensional_submodule [FiniteDimensional K V] (S : Submodule K V) :
    FiniteDimensional K S := by
  letI : IsNoetherian K V := iff_fg.2 _
  exact
    iff_fg.1
      (IsNoetherian.iff_rank_lt_aleph0.2
        (lt_of_le_of_lt (rank_submodule_le _) (rank_lt_aleph_0 K V)))
  infer_instance
#align finite_dimensional.finite_dimensional_submodule FiniteDimensional.finiteDimensional_submodule
-/

#print FiniteDimensional.finiteDimensional_quotient /-
/-- A quotient of a finite-dimensional space is also finite-dimensional. -/
instance finiteDimensional_quotient [FiniteDimensional K V] (S : Submodule K V) :
    FiniteDimensional K (V ⧸ S) :=
  Module.Finite.of_surjective (Submodule.mkQ S) <| surjective_quot_mk _
#align finite_dimensional.finite_dimensional_quotient FiniteDimensional.finiteDimensional_quotient
-/

variable (K V)

/- warning: finite_dimensional.finrank_eq_rank' -> FiniteDimensional.finrank_eq_rank' is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Eq.{succ (succ u2)} Cardinal.{u2} ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Eq.{succ (succ u2)} Cardinal.{u2} (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) (Module.rank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_eq_rank' FiniteDimensional.finrank_eq_rank'ₓ'. -/
/-- In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its
`finrank`. This is a copy of `finrank_eq_rank _ _` which creates easier typeclass searches. -/
theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=
  finrank_eq_rank _ _
#align finite_dimensional.finrank_eq_rank' FiniteDimensional.finrank_eq_rank'

variable {K V}

#print FiniteDimensional.finrank_of_infinite_dimensional /-
theorem finrank_of_infinite_dimensional (h : ¬FiniteDimensional K V) : finrank K V = 0 :=
  dif_neg <| mt IsNoetherian.iff_rank_lt_aleph0.2 <| (not_iff_not.2 iff_fg).2 h
#align finite_dimensional.finrank_of_infinite_dimensional FiniteDimensional.finrank_of_infinite_dimensional
-/

#print FiniteDimensional.finiteDimensional_of_finrank /-
theorem finiteDimensional_of_finrank (h : 0 < finrank K V) : FiniteDimensional K V :=
  by
  contrapose h
  simp [finrank_of_infinite_dimensional h]
#align finite_dimensional.finite_dimensional_of_finrank FiniteDimensional.finiteDimensional_of_finrank
-/

#print FiniteDimensional.finiteDimensional_of_finrank_eq_succ /-
theorem finiteDimensional_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) :
    FiniteDimensional K V :=
  finiteDimensional_of_finrank <| by rw [hn] <;> exact n.succ_pos
#align finite_dimensional.finite_dimensional_of_finrank_eq_succ FiniteDimensional.finiteDimensional_of_finrank_eq_succ
-/

#print FiniteDimensional.fact_finiteDimensional_of_finrank_eq_succ /-
/-- We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare
this as a local instance where needed. -/
theorem fact_finiteDimensional_of_finrank_eq_succ (n : ℕ) [Fact (finrank K V = n + 1)] :
    FiniteDimensional K V :=
  finiteDimensional_of_finrank <| by convert Nat.succ_pos n <;> apply Fact.out
#align finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ FiniteDimensional.fact_finiteDimensional_of_finrank_eq_succ
-/

#print FiniteDimensional.finiteDimensional_iff_of_rank_eq_nsmul /-
theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : ℕ}
    (hn : n ≠ 0) (hVW : Module.rank K V = n • Module.rank K W) :
    FiniteDimensional K V ↔ FiniteDimensional K W := by
  simp only [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_rank_lt_aleph0, hVW,
    Cardinal.nsmul_lt_aleph0_iff_of_ne_zero hn]
#align finite_dimensional.finite_dimensional_iff_of_rank_eq_nsmul FiniteDimensional.finiteDimensional_iff_of_rank_eq_nsmul
-/

/- warning: finite_dimensional.finrank_eq_card_basis' -> FiniteDimensional.finrank_eq_card_basis' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}}, (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (Eq.{succ (succ u3)} Cardinal.{u3} ((fun (a : Type) (b : Type.{succ u3}) [self : HasLiftT.{1, succ (succ u3)} a b] => self.0) Nat Cardinal.{u3} (HasLiftT.mk.{1, succ (succ u3)} Nat Cardinal.{u3} (CoeTCₓ.coe.{1, succ (succ u3)} Nat Cardinal.{u3} (Nat.castCoe.{succ u3} Cardinal.{u3} Cardinal.hasNatCast.{u3}))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) (Cardinal.mk.{u3} ι))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}}, (Basis.{u3, u1, u2} ι K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (Eq.{succ (succ u3)} Cardinal.{u3} (Nat.cast.{succ u3} Cardinal.{u3} Cardinal.instNatCastCardinal.{u3} (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) (Cardinal.mk.{u3} ι))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_eq_card_basis' FiniteDimensional.finrank_eq_card_basis'ₓ'. -/
/-- If a vector space is finite-dimensional, then the cardinality of any basis is equal to its
`finrank`. -/
theorem finrank_eq_card_basis' [FiniteDimensional K V] {ι : Type w} (h : Basis ι K V) :
    (finrank K V : Cardinal.{w}) = (#ι) :=
  by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  haveI : Fintype ι := fintype_basis_index h
  rw [Cardinal.mk_fintype, finrank_eq_card_basis h]
#align finite_dimensional.finrank_eq_card_basis' FiniteDimensional.finrank_eq_card_basis'

#print Basis.unique /-
/-- Given a basis of a division ring over itself indexed by a type `ι`, then `ι` is `unique`. -/
noncomputable def Basis.unique {ι : Type _} (b : Basis ι K K) : Unique ι :=
  by
  have A : Cardinal.mk ι = ↑(FiniteDimensional.finrank K K) :=
    (FiniteDimensional.finrank_eq_card_basis' b).symm
  simp only [Cardinal.eq_one_iff_unique, FiniteDimensional.finrank_self, algebraMap.coe_one] at A
  exact Nonempty.some ((unique_iff_subsingleton_and_nonempty _).2 A)
#align basis.unique Basis.unique
-/

variable (K V)

#print FiniteDimensional.finBasis /-
/-- A finite dimensional vector space has a basis indexed by `fin (finrank K V)`. -/
noncomputable def finBasis [FiniteDimensional K V] : Basis (Fin (finrank K V)) K V :=
  have h : Fintype.card (@finsetBasisIndex K V _ _ _ (iff_fg.2 inferInstance)) = finrank K V :=
    (finrank_eq_card_basis (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance))).symm
  (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance)).reindex (Fintype.equivFinOfCardEq h)
#align finite_dimensional.fin_basis FiniteDimensional.finBasis
-/

#print FiniteDimensional.finBasisOfFinrankEq /-
/-- An `n`-dimensional vector space has a basis indexed by `fin n`. -/
noncomputable def finBasisOfFinrankEq [FiniteDimensional K V] {n : ℕ} (hn : finrank K V = n) :
    Basis (Fin n) K V :=
  (finBasis K V).reindex (Fin.cast hn).toEquiv
#align finite_dimensional.fin_basis_of_finrank_eq FiniteDimensional.finBasisOfFinrankEq
-/

variable {K V}

#print FiniteDimensional.basisUnique /-
/-- A module with dimension 1 has a basis with one element. -/
noncomputable def basisUnique (ι : Type _) [Unique ι] (h : finrank K V = 1) : Basis ι K V :=
  haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
  (fin_basis_of_finrank_eq K V h).reindex (Equiv.equivOfUnique _ _)
#align finite_dimensional.basis_unique FiniteDimensional.basisUnique
-/

/- warning: finite_dimensional.basis_unique.repr_eq_zero_iff -> FiniteDimensional.basisUnique.repr_eq_zero_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_6 : Unique.{succ u3} ι] {h : Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))} {v : V} {i : ι}, Iff (Eq.{succ u1} K (coeFn.{max (succ u3) (succ u1), max (succ u3) (succ u1)} (Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (fun (_x : Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) => ι -> K) (Finsupp.coeFun.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (coeFn.{max (succ u2) (succ (max u3 u1)), max (succ u2) (succ (max u3 u1))} (LinearEquiv.{u1, u1, u2, max u3 u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) V (Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Finsupp.addCommMonoid.{u3, u1} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) _inst_3 (Finsupp.module.{u3, u1, u1} ι K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (fun (_x : LinearEquiv.{u1, u1, u2, max u3 u1} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) V (Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Finsupp.addCommMonoid.{u3, u1} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) _inst_3 (Finsupp.module.{u3, u1, u1} ι K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) => V -> (Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))) (LinearEquiv.hasCoeToFun.{u1, u1, u2, max u3 u1} K K V (Finsupp.{u3, u1} ι K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (Finsupp.addCommMonoid.{u3, u1} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) _inst_3 (Finsupp.module.{u3, u1, u1} ι K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (Semiring.toModule.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (Basis.repr.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (FiniteDimensional.basisUnique.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h)) v) i) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (Eq.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))))))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_6 : Unique.{succ u1} ι] {h : Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))} {v : V} {i : ι}, Iff (Eq.{succ u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) (FunLike.coe.{max (succ u1) (succ u2), succ u1, succ u2} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) ι (fun (_x : ι) => (fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) _x) (Finsupp.funLike.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u3, max (succ u2) (succ u1)} (LinearEquiv.{u2, u2, u3, max u2 u1} K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V) => Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) _x) (SMulHomClass.toFunLike.{max (max u2 u3) u1, u2, u3, max u2 u1} (LinearEquiv.{u2, u2, u3, max u2 u1} K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) K V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (SMulZeroClass.toSMul.{u2, u3} K V (AddMonoid.toZero.{u3} V (AddCommMonoid.toAddMonoid.{u3} V (AddCommGroup.toAddCommMonoid.{u3} V _inst_2))) (DistribSMul.toSMulZeroClass.{u2, u3} K V (AddMonoid.toAddZeroClass.{u3} V (AddCommMonoid.toAddMonoid.{u3} V (AddCommGroup.toAddCommMonoid.{u3} V _inst_2))) (DistribMulAction.toDistribSMul.{u2, u3} K V (MonoidWithZero.toMonoid.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u3} V (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)) (Module.toDistribMulAction.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u2, max u2 u1} K (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddMonoid.toZero.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))))) (DistribSMul.toSMulZeroClass.{u2, max u2 u1} K (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddMonoid.toAddZeroClass.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))))) (DistribMulAction.toDistribSMul.{u2, max u2 u1} K (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (MonoidWithZero.toMonoid.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))))) (Module.toDistribMulAction.{u2, max u2 u1} K (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u2 u3) u1, u2, u3, max u2 u1} (LinearEquiv.{u2, u2, u3, max u2 u1} K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) K V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (MonoidWithZero.toMonoid.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u3} V (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)) (AddCommMonoid.toAddMonoid.{max u2 u1} (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))))) (Module.toDistribMulAction.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Module.toDistribMulAction.{u2, max u2 u1} K (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (SemilinearMapClass.distribMulActionHomClass.{u2, u3, max u2 u1, max (max u2 u3) u1} K V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (LinearEquiv.{u2, u2, u3, max u2 u1} K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (SemilinearEquivClass.instSemilinearMapClass.{u2, u2, u3, max u2 u1, max (max u2 u3) u1} K K V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (LinearEquiv.{u2, u2, u3, max u2 u1} K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u2, u2, u3, max u2 u1} K K V (Finsupp.{u1, u2} ι K (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) (Finsupp.addCommMonoid.{u1, u2} ι K (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))) _inst_3 (Finsupp.module.{u1, u2, u2} ι K K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} K (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))))) (Semiring.toModule.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHom.id.{u2} K (Semiring.toNonAssocSemiring.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (RingHomInvPair.ids.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))))))) (Basis.repr.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (FiniteDimensional.basisUnique.{u2, u3, u1} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h)) v) i) (OfNat.ofNat.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) 0 (Zero.toOfNat0.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) (MonoidWithZero.toZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) (Semiring.toMonoidWithZero.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) (DivisionSemiring.toSemiring.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) (DivisionRing.toDivisionSemiring.{u2} ((fun (x._@.Mathlib.Data.Finsupp.Defs._hyg.779 : ι) => K) i) _inst_1))))))) (Eq.{succ u3} V v (OfNat.ofNat.{u3} V 0 (Zero.toOfNat0.{u3} V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.basis_unique.repr_eq_zero_iff FiniteDimensional.basisUnique.repr_eq_zero_iffₓ'. -/
@[simp]
theorem basisUnique.repr_eq_zero_iff {ι : Type _} [Unique ι] {h : finrank K V = 1} {v : V} {i : ι} :
    (basisUnique ι h).repr v i = 0 ↔ v = 0 :=
  ⟨fun hv =>
    (basisUnique ι h).repr.map_eq_zero_iff.mp (Finsupp.ext fun j => Subsingleton.elim i j ▸ hv),
    fun hv => by rw [hv, LinearEquiv.map_zero, Finsupp.zero_apply]⟩
#align finite_dimensional.basis_unique.repr_eq_zero_iff FiniteDimensional.basisUnique.repr_eq_zero_iff

/- warning: finite_dimensional.cardinal_mk_le_finrank_of_linear_independent -> FiniteDimensional.cardinal_mk_le_finrank_of_linearIndependent is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {b : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (LE.le.{succ u3} Cardinal.{u3} Cardinal.hasLe.{u3} (Cardinal.mk.{u3} ι) ((fun (a : Type) (b : Type.{succ u3}) [self : HasLiftT.{1, succ (succ u3)} a b] => self.0) Nat Cardinal.{u3} (HasLiftT.mk.{1, succ (succ u3)} Nat Cardinal.{u3} (CoeTCₓ.coe.{1, succ (succ u3)} Nat Cardinal.{u3} (Nat.castCoe.{succ u3} Cardinal.{u3} Cardinal.hasNatCast.{u3}))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {b : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V b (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (LE.le.{succ u3} Cardinal.{u3} Cardinal.instLECardinal.{u3} (Cardinal.mk.{u3} ι) (Nat.cast.{succ u3} Cardinal.{u3} Cardinal.instNatCastCardinal.{u3} (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.cardinal_mk_le_finrank_of_linear_independent FiniteDimensional.cardinal_mk_le_finrank_of_linearIndependentₓ'. -/
theorem cardinal_mk_le_finrank_of_linearIndependent [FiniteDimensional K V] {ι : Type w} {b : ι → V}
    (h : LinearIndependent K b) : (#ι) ≤ finrank K V :=
  by
  rw [← lift_le.{_, max v w}]
  simpa [← finrank_eq_rank', -finrank_eq_rank] using
    cardinal_lift_le_rank_of_linearIndependent.{_, _, _, max v w} h
#align finite_dimensional.cardinal_mk_le_finrank_of_linear_independent FiniteDimensional.cardinal_mk_le_finrank_of_linearIndependent

/- warning: finite_dimensional.fintype_card_le_finrank_of_linear_independent -> FiniteDimensional.fintype_card_le_finrank_of_linearIndependent is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} [_inst_7 : Fintype.{u3} ι] {b : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (LE.le.{0} Nat Nat.hasLe (Fintype.card.{u3} ι _inst_7) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_6 : FiniteDimensional.{u2, u3} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u1}} [_inst_7 : Fintype.{u1} ι] {b : ι -> V}, (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) -> (LE.le.{0} Nat instLENat (Fintype.card.{u1} ι _inst_7) (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.fintype_card_le_finrank_of_linear_independent FiniteDimensional.fintype_card_le_finrank_of_linearIndependentₓ'. -/
theorem fintype_card_le_finrank_of_linearIndependent [FiniteDimensional K V] {ι : Type _}
    [Fintype ι] {b : ι → V} (h : LinearIndependent K b) : Fintype.card ι ≤ finrank K V := by
  simpa using cardinal_mk_le_finrank_of_linear_independent h
#align finite_dimensional.fintype_card_le_finrank_of_linear_independent FiniteDimensional.fintype_card_le_finrank_of_linearIndependent

#print FiniteDimensional.finset_card_le_finrank_of_linearIndependent /-
theorem finset_card_le_finrank_of_linearIndependent [FiniteDimensional K V] {b : Finset V}
    (h : LinearIndependent K (fun x => x : b → V)) : b.card ≤ finrank K V :=
  by
  rw [← Fintype.card_coe]
  exact fintype_card_le_finrank_of_linear_independent h
#align finite_dimensional.finset_card_le_finrank_of_linear_independent FiniteDimensional.finset_card_le_finrank_of_linearIndependent
-/

/- warning: finite_dimensional.lt_aleph_0_of_linear_independent -> FiniteDimensional.lt_aleph0_of_linearIndependent is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {v : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V v (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (LT.lt.{succ u3} Cardinal.{u3} (Preorder.toHasLt.{succ u3} Cardinal.{u3} (PartialOrder.toPreorder.{succ u3} Cardinal.{u3} Cardinal.partialOrder.{u3})) (Cardinal.mk.{u3} ι) Cardinal.aleph0.{u3})
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {v : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V v (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (LT.lt.{succ u3} Cardinal.{u3} (Preorder.toLT.{succ u3} Cardinal.{u3} (PartialOrder.toPreorder.{succ u3} Cardinal.{u3} Cardinal.partialOrder.{u3})) (Cardinal.mk.{u3} ι) Cardinal.aleph0.{u3})
Case conversion may be inaccurate. Consider using '#align finite_dimensional.lt_aleph_0_of_linear_independent FiniteDimensional.lt_aleph0_of_linearIndependentₓ'. -/
theorem lt_aleph0_of_linearIndependent {ι : Type w} [FiniteDimensional K V] {v : ι → V}
    (h : LinearIndependent K v) : (#ι) < ℵ₀ :=
  by
  apply Cardinal.lift_lt.1
  apply lt_of_le_of_lt
  apply cardinal_lift_le_rank_of_linearIndependent h
  rw [← finrank_eq_rank, Cardinal.lift_aleph0, Cardinal.lift_natCast]
  apply Cardinal.nat_lt_aleph0
#align finite_dimensional.lt_aleph_0_of_linear_independent FiniteDimensional.lt_aleph0_of_linearIndependent

#print LinearIndependent.finite /-
theorem LinearIndependent.finite [FiniteDimensional K V] {b : Set V}
    (h : LinearIndependent K fun x : b => (x : V)) : b.Finite :=
  Cardinal.lt_aleph0_iff_set_finite.mp (FiniteDimensional.lt_aleph0_of_linearIndependent h)
#align linear_independent.finite LinearIndependent.finite
-/

#print FiniteDimensional.not_linearIndependent_of_infinite /-
theorem not_linearIndependent_of_infinite {ι : Type w} [inf : Infinite ι] [FiniteDimensional K V]
    (v : ι → V) : ¬LinearIndependent K v :=
  by
  intro h_lin_indep
  have : ¬ℵ₀ ≤ (#ι) := not_le.mpr (lt_aleph_0_of_linear_independent h_lin_indep)
  have : ℵ₀ ≤ (#ι) := infinite_iff.mp inf
  contradiction
#align finite_dimensional.not_linear_independent_of_infinite FiniteDimensional.not_linearIndependent_of_infinite
-/

/- warning: finite_dimensional.finrank_pos_iff_exists_ne_zero -> FiniteDimensional.finrank_pos_iff_exists_ne_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (LT.lt.{0} Nat Nat.hasLt (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) (Exists.{succ u2} V (fun (x : V) => Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (LT.lt.{0} Nat instLTNat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) (Exists.{succ u2} V (fun (x : V) => Ne.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.finrank_pos_iff_exists_ne_zero FiniteDimensional.finrank_pos_iff_exists_ne_zeroₓ'. -/
/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/
theorem finrank_pos_iff_exists_ne_zero [FiniteDimensional K V] : 0 < finrank K V ↔ ∃ x : V, x ≠ 0 :=
  Iff.trans
    (by
      rw [← finrank_eq_rank]
      norm_cast)
    (@rank_pos_iff_exists_ne_zero K V _ _ _ _ _)
#align finite_dimensional.finrank_pos_iff_exists_ne_zero FiniteDimensional.finrank_pos_iff_exists_ne_zero

#print FiniteDimensional.finrank_pos_iff /-
/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/
theorem finrank_pos_iff [FiniteDimensional K V] : 0 < finrank K V ↔ Nontrivial V :=
  Iff.trans
    (by
      rw [← finrank_eq_rank]
      norm_cast)
    (@rank_pos_iff_nontrivial K V _ _ _ _ _)
#align finite_dimensional.finrank_pos_iff FiniteDimensional.finrank_pos_iff
-/

#print FiniteDimensional.finrank_pos /-
/-- A nontrivial finite dimensional space has positive `finrank`. -/
theorem finrank_pos [FiniteDimensional K V] [h : Nontrivial V] : 0 < finrank K V :=
  finrank_pos_iff.mpr h
#align finite_dimensional.finrank_pos FiniteDimensional.finrank_pos
-/

#print FiniteDimensional.finrank_zero_iff /-
/-- A finite dimensional space has zero `finrank` iff it is a subsingleton.
This is the `finrank` version of `rank_zero_iff`. -/
theorem finrank_zero_iff [FiniteDimensional K V] : finrank K V = 0 ↔ Subsingleton V :=
  Iff.trans
    (by
      rw [← finrank_eq_rank]
      norm_cast)
    (@rank_zero_iff K V _ _ _ _ _)
#align finite_dimensional.finrank_zero_iff FiniteDimensional.finrank_zero_iff
-/

/- warning: finite_dimensional.eq_top_of_finrank_eq -> FiniteDimensional.eq_top_of_finrank_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {S : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {S : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.eq_top_of_finrank_eq FiniteDimensional.eq_top_of_finrank_eqₓ'. -/
/-- If a submodule has maximal dimension in a finite dimensional space, then it is equal to the
whole space. -/
theorem eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ :=
  by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K (coe : (coe '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linear_independent) (by simp)
  set b := Basis.extend this with b_eq
  letI : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linear_independent)).Fintype
  letI : Fintype (coe '' Basis.ofVectorSpaceIndex K S) := (finite_of_linearIndependent this).Fintype
  letI : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linear_independent)).Fintype
  have : coe '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h] <;>
          infer_instance)
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]
#align finite_dimensional.eq_top_of_finrank_eq FiniteDimensional.eq_top_of_finrank_eq

variable (K)

#print FiniteDimensional.finiteDimensional_self /-
instance finiteDimensional_self : FiniteDimensional K K := by infer_instance
#align finite_dimensional.finite_dimensional_self FiniteDimensional.finiteDimensional_self
-/

#print FiniteDimensional.span_of_finite /-
/-- The submodule generated by a finite set is finite-dimensional. -/
theorem span_of_finite {A : Set V} (hA : Set.Finite A) : FiniteDimensional K (Submodule.span K A) :=
  iff_fg.1 <| isNoetherian_span_of_finite K hA
#align finite_dimensional.span_of_finite FiniteDimensional.span_of_finite
-/

#print FiniteDimensional.span_singleton /-
/-- The submodule generated by a single element is finite-dimensional. -/
instance span_singleton (x : V) : FiniteDimensional K (K ∙ x) :=
  span_of_finite K <| Set.finite_singleton _
#align finite_dimensional.span_singleton FiniteDimensional.span_singleton
-/

#print FiniteDimensional.span_finset /-
/-- The submodule generated by a finset is finite-dimensional. -/
instance span_finset (s : Finset V) : FiniteDimensional K (span K (s : Set V)) :=
  span_of_finite K <| s.finite_toSet
#align finite_dimensional.span_finset FiniteDimensional.span_finset
-/

/-- Pushforwards of finite-dimensional submodules are finite-dimensional. -/
instance (f : V →ₗ[K] V₂) (p : Submodule K V) [h : FiniteDimensional K p] :
    FiniteDimensional K (p.map f) :=
  Module.Finite.map _ _

variable {K}

/- warning: complete_lattice.independent.subtype_ne_bot_le_finrank_aux -> CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (LE.le.{succ u3} Cardinal.{u3} Cardinal.hasLe.{u3} (Cardinal.mk.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) ((fun (a : Type) (b : Type.{succ u3}) [self : HasLiftT.{1, succ (succ u3)} a b] => self.0) Nat Cardinal.{u3} (HasLiftT.mk.{1, succ (succ u3)} Nat Cardinal.{u3} (CoeTCₓ.coe.{1, succ (succ u3)} Nat Cardinal.{u3} (Nat.castCoe.{succ u3} Cardinal.{u3} Cardinal.hasNatCast.{u3}))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (LE.le.{succ u3} Cardinal.{u3} Cardinal.instLECardinal.{u3} (Cardinal.mk.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (Nat.cast.{succ u3} Cardinal.{u3} Cardinal.instNatCastCardinal.{u3} (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align complete_lattice.independent.subtype_ne_bot_le_finrank_aux CompleteLattice.Independent.subtype_ne_bot_le_finrank_auxₓ'. -/
theorem CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux [FiniteDimensional K V]
    {ι : Type w} {p : ι → Submodule K V} (hp : CompleteLattice.Independent p) :
    (#{ i // p i ≠ ⊥ }) ≤ (finrank K V : Cardinal.{w}) :=
  by
  suffices Cardinal.lift.{v} (#{ i // p i ≠ ⊥ }) ≤ Cardinal.lift.{v} (finrank K V : Cardinal.{w}) by
    rwa [Cardinal.lift_le] at this
  calc
    Cardinal.lift.{v} (#{ i // p i ≠ ⊥ }) ≤ Cardinal.lift.{w} (Module.rank K V) :=
      hp.subtype_ne_bot_le_rank
    _ = Cardinal.lift.{w} (finrank K V : Cardinal.{v}) := by rw [finrank_eq_rank]
    _ = Cardinal.lift.{v} (finrank K V : Cardinal.{w}) := by simp
    
#align complete_lattice.independent.subtype_ne_bot_le_finrank_aux CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux

/- warning: complete_lattice.independent.fintype_ne_bot_of_finite_dimensional -> CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (Fintype.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (Fintype.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))))
Case conversion may be inaccurate. Consider using '#align complete_lattice.independent.fintype_ne_bot_of_finite_dimensional CompleteLattice.Independent.fintypeNeBotOfFiniteDimensionalₓ'. -/
/-- If `p` is an independent family of subspaces of a finite-dimensional space `V`, then the
number of nontrivial subspaces in the family `p` is finite. -/
noncomputable def CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional
    [FiniteDimensional K V] {ι : Type w} {p : ι → Submodule K V}
    (hp : CompleteLattice.Independent p) : Fintype { i : ι // p i ≠ ⊥ } :=
  by
  suffices (#{ i // p i ≠ ⊥ }) < (ℵ₀ : Cardinal.{w})
    by
    rw [Cardinal.lt_aleph0_iff_fintype] at this
    exact this.some
  refine' lt_of_le_of_lt hp.subtype_ne_bot_le_finrank_aux _
  simp [Cardinal.nat_lt_aleph0]
#align complete_lattice.independent.fintype_ne_bot_of_finite_dimensional CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional

/- warning: complete_lattice.independent.subtype_ne_bot_le_finrank -> CompleteLattice.Independent.subtype_ne_bot_le_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (forall [_inst_7 : Fintype.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))], LE.le.{0} Nat Nat.hasLe (Fintype.card.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) _inst_7) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {ι : Type.{u3}} {p : ι -> (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)}, (CompleteLattice.Independent.{succ u3, u2} ι (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) p) -> (forall [_inst_7 : Fintype.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))], LE.le.{0} Nat instLENat (Fintype.card.{u3} (Subtype.{succ u3} ι (fun (i : ι) => Ne.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (p i) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) _inst_7) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align complete_lattice.independent.subtype_ne_bot_le_finrank CompleteLattice.Independent.subtype_ne_bot_le_finrankₓ'. -/
/-- If `p` is an independent family of subspaces of a finite-dimensional space `V`, then the
number of nontrivial subspaces in the family `p` is bounded above by the dimension of `V`.

Note that the `fintype` hypothesis required here can be provided by
`complete_lattice.independent.fintype_ne_bot_of_finite_dimensional`. -/
theorem CompleteLattice.Independent.subtype_ne_bot_le_finrank [FiniteDimensional K V] {ι : Type w}
    {p : ι → Submodule K V} (hp : CompleteLattice.Independent p) [Fintype { i // p i ≠ ⊥ }] :
    Fintype.card { i // p i ≠ ⊥ } ≤ finrank K V := by simpa using hp.subtype_ne_bot_le_finrank_aux
#align complete_lattice.independent.subtype_ne_bot_le_finrank CompleteLattice.Independent.subtype_ne_bot_le_finrank

section

open BigOperators

open Finset

/- warning: finite_dimensional.exists_nontrivial_relation_of_rank_lt_card -> FiniteDimensional.exists_nontrivial_relation_of_rank_lt_card is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {t : Finset.{u2} V}, (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (Finset.card.{u2} V t)) -> (Exists.{max (succ u2) (succ u1)} (V -> K) (fun (f : V -> K) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (f e) e)) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) (Exists.{succ u2} V (fun (x : V) => Exists.{0} (Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) (fun (H : Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) => Ne.{succ u1} K (f x) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))))))))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {t : Finset.{u2} V}, (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (Finset.card.{u2} V t)) -> (Exists.{max (succ u1) (succ u2)} (V -> K) (fun (f : V -> K) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (f e) e)) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) (Exists.{succ u2} V (fun (x : V) => And (Membership.mem.{u2, u2} V (Finset.{u2} V) (Finset.instMembershipFinset.{u2} V) x t) (Ne.{succ u1} K (f x) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.exists_nontrivial_relation_of_rank_lt_card FiniteDimensional.exists_nontrivial_relation_of_rank_lt_cardₓ'. -/
/-- If a finset has cardinality larger than the dimension of the space,
then there is a nontrivial linear relation amongst its elements.
-/
theorem exists_nontrivial_relation_of_rank_lt_card [FiniteDimensional K V] {t : Finset V}
    (h : finrank K V < t.card) : ∃ f : V → K, (∑ e in t, f e • e) = 0 ∧ ∃ x ∈ t, f x ≠ 0 :=
  by
  have := mt finset_card_le_finrank_of_linear_independent (by simpa using h)
  rw [not_linearIndependent_iff] at this
  obtain ⟨s, g, sum, z, zm, nonzero⟩ := this
  -- Now we have to extend `g` to all of `t`, then to all of `V`.
  let f : V → K := fun x => if h : x ∈ t then if (⟨x, h⟩ : t) ∈ s then g ⟨x, h⟩ else 0 else 0
  -- and finally clean up the mess caused by the extension.
  refine' ⟨f, _, _⟩
  · dsimp [f]
    rw [← Sum]
    fapply sum_bij_ne_zero fun v hvt _ => (⟨v, hvt⟩ : { v // v ∈ t })
    · intro v hvt H
      dsimp
      rw [dif_pos hvt] at H
      contrapose! H
      rw [if_neg H, zero_smul]
    · intro _ _ _ _ _ _
      exact Subtype.mk.inj
    · intro b hbs hb
      use b
      simpa only [hbs, exists_prop, dif_pos, Finset.mk_coe, and_true_iff, if_true, Finset.coe_mem,
        eq_self_iff_true, exists_prop_of_true, Ne.def] using hb
    · intro a h₁
      dsimp
      rw [dif_pos h₁]
      intro h₂
      rw [if_pos]
      contrapose! h₂
      rw [if_neg h₂, zero_smul]
  · refine' ⟨z, z.2, _⟩
    dsimp only [f]
    erw [dif_pos z.2, if_pos] <;> rwa [Subtype.coe_eta]
#align finite_dimensional.exists_nontrivial_relation_of_rank_lt_card FiniteDimensional.exists_nontrivial_relation_of_rank_lt_card

/- warning: finite_dimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card -> FiniteDimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {t : Finset.{u2} V}, (LT.lt.{0} Nat Nat.hasLt (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Finset.card.{u2} V t)) -> (Exists.{max (succ u2) (succ u1)} (V -> K) (fun (f : V -> K) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (f e) e)) (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) (And (Eq.{succ u1} K (Finset.sum.{u1, u2} K V (AddCommGroup.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toAddCommGroup.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) t (fun (e : V) => f e)) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))) (Exists.{succ u2} V (fun (x : V) => Exists.{0} (Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) (fun (H : Membership.Mem.{u2, u2} V (Finset.{u2} V) (Finset.hasMem.{u2} V) x t) => Ne.{succ u1} K (f x) (OfNat.ofNat.{u1} K 0 (OfNat.mk.{u1} K 0 (Zero.zero.{u1} K (MulZeroClass.toHasZero.{u1} K (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))))))))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {t : Finset.{u2} V}, (LT.lt.{0} Nat instLTNat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Finset.card.{u2} V t)) -> (Exists.{max (succ u1) (succ u2)} (V -> K) (fun (f : V -> K) => And (Eq.{succ u2} V (Finset.sum.{u2, u2} V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) t (fun (e : V) => HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (f e) e)) (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) (And (Eq.{succ u1} K (Finset.sum.{u1, u2} K V (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} K (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} K (NonAssocRing.toNonUnitalNonAssocRing.{u1} K (Ring.toNonAssocRing.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) t (fun (e : V) => f e)) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))) (Exists.{succ u2} V (fun (x : V) => And (Membership.mem.{u2, u2} V (Finset.{u2} V) (Finset.instMembershipFinset.{u2} V) x t) (Ne.{succ u1} K (f x) (OfNat.ofNat.{u1} K 0 (Zero.toOfNat0.{u1} K (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))))))))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card FiniteDimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_cardₓ'. -/
/-- If a finset has cardinality larger than `finrank + 1`,
then there is a nontrivial linear relation amongst its elements,
such that the coefficients of the relation sum to zero.
-/
theorem exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card [FiniteDimensional K V]
    {t : Finset V} (h : finrank K V + 1 < t.card) :
    ∃ f : V → K, (∑ e in t, f e • e) = 0 ∧ (∑ e in t, f e) = 0 ∧ ∃ x ∈ t, f x ≠ 0 :=
  by
  -- Pick an element x₀ ∈ t,
  have card_pos : 0 < t.card := lt_trans (Nat.succ_pos _) h
  obtain ⟨x₀, m⟩ := (Finset.card_pos.1 card_pos).bex
  -- and apply the previous lemma to the {xᵢ - x₀}
  let shift : V ↪ V := ⟨fun x => x - x₀, sub_left_injective⟩
  let t' := (t.erase x₀).map shift
  have h' : finrank K V < t'.card :=
    by
    simp only [t', card_map, Finset.card_erase_of_mem m]
    exact nat.lt_pred_iff.mpr h
  -- to obtain a function `g`.
  obtain ⟨g, gsum, x₁, x₁_mem, nz⟩ := exists_nontrivial_relation_of_rank_lt_card h'
  -- Then obtain `f` by translating back by `x₀`,
  -- and setting the value of `f` at `x₀` to ensure `∑ e in t, f e = 0`.
  let f : V → K := fun z => if z = x₀ then -∑ z in t.erase x₀, g (z - x₀) else g (z - x₀)
  refine' ⟨f, _, _, _⟩
  -- After this, it's a matter of verifiying the properties,
  -- based on the corresponding properties for `g`.
  · show (∑ e : V in t, f e • e) = 0
    -- We prove this by splitting off the `x₀` term of the sum,
    -- which is itself a sum over `t.erase x₀`,
    -- combining the two sums, and
    -- observing that after reindexing we have exactly
    -- ∑ (x : V) in t', g x • x = 0.
    simp only [f]
    conv_lhs =>
      apply_congr
      skip
      rw [ite_smul]
    rw [Finset.sum_ite]
    conv =>
      congr
      congr
      apply_congr
      simp [filter_eq', m]
    conv =>
      congr
      congr
      skip
      apply_congr
      simp [filter_ne']
    rw [sum_singleton, neg_smul, add_comm, ← sub_eq_add_neg, sum_smul, ← sum_sub_distrib]
    simp only [← smul_sub]
    -- At the end we have to reindex the sum, so we use `change` to
    -- express the summand using `shift`.
    change (∑ x : V in t.erase x₀, (fun e => g e • e) (shift x)) = 0
    rw [← sum_map _ shift]
    exact gsum
  · show (∑ e : V in t, f e) = 0
    -- Again we split off the `x₀` term,
    -- observing that it exactly cancels the other terms.
    rw [← insert_erase m, sum_insert (not_mem_erase x₀ t)]
    dsimp [f]
    rw [if_pos rfl]
    conv_lhs =>
      congr
      skip
      apply_congr
      skip
      rw [if_neg (show x ≠ x₀ from (mem_erase.mp H).1)]
    exact neg_add_self _
  · show ∃ (x : V)(H : x ∈ t), f x ≠ 0
    -- We can use x₁ + x₀.
    refine' ⟨x₁ + x₀, _, _⟩
    · rw [Finset.mem_map] at x₁_mem
      rcases x₁_mem with ⟨x₁, x₁_mem, rfl⟩
      rw [mem_erase] at x₁_mem
      simp only [x₁_mem, sub_add_cancel, Function.Embedding.coeFn_mk]
    · dsimp only [f]
      rwa [if_neg, add_sub_cancel]
      rw [add_left_eq_self]
      rintro rfl
      simpa only [sub_eq_zero, exists_prop, Finset.mem_map, embedding.coe_fn_mk, eq_self_iff_true,
        mem_erase, not_true, exists_eq_right, Ne.def, false_and_iff] using x₁_mem
#align finite_dimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card FiniteDimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card

section

variable {L : Type _} [LinearOrderedField L]

variable {W : Type v} [AddCommGroup W] [Module L W]

/- warning: finite_dimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card -> FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card is a dubious translation:
lean 3 declaration is
  forall {L : Type.{u2}} [_inst_6 : LinearOrderedField.{u2} L] {W : Type.{u1}} [_inst_7 : AddCommGroup.{u1} W] [_inst_8 : Module.{u2, u1} L W (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)))) (AddCommGroup.toAddCommMonoid.{u1} W _inst_7)] [_inst_9 : FiniteDimensional.{u2, u1} L W (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)) _inst_7 _inst_8] {t : Finset.{u1} W}, (LT.lt.{0} Nat Nat.hasLt (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u2, u1} L W (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)))) _inst_7 _inst_8) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Finset.card.{u1} W t)) -> (Exists.{max (succ u1) (succ u2)} (W -> L) (fun (f : W -> L) => And (Eq.{succ u1} W (Finset.sum.{u1, u1} W W (AddCommGroup.toAddCommMonoid.{u1} W _inst_7) t (fun (e : W) => SMul.smul.{u2, u1} L W (SMulZeroClass.toHasSmul.{u2, u1} L W (AddZeroClass.toHasZero.{u1} W (AddMonoid.toAddZeroClass.{u1} W (AddCommMonoid.toAddMonoid.{u1} W (AddCommGroup.toAddCommMonoid.{u1} W _inst_7)))) (SMulWithZero.toSmulZeroClass.{u2, u1} L W (MulZeroClass.toHasZero.{u2} L (MulZeroOneClass.toMulZeroClass.{u2} L (MonoidWithZero.toMulZeroOneClass.{u2} L (Semiring.toMonoidWithZero.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)))))))) (AddZeroClass.toHasZero.{u1} W (AddMonoid.toAddZeroClass.{u1} W (AddCommMonoid.toAddMonoid.{u1} W (AddCommGroup.toAddCommMonoid.{u1} W _inst_7)))) (MulActionWithZero.toSMulWithZero.{u2, u1} L W (Semiring.toMonoidWithZero.{u2} L (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6))))) (AddZeroClass.toHasZero.{u1} W (AddMonoid.toAddZeroClass.{u1} W (AddCommMonoid.toAddMonoid.{u1} W (AddCommGroup.toAddCommMonoid.{u1} W _inst_7)))) (Module.toMulActionWithZero.{u2, u1} L W (Ring.toSemiring.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)))) (AddCommGroup.toAddCommMonoid.{u1} W _inst_7) _inst_8)))) (f e) e)) (OfNat.ofNat.{u1} W 0 (OfNat.mk.{u1} W 0 (Zero.zero.{u1} W (AddZeroClass.toHasZero.{u1} W (AddMonoid.toAddZeroClass.{u1} W (SubNegMonoid.toAddMonoid.{u1} W (AddGroup.toSubNegMonoid.{u1} W (AddCommGroup.toAddGroup.{u1} W _inst_7))))))))) (And (Eq.{succ u2} L (Finset.sum.{u2, u1} L W (AddCommGroup.toAddCommMonoid.{u2} L (OrderedAddCommGroup.toAddCommGroup.{u2} L (StrictOrderedRing.toOrderedAddCommGroup.{u2} L (LinearOrderedRing.toStrictOrderedRing.{u2} L (LinearOrderedCommRing.toLinearOrderedRing.{u2} L (LinearOrderedField.toLinearOrderedCommRing.{u2} L _inst_6)))))) t (fun (e : W) => f e)) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6)))))))))))) (Exists.{succ u1} W (fun (x : W) => Exists.{0} (Membership.Mem.{u1, u1} W (Finset.{u1} W) (Finset.hasMem.{u1} W) x t) (fun (H : Membership.Mem.{u1, u1} W (Finset.{u1} W) (Finset.hasMem.{u1} W) x t) => LT.lt.{u2} L (Preorder.toHasLt.{u2} L (PartialOrder.toPreorder.{u2} L (OrderedAddCommGroup.toPartialOrder.{u2} L (StrictOrderedRing.toOrderedAddCommGroup.{u2} L (LinearOrderedRing.toStrictOrderedRing.{u2} L (LinearOrderedCommRing.toLinearOrderedRing.{u2} L (LinearOrderedField.toLinearOrderedCommRing.{u2} L _inst_6))))))) (OfNat.ofNat.{u2} L 0 (OfNat.mk.{u2} L 0 (Zero.zero.{u2} L (MulZeroClass.toHasZero.{u2} L (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} L (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} L (NonAssocRing.toNonUnitalNonAssocRing.{u2} L (Ring.toNonAssocRing.{u2} L (DivisionRing.toRing.{u2} L (Field.toDivisionRing.{u2} L (LinearOrderedField.toField.{u2} L _inst_6))))))))))) (f x)))))))
but is expected to have type
  forall {L : Type.{u1}} [_inst_6 : LinearOrderedField.{u1} L] {W : Type.{u2}} [_inst_7 : AddCommGroup.{u2} W] [_inst_8 : Module.{u1, u2} L W (StrictOrderedSemiring.toSemiring.{u1} L (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} L (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} L (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6))))) (AddCommGroup.toAddCommMonoid.{u2} W _inst_7)] [_inst_9 : FiniteDimensional.{u1, u2} L W (Field.toDivisionRing.{u1} L (LinearOrderedField.toField.{u1} L _inst_6)) _inst_7 _inst_8] {t : Finset.{u2} W}, (LT.lt.{0} Nat instLTNat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u1, u2} L W (StrictOrderedSemiring.toSemiring.{u1} L (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} L (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} L (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6))))) _inst_7 _inst_8) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Finset.card.{u2} W t)) -> (Exists.{max (succ u2) (succ u1)} (W -> L) (fun (f : W -> L) => And (Eq.{succ u2} W (Finset.sum.{u2, u2} W W (AddCommGroup.toAddCommMonoid.{u2} W _inst_7) t (fun (e : W) => HSMul.hSMul.{u1, u2, u2} L W W (instHSMul.{u1, u2} L W (SMulZeroClass.toSMul.{u1, u2} L W (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_7))))) (SMulWithZero.toSMulZeroClass.{u1, u2} L W (CommMonoidWithZero.toZero.{u1} L (CommGroupWithZero.toCommMonoidWithZero.{u1} L (Semifield.toCommGroupWithZero.{u1} L (LinearOrderedSemifield.toSemifield.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6))))) (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_7))))) (MulActionWithZero.toSMulWithZero.{u1, u2} L W (Semiring.toMonoidWithZero.{u1} L (StrictOrderedSemiring.toSemiring.{u1} L (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} L (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} L (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6)))))) (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_7))))) (Module.toMulActionWithZero.{u1, u2} L W (StrictOrderedSemiring.toSemiring.{u1} L (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} L (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} L (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6))))) (AddCommGroup.toAddCommMonoid.{u2} W _inst_7) _inst_8))))) (f e) e)) (OfNat.ofNat.{u2} W 0 (Zero.toOfNat0.{u2} W (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_7)))))))) (And (Eq.{succ u1} L (Finset.sum.{u1, u2} L W (OrderedCancelAddCommMonoid.toAddCommMonoid.{u1} L (StrictOrderedSemiring.toOrderedCancelAddCommMonoid.{u1} L (LinearOrderedSemiring.toStrictOrderedSemiring.{u1} L (LinearOrderedCommSemiring.toLinearOrderedSemiring.{u1} L (LinearOrderedSemifield.toLinearOrderedCommSemiring.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6)))))) t (fun (e : W) => f e)) (OfNat.ofNat.{u1} L 0 (Zero.toOfNat0.{u1} L (CommMonoidWithZero.toZero.{u1} L (CommGroupWithZero.toCommMonoidWithZero.{u1} L (Semifield.toCommGroupWithZero.{u1} L (LinearOrderedSemifield.toSemifield.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6)))))))) (Exists.{succ u2} W (fun (x : W) => And (Membership.mem.{u2, u2} W (Finset.{u2} W) (Finset.instMembershipFinset.{u2} W) x t) (LT.lt.{u1} L (Preorder.toLT.{u1} L (PartialOrder.toPreorder.{u1} L (StrictOrderedRing.toPartialOrder.{u1} L (LinearOrderedRing.toStrictOrderedRing.{u1} L (LinearOrderedCommRing.toLinearOrderedRing.{u1} L (LinearOrderedField.toLinearOrderedCommRing.{u1} L _inst_6)))))) (OfNat.ofNat.{u1} L 0 (Zero.toOfNat0.{u1} L (CommMonoidWithZero.toZero.{u1} L (CommGroupWithZero.toCommMonoidWithZero.{u1} L (Semifield.toCommGroupWithZero.{u1} L (LinearOrderedSemifield.toSemifield.{u1} L (LinearOrderedField.toLinearOrderedSemifield.{u1} L _inst_6))))))) (f x)))))))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_cardₓ'. -/
/-- A slight strengthening of `exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card`
available when working over an ordered field:
we can ensure a positive coefficient, not just a nonzero coefficient.
-/
theorem exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card [FiniteDimensional L W]
    {t : Finset W} (h : finrank L W + 1 < t.card) :
    ∃ f : W → L, (∑ e in t, f e • e) = 0 ∧ (∑ e in t, f e) = 0 ∧ ∃ x ∈ t, 0 < f x :=
  by
  obtain ⟨f, sum, total, nonzero⟩ := exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card h
  exact ⟨f, Sum, Total, exists_pos_of_sum_zero_of_exists_nonzero f Total nonzero⟩
#align finite_dimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card

end

end

/- warning: finite_dimensional.basis_singleton -> FiniteDimensional.basisSingleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (ι : Type.{u3}) [_inst_6 : Unique.{succ u3} ι], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (forall (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (ι : Type.{u3}) [_inst_6 : Unique.{succ u3} ι], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (forall (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (Basis.{u3, u1, u2} ι K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.basis_singleton FiniteDimensional.basisSingletonₓ'. -/
/-- In a vector space with dimension 1, each set {v} is a basis for `v ≠ 0`. -/
@[simps]
noncomputable def basisSingleton (ι : Type _) [Unique ι] (h : finrank K V = 1) (v : V)
    (hv : v ≠ 0) : Basis ι K V :=
  let b := basisUnique ι h
  let h : b.repr v default ≠ 0 := mt basisUnique.repr_eq_zero_iff.mp hv
  Basis.ofRepr
    { toFun := fun w => Finsupp.single default (b.repr w default / b.repr v default)
      invFun := fun f => f default • v
      map_add' := by simp [add_div]
      map_smul' := by simp [mul_div]
      left_inv := fun w => by
        apply_fun b.repr using b.repr.to_equiv.injective
        apply_fun Equiv.finsuppUnique
        simp only [LinearEquiv.map_smulₛₗ, Finsupp.coe_smul, Finsupp.single_eq_same,
          RingHom.id_apply, smul_eq_mul, Pi.smul_apply, Equiv.finsuppUnique_apply]
        exact div_mul_cancel _ h
      right_inv := fun f => by
        ext
        simp only [LinearEquiv.map_smulₛₗ, Finsupp.coe_smul, Finsupp.single_eq_same,
          RingHom.id_apply, smul_eq_mul, Pi.smul_apply]
        exact mul_div_cancel _ h }
#align finite_dimensional.basis_singleton FiniteDimensional.basisSingleton

/- warning: finite_dimensional.basis_singleton_apply -> FiniteDimensional.basisSingleton_apply is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (ι : Type.{u3}) [_inst_6 : Unique.{succ u3} ι] (h : Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (v : V) (hv : Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) (i : ι), Eq.{succ u2} V (coeFn.{max (succ u3) (succ u1) (succ u2), max (succ u3) (succ u2)} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (fun (_x : Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) => ι -> V) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u2), succ u3, succ u2} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (fun (_x : ι) => V) (Basis.funLike.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (FiniteDimensional.basisSingleton.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h v hv) i) v
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] (ι : Type.{u1}) [_inst_6 : Unique.{succ u1} ι] (h : Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (v : V) (hv : Ne.{succ u3} V v (OfNat.ofNat.{u3} V 0 (Zero.toOfNat0.{u3} V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2)))))))) (i : ι), Eq.{succ u3} ((fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) i) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u1, succ u3} (Basis.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) _x) (Basis.funLike.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (FiniteDimensional.basisSingleton.{u2, u3, u1} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h v hv) i) v
Case conversion may be inaccurate. Consider using '#align finite_dimensional.basis_singleton_apply FiniteDimensional.basisSingleton_applyₓ'. -/
@[simp]
theorem basisSingleton_apply (ι : Type _) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0)
    (i : ι) : basisSingleton ι h v hv i = v :=
  by
  cases Unique.uniq ‹Unique ι› i
  simp [basis_singleton]
#align finite_dimensional.basis_singleton_apply FiniteDimensional.basisSingleton_apply

/- warning: finite_dimensional.range_basis_singleton -> FiniteDimensional.range_basisSingleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (ι : Type.{u3}) [_inst_6 : Unique.{succ u3} ι] (h : Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (v : V) (hv : Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))), Eq.{succ u2} (Set.{u2} V) (Set.range.{u2, succ u3} V ι (coeFn.{max (succ u3) (succ u1) (succ u2), max (succ u3) (succ u2)} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (fun (_x : Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) => ι -> V) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u2), succ u3, succ u2} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (fun (_x : ι) => V) (Basis.funLike.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (FiniteDimensional.basisSingleton.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h v hv))) (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) v)
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] (ι : Type.{u1}) [_inst_6 : Unique.{succ u1} ι] (h : Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (v : V) (hv : Ne.{succ u3} V v (OfNat.ofNat.{u3} V 0 (Zero.toOfNat0.{u3} V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2)))))))), Eq.{succ u3} (Set.{u3} V) (Set.range.{u3, succ u1} V ι (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u1, succ u3} (Basis.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) _x) (Basis.funLike.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (FiniteDimensional.basisSingleton.{u2, u3, u1} K V _inst_1 _inst_2 _inst_3 ι _inst_6 h v hv))) (Singleton.singleton.{u3, u3} V (Set.{u3} V) (Set.instSingletonSet.{u3} V) v)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.range_basis_singleton FiniteDimensional.range_basisSingletonₓ'. -/
@[simp]
theorem range_basisSingleton (ι : Type _) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) :
    Set.range (basisSingleton ι h v hv) = {v} := by rw [Set.range_unique, basis_singleton_apply]
#align finite_dimensional.range_basis_singleton FiniteDimensional.range_basisSingleton

end DivisionRing

end FiniteDimensional

variable {K V}

section ZeroRank

variable [DivisionRing K] [AddCommGroup V] [Module K V]

open FiniteDimensional

/- warning: finite_dimensional_of_rank_eq_nat -> finiteDimensional_of_rank_eq_nat is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ((fun (a : Type) (b : Type.{succ u2}) [self : HasLiftT.{1, succ (succ u2)} a b] => self.0) Nat Cardinal.{u2} (HasLiftT.mk.{1, succ (succ u2)} Nat Cardinal.{u2} (CoeTCₓ.coe.{1, succ (succ u2)} Nat Cardinal.{u2} (Nat.castCoe.{succ u2} Cardinal.{u2} Cardinal.hasNatCast.{u2}))) n)) -> (FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {n : Nat}, (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Nat.cast.{succ u2} Cardinal.{u2} Cardinal.instNatCastCardinal.{u2} n)) -> (FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3)
Case conversion may be inaccurate. Consider using '#align finite_dimensional_of_rank_eq_nat finiteDimensional_of_rank_eq_natₓ'. -/
theorem finiteDimensional_of_rank_eq_nat {n : ℕ} (h : Module.rank K V = n) :
    FiniteDimensional K V :=
  by
  rw [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_rank_lt_aleph0, h]
  exact nat_lt_aleph_0 n
#align finite_dimensional_of_rank_eq_nat finiteDimensional_of_rank_eq_nat

#print finiteDimensional_of_rank_eq_zero /-
-- TODO: generalize to free modules over general rings.
theorem finiteDimensional_of_rank_eq_zero (h : Module.rank K V = 0) : FiniteDimensional K V :=
  finiteDimensional_of_rank_eq_nat <| h.trans Nat.cast_zero.symm
#align finite_dimensional_of_rank_eq_zero finiteDimensional_of_rank_eq_zero
-/

#print finiteDimensional_of_rank_eq_one /-
theorem finiteDimensional_of_rank_eq_one (h : Module.rank K V = 1) : FiniteDimensional K V :=
  finiteDimensional_of_rank_eq_nat <| h.trans Nat.cast_one.symm
#align finite_dimensional_of_rank_eq_one finiteDimensional_of_rank_eq_one
-/

#print finrank_eq_zero_of_rank_eq_zero /-
theorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) :
    finrank K V = 0 := by
  convert finrank_eq_rank K V
  rw [h]; norm_cast
#align finrank_eq_zero_of_rank_eq_zero finrank_eq_zero_of_rank_eq_zero
-/

variable (K V)

/- warning: finite_dimensional_bot -> finiteDimensional_bot is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u2}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align finite_dimensional_bot finiteDimensional_botₓ'. -/
instance finiteDimensional_bot : FiniteDimensional K (⊥ : Submodule K V) :=
  finiteDimensional_of_rank_eq_zero <| by simp
#align finite_dimensional_bot finiteDimensional_bot

variable {K V}

/- warning: bot_eq_top_of_rank_eq_zero -> bot_eq_top_of_rank_eq_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OfNat.ofNat.{succ u2} Cardinal.{u2} 0 (OfNat.mk.{succ u2} Cardinal.{u2} 0 (Zero.zero.{succ u2} Cardinal.{u2} Cardinal.hasZero.{u2})))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OfNat.ofNat.{succ u2} Cardinal.{u2} 0 (Zero.toOfNat0.{succ u2} Cardinal.{u2} Cardinal.instZeroCardinal.{u2}))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align bot_eq_top_of_rank_eq_zero bot_eq_top_of_rank_eq_zeroₓ'. -/
theorem bot_eq_top_of_rank_eq_zero (h : Module.rank K V = 0) : (⊥ : Submodule K V) = ⊤ :=
  by
  haveI := finiteDimensional_of_rank_eq_zero h
  apply eq_top_of_finrank_eq
  rw [finrank_bot, finrank_eq_zero_of_rank_eq_zero h]
#align bot_eq_top_of_rank_eq_zero bot_eq_top_of_rank_eq_zero

/- warning: rank_eq_zero -> rank_eq_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, Iff (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommMonoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 0 (OfNat.mk.{succ u2} Cardinal.{u2} 0 (Zero.zero.{succ u2} Cardinal.{u2} Cardinal.hasZero.{u2})))) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, Iff (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommMonoid.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 0 (Zero.toOfNat0.{succ u2} Cardinal.{u2} Cardinal.instZeroCardinal.{u2}))) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align rank_eq_zero rank_eq_zeroₓ'. -/
@[simp]
theorem rank_eq_zero {S : Submodule K V} : Module.rank K S = 0 ↔ S = ⊥ :=
  ⟨fun h =>
    (Submodule.eq_bot_iff _).2 fun x hx =>
      congr_arg Subtype.val <|
        ((Submodule.eq_bot_iff _).1 <| Eq.symm <| bot_eq_top_of_rank_eq_zero h) ⟨x, hx⟩
          Submodule.mem_top,
    fun h => by rw [h, rank_bot]⟩
#align rank_eq_zero rank_eq_zero

/- warning: finrank_eq_zero -> finrank_eq_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_4 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_4 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align finrank_eq_zero finrank_eq_zeroₓ'. -/
@[simp]
theorem finrank_eq_zero {S : Submodule K V} [FiniteDimensional K S] : finrank K S = 0 ↔ S = ⊥ := by
  rw [← rank_eq_zero, ← finrank_eq_rank, ← @Nat.cast_zero Cardinal, Cardinal.natCast_inj]
#align finrank_eq_zero finrank_eq_zero

end ZeroRank

namespace Submodule

open IsNoetherian FiniteDimensional

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V]

#print Submodule.fg_iff_finiteDimensional /-
/-- A submodule is finitely generated if and only if it is finite-dimensional -/
theorem fg_iff_finiteDimensional (s : Submodule K V) : s.FG ↔ FiniteDimensional K s :=
  ⟨fun h => Module.finite_def.2 <| (fg_top s).2 h, fun h => (fg_top s).1 <| Module.finite_def.1 h⟩
#align submodule.fg_iff_finite_dimensional Submodule.fg_iff_finiteDimensional
-/

/- warning: submodule.finite_dimensional_of_le -> Submodule.finiteDimensional_of_le is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_4 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₁) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_4 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₁)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁))
Case conversion may be inaccurate. Consider using '#align submodule.finite_dimensional_of_le Submodule.finiteDimensional_of_leₓ'. -/
/-- A submodule contained in a finite-dimensional submodule is
finite-dimensional. -/
theorem finiteDimensional_of_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (h : S₁ ≤ S₂) :
    FiniteDimensional K S₁ :=
  haveI : IsNoetherian K S₂ := iff_fg.2 inferInstance
  iff_fg.1
    (IsNoetherian.iff_rank_lt_aleph0.2
      (lt_of_le_of_lt (rank_le_of_submodule _ _ h) (FiniteDimensional.rank_lt_aleph0 K S₂)))
#align submodule.finite_dimensional_of_le Submodule.finiteDimensional_of_le

#print Submodule.finiteDimensional_inf_left /-
/-- The inf of two submodules, the first finite-dimensional, is
finite-dimensional. -/
instance finiteDimensional_inf_left (S₁ S₂ : Submodule K V) [FiniteDimensional K S₁] :
    FiniteDimensional K (S₁ ⊓ S₂ : Submodule K V) :=
  finiteDimensional_of_le inf_le_left
#align submodule.finite_dimensional_inf_left Submodule.finiteDimensional_inf_left
-/

#print Submodule.finiteDimensional_inf_right /-
/-- The inf of two submodules, the second finite-dimensional, is
finite-dimensional. -/
instance finiteDimensional_inf_right (S₁ S₂ : Submodule K V) [FiniteDimensional K S₂] :
    FiniteDimensional K (S₁ ⊓ S₂ : Submodule K V) :=
  finiteDimensional_of_le inf_le_right
#align submodule.finite_dimensional_inf_right Submodule.finiteDimensional_inf_right
-/

/- warning: submodule.finite_dimensional_sup -> Submodule.finiteDimensional_sup is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (S₁ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (S₂ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) [h₁ : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₁) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁)] [h₂ : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂)) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (S₁ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (S₂ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) [h₁ : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₁)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁)] [h₂ : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂)) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂))
Case conversion may be inaccurate. Consider using '#align submodule.finite_dimensional_sup Submodule.finiteDimensional_supₓ'. -/
/-- The sup of two finite-dimensional submodules is
finite-dimensional. -/
instance finiteDimensional_sup (S₁ S₂ : Submodule K V) [h₁ : FiniteDimensional K S₁]
    [h₂ : FiniteDimensional K S₂] : FiniteDimensional K (S₁ ⊔ S₂ : Submodule K V) :=
  by
  unfold FiniteDimensional at *
  rw [finite_def] at *
  exact (fg_top _).2 (((fg_top S₁).1 h₁).sup ((fg_top S₂).1 h₂))
#align submodule.finite_dimensional_sup Submodule.finiteDimensional_sup

/- warning: submodule.finite_dimensional_finset_sup -> Submodule.finiteDimensional_finset_sup is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (S : ι -> (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) [_inst_4 : forall (i : ι), FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (S i)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (S i)) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (S i))], FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.orderBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.orderBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S)) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.orderBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} (s : Finset.{u3} ι) (S : ι -> (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) [_inst_4 : forall (i : ι), FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (S i))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (S i)) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (S i))], FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S)) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Finset.sup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s S))
Case conversion may be inaccurate. Consider using '#align submodule.finite_dimensional_finset_sup Submodule.finiteDimensional_finset_supₓ'. -/
/-- The submodule generated by a finite supremum of finite dimensional submodules is
finite-dimensional.

Note that strictly this only needs `∀ i ∈ s, finite_dimensional K (S i)`, but that doesn't
work well with typeclass search. -/
instance finiteDimensional_finset_sup {ι : Type _} (s : Finset ι) (S : ι → Submodule K V)
    [∀ i, FiniteDimensional K (S i)] : FiniteDimensional K (s.sup S : Submodule K V) :=
  by
  refine'
    @Finset.sup_induction _ _ _ _ s S (fun i => FiniteDimensional K ↥i) (finiteDimensional_bot K V)
      _ fun i hi => by infer_instance
  · intro S₁ hS₁ S₂ hS₂
    exact Submodule.finiteDimensional_sup S₁ S₂
#align submodule.finite_dimensional_finset_sup Submodule.finiteDimensional_finset_sup

/- warning: submodule.finite_dimensional_supr -> Submodule.finiteDimensional_iSup is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Sort.{u3}} [_inst_4 : Finite.{u3} ι] (S : ι -> (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) [_inst_5 : forall (i : ι), FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (S i)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (S i)) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (S i))], FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (iSup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (iSup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (iSup.{u2, u3} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Sort.{u3}} [_inst_4 : Finite.{u3} ι] (S : ι -> (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) [_inst_5 : forall (i : ι), FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (S i))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (S i)) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (S i))], FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (iSup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i)))) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (iSup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i))) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (iSup.{u2, u3} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toSupSet.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) ι (fun (i : ι) => S i)))
Case conversion may be inaccurate. Consider using '#align submodule.finite_dimensional_supr Submodule.finiteDimensional_iSupₓ'. -/
/-- The submodule generated by a supremum of finite dimensional submodules, indexed by a finite
sort is finite-dimensional. -/
instance finiteDimensional_iSup {ι : Sort _} [Finite ι] (S : ι → Submodule K V)
    [∀ i, FiniteDimensional K (S i)] : FiniteDimensional K ↥(⨆ i, S i) :=
  by
  cases nonempty_fintype (PLift ι)
  rw [← iSup_plift_down, ← Finset.sup_univ_eq_iSup]
  exact Submodule.finiteDimensional_finset_sup _ _
#align submodule.finite_dimensional_supr Submodule.finiteDimensional_iSup

#print Submodule.finrank_quotient_add_finrank /-
/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding
quotient add up to the dimension of the space. -/
theorem finrank_quotient_add_finrank [FiniteDimensional K V] (s : Submodule K V) :
    finrank K (V ⧸ s) + finrank K s = finrank K V :=
  by
  have := rank_quotient_add_rank s
  rw [← finrank_eq_rank, ← finrank_eq_rank, ← finrank_eq_rank] at this
  exact_mod_cast this
#align submodule.finrank_quotient_add_finrank Submodule.finrank_quotient_add_finrank
-/

/- warning: submodule.finrank_lt -> Submodule.finrank_lt is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) -> (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {s : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (LT.lt.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) -> (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3))
Case conversion may be inaccurate. Consider using '#align submodule.finrank_lt Submodule.finrank_ltₓ'. -/
/-- The dimension of a strict submodule is strictly bounded by the dimension of the ambient
space. -/
theorem finrank_lt [FiniteDimensional K V] {s : Submodule K V} (h : s < ⊤) :
    finrank K s < finrank K V :=
  by
  rw [← s.finrank_quotient_add_finrank, add_comm]
  exact Nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))
#align submodule.finrank_lt Submodule.finrank_lt

#print Submodule.finrank_sup_add_finrank_inf_eq /-
/-- The sum of the dimensions of s + t and s ∩ t is the sum of the dimensions of s and t -/
theorem finrank_sup_add_finrank_inf_eq (s t : Submodule K V) [FiniteDimensional K s]
    [FiniteDimensional K t] :
    finrank K ↥(s ⊔ t) + finrank K ↥(s ⊓ t) = finrank K ↥s + finrank K ↥t :=
  by
  have key : Module.rank K ↥(s ⊔ t) + Module.rank K ↥(s ⊓ t) = Module.rank K s + Module.rank K t :=
    rank_sup_add_rank_inf_eq s t
  repeat' rw [← finrank_eq_rank] at key
  norm_cast  at key
  exact key
#align submodule.finrank_sup_add_finrank_inf_eq Submodule.finrank_sup_add_finrank_inf_eq
-/

/- warning: submodule.finrank_add_le_finrank_add_finrank -> Submodule.finrank_add_le_finrank_add_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) [_inst_4 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)] [_inst_5 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)], LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t)) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (s : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (t : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) [_inst_4 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)] [_inst_5 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)], LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t))) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t)) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t))) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)))
Case conversion may be inaccurate. Consider using '#align submodule.finrank_add_le_finrank_add_finrank Submodule.finrank_add_le_finrank_add_finrankₓ'. -/
theorem finrank_add_le_finrank_add_finrank (s t : Submodule K V) [FiniteDimensional K s]
    [FiniteDimensional K t] : finrank K (s ⊔ t : Submodule K V) ≤ finrank K s + finrank K t :=
  by
  rw [← finrank_sup_add_finrank_inf_eq]
  exact self_le_add_right _ _
#align submodule.finrank_add_le_finrank_add_finrank Submodule.finrank_add_le_finrank_add_finrank

/- warning: submodule.eq_top_of_disjoint -> Submodule.eq_top_of_disjoint is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Disjoint.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.orderBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s t) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Sup.sup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toHasSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (s : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (t : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3), (Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t))) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Disjoint.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) s t) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Sup.sup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilatticeSup.toSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Lattice.toSemilatticeSup.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (ConditionallyCompleteLattice.toLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toConditionallyCompleteLattice.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.eq_top_of_disjoint Submodule.eq_top_of_disjointₓ'. -/
theorem eq_top_of_disjoint [FiniteDimensional K V] (s t : Submodule K V)
    (hdim : finrank K s + finrank K t = finrank K V) (hdisjoint : Disjoint s t) : s ⊔ t = ⊤ :=
  by
  have h_finrank_inf : finrank K ↥(s ⊓ t) = 0 :=
    by
    rw [disjoint_iff_inf_le, le_bot_iff] at hdisjoint
    rw [hdisjoint, finrank_bot]
  apply eq_top_of_finrank_eq
  rw [← hdim]
  convert s.finrank_sup_add_finrank_inf_eq t
  rw [h_finrank_inf]
  rfl
#align submodule.eq_top_of_disjoint Submodule.eq_top_of_disjoint

end DivisionRing

end Submodule

namespace LinearEquiv

open FiniteDimensional

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

#print LinearEquiv.finiteDimensional /-
/-- Finite dimensionality is preserved under linear equivalence. -/
protected theorem finiteDimensional (f : V ≃ₗ[K] V₂) [FiniteDimensional K V] :
    FiniteDimensional K V₂ :=
  Module.Finite.equiv f
#align linear_equiv.finite_dimensional LinearEquiv.finiteDimensional
-/

variable {R M M₂ : Type _} [Ring R] [AddCommGroup M] [AddCommGroup M₂]

variable [Module R M] [Module R M₂]

end LinearEquiv

section

variable [DivisionRing K] [AddCommGroup V] [Module K V]

/- warning: finite_dimensional_finsupp -> finiteDimensional_finsupp is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Finite.{succ u3} ι] [h : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], FiniteDimensional.{u1, max u3 u2} K (Finsupp.{u3, u2} ι V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))) _inst_1 (Finsupp.addCommGroup.{u3, u2} ι V _inst_2) (Finsupp.module.{u3, u2, u1} ι V K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Finite.{succ u3} ι] [h : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], FiniteDimensional.{u1, max u2 u3} K (Finsupp.{u3, u2} ι V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))) _inst_1 (Finsupp.addCommGroup.{u3, u2} ι V _inst_2) (Finsupp.module.{u3, u2, u1} ι V K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)
Case conversion may be inaccurate. Consider using '#align finite_dimensional_finsupp finiteDimensional_finsuppₓ'. -/
instance finiteDimensional_finsupp {ι : Type _} [Finite ι] [h : FiniteDimensional K V] :
    FiniteDimensional K (ι →₀ V) :=
  (Finsupp.linearEquivFunOnFinite K V ι).symm.FiniteDimensional
#align finite_dimensional_finsupp finiteDimensional_finsupp

end

namespace FiniteDimensional

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

/- warning: finite_dimensional.eq_of_le_of_finrank_le -> FiniteDimensional.eq_of_le_of_finrank_le is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₁) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S₁ S₂)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₁)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S₁ S₂)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.eq_of_le_of_finrank_le FiniteDimensional.eq_of_le_of_finrank_leₓ'. -/
theorem eq_of_le_of_finrank_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)
    (hd : finrank K S₂ ≤ finrank K S₁) : S₁ = S₂ :=
  by
  rw [← LinearEquiv.finrank_eq (Submodule.comapSubtypeEquivOfLe hle)] at hd
  exact
    le_antisymm hle
      (Submodule.comap_subtype_eq_top.1
        (eq_top_of_finrank_eq (le_antisymm (comap (Submodule.subtype S₂) S₁).finrank_le hd)))
#align finite_dimensional.eq_of_le_of_finrank_le FiniteDimensional.eq_of_le_of_finrank_le

/- warning: finite_dimensional.eq_of_le_of_finrank_eq -> FiniteDimensional.eq_of_le_of_finrank_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₁) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S₂) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S₁ S₂)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {S₁ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {S₂ : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂)], (LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) S₁ S₂) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₁)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₁) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₁)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S₂)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S₂) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S₂))) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S₁ S₂)
Case conversion may be inaccurate. Consider using '#align finite_dimensional.eq_of_le_of_finrank_eq FiniteDimensional.eq_of_le_of_finrank_eqₓ'. -/
/-- If a submodule is less than or equal to a finite-dimensional
submodule with the same dimension, they are equal. -/
theorem eq_of_le_of_finrank_eq {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)
    (hd : finrank K S₁ = finrank K S₂) : S₁ = S₂ :=
  eq_of_le_of_finrank_le hle hd.ge
#align finite_dimensional.eq_of_le_of_finrank_eq FiniteDimensional.eq_of_le_of_finrank_eq

variable [FiniteDimensional K V] [FiniteDimensional K V₂]

#print FiniteDimensional.LinearEquiv.quotEquivOfEquiv /-
/-- Given isomorphic subspaces `p q` of vector spaces `V` and `V₁` respectively,
  `p.quotient` is isomorphic to `q.quotient`. -/
noncomputable def LinearEquiv.quotEquivOfEquiv {p : Subspace K V} {q : Subspace K V₂}
    (f₁ : p ≃ₗ[K] q) (f₂ : V ≃ₗ[K] V₂) : (V ⧸ p) ≃ₗ[K] V₂ ⧸ q :=
  LinearEquiv.ofFinrankEq _ _
    (by
      rw [← @add_right_cancel_iff _ _ _ (finrank K p), Submodule.finrank_quotient_add_finrank,
        LinearEquiv.finrank_eq f₁, Submodule.finrank_quotient_add_finrank,
        LinearEquiv.finrank_eq f₂])
#align finite_dimensional.linear_equiv.quot_equiv_of_equiv FiniteDimensional.LinearEquiv.quotEquivOfEquiv
-/

#print FiniteDimensional.LinearEquiv.quotEquivOfQuotEquiv /-
-- TODO: generalize to the case where one of `p` and `q` is finite-dimensional.
/-- Given the subspaces `p q`, if `p.quotient ≃ₗ[K] q`, then `q.quotient ≃ₗ[K] p` -/
noncomputable def LinearEquiv.quotEquivOfQuotEquiv {p q : Subspace K V} (f : (V ⧸ p) ≃ₗ[K] q) :
    (V ⧸ q) ≃ₗ[K] p :=
  LinearEquiv.ofFinrankEq _ _ <|
    add_right_cancel <| by
      rw [Submodule.finrank_quotient_add_finrank, ← LinearEquiv.finrank_eq f, add_comm,
        Submodule.finrank_quotient_add_finrank]
#align finite_dimensional.linear_equiv.quot_equiv_of_quot_equiv FiniteDimensional.LinearEquiv.quotEquivOfQuotEquiv
-/

end DivisionRing

end FiniteDimensional

namespace LinearMap

open FiniteDimensional

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

/- warning: linear_map.surjective_of_injective -> LinearMap.surjective_of_injective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, (Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) -> (Function.Surjective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, (Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) -> (Function.Surjective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f))
Case conversion may be inaccurate. Consider using '#align linear_map.surjective_of_injective LinearMap.surjective_of_injectiveₓ'. -/
/-- On a finite-dimensional space, an injective linear map is surjective. -/
theorem surjective_of_injective [FiniteDimensional K V] {f : V →ₗ[K] V} (hinj : Injective f) :
    Surjective f := by
  have h := rank_eq_of_injective _ hinj
  rw [← finrank_eq_rank, ← finrank_eq_rank, nat_cast_inj] at h
  exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)
#align linear_map.surjective_of_injective LinearMap.surjective_of_injective

/- warning: linear_map.finite_dimensional_of_surjective -> LinearMap.finiteDimensional_of_surjective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Eq.{succ u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) f) (Top.top.{u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (Submodule.hasTop.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5))) -> (FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Eq.{succ u3} (Submodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) f) (Top.top.{u3} (Submodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (Submodule.instTopSubmodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5))) -> (FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_map.finite_dimensional_of_surjective LinearMap.finiteDimensional_of_surjectiveₓ'. -/
/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/
theorem finiteDimensional_of_surjective [FiniteDimensional K V] (f : V →ₗ[K] V₂)
    (hf : f.range = ⊤) : FiniteDimensional K V₂ :=
  Module.Finite.of_surjective f <| range_eq_top.1 hf
#align linear_map.finite_dimensional_of_surjective LinearMap.finiteDimensional_of_surjective

#print LinearMap.finiteDimensional_range /-
/-- The range of a linear map defined on a finite-dimensional space is also finite-dimensional. -/
instance finiteDimensional_range [FiniteDimensional K V] (f : V →ₗ[K] V₂) :
    FiniteDimensional K f.range :=
  Module.Finite.range f
#align linear_map.finite_dimensional_range LinearMap.finiteDimensional_range
-/

/- warning: linear_map.injective_iff_surjective -> LinearMap.injective_iff_surjective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, Iff (Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) (Function.Surjective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, Iff (Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) (Function.Surjective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f))
Case conversion may be inaccurate. Consider using '#align linear_map.injective_iff_surjective LinearMap.injective_iff_surjectiveₓ'. -/
/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/
theorem injective_iff_surjective [FiniteDimensional K V] {f : V →ₗ[K] V} :
    Injective f ↔ Surjective f :=
  ⟨surjective_of_injective, fun hsurj =>
    let ⟨g, hg⟩ := f.exists_rightInverse_of_surjective (range_eq_top.2 hsurj)
    have : Function.RightInverse g f := LinearMap.ext_iff.1 hg
    (leftInverse_of_surjective_of_rightInverse (surjective_of_injective this.Injective)
        this).Injective⟩
#align linear_map.injective_iff_surjective LinearMap.injective_iff_surjective

/- warning: linear_map.ker_eq_bot_iff_range_eq_top -> LinearMap.ker_eq_bot_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, Iff (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.range.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) f) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3}, Iff (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.range.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) f) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_eq_bot_iff_range_eq_top LinearMap.ker_eq_bot_iff_range_eq_topₓ'. -/
theorem ker_eq_bot_iff_range_eq_top [FiniteDimensional K V] {f : V →ₗ[K] V} :
    f.ker = ⊥ ↔ f.range = ⊤ := by rw [range_eq_top, ker_eq_bot, injective_iff_surjective]
#align linear_map.ker_eq_bot_iff_range_eq_top LinearMap.ker_eq_bot_iff_range_eq_top

#print LinearMap.mul_eq_one_of_mul_eq_one /-
/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they
are also inverse to each other on the other side. -/
theorem mul_eq_one_of_mul_eq_one [FiniteDimensional K V] {f g : V →ₗ[K] V} (hfg : f * g = 1) :
    g * f = 1 :=
  by
  have ginj : Injective g :=
    HasLeftInverse.injective ⟨f, fun x => show (f * g) x = (1 : V →ₗ[K] V) x by rw [hfg] <;> rfl⟩
  let ⟨i, hi⟩ :=
    g.exists_rightInverse_of_surjective (range_eq_top.2 (injective_iff_surjective.1 ginj))
  have : f * (g * i) = f * 1 := congr_arg _ hi
  rw [← mul_assoc, hfg, one_mul, mul_one] at this <;> rwa [← this]
#align linear_map.mul_eq_one_of_mul_eq_one LinearMap.mul_eq_one_of_mul_eq_one
-/

#print LinearMap.mul_eq_one_comm /-
/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if
they are inverse to each other on the other side. -/
theorem mul_eq_one_comm [FiniteDimensional K V] {f g : V →ₗ[K] V} : f * g = 1 ↔ g * f = 1 :=
  ⟨mul_eq_one_of_mul_eq_one, mul_eq_one_of_mul_eq_one⟩
#align linear_map.mul_eq_one_comm LinearMap.mul_eq_one_comm
-/

#print LinearMap.comp_eq_id_comm /-
/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if
they are inverse to each other on the other side. -/
theorem comp_eq_id_comm [FiniteDimensional K V] {f g : V →ₗ[K] V} : f.comp g = id ↔ g.comp f = id :=
  mul_eq_one_comm
#align linear_map.comp_eq_id_comm LinearMap.comp_eq_id_comm
-/

#print LinearMap.finrank_range_add_finrank_ker /-
/-- rank-nullity theorem : the dimensions of the kernel and the range of a linear map add up to
the dimension of the source space. -/
theorem finrank_range_add_finrank_ker [FiniteDimensional K V] (f : V →ₗ[K] V₂) :
    finrank K f.range + finrank K f.ker = finrank K V :=
  by
  rw [← f.quot_ker_equiv_range.finrank_eq]
  exact Submodule.finrank_quotient_add_finrank _
#align linear_map.finrank_range_add_finrank_ker LinearMap.finrank_range_add_finrank_ker
-/

end DivisionRing

end LinearMap

namespace LinearEquiv

open FiniteDimensional

variable [DivisionRing K] [AddCommGroup V] [Module K V]

variable [FiniteDimensional K V]

/- warning: linear_equiv.of_injective_endo -> LinearEquiv.ofInjectiveEndo is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), (Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) -> (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), (Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) -> (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3)
Case conversion may be inaccurate. Consider using '#align linear_equiv.of_injective_endo LinearEquiv.ofInjectiveEndoₓ'. -/
/-- The linear equivalence corresponging to an injective endomorphism. -/
noncomputable def ofInjectiveEndo (f : V →ₗ[K] V) (h_inj : Injective f) : V ≃ₗ[K] V :=
  LinearEquiv.ofBijective f ⟨h_inj, LinearMap.injective_iff_surjective.mp h_inj⟩
#align linear_equiv.of_injective_endo LinearEquiv.ofInjectiveEndo

/- warning: linear_equiv.coe_of_injective_endo -> LinearEquiv.coe_ofInjectiveEndo is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)), Eq.{succ u2} (V -> V) (coeFn.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1)) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj)) (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)), Eq.{succ u2} (forall (ᾰ : V), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V) => V) ᾰ) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V) => V) _x) (SMulHomClass.toFunLike.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) K V V (SMulZeroClass.toSMul.{u1, u2} K V (AddMonoid.toZero.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} K V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} K V (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u1, u2} K V (AddMonoid.toZero.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} K V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} K V (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (DistribMulActionHomClass.toSMulHomClass.{u2, u1, u2, u2} (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) K V V (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u2, u2} K V V (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u2, u2} K K V V (LinearEquiv.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj)) (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)
Case conversion may be inaccurate. Consider using '#align linear_equiv.coe_of_injective_endo LinearEquiv.coe_ofInjectiveEndoₓ'. -/
@[simp]
theorem coe_ofInjectiveEndo (f : V →ₗ[K] V) (h_inj : Injective f) :
    ⇑(ofInjectiveEndo f h_inj) = f :=
  rfl
#align linear_equiv.coe_of_injective_endo LinearEquiv.coe_ofInjectiveEndo

/- warning: linear_equiv.of_injective_endo_right_inv -> LinearEquiv.ofInjectiveEndo_right_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)), Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.module.End.hasMul.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) f ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HasLiftT.mk.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (CoeTCₓ.coe.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (coeBase.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1))))) (LinearEquiv.symm.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj)))) (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (OfNat.mk.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (One.one.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.module.End.hasOne.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)), Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.instMulEnd.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) f (LinearEquiv.toLinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj)))) (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (One.toOfNat1.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.instOneEnd.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_equiv.of_injective_endo_right_inv LinearEquiv.ofInjectiveEndo_right_invₓ'. -/
@[simp]
theorem ofInjectiveEndo_right_inv (f : V →ₗ[K] V) (h_inj : Injective f) :
    f * (ofInjectiveEndo f h_inj).symm = 1 :=
  LinearMap.ext <| (ofInjectiveEndo f h_inj).apply_symm_apply
#align linear_equiv.of_injective_endo_right_inv LinearEquiv.ofInjectiveEndo_right_inv

/- warning: linear_equiv.of_injective_endo_left_inv -> LinearEquiv.ofInjectiveEndo_left_inv is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (coeFn.{succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (fun (_x : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) => V -> V) (LinearMap.hasCoeToFun.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)), Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.module.End.hasMul.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HasLiftT.mk.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (CoeTCₓ.coe.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (coeBase.{succ u2, succ u2} (LinearEquiv.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearEquiv.LinearMap.hasCoe.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1))))) (LinearEquiv.symm.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearEquiv.ofInjectiveEndo._proof_1.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo._proof_2.{u1} K _inst_1) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj))) f) (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (OfNat.mk.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (One.one.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.module.End.hasOne.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (h_inj : Function.Injective.{succ u2, succ u2} V V (FunLike.coe.{succ u2, succ u2, succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)), Eq.{succ u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (HMul.hMul.{u2, u2, u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (instHMul.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.instMulEnd.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (LinearEquiv.toLinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (LinearEquiv.symm.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (LinearEquiv.ofInjectiveEndo.{u1, u2} K V _inst_1 _inst_2 _inst_3 _inst_4 f h_inj))) f) (OfNat.ofNat.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) 1 (One.toOfNat1.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.instOneEnd.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_equiv.of_injective_endo_left_inv LinearEquiv.ofInjectiveEndo_left_invₓ'. -/
@[simp]
theorem ofInjectiveEndo_left_inv (f : V →ₗ[K] V) (h_inj : Injective f) :
    ((ofInjectiveEndo f h_inj).symm : V →ₗ[K] V) * f = 1 :=
  LinearMap.ext <| (ofInjectiveEndo f h_inj).symm_apply_apply
#align linear_equiv.of_injective_endo_left_inv LinearEquiv.ofInjectiveEndo_left_inv

end LinearEquiv

namespace LinearMap

variable [DivisionRing K] [AddCommGroup V] [Module K V]

/- warning: linear_map.is_unit_iff_ker_eq_bot -> LinearMap.isUnit_iff_ker_eq_bot is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), Iff (IsUnit.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (Module.End.monoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) f) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), Iff (IsUnit.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (Module.End.monoid.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) f) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_map.is_unit_iff_ker_eq_bot LinearMap.isUnit_iff_ker_eq_botₓ'. -/
theorem isUnit_iff_ker_eq_bot [FiniteDimensional K V] (f : V →ₗ[K] V) : IsUnit f ↔ f.ker = ⊥ :=
  by
  constructor
  · rintro ⟨u, rfl⟩
    exact LinearMap.ker_eq_bot_of_inverse u.inv_mul
  · intro h_inj
    rw [ker_eq_bot] at h_inj
    exact
      ⟨⟨f, (LinearEquiv.ofInjectiveEndo f h_inj).symm.toLinearMap,
          LinearEquiv.ofInjectiveEndo_right_inv f h_inj,
          LinearEquiv.ofInjectiveEndo_left_inv f h_inj⟩,
        rfl⟩
#align linear_map.is_unit_iff_ker_eq_bot LinearMap.isUnit_iff_ker_eq_bot

/- warning: linear_map.is_unit_iff_range_eq_top -> LinearMap.isUnit_iff_range_eq_top is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), Iff (IsUnit.{u2} (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (Module.End.monoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) f) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.range.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) f) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3), Iff (IsUnit.{u2} (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (Module.End.monoid.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) f) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.range.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u2} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) f) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align linear_map.is_unit_iff_range_eq_top LinearMap.isUnit_iff_range_eq_topₓ'. -/
theorem isUnit_iff_range_eq_top [FiniteDimensional K V] (f : V →ₗ[K] V) : IsUnit f ↔ f.range = ⊤ :=
  by rw [is_unit_iff_ker_eq_bot, ker_eq_bot_iff_range_eq_top]
#align linear_map.is_unit_iff_range_eq_top LinearMap.isUnit_iff_range_eq_top

end LinearMap

open Module FiniteDimensional

section

variable [DivisionRing K] [AddCommGroup V] [Module K V]

/- warning: finrank_zero_iff_forall_zero -> finrank_zero_iff_forall_zero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (forall (x : V), Eq.{succ u2} V x (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2)))))))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (forall (x : V), Eq.{succ u2} V x (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))))))
Case conversion may be inaccurate. Consider using '#align finrank_zero_iff_forall_zero finrank_zero_iff_forall_zeroₓ'. -/
theorem finrank_zero_iff_forall_zero [FiniteDimensional K V] : finrank K V = 0 ↔ ∀ x : V, x = 0 :=
  finrank_zero_iff.trans (subsingleton_iff_forall_eq 0)
#align finrank_zero_iff_forall_zero finrank_zero_iff_forall_zero

#print basisOfFinrankZero /-
/-- If `ι` is an empty type and `V` is zero-dimensional, there is a unique `ι`-indexed basis. -/
noncomputable def basisOfFinrankZero [FiniteDimensional K V] {ι : Type _} [IsEmpty ι]
    (hV : finrank K V = 0) : Basis ι K V :=
  haveI : Subsingleton V := finrank_zero_iff.1 hV
  Basis.empty _
#align basis_of_finrank_zero basisOfFinrankZero
-/

end

namespace LinearMap

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

/- warning: linear_map.injective_iff_surjective_of_finrank_eq_finrank -> LinearMap.injective_iff_surjective_of_finrank_eq_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_4 _inst_5)) -> (forall {f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, Iff (Function.Injective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) (Function.Surjective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_4 _inst_5)) -> (forall {f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, Iff (Function.Injective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) (Function.Surjective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)))
Case conversion may be inaccurate. Consider using '#align linear_map.injective_iff_surjective_of_finrank_eq_finrank LinearMap.injective_iff_surjective_of_finrank_eq_finrankₓ'. -/
theorem injective_iff_surjective_of_finrank_eq_finrank [FiniteDimensional K V]
    [FiniteDimensional K V₂] (H : finrank K V = finrank K V₂) {f : V →ₗ[K] V₂} :
    Function.Injective f ↔ Function.Surjective f :=
  by
  have := finrank_range_add_finrank_ker f
  rw [← ker_eq_bot, ← range_eq_top]; refine' ⟨fun h => _, fun h => _⟩
  · rw [h, finrank_bot, add_zero, H] at this
    exact eq_top_of_finrank_eq this
  · rw [h, finrank_top, H] at this
    exact finrank_eq_zero.1 (add_right_injective _ this)
#align linear_map.injective_iff_surjective_of_finrank_eq_finrank LinearMap.injective_iff_surjective_of_finrank_eq_finrank

/- warning: linear_map.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank -> LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_4 _inst_5)) -> (forall {f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, Iff (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasBot.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) f) (Top.top.{u3} (Submodule.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (Submodule.hasTop.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_4 _inst_5)) -> (forall {f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5}, Iff (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.ker.{u1, u1, u2, u3, max u2 u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f) (Bot.bot.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instBotSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) (Eq.{succ u3} (Submodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (LinearMap.range.{u1, u1, u2, u3, max u2 u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (LinearMap.semilinearMapClass.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (RingHomSurjective.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) f) (Top.top.{u3} (Submodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (Submodule.instTopSubmodule.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5))))
Case conversion may be inaccurate. Consider using '#align linear_map.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrankₓ'. -/
theorem ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank [FiniteDimensional K V]
    [FiniteDimensional K V₂] (H : finrank K V = finrank K V₂) {f : V →ₗ[K] V₂} :
    f.ker = ⊥ ↔ f.range = ⊤ := by
  rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]
#align linear_map.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank

/- warning: linear_map.linear_equiv_of_injective -> LinearMap.linearEquivOfInjective is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5] (f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Injective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_4 _inst_5)) -> (LinearEquiv.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.linearEquivOfInjective._proof_1.{u1} K _inst_1) (LinearMap.linearEquivOfInjective._proof_2.{u1} K _inst_1) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5] (f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5), (Function.Injective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_4 _inst_5)) -> (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5)
Case conversion may be inaccurate. Consider using '#align linear_map.linear_equiv_of_injective LinearMap.linearEquivOfInjectiveₓ'. -/
/-- Given a linear map `f` between two vector spaces with the same dimension, if
`ker f = ⊥` then `linear_equiv_of_injective` is the induced isomorphism
between the two vector spaces. -/
noncomputable def linearEquivOfInjective [FiniteDimensional K V] [FiniteDimensional K V₂]
    (f : V →ₗ[K] V₂) (hf : Injective f) (hdim : finrank K V = finrank K V₂) : V ≃ₗ[K] V₂ :=
  LinearEquiv.ofBijective f
    ⟨hf, (LinearMap.injective_iff_surjective_of_finrank_eq_finrank hdim).mp hf⟩
#align linear_map.linear_equiv_of_injective LinearMap.linearEquivOfInjective

/- warning: linear_map.linear_equiv_of_injective_apply -> LinearMap.linearEquivOfInjective_apply is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5] {f : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5} (hf : Function.Injective.{succ u2, succ u3} V V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f)) (hdim : Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_4 _inst_5)) (x : V), Eq.{succ u3} V₂ (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearEquiv.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.linearEquivOfInjective._proof_1.{u1} K _inst_1) (LinearMap.linearEquivOfInjective._proof_2.{u1} K _inst_1) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearEquiv.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.linearEquivOfInjective._proof_1.{u1} K _inst_1) (LinearMap.linearEquivOfInjective._proof_2.{u1} K _inst_1) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearEquiv.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (LinearMap.linearEquivOfInjective._proof_1.{u1} K _inst_1) (LinearMap.linearEquivOfInjective._proof_2.{u1} K _inst_1)) (LinearMap.linearEquivOfInjective.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 V₂ _inst_4 _inst_5 _inst_6 _inst_7 f hf hdim) x) (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (fun (_x : LinearMap.{u1, u1, u2, u3} K K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) => V -> V₂) (LinearMap.hasCoeToFun.{u1, u1, u2, u3} K K V V₂ (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) f x)
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {V₂ : Type.{u3}} [_inst_4 : AddCommGroup.{u3} V₂] [_inst_5 : Module.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] [_inst_7 : FiniteDimensional.{u1, u3} K V₂ _inst_1 _inst_4 _inst_5] {f : LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5} (hf : Function.Injective.{succ u2, succ u3} V V₂ (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f)) (hdim : Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (FiniteDimensional.finrank.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_4 _inst_5)) (x : V), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V) => V₂) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : V) => V₂) _x) (SMulHomClass.toFunLike.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) K V V₂ (SMulZeroClass.toSMul.{u1, u2} K V (AddMonoid.toZero.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribSMul.toSMulZeroClass.{u1, u2} K V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2))) (DistribMulAction.toDistribSMul.{u1, u2} K V (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) (SMulZeroClass.toSMul.{u1, u3} K V₂ (AddMonoid.toZero.{u3} V₂ (AddCommMonoid.toAddMonoid.{u3} V₂ (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4))) (DistribSMul.toSMulZeroClass.{u1, u3} K V₂ (AddMonoid.toAddZeroClass.{u3} V₂ (AddCommMonoid.toAddMonoid.{u3} V₂ (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4))) (DistribMulAction.toDistribSMul.{u1, u3} K V₂ (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u3} V₂ (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)) (Module.toDistribMulAction.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5)))) (DistribMulActionHomClass.toSMulHomClass.{max u2 u3, u1, u2, u3} (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) K V V₂ (MonoidWithZero.toMonoid.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)) (AddCommMonoid.toAddMonoid.{u3} V₂ (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4)) (Module.toDistribMulAction.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.toDistribMulAction.{u1, u3} K V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_5) (SemilinearMapClass.distribMulActionHomClass.{u1, u2, u3, max u2 u3} K V V₂ (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (SemilinearEquivClass.instSemilinearMapClass.{u1, u1, u2, u3, max u2 u3} K K V V₂ (LinearEquiv.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (LinearEquiv.instSemilinearEquivClassLinearEquiv.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (RingHomInvPair.ids.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))))))) (LinearMap.linearEquivOfInjective.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 V₂ _inst_4 _inst_5 _inst_6 _inst_7 f hf hdim) x) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (LinearMap.{u1, u1, u2, u3} K K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) V V₂ (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => V₂) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u2, u3} K K V V₂ (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} V₂ _inst_4) _inst_3 _inst_5 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) f x)
Case conversion may be inaccurate. Consider using '#align linear_map.linear_equiv_of_injective_apply LinearMap.linearEquivOfInjective_applyₓ'. -/
@[simp]
theorem linearEquivOfInjective_apply [FiniteDimensional K V] [FiniteDimensional K V₂]
    {f : V →ₗ[K] V₂} (hf : Injective f) (hdim : finrank K V = finrank K V₂) (x : V) :
    f.linearEquivOfInjective hf hdim x = f x :=
  rfl
#align linear_map.linear_equiv_of_injective_apply LinearMap.linearEquivOfInjective_apply

end LinearMap

section

#print divisionRingOfFiniteDimensional /-
/-- A domain that is module-finite as an algebra over a field is a division ring. -/
noncomputable def divisionRingOfFiniteDimensional (F K : Type _) [Field F] [Ring K] [IsDomain K]
    [Algebra F K] [FiniteDimensional F K] : DivisionRing K :=
  { ‹IsDomain K›,
    ‹Ring
        K› with
    inv := fun x =>
      if H : x = 0 then 0
      else
        Classical.choose <|
          (show Function.Surjective (LinearMap.mulLeft F x) from
              LinearMap.injective_iff_surjective.1 fun _ _ => (mul_right_inj' H).1)
            1
    mul_inv_cancel := fun x hx =>
      show x * dite _ _ _ = _ by
        rw [dif_neg hx]
        exact
          Classical.choose_spec
            ((show Function.Surjective (LinearMap.mulLeft F x) from
                LinearMap.injective_iff_surjective.1 fun _ _ => (mul_right_inj' hx).1)
              1)
    inv_zero := dif_pos rfl }
#align division_ring_of_finite_dimensional divisionRingOfFiniteDimensional
-/

#print fieldOfFiniteDimensional /-
/-- An integral domain that is module-finite as an algebra over a field is a field. -/
noncomputable def fieldOfFiniteDimensional (F K : Type _) [Field F] [CommRing K] [IsDomain K]
    [Algebra F K] [FiniteDimensional F K] : Field K :=
  { divisionRingOfFiniteDimensional F K, ‹CommRing K› with }
#align field_of_finite_dimensional fieldOfFiniteDimensional
-/

end

namespace Submodule

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂]
  [Module K V₂]

/- warning: submodule.eq_top_of_finrank_eq -> Submodule.eq_top_of_finrank_eq is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {S : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] {S : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 S) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 S)) (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) S (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align submodule.eq_top_of_finrank_eq Submodule.eq_top_of_finrank_eqₓ'. -/
theorem eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ :=
  FiniteDimensional.eq_of_le_of_finrank_eq le_top (by simp [h, finrank_top])
#align submodule.eq_top_of_finrank_eq Submodule.eq_top_of_finrank_eq

#print Submodule.finrank_mono /-
theorem finrank_mono [FiniteDimensional K V] : Monotone fun s : Submodule K V => finrank K s :=
  fun s t => finrank_le_finrank_of_le
#align submodule.finrank_mono Submodule.finrank_mono
-/

/- warning: submodule.finrank_lt_finrank_of_lt -> Submodule.finrank_lt_finrank_of_lt is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {t : Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)], (LT.lt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLt.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t) -> (LT.lt.{0} Nat Nat.hasLt (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) s) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) t) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {s : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} {t : Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3} [_inst_6 : FiniteDimensional.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) _inst_1 (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)], (LT.lt.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLT.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) s t) -> (LT.lt.{0} Nat instLTNat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x s)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 s) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 s)) (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x t)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 t) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 t)))
Case conversion may be inaccurate. Consider using '#align submodule.finrank_lt_finrank_of_lt Submodule.finrank_lt_finrank_of_ltₓ'. -/
theorem finrank_lt_finrank_of_lt {s t : Submodule K V} [FiniteDimensional K t] (hst : s < t) :
    finrank K s < finrank K t :=
  (comapSubtypeEquivOfLe hst.le).finrank_eq.symm.trans_lt <|
    finrank_lt (le_top.lt_of_ne <| hst.not_le ∘ comap_subtype_eq_top.1)
#align submodule.finrank_lt_finrank_of_lt Submodule.finrank_lt_finrank_of_lt

#print Submodule.finrank_strictMono /-
theorem finrank_strictMono [FiniteDimensional K V] :
    StrictMono fun s : Submodule K V => finrank K s := fun s t => finrank_lt_finrank_of_lt
#align submodule.finrank_strict_mono Submodule.finrank_strictMono
-/

#print Submodule.finrank_add_eq_of_isCompl /-
theorem finrank_add_eq_of_isCompl [FiniteDimensional K V] {U W : Submodule K V} (h : IsCompl U W) :
    finrank K U + finrank K W = finrank K V :=
  by
  rw [← finrank_sup_add_finrank_inf_eq, h.codisjoint.eq_top, h.disjoint.eq_bot, finrank_bot,
    add_zero]
  exact finrank_top _ _
#align submodule.finrank_add_eq_of_is_compl Submodule.finrank_add_eq_of_isCompl
-/

end DivisionRing

end Submodule

section DivisionRing

variable [DivisionRing K] [AddCommGroup V] [Module K V]

section Span

open Submodule

/- warning: finrank_span_singleton -> finrank_span_singleton is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {v : V}, (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) v))) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) v))) (Submodule.module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) v)))) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {v : V}, (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K (Subtype.{succ u2} V (fun (x : V) => Membership.mem.{u2, u2} V (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (SetLike.instMembership.{u2, u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) V (Submodule.setLike.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) x (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) v)))) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (Submodule.addCommGroup.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) v))) (Submodule.module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) v)))) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align finrank_span_singleton finrank_span_singletonₓ'. -/
theorem finrank_span_singleton {v : V} (hv : v ≠ 0) : finrank K (K ∙ v) = 1 :=
  by
  apply le_antisymm
  · exact finrank_span_le_card ({v} : Set V)
  · rw [Nat.succ_le_iff, finrank_pos_iff]
    use ⟨v, mem_span_singleton_self v⟩, 0
    simp [hv]
#align finrank_span_singleton finrank_span_singleton

#print Set.finrank_mono /-
theorem Set.finrank_mono [FiniteDimensional K V] {s t : Set V} (h : s ⊆ t) :
    s.finrank K ≤ t.finrank K :=
  finrank_mono (span_mono h)
#align set.finrank_mono Set.finrank_mono
-/

end Span

section Basis

/- warning: span_eq_top_of_linear_independent_of_card_eq_finrank -> span_eq_top_of_linearIndependent_of_card_eq_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [hι : Nonempty.{succ u3} ι] [_inst_4 : Fintype.{u3} ι] {b : ι -> V}, (LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) -> (Eq.{1} Nat (Fintype.card.{u3} ι _inst_4) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Set.range.{u2, succ u3} V ι b)) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [hι : Nonempty.{succ u1} ι] [_inst_4 : Fintype.{u1} ι] {b : ι -> V}, (LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) -> (Eq.{1} Nat (Fintype.card.{u1} ι _inst_4) (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3)) -> (Eq.{succ u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.span.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3 (Set.range.{u3, succ u1} V ι b)) (Top.top.{u3} (Submodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align span_eq_top_of_linear_independent_of_card_eq_finrank span_eq_top_of_linearIndependent_of_card_eq_finrankₓ'. -/
theorem span_eq_top_of_linearIndependent_of_card_eq_finrank {ι : Type _} [hι : Nonempty ι]
    [Fintype ι] {b : ι → V} (lin_ind : LinearIndependent K b)
    (card_eq : Fintype.card ι = finrank K V) : span K (Set.range b) = ⊤ :=
  by
  by_cases fin : FiniteDimensional K V
  · haveI := Fin
    by_contra ne_top
    have lt_top : span K (Set.range b) < ⊤ := lt_of_le_of_ne le_top ne_top
    exact ne_of_lt (Submodule.finrank_lt lt_top) (trans (finrank_span_eq_card lin_ind) card_eq)
  · exfalso
    apply ne_of_lt (fintype.card_pos_iff.mpr hι)
    symm
    replace fin := (not_iff_not.2 IsNoetherian.iff_fg).2 Fin
    calc
      Fintype.card ι = finrank K V := card_eq
      _ = 0 := dif_neg (mt is_noetherian.iff_rank_lt_aleph_0.mpr Fin)
      
#align span_eq_top_of_linear_independent_of_card_eq_finrank span_eq_top_of_linearIndependent_of_card_eq_finrank

#print basisOfLinearIndependentOfCardEqFinrank /-
/-- A linear independent family of `finrank K V` vectors forms a basis. -/
@[simps]
noncomputable def basisOfLinearIndependentOfCardEqFinrank {ι : Type _} [Nonempty ι] [Fintype ι]
    {b : ι → V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) :
    Basis ι K V :=
  Basis.mk lin_ind <| (span_eq_top_of_linearIndependent_of_card_eq_finrank lin_ind card_eq).ge
#align basis_of_linear_independent_of_card_eq_finrank basisOfLinearIndependentOfCardEqFinrank
-/

/- warning: coe_basis_of_linear_independent_of_card_eq_finrank -> coe_basisOfLinearIndependentOfCardEqFinrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {ι : Type.{u3}} [_inst_4 : Nonempty.{succ u3} ι] [_inst_5 : Fintype.{u3} ι] {b : ι -> V} (lin_ind : LinearIndependent.{u3, u1, u2} ι K V b (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (card_eq : Eq.{1} Nat (Fintype.card.{u3} ι _inst_5) (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)), Eq.{max (succ u3) (succ u2)} (ι -> V) (coeFn.{max (succ u3) (succ u1) (succ u2), max (succ u3) (succ u2)} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (fun (_x : Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) => ι -> V) (FunLike.hasCoeToFun.{max (succ u3) (succ u1) (succ u2), succ u3, succ u2} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) ι (fun (_x : ι) => V) (Basis.funLike.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)) (basisOfLinearIndependentOfCardEqFinrank.{u1, u2, u3} K V _inst_1 _inst_2 _inst_3 ι _inst_4 _inst_5 b lin_ind card_eq)) b
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {ι : Type.{u1}} [_inst_4 : Nonempty.{succ u1} ι] [_inst_5 : Fintype.{u1} ι] {b : ι -> V} (lin_ind : LinearIndependent.{u1, u2, u3} ι K V b (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (card_eq : Eq.{1} Nat (Fintype.card.{u1} ι _inst_5) (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3)), Eq.{max (succ u3) (succ u1)} (forall (a : ι), (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) a) (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), succ u1, succ u3} (Basis.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) ι (fun (_x : ι) => (fun (x._@.Mathlib.LinearAlgebra.Basis._hyg.548 : ι) => V) _x) (Basis.funLike.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3) (basisOfLinearIndependentOfCardEqFinrank.{u2, u3, u1} K V _inst_1 _inst_2 _inst_3 ι _inst_4 _inst_5 b lin_ind card_eq)) b
Case conversion may be inaccurate. Consider using '#align coe_basis_of_linear_independent_of_card_eq_finrank coe_basisOfLinearIndependentOfCardEqFinrankₓ'. -/
@[simp]
theorem coe_basisOfLinearIndependentOfCardEqFinrank {ι : Type _} [Nonempty ι] [Fintype ι]
    {b : ι → V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) :
    ⇑(basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = b :=
  Basis.coe_mk _ _
#align coe_basis_of_linear_independent_of_card_eq_finrank coe_basisOfLinearIndependentOfCardEqFinrank

#print finsetBasisOfLinearIndependentOfCardEqFinrank /-
/-- A linear independent finset of `finrank K V` vectors forms a basis. -/
@[simps]
noncomputable def finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)
    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.card = finrank K V) : Basis s K V :=
  @basisOfLinearIndependentOfCardEqFinrank _ _ _ _ _ _ ⟨(⟨hs.some, hs.choose_spec⟩ : s)⟩ _ _ lin_ind
    (trans (Fintype.card_coe _) card_eq)
#align finset_basis_of_linear_independent_of_card_eq_finrank finsetBasisOfLinearIndependentOfCardEqFinrank
-/

#print coe_finsetBasisOfLinearIndependentOfCardEqFinrank /-
@[simp]
theorem coe_finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)
    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.card = finrank K V) :
    ⇑(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = coe :=
  Basis.coe_mk _ _
#align coe_finset_basis_of_linear_independent_of_card_eq_finrank coe_finsetBasisOfLinearIndependentOfCardEqFinrank
-/

#print setBasisOfLinearIndependentOfCardEqFinrank /-
/-- A linear independent set of `finrank K V` vectors forms a basis. -/
@[simps]
noncomputable def setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]
    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.toFinset.card = finrank K V) :
    Basis s K V :=
  basisOfLinearIndependentOfCardEqFinrank lin_ind (trans s.toFinset_card.symm card_eq)
#align set_basis_of_linear_independent_of_card_eq_finrank setBasisOfLinearIndependentOfCardEqFinrank
-/

#print coe_setBasisOfLinearIndependentOfCardEqFinrank /-
@[simp]
theorem coe_setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]
    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.toFinset.card = finrank K V) :
    ⇑(setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = coe :=
  Basis.coe_mk _ _
#align coe_set_basis_of_linear_independent_of_card_eq_finrank coe_setBasisOfLinearIndependentOfCardEqFinrank
-/

end Basis

/-!
We now give characterisations of `finrank K V = 1` and `finrank K V ≤ 1`.
-/


section finrank_eq_one

/- warning: finrank_eq_one_iff_of_nonzero -> finrank_eq_one_iff_of_nonzero is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Eq.{succ u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.span.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.hasSingleton.{u2} V) v)) (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Eq.{succ u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.span.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 (Singleton.singleton.{u2, u2} V (Set.{u2} V) (Set.instSingletonSet.{u2} V) v)) (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align finrank_eq_one_iff_of_nonzero finrank_eq_one_iff_of_nonzeroₓ'. -/
/-- A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.
-/
theorem finrank_eq_one_iff_of_nonzero (v : V) (nz : v ≠ 0) :
    finrank K V = 1 ↔ span K ({v} : Set V) = ⊤ :=
  ⟨fun h => by simpa using (basis_singleton PUnit h v nz).span_eq, fun s =>
    finrank_eq_card_basis
      (Basis.mk (linearIndependent_singleton nz)
        (by
          convert s
          simp))⟩
#align finrank_eq_one_iff_of_nonzero finrank_eq_one_iff_of_nonzero

/- warning: finrank_eq_one_iff_of_nonzero' -> finrank_eq_one_iff_of_nonzero' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) -> (Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c v) w)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (v : V), (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) -> (Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) c v) w)))
Case conversion may be inaccurate. Consider using '#align finrank_eq_one_iff_of_nonzero' finrank_eq_one_iff_of_nonzero'ₓ'. -/
/-- A module with a nonzero vector `v` has dimension 1 iff every vector is a multiple of `v`.
-/
theorem finrank_eq_one_iff_of_nonzero' (v : V) (nz : v ≠ 0) :
    finrank K V = 1 ↔ ∀ w : V, ∃ c : K, c • v = w :=
  by
  rw [finrank_eq_one_iff_of_nonzero v nz]
  apply span_singleton_eq_top_iff
#align finrank_eq_one_iff_of_nonzero' finrank_eq_one_iff_of_nonzero'

/- warning: finrank_eq_one_iff -> finrank_eq_one_iff is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] (ι : Type.{u3}) [_inst_4 : Unique.{succ u3} ι], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Nonempty.{max (succ u3) (succ u1) (succ u2)} (Basis.{u3, u1, u2} ι K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] (ι : Type.{u1}) [_inst_4 : Unique.{succ u1} ι], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Nonempty.{max (max (succ u3) (succ u2)) (succ u1)} (Basis.{u1, u2, u3} ι K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))
Case conversion may be inaccurate. Consider using '#align finrank_eq_one_iff finrank_eq_one_iffₓ'. -/
/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis.
-/
theorem finrank_eq_one_iff (ι : Type _) [Unique ι] : finrank K V = 1 ↔ Nonempty (Basis ι K V) :=
  by
  fconstructor
  · intro h
    haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
    exact ⟨basis_unique ι h⟩
  · rintro ⟨b⟩
    simpa using finrank_eq_card_basis b
#align finrank_eq_one_iff finrank_eq_one_iff

/- warning: finrank_eq_one_iff' -> finrank_eq_one_iff' is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Exists.{succ u2} V (fun (v : V) => Exists.{0} (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) (fun (n : Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (OfNat.mk.{u2} V 0 (Zero.zero.{u2} V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (SubNegMonoid.toAddMonoid.{u2} V (AddGroup.toSubNegMonoid.{u2} V (AddCommGroup.toAddGroup.{u2} V _inst_2))))))))) => forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (SMul.smul.{u1, u2} K V (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) c v) w))))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)], Iff (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Exists.{succ u2} V (fun (v : V) => Exists.{0} (Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) (fun (n : Ne.{succ u2} V v (OfNat.ofNat.{u2} V 0 (Zero.toOfNat0.{u2} V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2)))))))) => forall (w : V), Exists.{succ u1} K (fun (c : K) => Eq.{succ u2} V (HSMul.hSMul.{u1, u2, u2} K V V (instHSMul.{u1, u2} K V (SMulZeroClass.toSMul.{u1, u2} K V (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u2} K V (MonoidWithZero.toZero.{u1} K (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))) (NegZeroClass.toZero.{u2} V (SubNegZeroMonoid.toNegZeroClass.{u2} V (SubtractionMonoid.toSubNegZeroMonoid.{u2} V (SubtractionCommMonoid.toSubtractionMonoid.{u2} V (AddCommGroup.toDivisionAddCommMonoid.{u2} V _inst_2))))) (Module.toMulActionWithZero.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) c v) w))))
Case conversion may be inaccurate. Consider using '#align finrank_eq_one_iff' finrank_eq_one_iff'ₓ'. -/
/-- A module has dimension 1 iff there is some nonzero `v : V` so every vector is a multiple of `v`.
-/
theorem finrank_eq_one_iff' : finrank K V = 1 ↔ ∃ (v : V)(n : v ≠ 0), ∀ w : V, ∃ c : K, c • v = w :=
  by
  convert finrank_eq_one_iff PUnit
  simp only [exists_prop, eq_iff_iff, Ne.def]
  convert(Basis.basis_singleton_iff PUnit).symm
  funext v
  simp
  infer_instance; infer_instance
#align finrank_eq_one_iff' finrank_eq_one_iff'

#print finrank_le_one_iff /-
-- Not sure why this aren't found automatically.
/-- A finite dimensional module has dimension at most 1 iff
there is some `v : V` so every vector is a multiple of `v`.
-/
theorem finrank_le_one_iff [FiniteDimensional K V] :
    finrank K V ≤ 1 ↔ ∃ v : V, ∀ w : V, ∃ c : K, c • v = w :=
  by
  fconstructor
  · intro h
    by_cases h' : finrank K V = 0
    · use 0
      intro w
      use 0
      haveI := finrank_zero_iff.mp h'
      apply Subsingleton.elim
    · replace h' := zero_lt_iff.mpr h'
      have : finrank K V = 1 := by linarith
      obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this
      use ⟨v, p⟩
  · rintro ⟨v, p⟩
    exact finrank_le_one v p
#align finrank_le_one_iff finrank_le_one_iff
-/

#print Submodule.finrank_le_one_iff_isPrincipal /-
theorem Submodule.finrank_le_one_iff_isPrincipal (W : Submodule K V) [FiniteDimensional K W] :
    finrank K W ≤ 1 ↔ W.IsPrincipal := by
  rw [← W.rank_le_one_iff_is_principal, ← finrank_eq_rank, ← Cardinal.natCast_le, Nat.cast_one]
#align submodule.finrank_le_one_iff_is_principal Submodule.finrank_le_one_iff_isPrincipal
-/

/- warning: module.finrank_le_one_iff_top_is_principal -> Module.finrank_le_one_iff_top_isPrincipal is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (LE.le.{0} Nat Nat.hasLe (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Submodule.IsPrincipal.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.hasTop.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3], Iff (LE.le.{0} Nat instLENat (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Submodule.IsPrincipal.{u1, u2} K V (DivisionRing.toRing.{u1} K _inst_1) _inst_2 _inst_3 (Top.top.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.instTopSubmodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align module.finrank_le_one_iff_top_is_principal Module.finrank_le_one_iff_top_isPrincipalₓ'. -/
theorem Module.finrank_le_one_iff_top_isPrincipal [FiniteDimensional K V] :
    finrank K V ≤ 1 ↔ (⊤ : Submodule K V).IsPrincipal := by
  rw [← Module.rank_le_one_iff_top_isPrincipal, ← finrank_eq_rank, ← Cardinal.natCast_le,
    Nat.cast_one]
#align module.finrank_le_one_iff_top_is_principal Module.finrank_le_one_iff_top_isPrincipal

/- warning: surjective_of_nonzero_of_finrank_eq_one -> surjective_of_nonzero_of_finrank_eq_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {W : Type.{u3}} {A : Type.{u4}} [_inst_4 : Semiring.{u4} A] [_inst_5 : Module.{u4, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : AddCommGroup.{u3} W] [_inst_7 : Module.{u1, u3} K W (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6)] [_inst_8 : Module.{u4, u3} A W _inst_4 (AddCommGroup.toAddCommMonoid.{u3} W _inst_6)] [_inst_9 : LinearMap.CompatibleSMul.{u2, u3, u1, u4} V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) K A _inst_4 (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3)))) _inst_5 (SMulZeroClass.toHasSmul.{u1, u3} K W (AddZeroClass.toHasZero.{u3} W (AddMonoid.toAddZeroClass.{u3} W (AddCommMonoid.toAddMonoid.{u3} W (AddCommGroup.toAddCommMonoid.{u3} W _inst_6)))) (SMulWithZero.toSmulZeroClass.{u1, u3} K W (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u3} W (AddMonoid.toAddZeroClass.{u3} W (AddCommMonoid.toAddMonoid.{u3} W (AddCommGroup.toAddCommMonoid.{u3} W _inst_6)))) (MulActionWithZero.toSMulWithZero.{u1, u3} K W (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u3} W (AddMonoid.toAddZeroClass.{u3} W (AddCommMonoid.toAddMonoid.{u3} W (AddCommGroup.toAddCommMonoid.{u3} W _inst_6)))) (Module.toMulActionWithZero.{u1, u3} K W (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_7)))) _inst_8], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u3} K W (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_6 _inst_7) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (forall {f : LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8}, (Ne.{max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) f (OfNat.ofNat.{max u2 u3} (LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) 0 (OfNat.mk.{max u2 u3} (LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) 0 (Zero.zero.{max u2 u3} (LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) (LinearMap.hasZero.{u4, u4, u2, u3} A A V W _inst_4 _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4))))))) -> (Function.Surjective.{succ u2, succ u3} V W (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) (fun (_x : LinearMap.{u4, u4, u2, u3} A A _inst_4 _inst_4 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8) => V -> W) (LinearMap.hasCoeToFun.{u4, u4, u2, u3} A A V W _inst_4 _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u3} W _inst_6) _inst_5 _inst_8 (RingHom.id.{u4} A (Semiring.toNonAssocSemiring.{u4} A _inst_4))) f)))
but is expected to have type
  forall {K : Type.{u3}} {V : Type.{u4}} [_inst_1 : DivisionRing.{u3} K] [_inst_2 : AddCommGroup.{u4} V] [_inst_3 : Module.{u3, u4} K V (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] {W : Type.{u2}} {A : Type.{u1}} [_inst_4 : Semiring.{u1} A] [_inst_5 : Module.{u1, u4} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u4} V _inst_2)] [_inst_6 : AddCommGroup.{u2} W] [_inst_7 : Module.{u3, u2} K W (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6)] [_inst_8 : Module.{u1, u2} A W _inst_4 (AddCommGroup.toAddCommMonoid.{u2} W _inst_6)] [_inst_9 : LinearMap.CompatibleSMul.{u4, u2, u3, u1} V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) K A _inst_4 (SMulZeroClass.toSMul.{u3, u4} K V (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u3, u4} K V (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u3, u4} K V (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1))) (NegZeroClass.toZero.{u4} V (SubNegZeroMonoid.toNegZeroClass.{u4} V (SubtractionMonoid.toSubNegZeroMonoid.{u4} V (SubtractionCommMonoid.toSubtractionMonoid.{u4} V (AddCommGroup.toDivisionAddCommMonoid.{u4} V _inst_2))))) (Module.toMulActionWithZero.{u3, u4} K V (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) _inst_3)))) _inst_5 (SMulZeroClass.toSMul.{u3, u2} K W (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_6))))) (SMulWithZero.toSMulZeroClass.{u3, u2} K W (MonoidWithZero.toZero.{u3} K (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)))) (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_6))))) (MulActionWithZero.toSMulWithZero.{u3, u2} K W (Semiring.toMonoidWithZero.{u3} K (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1))) (NegZeroClass.toZero.{u2} W (SubNegZeroMonoid.toNegZeroClass.{u2} W (SubtractionMonoid.toSubNegZeroMonoid.{u2} W (SubtractionCommMonoid.toSubtractionMonoid.{u2} W (AddCommGroup.toDivisionAddCommMonoid.{u2} W _inst_6))))) (Module.toMulActionWithZero.{u3, u2} K W (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_7)))) _inst_8], (Eq.{1} Nat (FiniteDimensional.finrank.{u3, u2} K W (DivisionSemiring.toSemiring.{u3} K (DivisionRing.toDivisionSemiring.{u3} K _inst_1)) _inst_6 _inst_7) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (forall {f : LinearMap.{u1, u1, u4, u2} A A _inst_4 _inst_4 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8}, (Ne.{max (succ u4) (succ u2)} (LinearMap.{u1, u1, u4, u2} A A _inst_4 _inst_4 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8) f (OfNat.ofNat.{max u4 u2} (LinearMap.{u1, u1, u4, u2} A A _inst_4 _inst_4 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8) 0 (Zero.toOfNat0.{max u4 u2} (LinearMap.{u1, u1, u4, u2} A A _inst_4 _inst_4 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8) (LinearMap.instZeroLinearMap.{u1, u1, u4, u2} A A V W _inst_4 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)))))) -> (Function.Surjective.{succ u4, succ u2} V W (FunLike.coe.{max (succ u4) (succ u2), succ u4, succ u2} (LinearMap.{u1, u1, u4, u2} A A _inst_4 _inst_4 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4)) V W (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8) V (fun (_x : V) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6191 : V) => W) _x) (LinearMap.instFunLikeLinearMap.{u1, u1, u4, u2} A A V W _inst_4 _inst_4 (AddCommGroup.toAddCommMonoid.{u4} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} W _inst_6) _inst_5 _inst_8 (RingHom.id.{u1} A (Semiring.toNonAssocSemiring.{u1} A _inst_4))) f)))
Case conversion may be inaccurate. Consider using '#align surjective_of_nonzero_of_finrank_eq_one surjective_of_nonzero_of_finrank_eq_oneₓ'. -/
-- We use the `linear_map.compatible_smul` typeclass here, to encompass two situations:
-- * `A = K`
-- * `[field K] [algebra K A] [is_scalar_tower K A V] [is_scalar_tower K A W]`
theorem surjective_of_nonzero_of_finrank_eq_one {W A : Type _} [Semiring A] [Module A V]
    [AddCommGroup W] [Module K W] [Module A W] [LinearMap.CompatibleSMul V W K A]
    (h : finrank K W = 1) {f : V →ₗ[A] W} (w : f ≠ 0) : Surjective f :=
  by
  change surjective (f.restrict_scalars K)
  obtain ⟨v, n⟩ := fun_like.ne_iff.mp w
  intro z
  obtain ⟨c, rfl⟩ := (finrank_eq_one_iff_of_nonzero' (f v) n).mp h z
  exact ⟨c • v, by simp⟩
#align surjective_of_nonzero_of_finrank_eq_one surjective_of_nonzero_of_finrank_eq_one

/- warning: is_simple_module_of_finrank_eq_one -> is_simple_module_of_finrank_eq_one is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] {A : Type.{u3}} [_inst_4 : Semiring.{u3} A] [_inst_5 : Module.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_6 : SMul.{u1, u3} K A] [_inst_7 : IsScalarTower.{u1, u3, u2} K A V _inst_6 (SMulZeroClass.toHasSmul.{u3, u2} A V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u3, u2} A V (MulZeroClass.toHasZero.{u3} A (MulZeroOneClass.toMulZeroClass.{u3} A (MonoidWithZero.toMulZeroOneClass.{u3} A (Semiring.toMonoidWithZero.{u3} A _inst_4)))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u3, u2} A V (Semiring.toMonoidWithZero.{u3} A _inst_4) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5)))) (SMulZeroClass.toHasSmul.{u1, u2} K V (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (SMulWithZero.toSmulZeroClass.{u1, u2} K V (MulZeroClass.toHasZero.{u1} K (MulZeroOneClass.toMulZeroClass.{u1} K (MonoidWithZero.toMulZeroOneClass.{u1} K (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (MulActionWithZero.toSMulWithZero.{u1, u2} K V (Semiring.toMonoidWithZero.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))) (AddZeroClass.toHasZero.{u2} V (AddMonoid.toAddZeroClass.{u2} V (AddCommMonoid.toAddMonoid.{u2} V (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)))) (Module.toMulActionWithZero.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (IsSimpleOrder.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (Preorder.toHasLe.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (PartialOrder.toPreorder.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (Submodule.completeLattice.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5))))) (CompleteLattice.toBoundedOrder.{u2} (Submodule.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5) (Submodule.completeLattice.{u3, u2} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_5)))
but is expected to have type
  forall {K : Type.{u2}} {V : Type.{u3}} [_inst_1 : DivisionRing.{u2} K] [_inst_2 : AddCommGroup.{u3} V] [_inst_3 : Module.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] {A : Type.{u1}} [_inst_4 : Semiring.{u1} A] [_inst_5 : Module.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2)] [_inst_6 : SMul.{u2, u1} K A] [_inst_7 : IsScalarTower.{u2, u1, u3} K A V _inst_6 (SMulZeroClass.toSMul.{u1, u3} A V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u1, u3} A V (MonoidWithZero.toZero.{u1} A (Semiring.toMonoidWithZero.{u1} A _inst_4)) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u1, u3} A V (Semiring.toMonoidWithZero.{u1} A _inst_4) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5)))) (SMulZeroClass.toSMul.{u2, u3} K V (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (SMulWithZero.toSMulZeroClass.{u2, u3} K V (MonoidWithZero.toZero.{u2} K (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (MulActionWithZero.toSMulWithZero.{u2, u3} K V (Semiring.toMonoidWithZero.{u2} K (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1))) (NegZeroClass.toZero.{u3} V (SubNegZeroMonoid.toNegZeroClass.{u3} V (SubtractionMonoid.toSubNegZeroMonoid.{u3} V (SubtractionCommMonoid.toSubtractionMonoid.{u3} V (AddCommGroup.toDivisionAddCommMonoid.{u3} V _inst_2))))) (Module.toMulActionWithZero.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_3))))], (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u3} K V (DivisionSemiring.toSemiring.{u2} K (DivisionRing.toDivisionSemiring.{u2} K _inst_1)) _inst_2 _inst_3) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (IsSimpleOrder.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (Preorder.toLE.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (PartialOrder.toPreorder.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (OmegaCompletePartialOrder.toPartialOrder.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (CompleteLattice.instOmegaCompletePartialOrder.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (Submodule.completeLattice.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5))))) (CompleteLattice.toBoundedOrder.{u3} (Submodule.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5) (Submodule.completeLattice.{u1, u3} A V _inst_4 (AddCommGroup.toAddCommMonoid.{u3} V _inst_2) _inst_5)))
Case conversion may be inaccurate. Consider using '#align is_simple_module_of_finrank_eq_one is_simple_module_of_finrank_eq_oneₓ'. -/
/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/
theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]
    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) :=
  by
  haveI := nontrivial_of_finrank_eq_succ h
  refine' ⟨fun S => or_iff_not_imp_left.2 fun hn => _⟩
  rw [← restrict_scalars_inj K] at hn⊢
  haveI := finite_dimensional_of_finrank_eq_succ h
  refine' eq_top_of_finrank_eq ((Submodule.finrank_le _).antisymm _)
  simpa only [h, finrank_bot] using Submodule.finrank_strictMono (Ne.bot_lt hn)
#align is_simple_module_of_finrank_eq_one is_simple_module_of_finrank_eq_one

end finrank_eq_one

end DivisionRing

section SubalgebraRank

open Module

variable {F E : Type _} [Field F] [Ring E] [Algebra F E]

/- warning: subalgebra.finite_dimensional_to_submodule -> Subalgebra.finiteDimensional_toSubmodule is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] {S : Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3}, Iff (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Field.toDivisionRing.{u1} F _inst_1) (Submodule.addCommGroup.{u1, u2} F E (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Submodule.module.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S))) (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Field.toDivisionRing.{u1} F _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 _inst_3 S)))) (Subalgebra.module.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)] {S : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3}, Iff (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) E (Submodule.setLike.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (a : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) a) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S))) (Field.toDivisionRing.{u2} F _inst_1) (Submodule.addCommGroup.{u2, u1} F E (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S)) (Submodule.module.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S))) (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Field.toDivisionRing.{u2} F _inst_1) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (SubringClass.toRing.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) _inst_2 (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u2, u1} F E (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 _inst_3) S)) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S))
Case conversion may be inaccurate. Consider using '#align subalgebra.finite_dimensional_to_submodule Subalgebra.finiteDimensional_toSubmoduleₓ'. -/
/-- A `subalgebra` is `finite_dimensional` iff it is finite_dimensional as a submodule. -/
theorem Subalgebra.finiteDimensional_toSubmodule {S : Subalgebra F E} :
    FiniteDimensional F S.toSubmodule ↔ FiniteDimensional F S :=
  Iff.rfl
#align subalgebra.finite_dimensional_to_submodule Subalgebra.finiteDimensional_toSubmodule

/- warning: finite_dimensional.of_subalgebra_to_submodule -> FiniteDimensional.of_subalgebra_toSubmodule is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] {S : Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3}, (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Field.toDivisionRing.{u1} F _inst_1) (Submodule.addCommGroup.{u1, u2} F E (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Submodule.module.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S))) -> (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Field.toDivisionRing.{u1} F _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 _inst_3 S)))) (Subalgebra.module.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)] {S : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3}, (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) E (Submodule.setLike.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (a : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) a) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S))) (Field.toDivisionRing.{u2} F _inst_1) (Submodule.addCommGroup.{u2, u1} F E (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S)) (Submodule.module.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S))) -> (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Field.toDivisionRing.{u2} F _inst_1) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (SubringClass.toRing.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) _inst_2 (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u2, u1} F E (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 _inst_3) S)) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.of_subalgebra_to_submodule FiniteDimensional.of_subalgebra_toSubmoduleₓ'. -/
/- warning: finite_dimensional.subalgebra_to_submodule -> FiniteDimensional.subalgebra_toSubmodule is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] {S : Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3}, (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Field.toDivisionRing.{u1} F _inst_1) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 _inst_3 S)))) (Subalgebra.module.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S)) -> (FiniteDimensional.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) E (Submodule.setLike.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Field.toDivisionRing.{u1} F _inst_1) (Submodule.addCommGroup.{u1, u2} F E (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1)) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)) (Submodule.module.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (coeFn.{succ u2, succ u2} (OrderEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))))) (fun (_x : RelEmbedding.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) => (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) -> (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (RelEmbedding.hasCoeToFun.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (LE.le.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (SetLike.partialOrder.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (LE.le.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (Submodule.completeLattice.{u1, u2} F E (CommSemiring.toSemiring.{u1} F (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} E (Semiring.toNonAssocSemiring.{u2} E (Ring.toSemiring.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))))))) (Subalgebra.toSubmodule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S)))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)] {S : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3}, (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Field.toDivisionRing.{u2} F _inst_1) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (SubringClass.toRing.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) _inst_2 (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u2, u1} F E (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 _inst_3) S)) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S)) -> (FiniteDimensional.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) (SetLike.instMembership.{u1, u1} ((fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) S) E (Submodule.setLike.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))) x (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (a : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) a) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S))) (Field.toDivisionRing.{u2} F _inst_1) (Submodule.addCommGroup.{u2, u1} F E (DivisionRing.toRing.{u2} F (Field.toDivisionRing.{u2} F _inst_1)) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S)) (Submodule.module.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (FunLike.coe.{succ u1, succ u1, succ u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (fun (_x : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => (fun (x._@.Mathlib.Order.RelIso.Basic._hyg.867 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) _x) (RelHomClass.toFunLike.{u1, u1, u1} (OrderEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))))) (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697) (RelEmbedding.instRelHomClassRelEmbedding.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) => LE.le.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instPartialOrder.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) => LE.le.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Preorder.toLE.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (PartialOrder.toPreorder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Submodule.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (Submodule.completeLattice.{u2, u1} F E (CommSemiring.toSemiring.{u2} F (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} E (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} E (Semiring.toNonAssocSemiring.{u1} E (Ring.toSemiring.{u1} E _inst_2)))) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))) (Subalgebra.toSubmodule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S)))
Case conversion may be inaccurate. Consider using '#align finite_dimensional.subalgebra_to_submodule FiniteDimensional.subalgebra_toSubmoduleₓ'. -/
alias Subalgebra.finiteDimensional_toSubmodule ↔
  FiniteDimensional.of_subalgebra_toSubmodule FiniteDimensional.subalgebra_toSubmodule
#align finite_dimensional.of_subalgebra_to_submodule FiniteDimensional.of_subalgebra_toSubmodule
#align finite_dimensional.subalgebra_to_submodule FiniteDimensional.subalgebra_toSubmodule

#print FiniteDimensional.finiteDimensional_subalgebra /-
instance FiniteDimensional.finiteDimensional_subalgebra [FiniteDimensional F E]
    (S : Subalgebra F E) : FiniteDimensional F S :=
  FiniteDimensional.of_subalgebra_toSubmodule inferInstance
#align finite_dimensional.finite_dimensional_subalgebra FiniteDimensional.finiteDimensional_subalgebra
-/

#print Subalgebra.finiteDimensional_bot /-
instance Subalgebra.finiteDimensional_bot : FiniteDimensional F (⊥ : Subalgebra F E) :=
  by
  nontriviality E
  exact finiteDimensional_of_rank_eq_one Subalgebra.rank_bot
#align subalgebra.finite_dimensional_bot Subalgebra.finiteDimensional_bot
-/

/- warning: subalgebra.eq_bot_of_rank_le_one -> Subalgebra.eq_bot_of_rank_le_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] {S : Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3}, (LE.le.{succ u2} Cardinal.{u2} Cardinal.hasLe.{u2} (Module.rank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 _inst_3 S))))) (Subalgebra.module.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (OfNat.mk.{succ u2} Cardinal.{u2} 1 (One.one.{succ u2} Cardinal.{u2} Cardinal.hasOne.{u2})))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)] {S : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3}, (LE.le.{succ u1} Cardinal.{u1} Cardinal.instLECardinal.{u1} (Module.rank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (NonAssocRing.toNonUnitalNonAssocRing.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (Ring.toNonAssocRing.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (SubringClass.toRing.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) _inst_2 (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u2, u1} F E (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 _inst_3) S))))) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S)) (OfNat.ofNat.{succ u1} Cardinal.{u1} 1 (One.toOfNat1.{succ u1} Cardinal.{u1} Cardinal.instOneCardinal.{u1}))) -> (Eq.{succ u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align subalgebra.eq_bot_of_rank_le_one Subalgebra.eq_bot_of_rank_le_oneₓ'. -/
theorem Subalgebra.eq_bot_of_rank_le_one {S : Subalgebra F E} (h : Module.rank F S ≤ 1) : S = ⊥ :=
  by
  nontriviality E
  obtain ⟨m, hm, he⟩ := Cardinal.exists_nat_eq_of_le_nat (h.trans_eq nat.cast_one.symm)
  haveI := finiteDimensional_of_rank_eq_nat he
  rw [← not_bot_lt_iff, ← subalgebra.to_submodule.lt_iff_lt]
  haveI := S.to_submodule_equiv.symm.FiniteDimensional
  refine' fun hl => (Submodule.finrank_lt_finrank_of_lt hl).not_le (nat_cast_le.1 _)
  iterate 2 rw [Subalgebra.finrank_toSubmodule, finrank_eq_rank]
  exact h.trans_eq subalgebra.rank_bot.symm
#align subalgebra.eq_bot_of_rank_le_one Subalgebra.eq_bot_of_rank_le_one

/- warning: subalgebra.eq_bot_of_finrank_one -> Subalgebra.eq_bot_of_finrank_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] {S : Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (NonAssocRing.toNonUnitalNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Ring.toNonAssocRing.{u2} (coeSort.{succ u2, succ (succ u2)} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) Type.{u2} (SetLike.hasCoeToSort.{u2, u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) E (Subalgebra.setLike.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) S) (Subalgebra.toRing.{u1, u2} F E (EuclideanDomain.toCommRing.{u1} F (Field.toEuclideanDomain.{u1} F _inst_1)) _inst_2 _inst_3 S)))) (Subalgebra.module.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3 S)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) S (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)] {S : Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3}, (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} F (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (Ring.toAddCommGroup.{u1} (Subtype.{succ u1} E (fun (x : E) => Membership.mem.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (SetLike.instMembership.{u1, u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) E (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) x S)) (SubringClass.toRing.{u1, u1} E (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) _inst_2 (Subalgebra.instSetLikeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Subalgebra.instSubringClassSubalgebraToCommSemiringToSemiringInstSetLikeSubalgebra.{u2, u1} F E (EuclideanDomain.toCommRing.{u2} F (Field.toEuclideanDomain.{u2} F _inst_1)) _inst_2 _inst_3) S)) (Subalgebra.instModuleSubtypeMemSubalgebraInstMembershipInstSetLikeSubalgebraToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToNonAssocSemiringToSubsemiring.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3 S)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{succ u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) S (Bot.bot.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.toBot.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align subalgebra.eq_bot_of_finrank_one Subalgebra.eq_bot_of_finrank_oneₓ'. -/
theorem Subalgebra.eq_bot_of_finrank_one {S : Subalgebra F E} (h : finrank F S = 1) : S = ⊥ :=
  Subalgebra.eq_bot_of_rank_le_one <|
    by
    haveI := finite_dimensional_of_finrank_eq_succ h
    rw [← finrank_eq_rank, h, Nat.cast_one]
#align subalgebra.eq_bot_of_finrank_one Subalgebra.eq_bot_of_finrank_one

#print Subalgebra.rank_eq_one_iff /-
@[simp]
theorem Subalgebra.rank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} :
    Module.rank F S = 1 ↔ S = ⊥ :=
  ⟨fun h => Subalgebra.eq_bot_of_rank_le_one h.le, fun h => h.symm ▸ Subalgebra.rank_bot⟩
#align subalgebra.rank_eq_one_iff Subalgebra.rank_eq_one_iff
-/

#print Subalgebra.finrank_eq_one_iff /-
@[simp]
theorem Subalgebra.finrank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} :
    finrank F S = 1 ↔ S = ⊥ :=
  ⟨Subalgebra.eq_bot_of_finrank_one, fun h => h.symm ▸ Subalgebra.finrank_bot⟩
#align subalgebra.finrank_eq_one_iff Subalgebra.finrank_eq_one_iff
-/

/- warning: subalgebra.bot_eq_top_iff_rank_eq_one -> Subalgebra.bot_eq_top_iff_rank_eq_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], Iff (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F E (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (OfNat.mk.{succ u2} Cardinal.{u2} 1 (One.one.{succ u2} Cardinal.{u2} Cardinal.hasOne.{u2}))))
but is expected to have type
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], Iff (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F E (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (One.toOfNat1.{succ u2} Cardinal.{u2} Cardinal.instOneCardinal.{u2})))
Case conversion may be inaccurate. Consider using '#align subalgebra.bot_eq_top_iff_rank_eq_one Subalgebra.bot_eq_top_iff_rank_eq_oneₓ'. -/
theorem Subalgebra.bot_eq_top_iff_rank_eq_one [Nontrivial E] :
    (⊥ : Subalgebra F E) = ⊤ ↔ Module.rank F E = 1 := by
  rw [← rank_top, ← subalgebra_top_rank_eq_submodule_top_rank, Subalgebra.rank_eq_one_iff, eq_comm]
#align subalgebra.bot_eq_top_iff_rank_eq_one Subalgebra.bot_eq_top_iff_rank_eq_one

/- warning: subalgebra.bot_eq_top_iff_finrank_eq_one -> Subalgebra.bot_eq_top_iff_finrank_eq_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], Iff (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F E (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))
but is expected to have type
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], Iff (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))) (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F E (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (Ring.toAddCommGroup.{u2} E _inst_2) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))
Case conversion may be inaccurate. Consider using '#align subalgebra.bot_eq_top_iff_finrank_eq_one Subalgebra.bot_eq_top_iff_finrank_eq_oneₓ'. -/
theorem Subalgebra.bot_eq_top_iff_finrank_eq_one [Nontrivial E] :
    (⊥ : Subalgebra F E) = ⊤ ↔ finrank F E = 1 := by
  rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank,
    Subalgebra.finrank_eq_one_iff, eq_comm]
#align subalgebra.bot_eq_top_iff_finrank_eq_one Subalgebra.bot_eq_top_iff_finrank_eq_one

/- warning: subalgebra.bot_eq_top_of_rank_eq_one -> Subalgebra.bot_eq_top_of_rank_eq_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F E (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (AddCommGroup.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (OfNat.mk.{succ u2} Cardinal.{u2} 1 (One.one.{succ u2} Cardinal.{u2} Cardinal.hasOne.{u2})))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
but is expected to have type
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], (Eq.{succ (succ u2)} Cardinal.{u2} (Module.rank.{u1, u2} F E (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} E (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2)))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{succ u2} Cardinal.{u2} 1 (One.toOfNat1.{succ u2} Cardinal.{u2} Cardinal.instOneCardinal.{u2}))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align subalgebra.bot_eq_top_of_rank_eq_one Subalgebra.bot_eq_top_of_rank_eq_oneₓ'. -/
alias Subalgebra.bot_eq_top_iff_rank_eq_one ↔ _ Subalgebra.bot_eq_top_of_rank_eq_one
#align subalgebra.bot_eq_top_of_rank_eq_one Subalgebra.bot_eq_top_of_rank_eq_one

/- warning: subalgebra.bot_eq_top_of_finrank_eq_one -> Subalgebra.bot_eq_top_of_finrank_eq_one is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F E (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toHasTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
but is expected to have type
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)] [_inst_4 : Nontrivial.{u2} E], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F E (DivisionSemiring.toSemiring.{u1} F (Semifield.toDivisionSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1))) (Ring.toAddCommGroup.{u2} E _inst_2) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (Eq.{succ u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Bot.bot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toBot.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))) (Top.top.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toTop.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))
Case conversion may be inaccurate. Consider using '#align subalgebra.bot_eq_top_of_finrank_eq_one Subalgebra.bot_eq_top_of_finrank_eq_oneₓ'. -/
alias Subalgebra.bot_eq_top_iff_finrank_eq_one ↔ _ Subalgebra.bot_eq_top_of_finrank_eq_one
#align subalgebra.bot_eq_top_of_finrank_eq_one Subalgebra.bot_eq_top_of_finrank_eq_one

attribute [simp] Subalgebra.bot_eq_top_of_finrank_eq_one Subalgebra.bot_eq_top_of_rank_eq_one

/- warning: subalgebra.is_simple_order_of_finrank -> Subalgebra.isSimpleOrder_of_finrank is a dubious translation:
lean 3 declaration is
  forall {F : Type.{u1}} {E : Type.{u2}} [_inst_1 : Field.{u1} F] [_inst_2 : Ring.{u2} E] [_inst_3 : Algebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2)], (Eq.{1} Nat (FiniteDimensional.finrank.{u1, u2} F E (Ring.toSemiring.{u1} F (DivisionRing.toRing.{u1} F (Field.toDivisionRing.{u1} F _inst_1))) (NonUnitalNonAssocRing.toAddCommGroup.{u2} E (NonAssocRing.toNonUnitalNonAssocRing.{u2} E (Ring.toNonAssocRing.{u2} E _inst_2))) (Algebra.toModule.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) -> (IsSimpleOrder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3))))) (CompleteLattice.toBoundedOrder.{u2} (Subalgebra.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3) (Algebra.Subalgebra.completeLattice.{u1, u2} F E (Semifield.toCommSemiring.{u1} F (Field.toSemifield.{u1} F _inst_1)) (Ring.toSemiring.{u2} E _inst_2) _inst_3)))
but is expected to have type
  forall {F : Type.{u2}} {E : Type.{u1}} [_inst_1 : Field.{u2} F] [_inst_2 : Ring.{u1} E] [_inst_3 : Algebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2)], (Eq.{1} Nat (FiniteDimensional.finrank.{u2, u1} F E (DivisionSemiring.toSemiring.{u2} F (Semifield.toDivisionSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1))) (Ring.toAddCommGroup.{u1} E _inst_2) (Algebra.toModule.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (IsSimpleOrder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Preorder.toLE.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (PartialOrder.toPreorder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3))))) (CompleteLattice.toBoundedOrder.{u1} (Subalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3) (Algebra.instCompleteLatticeSubalgebra.{u2, u1} F E (Semifield.toCommSemiring.{u2} F (Field.toSemifield.{u2} F _inst_1)) (Ring.toSemiring.{u1} E _inst_2) _inst_3)))
Case conversion may be inaccurate. Consider using '#align subalgebra.is_simple_order_of_finrank Subalgebra.isSimpleOrder_of_finrankₓ'. -/
theorem Subalgebra.isSimpleOrder_of_finrank (hr : finrank F E = 2) :
    IsSimpleOrder (Subalgebra F E) :=
  let i := nontrivial_of_finrank_pos (zero_lt_two.trans_eq hr.symm)
  { to_nontrivial :=
      ⟨⟨⊥, ⊤, fun h => by cases hr.symm.trans (Subalgebra.bot_eq_top_iff_finrank_eq_one.1 h)⟩⟩
    eq_bot_or_eq_top := by
      intro S
      haveI : FiniteDimensional F E := finite_dimensional_of_finrank_eq_succ hr
      haveI : FiniteDimensional F S := FiniteDimensional.finiteDimensional_submodule S.to_submodule
      have : finrank F S ≤ 2 := hr ▸ S.to_submodule.finrank_le
      have : 0 < finrank F S := finrank_pos_iff.mpr inferInstance
      interval_cases
      · left
        exact Subalgebra.eq_bot_of_finrank_one h
      · right
        rw [← hr] at h
        rw [← Algebra.toSubmodule_eq_top]
        exact Submodule.eq_top_of_finrank_eq h }
#align subalgebra.is_simple_order_of_finrank Subalgebra.isSimpleOrder_of_finrank

end SubalgebraRank

namespace Module

namespace End

variable [DivisionRing K] [AddCommGroup V] [Module K V]

#print Module.End.exists_ker_pow_eq_ker_pow_succ /-
theorem exists_ker_pow_eq_ker_pow_succ [FiniteDimensional K V] (f : End K V) :
    ∃ k : ℕ, k ≤ finrank K V ∧ (f ^ k).ker = (f ^ k.succ).ker := by
  classical
    by_contra h_contra
    simp_rw [not_exists, not_and] at h_contra
    have h_le_ker_pow : ∀ n : ℕ, n ≤ (finrank K V).succ → n ≤ finrank K (f ^ n).ker :=
      by
      intro n hn
      induction' n with n ih
      · exact zero_le (finrank _ _)
      · have h_ker_lt_ker : (f ^ n).ker < (f ^ n.succ).ker :=
          by
          refine' lt_of_le_of_ne _ (h_contra n (Nat.le_of_succ_le_succ hn))
          rw [pow_succ]
          apply LinearMap.ker_le_ker_comp
        have h_finrank_lt_finrank : finrank K (f ^ n).ker < finrank K (f ^ n.succ).ker := by
          apply Submodule.finrank_lt_finrank_of_lt h_ker_lt_ker
        calc
          n.succ ≤ (finrank K ↥(LinearMap.ker (f ^ n))).succ :=
            Nat.succ_le_succ (ih (Nat.le_of_succ_le hn))
          _ ≤ finrank K ↥(LinearMap.ker (f ^ n.succ)) := Nat.succ_le_of_lt h_finrank_lt_finrank
          
    have h_le_finrank_V : ∀ n, finrank K (f ^ n).ker ≤ finrank K V := fun n =>
      Submodule.finrank_le _
    have h_any_n_lt : ∀ n, n ≤ (finrank K V).succ → n ≤ finrank K V := fun n hn =>
      (h_le_ker_pow n hn).trans (h_le_finrank_V n)
    show False
    exact Nat.not_succ_le_self _ (h_any_n_lt (finrank K V).succ (finrank K V).succ.le_refl)
#align module.End.exists_ker_pow_eq_ker_pow_succ Module.End.exists_ker_pow_eq_ker_pow_succ
-/

#print Module.End.ker_pow_constant /-
theorem ker_pow_constant {f : End K V} {k : ℕ} (h : (f ^ k).ker = (f ^ k.succ).ker) :
    ∀ m, (f ^ k).ker = (f ^ (k + m)).ker
  | 0 => by simp
  | m + 1 => by
    apply le_antisymm
    · rw [add_comm, pow_add]
      apply LinearMap.ker_le_ker_comp
    · rw [ker_pow_constant m, add_comm m 1, ← add_assoc, pow_add, pow_add f k m]
      change LinearMap.ker ((f ^ (k + 1)).comp (f ^ m)) ≤ LinearMap.ker ((f ^ k).comp (f ^ m))
      rw [LinearMap.ker_comp, LinearMap.ker_comp, h, Nat.add_one]
      exact le_rfl
#align module.End.ker_pow_constant Module.End.ker_pow_constant
-/

#print Module.End.ker_pow_eq_ker_pow_finrank_of_le /-
theorem ker_pow_eq_ker_pow_finrank_of_le [FiniteDimensional K V] {f : End K V} {m : ℕ}
    (hm : finrank K V ≤ m) : (f ^ m).ker = (f ^ finrank K V).ker :=
  by
  obtain ⟨k, h_k_le, hk⟩ :
    ∃ k, k ≤ finrank K V ∧ LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) :=
    exists_ker_pow_eq_ker_pow_succ f
  calc
    (f ^ m).ker = (f ^ (k + (m - k))).ker := by rw [add_tsub_cancel_of_le (h_k_le.trans hm)]
    _ = (f ^ k).ker := by rw [ker_pow_constant hk _]
    _ = (f ^ (k + (finrank K V - k))).ker := (ker_pow_constant hk (finrank K V - k))
    _ = (f ^ finrank K V).ker := by rw [add_tsub_cancel_of_le h_k_le]
    
#align module.End.ker_pow_eq_ker_pow_finrank_of_le Module.End.ker_pow_eq_ker_pow_finrank_of_le
-/

/- warning: module.End.ker_pow_le_ker_pow_finrank -> Module.End.ker_pow_le_ker_pow_finrank is a dubious translation:
lean 3 declaration is
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (m : Nat), LE.le.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toHasLe.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteSemilatticeInf.toPartialOrder.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Submodule.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HPow.hPow.{u2, 0, u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (instHPow.{u2, 0} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Monoid.Pow.{u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.End.monoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) f m)) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)))) (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1))))) (HPow.hPow.{u2, 0, u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (instHPow.{u2, 0} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Monoid.Pow.{u2} (Module.End.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.End.monoid.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) f (FiniteDimensional.finrank.{u1, u2} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) _inst_2 _inst_3)))
but is expected to have type
  forall {K : Type.{u1}} {V : Type.{u2}} [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u2} V] [_inst_3 : Module.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2)] [_inst_4 : FiniteDimensional.{u1, u2} K V _inst_1 _inst_2 _inst_3] (f : Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (m : Nat), LE.le.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Preorder.toLE.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (PartialOrder.toPreorder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (OmegaCompletePartialOrder.toPartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (CompleteLattice.instOmegaCompletePartialOrder.{u2} (Submodule.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Submodule.completeLattice.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))))) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (HPow.hPow.{u2, 0, u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (instHPow.{u2, 0} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Monoid.Pow.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.End.monoid.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) f m)) (LinearMap.ker.{u1, u1, u2, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)))) (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (LinearMap.semilinearMapClass.{u1, u1, u2, u2} K K V V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3 _inst_3 (RingHom.id.{u1} K (Semiring.toNonAssocSemiring.{u1} K (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1))))) (HPow.hPow.{u2, 0, u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (instHPow.{u2, 0} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) Nat (Monoid.Pow.{u2} (Module.End.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3) (Module.End.monoid.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u2} V _inst_2) _inst_3))) f (FiniteDimensional.finrank.{u1, u2} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) _inst_2 _inst_3)))
Case conversion may be inaccurate. Consider using '#align module.End.ker_pow_le_ker_pow_finrank Module.End.ker_pow_le_ker_pow_finrankₓ'. -/
theorem ker_pow_le_ker_pow_finrank [FiniteDimensional K V] (f : End K V) (m : ℕ) :
    (f ^ m).ker ≤ (f ^ finrank K V).ker :=
  by
  by_cases h_cases : m < finrank K V
  · rw [← add_tsub_cancel_of_le (Nat.le_of_lt h_cases), add_comm, pow_add]
    apply LinearMap.ker_le_ker_comp
  · rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]
    exact le_rfl
#align module.End.ker_pow_le_ker_pow_finrank Module.End.ker_pow_le_ker_pow_finrank

end End

end Module

section Module

open Module

open Cardinal

#print cardinal_mk_eq_cardinal_mk_field_pow_rank /-
theorem cardinal_mk_eq_cardinal_mk_field_pow_rank (K V : Type u) [DivisionRing K] [AddCommGroup V]
    [Module K V] [FiniteDimensional K V] : (#V) = (#K) ^ Module.rank K V :=
  by
  let s := Basis.ofVectorSpaceIndex K V
  let hs := Basis.ofVectorSpace K V
  calc
    (#V) = (#s →₀ K) := Quotient.sound ⟨hs.repr.to_equiv⟩
    _ = (#s → K) := (Quotient.sound ⟨Finsupp.equivFunOnFinite⟩)
    _ = _ := by rw [← Cardinal.lift_inj.1 hs.mk_eq_rank, Cardinal.power_def]
    
#align cardinal_mk_eq_cardinal_mk_field_pow_rank cardinal_mk_eq_cardinal_mk_field_pow_rank
-/

/- warning: cardinal_lt_aleph_0_of_finite_dimensional -> cardinal_lt_aleph0_of_finiteDimensional is a dubious translation:
lean 3 declaration is
  forall (K : Type.{u1}) (V : Type.{u1}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u1, u1} K V (Ring.toSemiring.{u1} K (DivisionRing.toRing.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : Finite.{succ u1} K] [_inst_5 : FiniteDimensional.{u1, u1} K V _inst_1 _inst_2 _inst_3], LT.lt.{succ u1} Cardinal.{u1} (Preorder.toHasLt.{succ u1} Cardinal.{u1} (PartialOrder.toPreorder.{succ u1} Cardinal.{u1} Cardinal.partialOrder.{u1})) (Cardinal.mk.{u1} V) Cardinal.aleph0.{u1}
but is expected to have type
  forall (K : Type.{u1}) (V : Type.{u1}) [_inst_1 : DivisionRing.{u1} K] [_inst_2 : AddCommGroup.{u1} V] [_inst_3 : Module.{u1, u1} K V (DivisionSemiring.toSemiring.{u1} K (DivisionRing.toDivisionSemiring.{u1} K _inst_1)) (AddCommGroup.toAddCommMonoid.{u1} V _inst_2)] [_inst_4 : Finite.{succ u1} K] [_inst_5 : FiniteDimensional.{u1, u1} K V _inst_1 _inst_2 _inst_3], LT.lt.{succ u1} Cardinal.{u1} (Preorder.toLT.{succ u1} Cardinal.{u1} (PartialOrder.toPreorder.{succ u1} Cardinal.{u1} Cardinal.partialOrder.{u1})) (Cardinal.mk.{u1} V) Cardinal.aleph0.{u1}
Case conversion may be inaccurate. Consider using '#align cardinal_lt_aleph_0_of_finite_dimensional cardinal_lt_aleph0_of_finiteDimensionalₓ'. -/
theorem cardinal_lt_aleph0_of_finiteDimensional (K V : Type u) [DivisionRing K] [AddCommGroup V]
    [Module K V] [Finite K] [FiniteDimensional K V] : (#V) < ℵ₀ :=
  by
  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance
  rw [cardinal_mk_eq_cardinal_mk_field_pow_rank K V]
  exact Cardinal.power_lt_aleph0 (Cardinal.lt_aleph0_of_finite K) (IsNoetherian.rank_lt_aleph0 K V)
#align cardinal_lt_aleph_0_of_finite_dimensional cardinal_lt_aleph0_of_finiteDimensional

end Module

