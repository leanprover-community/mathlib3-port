/-
Copyright (c) 2021 Shing Tak Lam. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shing Tak Lam

! This file was ported from Lean 3 source module linear_algebra.unitary_group
! leanprover-community/mathlib commit 33c67ae661dd8988516ff7f247b0be3018cdd952
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.GeneralLinearGroup
import Mathbin.LinearAlgebra.Matrix.ToLin
import Mathbin.LinearAlgebra.Matrix.NonsingularInverse
import Mathbin.Algebra.Star.Unitary

/-!
# The Unitary Group

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines elements of the unitary group `unitary_group n α`, where `α` is a `star_ring`.
This consists of all `n` by `n` matrices with entries in `α` such that the star-transpose is its
inverse. In addition, we define the group structure on `unitary_group n α`, and the embedding into
the general linear group `general_linear_group α (n → α)`.

We also define the orthogonal group `orthogonal_group n β`, where `β` is a `comm_ring`.

## Main Definitions

 * `matrix.unitary_group` is the type of matrices where the star-transpose is the inverse
 * `matrix.unitary_group.group` is the group structure (under multiplication)
 * `matrix.unitary_group.embedding_GL` is the embedding `unitary_group n α → GLₙ(α)`
 * `matrix.orthogonal_group` is the type of matrices where the transpose is the inverse

## References

 * https://en.wikipedia.org/wiki/Unitary_group

## Tags

matrix group, group, unitary group, orthogonal group

-/


universe u v

namespace Matrix

open LinearMap

open Matrix

section

variable (n : Type u) [DecidableEq n] [Fintype n]

variable (α : Type v) [CommRing α] [StarRing α]

/- warning: matrix.unitary_group -> Matrix.unitaryGroup is a dubious translation:
lean 3 declaration is
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (α : Type.{u2}) [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))
but is expected to have type
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (α : Type.{u2}) [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group Matrix.unitaryGroupₓ'. -/
/-- `unitary_group n` is the group of `n` by `n` matrices where the star-transpose is the inverse.
-/
abbrev unitaryGroup :=
  unitary (Matrix n n α)
#align matrix.unitary_group Matrix.unitaryGroup

end

variable {n : Type u} [DecidableEq n] [Fintype n]

variable {α : Type v} [CommRing α] [StarRing α]

/- warning: matrix.mem_unitary_group_iff -> Matrix.mem_unitaryGroup_iff is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3)))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))) A (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasStar.{u2, u1} n α (InvolutiveStar.toHasStar.{u2} α (StarAddMonoid.toHasInvolutiveStar.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, Iff (Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))) A (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instStarMatrix.{u2, u1} n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mem_unitary_group_iff Matrix.mem_unitaryGroup_iffₓ'. -/
theorem mem_unitaryGroup_iff {A : Matrix n n α} : A ∈ Matrix.unitaryGroup n α ↔ A * star A = 1 :=
  by
  refine' ⟨And.right, fun hA => ⟨_, hA⟩⟩
  simpa only [mul_eq_mul, mul_eq_one_comm] using hA
#align matrix.mem_unitary_group_iff Matrix.mem_unitaryGroup_iff

/- warning: matrix.mem_unitary_group_iff' -> Matrix.mem_unitaryGroup_iff' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3)))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_2 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))) (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasStar.{u2, u1} n α (InvolutiveStar.toHasStar.{u2} α (StarAddMonoid.toHasInvolutiveStar.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, Iff (Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_2 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))) (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instStarMatrix.{u2, u1} n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mem_unitary_group_iff' Matrix.mem_unitaryGroup_iff'ₓ'. -/
theorem mem_unitaryGroup_iff' {A : Matrix n n α} : A ∈ Matrix.unitaryGroup n α ↔ star A * A = 1 :=
  by
  refine' ⟨And.left, fun hA => ⟨hA, _⟩⟩
  rwa [mul_eq_mul, mul_eq_one_comm] at hA
#align matrix.mem_unitary_group_iff' Matrix.mem_unitaryGroup_iff'

/- warning: matrix.det_of_mem_unitary -> Matrix.det_of_mem_unitary is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} α _inst_3)))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) -> (Membership.Mem.{u2, u2} α (Submonoid.{u2} α (Monoid.toMulOneClass.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (SetLike.hasMem.{u2, u2} (Submonoid.{u2} α (Monoid.toMulOneClass.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)))) α (Submonoid.setLike.{u2} α (Monoid.toMulOneClass.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 A) (unitary.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (StarRing.toStarSemigroup.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] {A : Matrix.{u1, u1, u2} n n α}, (Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) A (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) -> (Membership.mem.{u2, u2} α (Submonoid.{u2} α (Monoid.toMulOneClass.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (SetLike.instMembership.{u2, u2} (Submonoid.{u2} α (Monoid.toMulOneClass.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) α (Submonoid.instSetLikeSubmonoid.{u2} α (Monoid.toMulOneClass.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 A) (unitary.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (StarRing.toStarSemigroup.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4)))
Case conversion may be inaccurate. Consider using '#align matrix.det_of_mem_unitary Matrix.det_of_mem_unitaryₓ'. -/
theorem det_of_mem_unitary {A : Matrix n n α} (hA : A ∈ Matrix.unitaryGroup n α) :
    A.det ∈ unitary α := by
  constructor
  · simpa [star, det_transpose] using congr_arg det hA.1
  · simpa [star, det_transpose] using congr_arg det hA.2
#align matrix.det_of_mem_unitary Matrix.det_of_mem_unitary

namespace UnitaryGroup

/- warning: matrix.unitary_group.coe_matrix -> Matrix.UnitaryGroup.coeMatrix is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Coe.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (Matrix.{u1, u1, u2} n n α)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Coe.{max (succ u1) (succ u2), max (succ u2) (succ u1)} (Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))) (Matrix.{u1, u1, u2} n n α)
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.coe_matrix Matrix.UnitaryGroup.coeMatrixₓ'. -/
instance coeMatrix : Coe (unitaryGroup n α) (Matrix n n α) :=
  ⟨Subtype.val⟩
#align matrix.unitary_group.coe_matrix Matrix.UnitaryGroup.coeMatrix

/- warning: matrix.unitary_group.coe_fun -> Matrix.UnitaryGroup.coeFun is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], CoeFun.{succ (max u1 u2), max (succ u1) (succ u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) (fun (_x : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) => n -> n -> α)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], CoeFun.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))) (fun (_x : Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))) => n -> n -> α)
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.coe_fun Matrix.UnitaryGroup.coeFunₓ'. -/
instance coeFun : CoeFun (unitaryGroup n α) fun _ => n → n → α where coe A := A.val
#align matrix.unitary_group.coe_fun Matrix.UnitaryGroup.coeFun

/- warning: matrix.unitary_group.to_lin' -> Matrix.UnitaryGroup.toLin' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) -> (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] (A : Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))), (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2187 : Matrix.{u1, u1, u2} n n α) => LinearMap.{u2, u2, max u2 u1, max u2 u1} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.ToLin._hyg.2099 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.ToLin._hyg.2102 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.ToLin._hyg.2099 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.ToLin._hyg.2102 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Subtype.val.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) A)
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_lin' Matrix.UnitaryGroup.toLin'ₓ'. -/
/-- `to_lin' A` is matrix multiplication of vectors by `A`, as a linear map.

After the group structure on `unitary_group n` is defined,
we show in `to_linear_equiv` that this gives a linear equivalence.
-/
def toLin' (A : unitaryGroup n α) :=
  Matrix.toLin' A
#align matrix.unitary_group.to_lin' Matrix.UnitaryGroup.toLin'

/- warning: matrix.unitary_group.ext_iff -> Matrix.UnitaryGroup.ext_iff is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.ext_iff Matrix.UnitaryGroup.ext_iffₓ'. -/
theorem ext_iff (A B : unitaryGroup n α) : A = B ↔ ∀ i j, A i j = B i j :=
  Subtype.ext_iff_val.trans ⟨fun h i j => congr_fun (congr_fun h i) j, Matrix.ext⟩
#align matrix.unitary_group.ext_iff Matrix.UnitaryGroup.ext_iff

/- warning: matrix.unitary_group.ext -> Matrix.UnitaryGroup.ext is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.ext Matrix.UnitaryGroup.extₓ'. -/
@[ext]
theorem ext (A B : unitaryGroup n α) : (∀ i j, A i j = B i j) → A = B :=
  (UnitaryGroup.ext_iff A B).mpr
#align matrix.unitary_group.ext Matrix.UnitaryGroup.ext

/- warning: matrix.unitary_group.star_mul_self -> Matrix.UnitaryGroup.star_mul_self is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.star_mul_self Matrix.UnitaryGroup.star_mul_selfₓ'. -/
@[simp]
theorem star_mul_self (A : unitaryGroup n α) : star A ⬝ A = 1 :=
  A.2.1
#align matrix.unitary_group.star_mul_self Matrix.UnitaryGroup.star_mul_self

section CoeLemmas

variable (A B : unitaryGroup n α)

/- warning: matrix.unitary_group.inv_val -> Matrix.UnitaryGroup.inv_val is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.inv_val Matrix.UnitaryGroup.inv_valₓ'. -/
@[simp]
theorem inv_val : ↑A⁻¹ = (star A : Matrix n n α) :=
  rfl
#align matrix.unitary_group.inv_val Matrix.UnitaryGroup.inv_val

/- warning: matrix.unitary_group.inv_apply -> Matrix.UnitaryGroup.inv_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.inv_apply Matrix.UnitaryGroup.inv_applyₓ'. -/
@[simp]
theorem inv_apply : ⇑A⁻¹ = (star A : Matrix n n α) :=
  rfl
#align matrix.unitary_group.inv_apply Matrix.UnitaryGroup.inv_apply

/- warning: matrix.unitary_group.mul_val -> Matrix.UnitaryGroup.mul_val is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.mul_val Matrix.UnitaryGroup.mul_valₓ'. -/
@[simp]
theorem mul_val : ↑(A * B) = A ⬝ B :=
  rfl
#align matrix.unitary_group.mul_val Matrix.UnitaryGroup.mul_val

/- warning: matrix.unitary_group.mul_apply -> Matrix.UnitaryGroup.mul_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.mul_apply Matrix.UnitaryGroup.mul_applyₓ'. -/
@[simp]
theorem mul_apply : ⇑(A * B) = A ⬝ B :=
  rfl
#align matrix.unitary_group.mul_apply Matrix.UnitaryGroup.mul_apply

/- warning: matrix.unitary_group.one_val -> Matrix.UnitaryGroup.one_val is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.one_val Matrix.UnitaryGroup.one_valₓ'. -/
@[simp]
theorem one_val : ↑(1 : unitaryGroup n α) = (1 : Matrix n n α) :=
  rfl
#align matrix.unitary_group.one_val Matrix.UnitaryGroup.one_val

/- warning: matrix.unitary_group.one_apply -> Matrix.UnitaryGroup.one_apply is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.one_apply Matrix.UnitaryGroup.one_applyₓ'. -/
@[simp]
theorem one_apply : ⇑(1 : unitaryGroup n α) = (1 : Matrix n n α) :=
  rfl
#align matrix.unitary_group.one_apply Matrix.UnitaryGroup.one_apply

/- warning: matrix.unitary_group.to_lin'_mul -> Matrix.UnitaryGroup.toLin'_mul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_lin'_mul Matrix.UnitaryGroup.toLin'_mulₓ'. -/
@[simp]
theorem toLin'_mul : toLin' (A * B) = (toLin' A).comp (toLin' B) :=
  Matrix.toLin'_mul A B
#align matrix.unitary_group.to_lin'_mul Matrix.UnitaryGroup.toLin'_mul

/- warning: matrix.unitary_group.to_lin'_one -> Matrix.UnitaryGroup.toLin'_one is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_lin'_one Matrix.UnitaryGroup.toLin'_oneₓ'. -/
@[simp]
theorem toLin'_one : toLin' (1 : unitaryGroup n α) = LinearMap.id :=
  Matrix.toLin'_one
#align matrix.unitary_group.to_lin'_one Matrix.UnitaryGroup.toLin'_one

end CoeLemmas

/- warning: matrix.unitary_group.to_linear_equiv -> Matrix.UnitaryGroup.toLinearEquiv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) -> (LinearEquiv.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Matrix.UnitaryGroup.toLinearEquiv._proof_1.{u2} α _inst_3) (Matrix.UnitaryGroup.toLinearEquiv._proof_2.{u2} α _inst_3) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], (Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))) -> (LinearEquiv.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (RingHomInvPair.ids.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (RingHomInvPair.ids.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.UnitaryGroup._hyg.1017 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.UnitaryGroup._hyg.1017 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_linear_equiv Matrix.UnitaryGroup.toLinearEquivₓ'. -/
/-- `to_linear_equiv A` is matrix multiplication of vectors by `A`, as a linear equivalence. -/
def toLinearEquiv (A : unitaryGroup n α) : (n → α) ≃ₗ[α] n → α :=
  { Matrix.toLin' A with
    invFun := toLin' A⁻¹
    left_inv := fun x =>
      calc
        (toLin' A⁻¹).comp (toLin' A) x = (toLin' (A⁻¹ * A)) x := by rw [← to_lin'_mul]
        _ = x := by rw [mul_left_inv, to_lin'_one, id_apply]
        
    right_inv := fun x =>
      calc
        (toLin' A).comp (toLin' A⁻¹) x = toLin' (A * A⁻¹) x := by rw [← to_lin'_mul]
        _ = x := by rw [mul_right_inv, to_lin'_one, id_apply]
         }
#align matrix.unitary_group.to_linear_equiv Matrix.UnitaryGroup.toLinearEquiv

/- warning: matrix.unitary_group.to_GL -> Matrix.UnitaryGroup.toGL is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) Type.{max u1 u2} (SetLike.hasCoeToSort.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_2 (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_1 a b) a b) (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4)) -> (LinearMap.GeneralLinearGroup.{u2, max u1 u2} α (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], (Subtype.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (fun (x : Matrix.{u1, u1, u2} n n α) => Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n α) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) x (Matrix.unitaryGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 α _inst_3 _inst_4))) -> (LinearMap.GeneralLinearGroup.{u2, max u1 u2} α (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.UnitaryGroup._hyg.1291 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_GL Matrix.UnitaryGroup.toGLₓ'. -/
/-- `to_GL` is the map from the unitary group to the general linear group -/
def toGL (A : unitaryGroup n α) : GeneralLinearGroup α (n → α) :=
  GeneralLinearGroup.ofLinearEquiv (toLinearEquiv A)
#align matrix.unitary_group.to_GL Matrix.UnitaryGroup.toGL

/- warning: matrix.unitary_group.coe_to_GL -> Matrix.UnitaryGroup.coe_toGL is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.coe_to_GL Matrix.UnitaryGroup.coe_toGLₓ'. -/
theorem coe_toGL (A : unitaryGroup n α) : ↑(toGL A) = toLin' A :=
  rfl
#align matrix.unitary_group.coe_to_GL Matrix.UnitaryGroup.coe_toGL

/- warning: matrix.unitary_group.to_GL_one -> Matrix.UnitaryGroup.toGL_one is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_GL_one Matrix.UnitaryGroup.toGL_oneₓ'. -/
@[simp]
theorem toGL_one : toGL (1 : unitaryGroup n α) = 1 :=
  by
  ext1 v i
  rw [coe_to_GL, to_lin'_one]
  rfl
#align matrix.unitary_group.to_GL_one Matrix.UnitaryGroup.toGL_one

/- warning: matrix.unitary_group.to_GL_mul -> Matrix.UnitaryGroup.toGL_mul is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.to_GL_mul Matrix.UnitaryGroup.toGL_mulₓ'. -/
@[simp]
theorem toGL_mul (A B : unitaryGroup n α) : toGL (A * B) = toGL A * toGL B :=
  by
  ext1 v i
  rw [coe_to_GL, to_lin'_mul]
  rfl
#align matrix.unitary_group.to_GL_mul Matrix.UnitaryGroup.toGL_mul

/- warning: matrix.unitary_group.embedding_GL -> Matrix.UnitaryGroup.embeddingGL is a dubious translation:
<too large>
Case conversion may be inaccurate. Consider using '#align matrix.unitary_group.embedding_GL Matrix.UnitaryGroup.embeddingGLₓ'. -/
/-- `unitary_group.embedding_GL` is the embedding from `unitary_group n α`
to `general_linear_group n α`. -/
def embeddingGL : unitaryGroup n α →* GeneralLinearGroup α (n → α) :=
  ⟨fun A => toGL A, by simp, by simp⟩
#align matrix.unitary_group.embedding_GL Matrix.UnitaryGroup.embeddingGL

end UnitaryGroup

section OrthogonalGroup

variable (n) (β : Type v) [CommRing β]

attribute [local instance] starRingOfComm

/- warning: matrix.orthogonal_group -> Matrix.orthogonalGroup is a dubious translation:
lean 3 declaration is
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β], Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5))))
but is expected to have type
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β], Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))
Case conversion may be inaccurate. Consider using '#align matrix.orthogonal_group Matrix.orthogonalGroupₓ'. -/
/-- `orthogonal_group n` is the group of `n` by `n` matrices where the transpose is the inverse.
-/
abbrev orthogonalGroup :=
  unitaryGroup n β
#align matrix.orthogonal_group Matrix.orthogonalGroup

/- warning: matrix.mem_orthogonal_group_iff -> Matrix.mem_orthogonalGroup_iff is a dubious translation:
lean 3 declaration is
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β] {A : Matrix.{u1, u1, u2} n n β}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5))))) (Matrix.{u1, u1, u2} n n β) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5)))))) A (Matrix.orthogonalGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 β _inst_5)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n β) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasMul.{u2, u1} n β _inst_2 (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (CommRing.toRing.{u2} β _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} β (NonUnitalNonAssocRing.toAddCommGroup.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5))))))) A (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasStar.{u2, u1} n β (InvolutiveStar.toHasStar.{u2} β (StarAddMonoid.toHasInvolutiveStar.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (CommSemiring.toNonUnitalCommSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) (StarRing.toStarAddMonoid.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (CommSemiring.toNonUnitalCommSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5))) (starRingOfComm.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasOne.{u2, u1} n β (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5)))))) (AddMonoidWithOne.toOne.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (AddCommGroupWithOne.toAddGroupWithOne.{u2} β (Ring.toAddCommGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_5))))))))))
but is expected to have type
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β] {A : Matrix.{u1, u1, u2} n n β}, Iff (Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n β) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) A (Matrix.orthogonalGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 β _inst_5)) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n β) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.instMulMatrix.{u2, u1} n β _inst_2 (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5))))))) A (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.instStarMatrix.{u2, u1} n β (InvolutiveStar.toStar.{u2} β (StarAddMonoid.toInvolutiveStar.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_5)))) (StarRing.toStarAddMonoid.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} β (CommRing.toNonUnitalCommRing.{u2} β _inst_5))) (starRingOfComm.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.one.{u2, u1} n β (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} β (CommSemiring.toCommMonoidWithZero.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5))) (Semiring.toOne.{u2} β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mem_orthogonal_group_iff Matrix.mem_orthogonalGroup_iffₓ'. -/
theorem mem_orthogonalGroup_iff {A : Matrix n n β} :
    A ∈ Matrix.orthogonalGroup n β ↔ A * star A = 1 :=
  by
  refine' ⟨And.right, fun hA => ⟨_, hA⟩⟩
  simpa only [mul_eq_mul, mul_eq_one_comm] using hA
#align matrix.mem_orthogonal_group_iff Matrix.mem_orthogonalGroup_iff

/- warning: matrix.mem_orthogonal_group_iff' -> Matrix.mem_orthogonalGroup_iff' is a dubious translation:
lean 3 declaration is
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β] {A : Matrix.{u1, u1, u2} n n β}, Iff (Membership.Mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5))))) (SetLike.hasMem.{max u1 u2, max u1 u2} (Submonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5))))) (Matrix.{u1, u1, u2} n n β) (Submonoid.setLike.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.ring.{u2, u1} n β _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toRing.{u2} β _inst_5)))))) A (Matrix.orthogonalGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 β _inst_5)) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n β) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasMul.{u2, u1} n β _inst_2 (Distrib.toHasMul.{u2} β (Ring.toDistrib.{u2} β (CommRing.toRing.{u2} β _inst_5))) (AddCommGroup.toAddCommMonoid.{u2} β (NonUnitalNonAssocRing.toAddCommGroup.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5))))))) (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasStar.{u2, u1} n β (InvolutiveStar.toHasStar.{u2} β (StarAddMonoid.toHasInvolutiveStar.{u2} β (AddCommMonoid.toAddMonoid.{u2} β (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (CommSemiring.toNonUnitalCommSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) (StarRing.toStarAddMonoid.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (CommSemiring.toNonUnitalCommSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5))) (starRingOfComm.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.hasOne.{u2, u1} n β (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u2} β (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5)))))) (AddMonoidWithOne.toOne.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (AddCommGroupWithOne.toAddGroupWithOne.{u2} β (Ring.toAddCommGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_5))))))))))
but is expected to have type
  forall (n : Type.{u1}) [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] (β : Type.{u2}) [_inst_5 : CommRing.{u2} β] {A : Matrix.{u1, u1, u2} n n β}, Iff (Membership.mem.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (SetLike.instMembership.{max u1 u2, max u1 u2} (Submonoid.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Matrix.{u1, u1, u2} n n β) (Submonoid.instSetLikeSubmonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Monoid.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n β) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.semiring.{u2, u1} n β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) A (Matrix.orthogonalGroup.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 β _inst_5)) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n β) (HMul.hMul.{max u1 u2, max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (Matrix.{u1, u1, u2} n n β) (instHMul.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.instMulMatrix.{u2, u1} n β _inst_2 (NonUnitalNonAssocRing.toMul.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} β (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} β (NonAssocRing.toNonUnitalNonAssocRing.{u2} β (Ring.toNonAssocRing.{u2} β (CommRing.toRing.{u2} β _inst_5))))))) (Star.star.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.instStarMatrix.{u2, u1} n β (InvolutiveStar.toStar.{u2} β (StarAddMonoid.toInvolutiveStar.{u2} β (AddMonoidWithOne.toAddMonoid.{u2} β (AddGroupWithOne.toAddMonoidWithOne.{u2} β (Ring.toAddGroupWithOne.{u2} β (CommRing.toRing.{u2} β _inst_5)))) (StarRing.toStarAddMonoid.{u2} β (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} β (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} β (CommRing.toNonUnitalCommRing.{u2} β _inst_5))) (starRingOfComm.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n β) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n β) (Matrix.one.{u2, u1} n β (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} β (CommSemiring.toCommMonoidWithZero.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5))) (Semiring.toOne.{u2} β (CommSemiring.toSemiring.{u2} β (CommRing.toCommSemiring.{u2} β _inst_5)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mem_orthogonal_group_iff' Matrix.mem_orthogonalGroup_iff'ₓ'. -/
theorem mem_orthogonalGroup_iff' {A : Matrix n n β} :
    A ∈ Matrix.orthogonalGroup n β ↔ star A * A = 1 :=
  by
  refine' ⟨And.left, fun hA => ⟨hA, _⟩⟩
  rwa [mul_eq_mul, mul_eq_one_comm] at hA
#align matrix.mem_orthogonal_group_iff' Matrix.mem_orthogonalGroup_iff'

end OrthogonalGroup

end Matrix

