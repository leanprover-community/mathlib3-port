/-
Copyright (c) 2021 Lu-Ming Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lu-Ming Zhang

! This file was ported from Lean 3 source module linear_algebra.matrix.is_diag
! leanprover-community/mathlib commit 55e2dfde0cff928ce5c70926a3f2c7dee3e2dd99
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Matrix.Symmetric
import Mathbin.LinearAlgebra.Matrix.Orthogonal
import Mathbin.Data.Matrix.Kronecker

/-!
# Diagonal matrices

This file contains the definition and basic results about diagonal matrices.

## Main results

- `matrix.is_diag`: a proposition that states a given square matrix `A` is diagonal.

## Tags

diag, diagonal, matrix
-/


namespace Matrix

variable {α β R n m : Type _}

open Function

open Matrix Kronecker

#print Matrix.IsDiag /-
/-- `A.is_diag` means square matrix `A` is a diagonal matrix. -/
def IsDiag [Zero α] (A : Matrix n n α) : Prop :=
  ∀ ⦃i j⦄, i ≠ j → A i j = 0
#align matrix.is_diag Matrix.IsDiag
-/

/- warning: matrix.is_diag_diagonal -> Matrix.isDiag_diagonal is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] [_inst_2 : DecidableEq.{succ u2} n] (d : n -> α), Matrix.IsDiag.{u1, u2} α n _inst_1 (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 d)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] [_inst_2 : DecidableEq.{succ u1} n] (d : n -> α), Matrix.IsDiag.{u2, u1} α n _inst_1 (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 d)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_diagonal Matrix.isDiag_diagonalₓ'. -/
@[simp]
theorem isDiag_diagonal [Zero α] [DecidableEq n] (d : n → α) : (diagonal d).IsDiag := fun i j =>
  Matrix.diagonal_apply_ne _
#align matrix.is_diag_diagonal Matrix.isDiag_diagonal

/- warning: matrix.is_diag.diagonal_diag -> Matrix.IsDiag.diagonal_diag is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] [_inst_2 : DecidableEq.{succ u2} n] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n _inst_1 A) -> (Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n α) (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 (Matrix.diag.{u1, u2} n α A)) A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] [_inst_2 : DecidableEq.{succ u1} n] {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n _inst_1 A) -> (Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n α) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 (Matrix.diag.{u2, u1} n α A)) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.diagonal_diag Matrix.IsDiag.diagonal_diagₓ'. -/
/-- Diagonal matrices are generated by the `matrix.diagonal` of their `matrix.diag`. -/
theorem IsDiag.diagonal_diag [Zero α] [DecidableEq n] {A : Matrix n n α} (h : A.IsDiag) :
    diagonal (diag A) = A :=
  ext fun i j => by
    obtain rfl | hij := Decidable.eq_or_ne i j
    · rw [diagonal_apply_eq, diag]
    · rw [diagonal_apply_ne _ hij, h hij]
#align matrix.is_diag.diagonal_diag Matrix.IsDiag.diagonal_diag

/- warning: matrix.is_diag_iff_diagonal_diag -> Matrix.isDiag_iff_diagonal_diag is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] [_inst_2 : DecidableEq.{succ u2} n] (A : Matrix.{u2, u2, u1} n n α), Iff (Matrix.IsDiag.{u1, u2} α n _inst_1 A) (Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n α) (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 (Matrix.diag.{u1, u2} n α A)) A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] [_inst_2 : DecidableEq.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α), Iff (Matrix.IsDiag.{u2, u1} α n _inst_1 A) (Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n α) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 (Matrix.diag.{u2, u1} n α A)) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_iff_diagonal_diag Matrix.isDiag_iff_diagonal_diagₓ'. -/
/-- `matrix.is_diag.diagonal_diag` as an iff. -/
theorem isDiag_iff_diagonal_diag [Zero α] [DecidableEq n] (A : Matrix n n α) :
    A.IsDiag ↔ diagonal (diag A) = A :=
  ⟨IsDiag.diagonal_diag, fun hd => hd ▸ isDiag_diagonal (diag A)⟩
#align matrix.is_diag_iff_diagonal_diag Matrix.isDiag_iff_diagonal_diag

/- warning: matrix.is_diag_of_subsingleton -> Matrix.isDiag_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] [_inst_2 : Subsingleton.{succ u2} n] (A : Matrix.{u2, u2, u1} n n α), Matrix.IsDiag.{u1, u2} α n _inst_1 A
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] [_inst_2 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n α), Matrix.IsDiag.{u2, u1} α n _inst_1 A
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_of_subsingleton Matrix.isDiag_of_subsingletonₓ'. -/
/-- Every matrix indexed by a subsingleton is diagonal. -/
theorem isDiag_of_subsingleton [Zero α] [Subsingleton n] (A : Matrix n n α) : A.IsDiag :=
  fun i j h => (h <| Subsingleton.elim i j).elim
#align matrix.is_diag_of_subsingleton Matrix.isDiag_of_subsingleton

/- warning: matrix.is_diag_zero -> Matrix.isDiag_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α], Matrix.IsDiag.{u1, u2} α n _inst_1 (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n α) 0 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n α) 0 (Zero.zero.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasZero.{u1, u2, u2} n n α _inst_1))))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α], Matrix.IsDiag.{u2, u1} α n _inst_1 (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α _inst_1)))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_zero Matrix.isDiag_zeroₓ'. -/
/-- Every zero matrix is diagonal. -/
@[simp]
theorem isDiag_zero [Zero α] : (0 : Matrix n n α).IsDiag := fun i j h => rfl
#align matrix.is_diag_zero Matrix.isDiag_zero

#print Matrix.isDiag_one /-
/-- Every identity matrix is diagonal. -/
@[simp]
theorem isDiag_one [DecidableEq n] [Zero α] [One α] : (1 : Matrix n n α).IsDiag := fun i j =>
  one_apply_ne
#align matrix.is_diag_one Matrix.isDiag_one
-/

/- warning: matrix.is_diag.map -> Matrix.IsDiag.map is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {β : Type.{u2}} {n : Type.{u3}} [_inst_1 : Zero.{u1} α] [_inst_2 : Zero.{u2} β] {A : Matrix.{u3, u3, u1} n n α}, (Matrix.IsDiag.{u1, u3} α n _inst_1 A) -> (forall {f : α -> β}, (Eq.{succ u2} β (f (OfNat.ofNat.{u1} α 0 (OfNat.mk.{u1} α 0 (Zero.zero.{u1} α _inst_1)))) (OfNat.ofNat.{u2} β 0 (OfNat.mk.{u2} β 0 (Zero.zero.{u2} β _inst_2)))) -> (Matrix.IsDiag.{u2, u3} β n _inst_2 (Matrix.map.{u1, u2, u3, u3} n n α β A f)))
but is expected to have type
  forall {α : Type.{u3}} {β : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u3} α] [_inst_2 : Zero.{u2} β] {A : Matrix.{u1, u1, u3} n n α}, (Matrix.IsDiag.{u3, u1} α n _inst_1 A) -> (forall {f : α -> β}, (Eq.{succ u2} β (f (OfNat.ofNat.{u3} α 0 (Zero.toOfNat0.{u3} α _inst_1))) (OfNat.ofNat.{u2} β 0 (Zero.toOfNat0.{u2} β _inst_2))) -> (Matrix.IsDiag.{u2, u1} β n _inst_2 (Matrix.map.{u3, u2, u1, u1} n n α β A f)))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.map Matrix.IsDiag.mapₓ'. -/
theorem IsDiag.map [Zero α] [Zero β] {A : Matrix n n α} (ha : A.IsDiag) {f : α → β} (hf : f 0 = 0) :
    (A.map f).IsDiag := by
  intro i j h
  simp [ha h, hf]
#align matrix.is_diag.map Matrix.IsDiag.map

/- warning: matrix.is_diag.neg -> Matrix.IsDiag.neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : AddGroup.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) A) -> (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasNeg.{u1, u2, u2} n n α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) A))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : AddGroup.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) A) -> (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) (Neg.neg.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.neg.{u2, u1, u1} n n α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1))))) A))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.neg Matrix.IsDiag.negₓ'. -/
theorem IsDiag.neg [AddGroup α] {A : Matrix n n α} (ha : A.IsDiag) : (-A).IsDiag :=
  by
  intro i j h
  simp [ha h]
#align matrix.is_diag.neg Matrix.IsDiag.neg

/- warning: matrix.is_diag_neg_iff -> Matrix.isDiag_neg_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : AddGroup.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, Iff (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasNeg.{u1, u2, u2} n n α (SubNegMonoid.toHasNeg.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1))) A)) (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : AddGroup.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, Iff (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) (Neg.neg.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.neg.{u2, u1, u1} n n α (NegZeroClass.toNeg.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1))))) A)) (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_neg_iff Matrix.isDiag_neg_iffₓ'. -/
@[simp]
theorem isDiag_neg_iff [AddGroup α] {A : Matrix n n α} : (-A).IsDiag ↔ A.IsDiag :=
  ⟨fun ha i j h => neg_eq_zero.1 (ha h), IsDiag.neg⟩
#align matrix.is_diag_neg_iff Matrix.isDiag_neg_iff

/- warning: matrix.is_diag.add -> Matrix.IsDiag.add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : AddZeroClass.{u1} α] {A : Matrix.{u2, u2, u1} n n α} {B : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α _inst_1) A) -> (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α _inst_1) B) -> (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.{u2, u2, u1} n n α) (Matrix.{u2, u2, u1} n n α) (instHAdd.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasAdd.{u1, u2, u2} n n α (AddZeroClass.toHasAdd.{u1} α _inst_1))) A B))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : AddZeroClass.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n (AddZeroClass.toZero.{u2} α _inst_1) A) -> (Matrix.IsDiag.{u2, u1} α n (AddZeroClass.toZero.{u2} α _inst_1) B) -> (Matrix.IsDiag.{u2, u1} α n (AddZeroClass.toZero.{u2} α _inst_1) (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHAdd.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.add.{u2, u1, u1} n n α (AddZeroClass.toAdd.{u2} α _inst_1))) A B))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.add Matrix.IsDiag.addₓ'. -/
theorem IsDiag.add [AddZeroClass α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) :
    (A + B).IsDiag := by
  intro i j h
  simp [ha h, hb h]
#align matrix.is_diag.add Matrix.IsDiag.add

/- warning: matrix.is_diag.sub -> Matrix.IsDiag.sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : AddGroup.{u1} α] {A : Matrix.{u2, u2, u1} n n α} {B : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) A) -> (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) B) -> (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (SubNegMonoid.toAddMonoid.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.{u2, u2, u1} n n α) (Matrix.{u2, u2, u1} n n α) (instHSub.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasSub.{u1, u2, u2} n n α (SubNegMonoid.toHasSub.{u1} α (AddGroup.toSubNegMonoid.{u1} α _inst_1)))) A B))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : AddGroup.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) A) -> (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) B) -> (Matrix.IsDiag.{u2, u1} α n (NegZeroClass.toZero.{u2} α (SubNegZeroMonoid.toNegZeroClass.{u2} α (SubtractionMonoid.toSubNegZeroMonoid.{u2} α (AddGroup.toSubtractionMonoid.{u2} α _inst_1)))) (HSub.hSub.{max u2 u1, max u2 u1, max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSub.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.sub.{u2, u1, u1} n n α (SubNegMonoid.toSub.{u2} α (AddGroup.toSubNegMonoid.{u2} α _inst_1)))) A B))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.sub Matrix.IsDiag.subₓ'. -/
theorem IsDiag.sub [AddGroup α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) :
    (A - B).IsDiag := by
  intro i j h
  simp [ha h, hb h]
#align matrix.is_diag.sub Matrix.IsDiag.sub

/- warning: matrix.is_diag.smul -> Matrix.IsDiag.smul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {R : Type.{u2}} {n : Type.{u3}} [_inst_1 : Monoid.{u2} R] [_inst_2 : AddMonoid.{u1} α] [_inst_3 : DistribMulAction.{u2, u1} R α _inst_1 _inst_2] (k : R) {A : Matrix.{u3, u3, u1} n n α}, (Matrix.IsDiag.{u1, u3} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_2)) A) -> (Matrix.IsDiag.{u1, u3} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_2)) (SMul.smul.{u2, max u3 u1} R (Matrix.{u3, u3, u1} n n α) (Matrix.hasSmul.{u1, u3, u3, u2} n n R α (SMulZeroClass.toHasSmul.{u2, u1} R α (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α _inst_2)) (DistribSMul.toSmulZeroClass.{u2, u1} R α (AddMonoid.toAddZeroClass.{u1} α _inst_2) (DistribMulAction.toDistribSMul.{u2, u1} R α _inst_1 _inst_2 _inst_3)))) k A))
but is expected to have type
  forall {α : Type.{u2}} {R : Type.{u3}} {n : Type.{u1}} [_inst_1 : Monoid.{u3} R] [_inst_2 : AddMonoid.{u2} α] [_inst_3 : DistribMulAction.{u3, u2} R α _inst_1 _inst_2] (k : R) {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n (AddMonoid.toZero.{u2} α _inst_2) A) -> (Matrix.IsDiag.{u2, u1} α n (AddMonoid.toZero.{u2} α _inst_2) (HSMul.hSMul.{u3, max u2 u1, max u2 u1} R (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u3, max u2 u1} R (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u3} n n R α (SMulZeroClass.toSMul.{u3, u2} R α (AddMonoid.toZero.{u2} α _inst_2) (DistribSMul.toSMulZeroClass.{u3, u2} R α (AddMonoid.toAddZeroClass.{u2} α _inst_2) (DistribMulAction.toDistribSMul.{u3, u2} R α _inst_1 _inst_2 _inst_3))))) k A))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.smul Matrix.IsDiag.smulₓ'. -/
theorem IsDiag.smul [Monoid R] [AddMonoid α] [DistribMulAction R α] (k : R) {A : Matrix n n α}
    (ha : A.IsDiag) : (k • A).IsDiag := by
  intro i j h
  simp [ha h]
#align matrix.is_diag.smul Matrix.IsDiag.smul

/- warning: matrix.is_diag_smul_one -> Matrix.isDiag_smul_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} (n : Type.{u2}) [_inst_1 : Semiring.{u1} α] [_inst_2 : DecidableEq.{succ u2} n] (k : α), Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (SMul.smul.{u1, max u2 u1} α (Matrix.{u2, u2, u1} n n α) (Matrix.hasSmul.{u1, u2, u2, u1} n n α α (Mul.toSMul.{u1} α (Distrib.toHasMul.{u1} α (NonUnitalNonAssocSemiring.toDistrib.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))) k (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n α) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n α) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.hasOne.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (AddMonoidWithOne.toOne.{u1} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u1} α (NonAssocSemiring.toAddCommMonoidWithOne.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))))
but is expected to have type
  forall {α : Type.{u1}} (n : Type.{u2}) [_inst_1 : Semiring.{u1} α] [_inst_2 : DecidableEq.{succ u2} n] (k : α), Matrix.IsDiag.{u1, u2} α n (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) (HSMul.hSMul.{u1, max u1 u2, max u1 u2} α (Matrix.{u2, u2, u1} n n α) (Matrix.{u2, u2, u1} n n α) (instHSMul.{u1, max u1 u2} α (Matrix.{u2, u2, u1} n n α) (Matrix.smul.{u1, u2, u2, u1} n n α α (SMulZeroClass.toSMul.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) (SMulWithZero.toSMulZeroClass.{u1, u1} α α (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) (MulZeroClass.toSMulWithZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))))))) k (OfNat.ofNat.{max u1 u2} (Matrix.{u2, u2, u1} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u2, u2, u1} n n α) (Matrix.one.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_1)) (Semiring.toOne.{u1} α _inst_1)))))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_smul_one Matrix.isDiag_smul_oneₓ'. -/
@[simp]
theorem isDiag_smul_one (n) [Semiring α] [DecidableEq n] (k : α) :
    (k • (1 : Matrix n n α)).IsDiag :=
  isDiag_one.smul k
#align matrix.is_diag_smul_one Matrix.isDiag_smul_one

/- warning: matrix.is_diag.transpose -> Matrix.IsDiag.transpose is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n _inst_1 A) -> (Matrix.IsDiag.{u1, u2} α n _inst_1 (Matrix.transpose.{u1, u2, u2} n n α A))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n _inst_1 A) -> (Matrix.IsDiag.{u2, u1} α n _inst_1 (Matrix.transpose.{u2, u1, u1} n n α A))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.transpose Matrix.IsDiag.transposeₓ'. -/
theorem IsDiag.transpose [Zero α] {A : Matrix n n α} (ha : A.IsDiag) : Aᵀ.IsDiag := fun i j h =>
  ha h.symm
#align matrix.is_diag.transpose Matrix.IsDiag.transpose

/- warning: matrix.is_diag_transpose_iff -> Matrix.isDiag_transpose_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, Iff (Matrix.IsDiag.{u1, u2} α n _inst_1 (Matrix.transpose.{u1, u2, u2} n n α A)) (Matrix.IsDiag.{u1, u2} α n _inst_1 A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, Iff (Matrix.IsDiag.{u2, u1} α n _inst_1 (Matrix.transpose.{u2, u1, u1} n n α A)) (Matrix.IsDiag.{u2, u1} α n _inst_1 A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_transpose_iff Matrix.isDiag_transpose_iffₓ'. -/
@[simp]
theorem isDiag_transpose_iff [Zero α] {A : Matrix n n α} : Aᵀ.IsDiag ↔ A.IsDiag :=
  ⟨IsDiag.transpose, IsDiag.transpose⟩
#align matrix.is_diag_transpose_iff Matrix.isDiag_transpose_iff

/- warning: matrix.is_diag.conj_transpose -> Matrix.IsDiag.conjTranspose is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Semiring.{u1} α] [_inst_2 : StarRing.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1)] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) A) -> (Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (Matrix.conjTranspose.{u1, u2, u2} n n α (InvolutiveStar.toHasStar.{u1} α (StarAddMonoid.toHasInvolutiveStar.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1)))) (StarRing.toStarAddMonoid.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1) _inst_2))) A))
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Semiring.{u2} α] [_inst_2 : StarRing.{u2} α (Semiring.toNonUnitalSemiring.{u2} α _inst_1)] {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1)) A) -> (Matrix.IsDiag.{u2, u1} α n (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1)) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (StarRing.toStarAddMonoid.{u2} α (Semiring.toNonUnitalSemiring.{u2} α _inst_1) _inst_2))) A))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.conj_transpose Matrix.IsDiag.conjTransposeₓ'. -/
theorem IsDiag.conjTranspose [Semiring α] [StarRing α] {A : Matrix n n α} (ha : A.IsDiag) :
    Aᴴ.IsDiag :=
  ha.transpose.map (star_zero _)
#align matrix.is_diag.conj_transpose Matrix.IsDiag.conjTranspose

/- warning: matrix.is_diag_conj_transpose_iff -> Matrix.isDiag_conjTranspose_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Semiring.{u1} α] [_inst_2 : StarRing.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1)] {A : Matrix.{u2, u2, u1} n n α}, Iff (Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) (Matrix.conjTranspose.{u1, u2, u2} n n α (InvolutiveStar.toHasStar.{u1} α (StarAddMonoid.toHasInvolutiveStar.{u1} α (AddCommMonoid.toAddMonoid.{u1} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1)))) (StarRing.toStarAddMonoid.{u1} α (Semiring.toNonUnitalSemiring.{u1} α _inst_1) _inst_2))) A)) (Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_1)))) A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Semiring.{u2} α] [_inst_2 : StarRing.{u2} α (Semiring.toNonUnitalSemiring.{u2} α _inst_1)] {A : Matrix.{u1, u1, u2} n n α}, Iff (Matrix.IsDiag.{u2, u1} α n (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1)) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_1)))) (StarRing.toStarAddMonoid.{u2} α (Semiring.toNonUnitalSemiring.{u2} α _inst_1) _inst_2))) A)) (Matrix.IsDiag.{u2, u1} α n (MonoidWithZero.toZero.{u2} α (Semiring.toMonoidWithZero.{u2} α _inst_1)) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_conj_transpose_iff Matrix.isDiag_conjTranspose_iffₓ'. -/
@[simp]
theorem isDiag_conjTranspose_iff [Semiring α] [StarRing α] {A : Matrix n n α} :
    Aᴴ.IsDiag ↔ A.IsDiag :=
  ⟨fun ha => by
    convert ha.conj_transpose
    simp, IsDiag.conjTranspose⟩
#align matrix.is_diag_conj_transpose_iff Matrix.isDiag_conjTranspose_iff

/- warning: matrix.is_diag.submatrix -> Matrix.IsDiag.submatrix is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n _inst_1 A) -> (forall {f : m -> n}, (Function.Injective.{succ u3, succ u2} m n f) -> (Matrix.IsDiag.{u1, u3} α m _inst_1 (Matrix.submatrix.{u1, u3, u2, u2, u3} m n n m α A f f)))
but is expected to have type
  forall {α : Type.{u3}} {n : Type.{u2}} {m : Type.{u1}} [_inst_1 : Zero.{u3} α] {A : Matrix.{u2, u2, u3} n n α}, (Matrix.IsDiag.{u3, u2} α n _inst_1 A) -> (forall {f : m -> n}, (Function.Injective.{succ u1, succ u2} m n f) -> (Matrix.IsDiag.{u3, u1} α m _inst_1 (Matrix.submatrix.{u3, u1, u2, u2, u1} m n n m α A f f)))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.submatrix Matrix.IsDiag.submatrixₓ'. -/
theorem IsDiag.submatrix [Zero α] {A : Matrix n n α} (ha : A.IsDiag) {f : m → n}
    (hf : Injective f) : (A.submatrix f f).IsDiag := fun i j h => ha (hf.Ne h)
#align matrix.is_diag.submatrix Matrix.IsDiag.submatrix

/- warning: matrix.is_diag.kronecker -> Matrix.IsDiag.kronecker is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : MulZeroClass.{u1} α] {A : Matrix.{u3, u3, u1} m m α} {B : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u3} α m (MulZeroClass.toHasZero.{u1} α _inst_1) A) -> (Matrix.IsDiag.{u1, u2} α n (MulZeroClass.toHasZero.{u1} α _inst_1) B) -> (Matrix.IsDiag.{u1, max u3 u2} α (Prod.{u3, u2} m n) (MulZeroClass.toHasZero.{u1} α _inst_1) (Matrix.kroneckerMap.{u1, u1, u1, u3, u3, u2, u2} α α α m m n n (HMul.hMul.{u1, u1, u1} α α α (instHMul.{u1} α (MulZeroClass.toHasMul.{u1} α _inst_1))) A B))
but is expected to have type
  forall {α : Type.{u3}} {n : Type.{u1}} {m : Type.{u2}} [_inst_1 : MulZeroClass.{u3} α] {A : Matrix.{u2, u2, u3} m m α} {B : Matrix.{u1, u1, u3} n n α}, (Matrix.IsDiag.{u3, u2} α m (MulZeroClass.toZero.{u3} α _inst_1) A) -> (Matrix.IsDiag.{u3, u1} α n (MulZeroClass.toZero.{u3} α _inst_1) B) -> (Matrix.IsDiag.{u3, max u1 u2} α (Prod.{u2, u1} m n) (MulZeroClass.toZero.{u3} α _inst_1) (Matrix.kroneckerMap.{u3, u3, u3, u2, u2, u1, u1} α α α m m n n (fun (x._@.Mathlib.LinearAlgebra.Matrix.IsDiag._hyg.853 : α) (x._@.Mathlib.LinearAlgebra.Matrix.IsDiag._hyg.855 : α) => HMul.hMul.{u3, u3, u3} α α α (instHMul.{u3} α (MulZeroClass.toMul.{u3} α _inst_1)) x._@.Mathlib.LinearAlgebra.Matrix.IsDiag._hyg.853 x._@.Mathlib.LinearAlgebra.Matrix.IsDiag._hyg.855) A B))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.kronecker Matrix.IsDiag.kroneckerₓ'. -/
/-- `(A ⊗ B).is_diag` if both `A` and `B` are diagonal. -/
theorem IsDiag.kronecker [MulZeroClass α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.IsDiag)
    (hB : B.IsDiag) : (A ⊗ₖ B).IsDiag :=
  by
  rintro ⟨a, b⟩ ⟨c, d⟩ h
  simp only [Prod.mk.inj_iff, Ne.def, not_and_or] at h
  cases' h with hac hbd
  · simp [hA hac]
  · simp [hB hbd]
#align matrix.is_diag.kronecker Matrix.IsDiag.kronecker

/- warning: matrix.is_diag.is_symm -> Matrix.IsDiag.isSymm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u2} α n _inst_1 A) -> (Matrix.IsSymm.{u1, u2} α n A)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} [_inst_1 : Zero.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, (Matrix.IsDiag.{u2, u1} α n _inst_1 A) -> (Matrix.IsSymm.{u2, u1} α n A)
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.is_symm Matrix.IsDiag.isSymmₓ'. -/
theorem IsDiag.isSymm [Zero α] {A : Matrix n n α} (h : A.IsDiag) : A.IsSymm :=
  by
  ext (i j)
  by_cases g : i = j; · rw [g]
  simp [h g, h (Ne.symm g)]
#align matrix.is_diag.is_symm Matrix.IsDiag.isSymm

/- warning: matrix.is_diag.from_blocks -> Matrix.IsDiag.fromBlocks is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u3, u3, u1} m m α} {D : Matrix.{u2, u2, u1} n n α}, (Matrix.IsDiag.{u1, u3} α m _inst_1 A) -> (Matrix.IsDiag.{u1, u2} α n _inst_1 D) -> (Matrix.IsDiag.{u1, max u3 u2} α (Sum.{u3, u2} m n) _inst_1 (Matrix.fromBlocks.{u3, u2, u3, u2, u1} m n m n α A (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) (Matrix.hasZero.{u1, u3, u2} m n α _inst_1)))) (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) (Matrix.hasZero.{u1, u2, u3} n m α _inst_1)))) D))
but is expected to have type
  forall {α : Type.{u3}} {n : Type.{u1}} {m : Type.{u2}} [_inst_1 : Zero.{u3} α] {A : Matrix.{u2, u2, u3} m m α} {D : Matrix.{u1, u1, u3} n n α}, (Matrix.IsDiag.{u3, u2} α m _inst_1 A) -> (Matrix.IsDiag.{u3, u1} α n _inst_1 D) -> (Matrix.IsDiag.{u3, max u1 u2} α (Sum.{u2, u1} m n) _inst_1 (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n α A (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) (Matrix.zero.{u3, u2, u1} m n α _inst_1))) (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} n m α) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} n m α) (Matrix.zero.{u3, u1, u2} n m α _inst_1))) D))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.from_blocks Matrix.IsDiag.fromBlocksₓ'. -/
/-- The block matrix `A.from_blocks 0 0 D` is diagonal if `A` and `D` are diagonal. -/
theorem IsDiag.fromBlocks [Zero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.IsDiag)
    (hd : D.IsDiag) : (A.fromBlocks 0 0 D).IsDiag :=
  by
  rintro (i | i) (j | j) hij
  · exact ha (ne_of_apply_ne _ hij)
  · rfl
  · rfl
  · exact hd (ne_of_apply_ne _ hij)
#align matrix.is_diag.from_blocks Matrix.IsDiag.fromBlocks

/- warning: matrix.is_diag_from_blocks_iff -> Matrix.isDiag_fromBlocks_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u3, u3, u1} m m α} {B : Matrix.{u3, u2, u1} m n α} {C : Matrix.{u2, u3, u1} n m α} {D : Matrix.{u2, u2, u1} n n α}, Iff (Matrix.IsDiag.{u1, max u3 u2} α (Sum.{u3, u2} m n) _inst_1 (Matrix.fromBlocks.{u3, u2, u3, u2, u1} m n m n α A B C D)) (And (Matrix.IsDiag.{u1, u3} α m _inst_1 A) (And (Eq.{succ (max u3 u2 u1)} (Matrix.{u3, u2, u1} m n α) B (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) (Matrix.hasZero.{u1, u3, u2} m n α _inst_1))))) (And (Eq.{succ (max u2 u3 u1)} (Matrix.{u2, u3, u1} n m α) C (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} n m α) (Matrix.hasZero.{u1, u2, u3} n m α _inst_1))))) (Matrix.IsDiag.{u1, u2} α n _inst_1 D))))
but is expected to have type
  forall {α : Type.{u3}} {n : Type.{u1}} {m : Type.{u2}} [_inst_1 : Zero.{u3} α] {A : Matrix.{u2, u2, u3} m m α} {B : Matrix.{u2, u1, u3} m n α} {C : Matrix.{u1, u2, u3} n m α} {D : Matrix.{u1, u1, u3} n n α}, Iff (Matrix.IsDiag.{u3, max u1 u2} α (Sum.{u2, u1} m n) _inst_1 (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n α A B C D)) (And (Matrix.IsDiag.{u3, u2} α m _inst_1 A) (And (Eq.{max (max (succ u3) (succ u1)) (succ u2)} (Matrix.{u2, u1, u3} m n α) B (OfNat.ofNat.{max (max u3 u1) u2} (Matrix.{u2, u1, u3} m n α) 0 (Zero.toOfNat0.{max (max u3 u1) u2} (Matrix.{u2, u1, u3} m n α) (Matrix.zero.{u3, u2, u1} m n α _inst_1)))) (And (Eq.{max (max (succ u3) (succ u1)) (succ u2)} (Matrix.{u1, u2, u3} n m α) C (OfNat.ofNat.{max (max u3 u1) u2} (Matrix.{u1, u2, u3} n m α) 0 (Zero.toOfNat0.{max (max u3 u1) u2} (Matrix.{u1, u2, u3} n m α) (Matrix.zero.{u3, u1, u2} n m α _inst_1)))) (Matrix.IsDiag.{u3, u1} α n _inst_1 D))))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag_from_blocks_iff Matrix.isDiag_fromBlocks_iffₓ'. -/
/-- This is the `iff` version of `matrix.is_diag.from_blocks`. -/
theorem isDiag_fromBlocks_iff [Zero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}
    {D : Matrix n n α} : (A.fromBlocks B C D).IsDiag ↔ A.IsDiag ∧ B = 0 ∧ C = 0 ∧ D.IsDiag :=
  by
  constructor
  · intro h
    refine' ⟨fun i j hij => _, ext fun i j => _, ext fun i j => _, fun i j hij => _⟩
    · exact h (sum.inl_injective.ne hij)
    · exact h Sum.inl_ne_inr
    · exact h Sum.inr_ne_inl
    · exact h (sum.inr_injective.ne hij)
  · rintro ⟨ha, hb, hc, hd⟩
    convert is_diag.from_blocks ha hd
#align matrix.is_diag_from_blocks_iff Matrix.isDiag_fromBlocks_iff

/- warning: matrix.is_diag.from_blocks_of_is_symm -> Matrix.IsDiag.fromBlocks_of_isSymm is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Zero.{u1} α] {A : Matrix.{u3, u3, u1} m m α} {C : Matrix.{u2, u3, u1} n m α} {D : Matrix.{u2, u2, u1} n n α}, (Matrix.IsSymm.{u1, max u3 u2} α (Sum.{u3, u2} m n) (Matrix.fromBlocks.{u3, u2, u3, u2, u1} m n m n α A (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) (Matrix.hasZero.{u1, u3, u2} m n α _inst_1)))) C D)) -> (Matrix.IsDiag.{u1, u3} α m _inst_1 A) -> (Matrix.IsDiag.{u1, u2} α n _inst_1 D) -> (Matrix.IsDiag.{u1, max u3 u2} α (Sum.{u3, u2} m n) _inst_1 (Matrix.fromBlocks.{u3, u2, u3, u2, u1} m n m n α A (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} m n α) (Matrix.hasZero.{u1, u3, u2} m n α _inst_1)))) C D))
but is expected to have type
  forall {α : Type.{u3}} {n : Type.{u1}} {m : Type.{u2}} [_inst_1 : Zero.{u3} α] {A : Matrix.{u2, u2, u3} m m α} {C : Matrix.{u1, u2, u3} n m α} {D : Matrix.{u1, u1, u3} n n α}, (Matrix.IsSymm.{u3, max u1 u2} α (Sum.{u2, u1} m n) (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n α A (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) (Matrix.zero.{u3, u2, u1} m n α _inst_1))) C D)) -> (Matrix.IsDiag.{u3, u2} α m _inst_1 A) -> (Matrix.IsDiag.{u3, u1} α n _inst_1 D) -> (Matrix.IsDiag.{u3, max u1 u2} α (Sum.{u2, u1} m n) _inst_1 (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n α A (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n α) (Matrix.zero.{u3, u2, u1} m n α _inst_1))) C D))
Case conversion may be inaccurate. Consider using '#align matrix.is_diag.from_blocks_of_is_symm Matrix.IsDiag.fromBlocks_of_isSymmₓ'. -/
/-- A symmetric block matrix `A.from_blocks B C D` is diagonal
    if  `A` and `D` are diagonal and `B` is `0`. -/
theorem IsDiag.fromBlocks_of_isSymm [Zero α] {A : Matrix m m α} {C : Matrix n m α}
    {D : Matrix n n α} (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) :
    (A.fromBlocks 0 C D).IsDiag :=
  by
  rw [← (is_symm_from_blocks_iff.1 h).2.1]
  exact ha.from_blocks hd
#align matrix.is_diag.from_blocks_of_is_symm Matrix.IsDiag.fromBlocks_of_isSymm

/- warning: matrix.mul_transpose_self_is_diag_iff_has_orthogonal_rows -> Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRows is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : Mul.{u1} α] [_inst_3 : AddCommMonoid.{u1} α] {A : Matrix.{u3, u2, u1} m n α}, Iff (Matrix.IsDiag.{u1, u3} α m (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_3))) (Matrix.mul.{u1, u3, u2, u3} m n m α _inst_1 _inst_2 _inst_3 A (Matrix.transpose.{u1, u3, u2} m n α A))) (Matrix.HasOrthogonalRows.{u1, u2, u3} α n m _inst_2 _inst_3 A _inst_1)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u3}} {m : Type.{u1}} [_inst_1 : Fintype.{u3} n] [_inst_2 : Mul.{u2} α] [_inst_3 : AddCommMonoid.{u2} α] {A : Matrix.{u1, u3, u2} m n α}, Iff (Matrix.IsDiag.{u2, u1} α m (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_3)) (Matrix.mul.{u2, u1, u3, u1} m n m α _inst_1 _inst_2 _inst_3 A (Matrix.transpose.{u2, u1, u3} m n α A))) (Matrix.HasOrthogonalRows.{u2, u3, u1} α n m _inst_2 _inst_3 A _inst_1)
Case conversion may be inaccurate. Consider using '#align matrix.mul_transpose_self_is_diag_iff_has_orthogonal_rows Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRowsₓ'. -/
theorem mul_transpose_self_isDiag_iff_hasOrthogonalRows [Fintype n] [Mul α] [AddCommMonoid α]
    {A : Matrix m n α} : (A ⬝ Aᵀ).IsDiag ↔ A.HasOrthogonalRows :=
  Iff.rfl
#align matrix.mul_transpose_self_is_diag_iff_has_orthogonal_rows Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRows

/- warning: matrix.transpose_mul_self_is_diag_iff_has_orthogonal_cols -> Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalCols is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u1}} {n : Type.{u2}} {m : Type.{u3}} [_inst_1 : Fintype.{u3} m] [_inst_2 : Mul.{u1} α] [_inst_3 : AddCommMonoid.{u1} α] {A : Matrix.{u3, u2, u1} m n α}, Iff (Matrix.IsDiag.{u1, u2} α n (AddZeroClass.toHasZero.{u1} α (AddMonoid.toAddZeroClass.{u1} α (AddCommMonoid.toAddMonoid.{u1} α _inst_3))) (Matrix.mul.{u1, u2, u3, u2} n m n α _inst_1 _inst_2 _inst_3 (Matrix.transpose.{u1, u3, u2} m n α A) A)) (Matrix.HasOrthogonalCols.{u1, u2, u3} α n m _inst_2 _inst_3 A _inst_1)
but is expected to have type
  forall {α : Type.{u2}} {n : Type.{u1}} {m : Type.{u3}} [_inst_1 : Fintype.{u3} m] [_inst_2 : Mul.{u2} α] [_inst_3 : AddCommMonoid.{u2} α] {A : Matrix.{u3, u1, u2} m n α}, Iff (Matrix.IsDiag.{u2, u1} α n (AddMonoid.toZero.{u2} α (AddCommMonoid.toAddMonoid.{u2} α _inst_3)) (Matrix.mul.{u2, u1, u3, u1} n m n α _inst_1 _inst_2 _inst_3 (Matrix.transpose.{u2, u3, u1} m n α A) A)) (Matrix.HasOrthogonalCols.{u2, u1, u3} α n m _inst_2 _inst_3 A _inst_1)
Case conversion may be inaccurate. Consider using '#align matrix.transpose_mul_self_is_diag_iff_has_orthogonal_cols Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalColsₓ'. -/
theorem transpose_mul_self_isDiag_iff_hasOrthogonalCols [Fintype m] [Mul α] [AddCommMonoid α]
    {A : Matrix m n α} : (Aᵀ ⬝ A).IsDiag ↔ A.HasOrthogonalCols :=
  Iff.rfl
#align matrix.transpose_mul_self_is_diag_iff_has_orthogonal_cols Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalCols

end Matrix

