/-
Copyright (c) 2019 Tim Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tim Baanen, Lu-Ming Zhang

! This file was ported from Lean 3 source module linear_algebra.matrix.nonsingular_inverse
! leanprover-community/mathlib commit 9d2f0748e6c50d7a2657c564b1ff2c695b39148d
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Matrix.Adjugate

/-!
# Nonsingular inverses

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we define an inverse for square matrices of invertible determinant.

For matrices that are not square or not of full rank, there is a more general notion of
pseudoinverses which we do not consider here.

The definition of inverse used in this file is the adjugate divided by the determinant.
We show that dividing the adjugate by `det A` (if possible), giving a matrix `A⁻¹` (`nonsing_inv`),
will result in a multiplicative inverse to `A`.

Note that there are at least three different inverses in mathlib:

* `A⁻¹` (`has_inv.inv`): alone, this satisfies no properties, although it is usually used in
  conjunction with `group` or `group_with_zero`. On matrices, this is defined to be zero when no
  inverse exists.
* `⅟A` (`inv_of`): this is only available in the presence of `[invertible A]`, which guarantees an
  inverse exists.
* `ring.inverse A`: this is defined on any `monoid_with_zero`, and just like `⁻¹` on matrices, is
  defined to be zero when no inverse exists.

We start by working with `invertible`, and show the main results:

* `matrix.invertible_of_det_invertible`
* `matrix.det_invertible_of_invertible`
* `matrix.is_unit_iff_is_unit_det`
* `matrix.mul_eq_one_comm`

After this we define `matrix.has_inv` and show it matches `⅟A` and `ring.inverse A`.
The rest of the results in the file are then about `A⁻¹`

## References

  * https://en.wikipedia.org/wiki/Cramer's_rule#Finding_inverse_matrix

## Tags

matrix inverse, cramer, cramer's rule, adjugate
-/


namespace Matrix

universe u u' v

variable {l : Type _} {m : Type u} {n : Type u'} {α : Type v}

open Matrix BigOperators

open Equiv Equiv.Perm Finset

/-! ### Matrices are `invertible` iff their determinants are -/


section Invertible

variable [Fintype n] [DecidableEq n] [CommRing α]

/- warning: matrix.inv_of_mul_self -> Matrix.invOf_mul_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A _inst_4) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A _inst_4) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_mul_self Matrix.invOf_mul_selfₓ'. -/
/-- A copy of `inv_of_mul_self` using `⬝` not `*`. -/
protected theorem invOf_mul_self (A : Matrix n n α) [Invertible A] : ⅟ A ⬝ A = 1 :=
  invOf_mul_self A
#align matrix.inv_of_mul_self Matrix.invOf_mul_self

/- warning: matrix.mul_inv_of_self -> Matrix.mul_invOf_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A _inst_4)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A _inst_4)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_of_self Matrix.mul_invOf_selfₓ'. -/
/-- A copy of `mul_inv_of_self` using `⬝` not `*`. -/
protected theorem mul_invOf_self (A : Matrix n n α) [Invertible A] : A ⬝ ⅟ A = 1 :=
  mul_invOf_self A
#align matrix.mul_inv_of_self Matrix.mul_invOf_self

/- warning: matrix.inv_of_mul_self_assoc -> Matrix.invOf_mul_self_assoc is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A _inst_4) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A _inst_4) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_mul_self_assoc Matrix.invOf_mul_self_assocₓ'. -/
/-- A copy of `inv_of_mul_self_assoc` using `⬝` not `*`. -/
protected theorem invOf_mul_self_assoc (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :
    ⅟ A ⬝ (A ⬝ B) = B := by rw [← Matrix.mul_assoc, Matrix.invOf_mul_self, Matrix.one_mul]
#align matrix.inv_of_mul_self_assoc Matrix.invOf_mul_self_assoc

/- warning: matrix.mul_inv_of_self_assoc -> Matrix.mul_invOf_self_assoc is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A _inst_4) B)) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A _inst_4) B)) B
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_of_self_assoc Matrix.mul_invOf_self_assocₓ'. -/
/-- A copy of `mul_inv_of_self_assoc` using `⬝` not `*`. -/
protected theorem mul_invOf_self_assoc (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :
    A ⬝ (⅟ A ⬝ B) = B := by rw [← Matrix.mul_assoc, Matrix.mul_invOf_self, Matrix.one_mul]
#align matrix.mul_inv_of_self_assoc Matrix.mul_invOf_self_assoc

/- warning: matrix.mul_inv_of_mul_self_cancel -> Matrix.mul_invOf_mul_self_cancel is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u1, u2, u3} m n α) (B : Matrix.{u2, u2, u3} n n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) B], Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) B _inst_4)) B) A
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u1, u2, u3} m n α) (B : Matrix.{u2, u2, u3} n n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) B], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) B _inst_4)) B) A
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_of_mul_self_cancel Matrix.mul_invOf_mul_self_cancelₓ'. -/
/-- A copy of `mul_inv_of_mul_self_cancel` using `⬝` not `*`. -/
protected theorem mul_invOf_mul_self_cancel (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :
    A ⬝ ⅟ B ⬝ B = A := by rw [Matrix.mul_assoc, Matrix.invOf_mul_self, Matrix.mul_one]
#align matrix.mul_inv_of_mul_self_cancel Matrix.mul_invOf_mul_self_cancel

/- warning: matrix.mul_mul_inv_of_self_cancel -> Matrix.mul_mul_invOf_self_cancel is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u1, u2, u3} m n α) (B : Matrix.{u2, u2, u3} n n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) B], Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) B _inst_4)) A
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u1, u2, u3} m n α) (B : Matrix.{u2, u2, u3} n n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) B], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) B _inst_4)) A
Case conversion may be inaccurate. Consider using '#align matrix.mul_mul_inv_of_self_cancel Matrix.mul_mul_invOf_self_cancelₓ'. -/
/-- A copy of `mul_mul_inv_of_self_cancel` using `⬝` not `*`. -/
protected theorem mul_mul_invOf_self_cancel (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :
    A ⬝ B ⬝ ⅟ B = A := by rw [Matrix.mul_assoc, Matrix.mul_invOf_self, Matrix.mul_one]
#align matrix.mul_mul_inv_of_self_cancel Matrix.mul_mul_invOf_self_cancel

variable (A : Matrix n n α) (B : Matrix n n α)

/- warning: matrix.invertible_of_det_invertible -> Matrix.invertibleOfDetInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_det_invertible Matrix.invertibleOfDetInvertibleₓ'. -/
/-- If `A.det` has a constructive inverse, produce one for `A`. -/
def invertibleOfDetInvertible [Invertible A.det] : Invertible A
    where
  invOf := ⅟ A.det • A.adjugate
  mul_invOf_self := by
    rw [mul_smul_comm, Matrix.mul_eq_mul, mul_adjugate, smul_smul, invOf_mul_self, one_smul]
  invOf_mul_self := by
    rw [smul_mul_assoc, Matrix.mul_eq_mul, adjugate_mul, smul_smul, invOf_mul_self, one_smul]
#align matrix.invertible_of_det_invertible Matrix.invertibleOfDetInvertible

/- warning: matrix.inv_of_eq -> Matrix.invOf_eq is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)] [_inst_5 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A _inst_5) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Invertible.invOf.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_4) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)] [_inst_5 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A _inst_5) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Invertible.invOf.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_4) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_eq Matrix.invOf_eqₓ'. -/
theorem invOf_eq [Invertible A.det] [Invertible A] : ⅟ A = ⅟ A.det • A.adjugate :=
  by
  letI := invertible_of_det_invertible A
  convert(rfl : ⅟ A = _)
#align matrix.inv_of_eq Matrix.invOf_eq

/- warning: matrix.det_invertible_of_left_inverse -> Matrix.detInvertibleOfLeftInverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_invertible_of_left_inverse Matrix.detInvertibleOfLeftInverseₓ'. -/
/-- `A.det` is invertible if `A` has a left inverse. -/
def detInvertibleOfLeftInverse (h : B ⬝ A = 1) : Invertible A.det
    where
  invOf := B.det
  mul_invOf_self := by rw [mul_comm, ← det_mul, h, det_one]
  invOf_mul_self := by rw [← det_mul, h, det_one]
#align matrix.det_invertible_of_left_inverse Matrix.detInvertibleOfLeftInverse

/- warning: matrix.det_invertible_of_right_inverse -> Matrix.detInvertibleOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_invertible_of_right_inverse Matrix.detInvertibleOfRightInverseₓ'. -/
/-- `A.det` is invertible if `A` has a right inverse. -/
def detInvertibleOfRightInverse (h : A ⬝ B = 1) : Invertible A.det
    where
  invOf := B.det
  mul_invOf_self := by rw [← det_mul, h, det_one]
  invOf_mul_self := by rw [mul_comm, ← det_mul, h, det_one]
#align matrix.det_invertible_of_right_inverse Matrix.detInvertibleOfRightInverse

/- warning: matrix.det_invertible_of_invertible -> Matrix.detInvertibleOfInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)
Case conversion may be inaccurate. Consider using '#align matrix.det_invertible_of_invertible Matrix.detInvertibleOfInvertibleₓ'. -/
/-- If `A` has a constructive inverse, produce one for `A.det`. -/
def detInvertibleOfInvertible [Invertible A] : Invertible A.det :=
  detInvertibleOfLeftInverse A (⅟ A) (invOf_mul_self _)
#align matrix.det_invertible_of_invertible Matrix.detInvertibleOfInvertible

/- warning: matrix.det_inv_of -> Matrix.det_invOf is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A] [_inst_5 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A _inst_4)) (Invertible.invOf.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_5)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A] [_inst_5 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A _inst_4)) (Invertible.invOf.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_5)
Case conversion may be inaccurate. Consider using '#align matrix.det_inv_of Matrix.det_invOfₓ'. -/
theorem det_invOf [Invertible A] [Invertible A.det] : (⅟ A).det = ⅟ A.det :=
  by
  letI := det_invertible_of_invertible A
  convert(rfl : _ = ⅟ A.det)
#align matrix.det_inv_of Matrix.det_invOf

/- warning: matrix.invertible_equiv_det_invertible -> Matrix.invertibleEquivDetInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Equiv.{succ (max u1 u2), succ u2} (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A) (Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Equiv.{succ (max u1 u2), succ u2} (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A) (Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.invertible_equiv_det_invertible Matrix.invertibleEquivDetInvertibleₓ'. -/
/-- Together `matrix.det_invertible_of_invertible` and `matrix.invertible_of_det_invertible` form an
equivalence, although both sides of the equiv are subsingleton anyway. -/
@[simps]
def invertibleEquivDetInvertible : Invertible A ≃ Invertible A.det
    where
  toFun := @detInvertibleOfInvertible _ _ _ _ _ A
  invFun := @invertibleOfDetInvertible _ _ _ _ _ A
  left_inv _ := Subsingleton.elim _ _
  right_inv _ := Subsingleton.elim _ _
#align matrix.invertible_equiv_det_invertible Matrix.invertibleEquivDetInvertible

variable {A B}

/- warning: matrix.mul_eq_one_comm -> Matrix.mul_eq_one_comm is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, Iff (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, Iff (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mul_eq_one_comm Matrix.mul_eq_one_commₓ'. -/
theorem mul_eq_one_comm : A ⬝ B = 1 ↔ B ⬝ A = 1 :=
  suffices ∀ A B, A ⬝ B = 1 → B ⬝ A = 1 from ⟨this A B, this B A⟩
  fun A B h => by
  letI : Invertible B.det := det_invertible_of_left_inverse _ _ h
  letI : Invertible B := invertible_of_det_invertible B
  calc
    B ⬝ A = B ⬝ A ⬝ (B ⬝ ⅟ B) := by rw [Matrix.mul_invOf_self, Matrix.mul_one]
    _ = B ⬝ (A ⬝ B ⬝ ⅟ B) := by simp only [Matrix.mul_assoc]
    _ = B ⬝ ⅟ B := by rw [h, Matrix.one_mul]
    _ = 1 := Matrix.mul_invOf_self B
    
#align matrix.mul_eq_one_comm Matrix.mul_eq_one_comm

variable (A B)

/- warning: matrix.invertible_of_left_inverse -> Matrix.invertibleOfLeftInverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_left_inverse Matrix.invertibleOfLeftInverseₓ'. -/
/-- We can construct an instance of invertible A if A has a left inverse. -/
def invertibleOfLeftInverse (h : B ⬝ A = 1) : Invertible A :=
  ⟨B, h, mul_eq_one_comm.mp h⟩
#align matrix.invertible_of_left_inverse Matrix.invertibleOfLeftInverse

/- warning: matrix.invertible_of_right_inverse -> Matrix.invertibleOfRightInverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_right_inverse Matrix.invertibleOfRightInverseₓ'. -/
/-- We can construct an instance of invertible A if A has a right inverse. -/
def invertibleOfRightInverse (h : A ⬝ B = 1) : Invertible A :=
  ⟨B, mul_eq_one_comm.mp h, h⟩
#align matrix.invertible_of_right_inverse Matrix.invertibleOfRightInverse

/- warning: matrix.invertible_transpose -> Matrix.invertibleTranspose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.transpose.{u2, u1, u1} n n α A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.transpose.{u2, u1, u1} n n α A)
Case conversion may be inaccurate. Consider using '#align matrix.invertible_transpose Matrix.invertibleTransposeₓ'. -/
/-- The transpose of an invertible matrix is invertible. -/
instance invertibleTranspose [Invertible A] : Invertible Aᵀ :=
  haveI : Invertible Aᵀ.det := by simpa using det_invertible_of_invertible A
  invertible_of_det_invertible Aᵀ
#align matrix.invertible_transpose Matrix.invertibleTranspose

/- warning: matrix.invertible__of_invertible_transpose -> Matrix.invertibleOfInvertibleTranspose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.transpose.{u2, u1, u1} n n α A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.transpose.{u2, u1, u1} n n α A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A
Case conversion may be inaccurate. Consider using '#align matrix.invertible__of_invertible_transpose Matrix.invertibleOfInvertibleTransposeₓ'. -/
/-- A matrix is invertible if the transpose is invertible. -/
def invertibleOfInvertibleTranspose [Invertible Aᵀ] : Invertible A :=
  by
  rw [← transpose_transpose A]
  infer_instance
#align matrix.invertible__of_invertible_transpose Matrix.invertibleOfInvertibleTranspose

/- warning: matrix.invertible_of_invertible_conj_transpose -> Matrix.invertibleOfInvertibleConjTranspose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] [_inst_5 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toHasStar.{u2} α (StarAddMonoid.toHasInvolutiveStar.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))] [_inst_5 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) A)], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_invertible_conj_transpose Matrix.invertibleOfInvertibleConjTransposeₓ'. -/
/-- A matrix is invertible if the conjugate transpose is invertible. -/
def invertibleOfInvertibleConjTranspose [StarRing α] [Invertible Aᴴ] : Invertible A :=
  by
  rw [← conj_transpose_conj_transpose A]
  infer_instance
#align matrix.invertible_of_invertible_conj_transpose Matrix.invertibleOfInvertibleConjTranspose

/- warning: matrix.unit_of_det_invertible -> Matrix.unitOfDetInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Units.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))
Case conversion may be inaccurate. Consider using '#align matrix.unit_of_det_invertible Matrix.unitOfDetInvertibleₓ'. -/
/-- Given a proof that `A.det` has a constructive inverse, lift `A` to `(matrix n n α)ˣ`-/
def unitOfDetInvertible [Invertible A.det] : (Matrix n n α)ˣ :=
  @unitOfInvertible _ _ A (invertibleOfDetInvertible A)
#align matrix.unit_of_det_invertible Matrix.unitOfDetInvertible

/- warning: matrix.is_unit_iff_is_unit_det -> Matrix.isUnit_iff_isUnit_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))) A) (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) A) (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_iff_is_unit_det Matrix.isUnit_iff_isUnit_detₓ'. -/
/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/
theorem isUnit_iff_isUnit_det : IsUnit A ↔ IsUnit A.det := by
  simp only [← nonempty_invertible_iff_isUnit, (invertible_equiv_det_invertible A).nonempty_congr]
#align matrix.is_unit_iff_is_unit_det Matrix.isUnit_iff_isUnit_det

/-! #### Variants of the statements above with `is_unit`-/


/- warning: matrix.is_unit_det_of_invertible -> Matrix.isUnit_det_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_det_of_invertible Matrix.isUnit_det_of_invertibleₓ'. -/
theorem isUnit_det_of_invertible [Invertible A] : IsUnit A.det :=
  @isUnit_of_invertible _ _ _ (detInvertibleOfInvertible A)
#align matrix.is_unit_det_of_invertible Matrix.isUnit_det_of_invertible

variable {A B}

/- warning: matrix.is_unit_of_left_inverse -> Matrix.isUnit_of_left_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_of_left_inverse Matrix.isUnit_of_left_inverseₓ'. -/
theorem isUnit_of_left_inverse (h : B ⬝ A = 1) : IsUnit A :=
  ⟨⟨A, B, mul_eq_one_comm.mp h, h⟩, rfl⟩
#align matrix.is_unit_of_left_inverse Matrix.isUnit_of_left_inverse

/- warning: matrix.is_unit_of_right_inverse -> Matrix.isUnit_of_right_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_of_right_inverse Matrix.isUnit_of_right_inverseₓ'. -/
theorem isUnit_of_right_inverse (h : A ⬝ B = 1) : IsUnit A :=
  ⟨⟨A, B, h, mul_eq_one_comm.mp h⟩, rfl⟩
#align matrix.is_unit_of_right_inverse Matrix.isUnit_of_right_inverse

/- warning: matrix.is_unit_det_of_left_inverse -> Matrix.isUnit_det_of_left_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_det_of_left_inverse Matrix.isUnit_det_of_left_inverseₓ'. -/
theorem isUnit_det_of_left_inverse (h : B ⬝ A = 1) : IsUnit A.det :=
  @isUnit_of_invertible _ _ _ (detInvertibleOfLeftInverse _ _ h)
#align matrix.is_unit_det_of_left_inverse Matrix.isUnit_det_of_left_inverse

/- warning: matrix.is_unit_det_of_right_inverse -> Matrix.isUnit_det_of_right_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_det_of_right_inverse Matrix.isUnit_det_of_right_inverseₓ'. -/
theorem isUnit_det_of_right_inverse (h : A ⬝ B = 1) : IsUnit A.det :=
  @isUnit_of_invertible _ _ _ (detInvertibleOfRightInverse _ _ h)
#align matrix.is_unit_det_of_right_inverse Matrix.isUnit_det_of_right_inverse

/- warning: matrix.det_ne_zero_of_left_inverse -> Matrix.det_ne_zero_of_left_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} [_inst_4 : Nontrivial.{u2} α], (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Ne.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (OfNat.ofNat.{u2} α 0 (OfNat.mk.{u2} α 0 (Zero.zero.{u2} α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} [_inst_4 : Nontrivial.{u2} α], (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Ne.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_ne_zero_of_left_inverse Matrix.det_ne_zero_of_left_inverseₓ'. -/
theorem det_ne_zero_of_left_inverse [Nontrivial α] (h : B ⬝ A = 1) : A.det ≠ 0 :=
  (isUnit_det_of_left_inverse h).NeZero
#align matrix.det_ne_zero_of_left_inverse Matrix.det_ne_zero_of_left_inverse

/- warning: matrix.det_ne_zero_of_right_inverse -> Matrix.det_ne_zero_of_right_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} [_inst_4 : Nontrivial.{u2} α], (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Ne.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (OfNat.ofNat.{u2} α 0 (OfNat.mk.{u2} α 0 (Zero.zero.{u2} α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} [_inst_4 : Nontrivial.{u2} α], (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Ne.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (OfNat.ofNat.{u2} α 0 (Zero.toOfNat0.{u2} α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_ne_zero_of_right_inverse Matrix.det_ne_zero_of_right_inverseₓ'. -/
theorem det_ne_zero_of_right_inverse [Nontrivial α] (h : A ⬝ B = 1) : A.det ≠ 0 :=
  (isUnit_det_of_right_inverse h).NeZero
#align matrix.det_ne_zero_of_right_inverse Matrix.det_ne_zero_of_right_inverse

end Invertible

variable [Fintype n] [DecidableEq n] [CommRing α]

variable (A : Matrix n n α) (B : Matrix n n α)

/- warning: matrix.is_unit_det_transpose -> Matrix.isUnit_det_transpose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Matrix.transpose.{u2, u1, u1} n n α A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Matrix.transpose.{u2, u1, u1} n n α A)))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_det_transpose Matrix.isUnit_det_transposeₓ'. -/
theorem isUnit_det_transpose (h : IsUnit A.det) : IsUnit Aᵀ.det :=
  by
  rw [det_transpose]
  exact h
#align matrix.is_unit_det_transpose Matrix.isUnit_det_transpose

/-! ### A noncomputable `has_inv` instance  -/


/-- The inverse of a square matrix, when it is invertible (and zero otherwise).-/
noncomputable instance : Inv (Matrix n n α) :=
  ⟨fun A => Ring.inverse A.det • A.adjugate⟩

/- warning: matrix.inv_def -> Matrix.inv_def is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Ring.inverse.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Ring.inverse.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.inv_def Matrix.inv_defₓ'. -/
theorem inv_def (A : Matrix n n α) : A⁻¹ = Ring.inverse A.det • A.adjugate :=
  rfl
#align matrix.inv_def Matrix.inv_def

/- warning: matrix.nonsing_inv_apply_not_is_unit -> Matrix.nonsing_inv_apply_not_isUnit is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (Not (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (Not (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_apply_not_is_unit Matrix.nonsing_inv_apply_not_isUnitₓ'. -/
theorem nonsing_inv_apply_not_isUnit (h : ¬IsUnit A.det) : A⁻¹ = 0 := by
  rw [inv_def, Ring.inverse_non_unit _ h, zero_smul]
#align matrix.nonsing_inv_apply_not_is_unit Matrix.nonsing_inv_apply_not_isUnit

/- warning: matrix.nonsing_inv_apply -> Matrix.nonsing_inv_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (h : IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) ((fun (a : Type.{u2}) (b : Type.{u2}) [self : HasLiftT.{succ u2, succ u2} a b] => self.0) (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (HasLiftT.mk.{succ u2, succ u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (CoeTCₓ.coe.{succ u2, succ u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (coeBase.{succ u2, succ u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (Units.hasCoe.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Inv.inv.{u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Units.hasInv.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (IsUnit.unit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) h))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (h : IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Units.val.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Inv.inv.{u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Units.instInv.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (IsUnit.unit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) h))) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_apply Matrix.nonsing_inv_applyₓ'. -/
theorem nonsing_inv_apply (h : IsUnit A.det) : A⁻¹ = (↑h.Unit⁻¹ : α) • A.adjugate := by
  rw [inv_def, ← Ring.inverse_unit h.unit, IsUnit.unit_spec]
#align matrix.nonsing_inv_apply Matrix.nonsing_inv_apply

/- warning: matrix.inv_of_eq_nonsing_inv -> Matrix.invOf_eq_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A _inst_4) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A _inst_4) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_eq_nonsing_inv Matrix.invOf_eq_nonsing_invₓ'. -/
/-- The nonsingular inverse is the same as `inv_of` when `A` is invertible. -/
@[simp]
theorem invOf_eq_nonsing_inv [Invertible A] : ⅟ A = A⁻¹ :=
  by
  letI := det_invertible_of_invertible A
  rw [inv_def, Ring.inverse_invertible, inv_of_eq]
#align matrix.inv_of_eq_nonsing_inv Matrix.invOf_eq_nonsing_inv

/- warning: matrix.coe_units_inv -> Matrix.coe_units_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (Units.hasCoe.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))))))) (Inv.inv.{max u1 u2} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Units.hasInv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) ((fun (a : Type.{max u1 u2}) (b : Type.{max u1 u2}) [self : HasLiftT.{succ (max u1 u2), succ (max u1 u2)} a b] => self.0) (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (HasLiftT.mk.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (CoeTCₓ.coe.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (coeBase.{succ (max u1 u2), succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.{u1, u1, u2} n n α) (Units.hasCoe.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))))))) A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Units.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Units.val.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) (Inv.inv.{max u1 u2} (Units.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))) (Units.instInv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Units.val.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) A))
Case conversion may be inaccurate. Consider using '#align matrix.coe_units_inv Matrix.coe_units_invₓ'. -/
/-- Coercing the result of `units.has_inv` is the same as coercing first and applying the
nonsingular inverse. -/
@[simp, norm_cast]
theorem coe_units_inv (A : (Matrix n n α)ˣ) : ↑A⁻¹ = (A⁻¹ : Matrix n n α) :=
  by
  letI := A.invertible
  rw [← inv_of_eq_nonsing_inv, invOf_units]
#align matrix.coe_units_inv Matrix.coe_units_inv

/- warning: matrix.nonsing_inv_eq_ring_inverse -> Matrix.nonsing_inv_eq_ring_inverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Ring.inverse.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Ring.inverse.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))) A)
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_eq_ring_inverse Matrix.nonsing_inv_eq_ring_inverseₓ'. -/
/-- The nonsingular inverse is the same as the general `ring.inverse`. -/
theorem nonsing_inv_eq_ring_inverse : A⁻¹ = Ring.inverse A :=
  by
  by_cases h_det : IsUnit A.det
  · cases (A.is_unit_iff_is_unit_det.mpr h_det).nonempty_invertible
    rw [← inv_of_eq_nonsing_inv, Ring.inverse_invertible]
  · have h := mt A.is_unit_iff_is_unit_det.mp h_det
    rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_is_unit A h_det]
#align matrix.nonsing_inv_eq_ring_inverse Matrix.nonsing_inv_eq_ring_inverse

/- warning: matrix.transpose_nonsing_inv -> Matrix.transpose_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.transpose.{u2, u1, u1} n n α (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.transpose.{u2, u1, u1} n n α A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.transpose.{u2, u1, u1} n n α (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.transpose.{u2, u1, u1} n n α A))
Case conversion may be inaccurate. Consider using '#align matrix.transpose_nonsing_inv Matrix.transpose_nonsing_invₓ'. -/
theorem transpose_nonsing_inv : A⁻¹ᵀ = Aᵀ⁻¹ := by
  rw [inv_def, inv_def, transpose_smul, det_transpose, adjugate_transpose]
#align matrix.transpose_nonsing_inv Matrix.transpose_nonsing_inv

/- warning: matrix.conj_transpose_nonsing_inv -> Matrix.conjTranspose_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : StarRing.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toHasStar.{u2} α (StarAddMonoid.toHasInvolutiveStar.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toHasStar.{u2} α (StarAddMonoid.toHasInvolutiveStar.{u2} α (AddCommMonoid.toAddMonoid.{u2} α (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalRing.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalRing.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : StarRing.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3)))], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.conjTranspose.{u2, u1, u1} n n α (InvolutiveStar.toStar.{u2} α (StarAddMonoid.toInvolutiveStar.{u2} α (AddMonoidWithOne.toAddMonoid.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (Ring.toAddGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (StarRing.toStarAddMonoid.{u2} α (NonUnitalCommSemiring.toNonUnitalSemiring.{u2} α (NonUnitalCommRing.toNonUnitalCommSemiring.{u2} α (CommRing.toNonUnitalCommRing.{u2} α _inst_3))) _inst_4))) A))
Case conversion may be inaccurate. Consider using '#align matrix.conj_transpose_nonsing_inv Matrix.conjTranspose_nonsing_invₓ'. -/
theorem conjTranspose_nonsing_inv [StarRing α] : A⁻¹ᴴ = Aᴴ⁻¹ := by
  rw [inv_def, inv_def, conj_transpose_smul, det_conj_transpose, adjugate_conj_transpose,
    Ring.inverse_star]
#align matrix.conj_transpose_nonsing_inv Matrix.conjTranspose_nonsing_inv

/- warning: matrix.mul_nonsing_inv -> Matrix.mul_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.mul_nonsing_inv Matrix.mul_nonsing_invₓ'. -/
/-- The `nonsing_inv` of `A` is a right inverse. -/
@[simp]
theorem mul_nonsing_inv (h : IsUnit A.det) : A ⬝ A⁻¹ = 1 :=
  by
  cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible
  rw [← inv_of_eq_nonsing_inv, Matrix.mul_invOf_self]
#align matrix.mul_nonsing_inv Matrix.mul_nonsing_inv

/- warning: matrix.nonsing_inv_mul -> Matrix.nonsing_inv_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_mul Matrix.nonsing_inv_mulₓ'. -/
/-- The `nonsing_inv` of `A` is a left inverse. -/
@[simp]
theorem nonsing_inv_mul (h : IsUnit A.det) : A⁻¹ ⬝ A = 1 :=
  by
  cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible
  rw [← inv_of_eq_nonsing_inv, Matrix.invOf_mul_self]
#align matrix.nonsing_inv_mul Matrix.nonsing_inv_mul

instance [Invertible A] : Invertible A⁻¹ :=
  by
  rw [← inv_of_eq_nonsing_inv]
  infer_instance

/- warning: matrix.inv_inv_of_invertible -> Matrix.inv_inv_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A
Case conversion may be inaccurate. Consider using '#align matrix.inv_inv_of_invertible Matrix.inv_inv_of_invertibleₓ'. -/
@[simp]
theorem inv_inv_of_invertible [Invertible A] : A⁻¹⁻¹ = A := by
  simp only [← inv_of_eq_nonsing_inv, invOf_invOf]
#align matrix.inv_inv_of_invertible Matrix.inv_inv_of_invertible

/- warning: matrix.mul_nonsing_inv_cancel_right -> Matrix.mul_nonsing_inv_cancel_right is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α), (IsUnit.{u3} α (Ring.toMonoid.{u3} α (CommRing.toRing.{u3} α _inst_3)) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B A) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) B)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α), (IsUnit.{u3} α (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B A) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) B)
Case conversion may be inaccurate. Consider using '#align matrix.mul_nonsing_inv_cancel_right Matrix.mul_nonsing_inv_cancel_rightₓ'. -/
@[simp]
theorem mul_nonsing_inv_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : B ⬝ A ⬝ A⁻¹ = B := by
  simp [Matrix.mul_assoc, mul_nonsing_inv A h]
#align matrix.mul_nonsing_inv_cancel_right Matrix.mul_nonsing_inv_cancel_right

/- warning: matrix.mul_nonsing_inv_cancel_left -> Matrix.mul_nonsing_inv_cancel_left is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α), (IsUnit.{u3} α (Ring.toMonoid.{u3} α (CommRing.toRing.{u3} α _inst_3)) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)) B)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α), (IsUnit.{u3} α (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)) B)
Case conversion may be inaccurate. Consider using '#align matrix.mul_nonsing_inv_cancel_left Matrix.mul_nonsing_inv_cancel_leftₓ'. -/
@[simp]
theorem mul_nonsing_inv_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : A ⬝ (A⁻¹ ⬝ B) = B := by
  simp [← Matrix.mul_assoc, mul_nonsing_inv A h]
#align matrix.mul_nonsing_inv_cancel_left Matrix.mul_nonsing_inv_cancel_left

/- warning: matrix.nonsing_inv_mul_cancel_right -> Matrix.nonsing_inv_mul_cancel_right is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α), (IsUnit.{u3} α (Ring.toMonoid.{u3} α (CommRing.toRing.{u3} α _inst_3)) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A) B)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α), (IsUnit.{u3} α (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A) B)
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_mul_cancel_right Matrix.nonsing_inv_mul_cancel_rightₓ'. -/
@[simp]
theorem nonsing_inv_mul_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : B ⬝ A⁻¹ ⬝ A = B := by
  simp [Matrix.mul_assoc, nonsing_inv_mul A h]
#align matrix.nonsing_inv_mul_cancel_right Matrix.nonsing_inv_mul_cancel_right

/- warning: matrix.nonsing_inv_mul_cancel_left -> Matrix.nonsing_inv_mul_cancel_left is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α), (IsUnit.{u3} α (Ring.toMonoid.{u3} α (CommRing.toRing.{u3} α _inst_3)) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α), (IsUnit.{u3} α (MonoidWithZero.toMonoid.{u3} α (Semiring.toMonoidWithZero.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B)
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_mul_cancel_left Matrix.nonsing_inv_mul_cancel_leftₓ'. -/
@[simp]
theorem nonsing_inv_mul_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : A⁻¹ ⬝ (A ⬝ B) = B := by
  simp [← Matrix.mul_assoc, nonsing_inv_mul A h]
#align matrix.nonsing_inv_mul_cancel_left Matrix.nonsing_inv_mul_cancel_left

/- warning: matrix.mul_inv_of_invertible -> Matrix.mul_inv_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_of_invertible Matrix.mul_inv_of_invertibleₓ'. -/
@[simp]
theorem mul_inv_of_invertible [Invertible A] : A ⬝ A⁻¹ = 1 :=
  mul_nonsing_inv A (isUnit_det_of_invertible A)
#align matrix.mul_inv_of_invertible Matrix.mul_inv_of_invertible

/- warning: matrix.inv_mul_of_invertible -> Matrix.inv_mul_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.inv_mul_of_invertible Matrix.inv_mul_of_invertibleₓ'. -/
@[simp]
theorem inv_mul_of_invertible [Invertible A] : A⁻¹ ⬝ A = 1 :=
  nonsing_inv_mul A (isUnit_det_of_invertible A)
#align matrix.inv_mul_of_invertible Matrix.inv_mul_of_invertible

/- warning: matrix.mul_inv_cancel_right_of_invertible -> Matrix.mul_inv_cancel_right_of_invertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B A) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B A) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) B
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_cancel_right_of_invertible Matrix.mul_inv_cancel_right_of_invertibleₓ'. -/
@[simp]
theorem mul_inv_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : B ⬝ A ⬝ A⁻¹ = B :=
  mul_nonsing_inv_cancel_right A B (isUnit_det_of_invertible A)
#align matrix.mul_inv_cancel_right_of_invertible Matrix.mul_inv_cancel_right_of_invertible

/- warning: matrix.mul_inv_cancel_left_of_invertible -> Matrix.mul_inv_cancel_left_of_invertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)) B
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_cancel_left_of_invertible Matrix.mul_inv_cancel_left_of_invertibleₓ'. -/
@[simp]
theorem mul_inv_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : A ⬝ (A⁻¹ ⬝ B) = B :=
  mul_nonsing_inv_cancel_left A B (isUnit_det_of_invertible A)
#align matrix.mul_inv_cancel_left_of_invertible Matrix.mul_inv_cancel_left_of_invertible

/- warning: matrix.inv_mul_cancel_right_of_invertible -> Matrix.inv_mul_cancel_right_of_invertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u1 u2 u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u1, u2, u3} m n α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u1, u2, u3} m n α) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Matrix.mul.{u3, u1, u2, u2} m n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) B (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A) B
Case conversion may be inaccurate. Consider using '#align matrix.inv_mul_cancel_right_of_invertible Matrix.inv_mul_cancel_right_of_invertibleₓ'. -/
@[simp]
theorem inv_mul_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : B ⬝ A⁻¹ ⬝ A = B :=
  nonsing_inv_mul_cancel_right A B (isUnit_det_of_invertible A)
#align matrix.inv_mul_cancel_right_of_invertible Matrix.inv_mul_cancel_right_of_invertible

/- warning: matrix.inv_mul_cancel_left_of_invertible -> Matrix.inv_mul_cancel_left_of_invertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Eq.{succ (max u2 u1 u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] (A : Matrix.{u2, u2, u3} n n α) (B : Matrix.{u2, u1, u3} n m α) [_inst_4 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Eq.{max (max (succ u1) (succ u2)) (succ u3)} (Matrix.{u2, u1, u3} n m α) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Matrix.mul.{u3, u2, u2, u1} n n m α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3))))) A B)) B
Case conversion may be inaccurate. Consider using '#align matrix.inv_mul_cancel_left_of_invertible Matrix.inv_mul_cancel_left_of_invertibleₓ'. -/
@[simp]
theorem inv_mul_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : A⁻¹ ⬝ (A ⬝ B) = B :=
  nonsing_inv_mul_cancel_left A B (isUnit_det_of_invertible A)
#align matrix.inv_mul_cancel_left_of_invertible Matrix.inv_mul_cancel_left_of_invertible

/- warning: matrix.inv_mul_eq_iff_eq_mul_of_invertible -> Matrix.inv_mul_eq_iff_eq_mul_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α) (C : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Iff (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B) C) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) B (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A C))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α) (C : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Iff (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B) C) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) B (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A C))
Case conversion may be inaccurate. Consider using '#align matrix.inv_mul_eq_iff_eq_mul_of_invertible Matrix.inv_mul_eq_iff_eq_mul_of_invertibleₓ'. -/
theorem inv_mul_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :
    A⁻¹ ⬝ B = C ↔ B = A ⬝ C :=
  ⟨fun h => by rw [← h, mul_inv_cancel_left_of_invertible], fun h => by
    rw [h, inv_mul_cancel_left_of_invertible]⟩
#align matrix.inv_mul_eq_iff_eq_mul_of_invertible Matrix.inv_mul_eq_iff_eq_mul_of_invertible

/- warning: matrix.mul_inv_eq_iff_eq_mul_of_invertible -> Matrix.mul_inv_eq_iff_eq_mul_of_invertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α) (C : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A], Iff (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) C) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) B (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α) (C : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A], Iff (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) C) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) B (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A))
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_eq_iff_eq_mul_of_invertible Matrix.mul_inv_eq_iff_eq_mul_of_invertibleₓ'. -/
theorem mul_inv_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :
    B ⬝ A⁻¹ = C ↔ B = C ⬝ A :=
  ⟨fun h => by rw [← h, inv_mul_cancel_right_of_invertible], fun h => by
    rw [h, mul_inv_cancel_right_of_invertible]⟩
#align matrix.mul_inv_eq_iff_eq_mul_of_invertible Matrix.mul_inv_eq_iff_eq_mul_of_invertible

/- warning: matrix.nonsing_inv_cancel_or_zero -> Matrix.nonsing_inv_cancel_or_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Or (And (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))) (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Or (And (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))) (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))))
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_cancel_or_zero Matrix.nonsing_inv_cancel_or_zeroₓ'. -/
theorem nonsing_inv_cancel_or_zero : A⁻¹ ⬝ A = 1 ∧ A ⬝ A⁻¹ = 1 ∨ A⁻¹ = 0 :=
  by
  by_cases h : IsUnit A.det
  · exact Or.inl ⟨nonsing_inv_mul _ h, mul_nonsing_inv _ h⟩
  · exact Or.inr (nonsing_inv_apply_not_is_unit _ h)
#align matrix.nonsing_inv_cancel_or_zero Matrix.nonsing_inv_cancel_or_zero

/- warning: matrix.det_nonsing_inv_mul_det -> Matrix.det_nonsing_inv_mul_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ u2} α (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) (OfNat.ofNat.{u2} α 1 (OfNat.mk.{u2} α 1 (One.one.{u2} α (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ u2} α (HMul.hMul.{u2, u2, u2} α α α (instHMul.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) (OfNat.ofNat.{u2} α 1 (One.toOfNat1.{u2} α (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_nonsing_inv_mul_det Matrix.det_nonsing_inv_mul_detₓ'. -/
theorem det_nonsing_inv_mul_det (h : IsUnit A.det) : A⁻¹.det * A.det = 1 := by
  rw [← det_mul, A.nonsing_inv_mul h, det_one]
#align matrix.det_nonsing_inv_mul_det Matrix.det_nonsing_inv_mul_det

/- warning: matrix.det_nonsing_inv -> Matrix.det_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Ring.inverse.{u2} α (Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ u2} α (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) (Ring.inverse.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_nonsing_inv Matrix.det_nonsing_invₓ'. -/
@[simp]
theorem det_nonsing_inv : A⁻¹.det = Ring.inverse A.det :=
  by
  by_cases h : IsUnit A.det
  · cases h.nonempty_invertible
    letI := invertible_of_det_invertible A
    rw [Ring.inverse_invertible, ← inv_of_eq_nonsing_inv, det_inv_of]
  cases isEmpty_or_nonempty n
  · rw [det_is_empty, det_is_empty, Ring.inverse_one]
  · rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_is_unit _ h, det_zero ‹_›]
#align matrix.det_nonsing_inv Matrix.det_nonsing_inv

/- warning: matrix.is_unit_nonsing_inv_det -> Matrix.isUnit_nonsing_inv_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_nonsing_inv_det Matrix.isUnit_nonsing_inv_detₓ'. -/
theorem isUnit_nonsing_inv_det (h : IsUnit A.det) : IsUnit A⁻¹.det :=
  isUnit_of_mul_eq_one _ _ (A.det_nonsing_inv_mul_det h)
#align matrix.is_unit_nonsing_inv_det Matrix.isUnit_nonsing_inv_det

/- warning: matrix.nonsing_inv_nonsing_inv -> Matrix.nonsing_inv_nonsing_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)) A)
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_nonsing_inv Matrix.nonsing_inv_nonsing_invₓ'. -/
@[simp]
theorem nonsing_inv_nonsing_inv (h : IsUnit A.det) : A⁻¹⁻¹ = A :=
  calc
    A⁻¹⁻¹ = 1 ⬝ A⁻¹⁻¹ := by rw [Matrix.one_mul]
    _ = A ⬝ A⁻¹ ⬝ A⁻¹⁻¹ := by rw [A.mul_nonsing_inv h]
    _ = A := by
      rw [Matrix.mul_assoc, A⁻¹.mul_nonsing_inv (A.is_unit_nonsing_inv_det h), Matrix.mul_one]
    
#align matrix.nonsing_inv_nonsing_inv Matrix.nonsing_inv_nonsing_inv

/- warning: matrix.is_unit_nonsing_inv_det_iff -> Matrix.isUnit_nonsing_inv_det_iff is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, Iff (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α}, Iff (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A))
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_nonsing_inv_det_iff Matrix.isUnit_nonsing_inv_det_iffₓ'. -/
theorem isUnit_nonsing_inv_det_iff {A : Matrix n n α} : IsUnit A⁻¹.det ↔ IsUnit A.det := by
  rw [Matrix.det_nonsing_inv, isUnit_ring_inverse]
#align matrix.is_unit_nonsing_inv_det_iff Matrix.isUnit_nonsing_inv_det_iff

/- warning: matrix.invertible_of_is_unit_det -> Matrix.invertibleOfIsUnitDet is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_is_unit_det Matrix.invertibleOfIsUnitDetₓ'. -/
-- `is_unit.invertible` lifts the proposition `is_unit A` to a constructive inverse of `A`.
/-- A version of `matrix.invertible_of_det_invertible` with the inverse defeq to `A⁻¹` that is
therefore noncomputable. -/
noncomputable def invertibleOfIsUnitDet (h : IsUnit A.det) : Invertible A :=
  ⟨A⁻¹, nonsing_inv_mul A h, mul_nonsing_inv A h⟩
#align matrix.invertible_of_is_unit_det Matrix.invertibleOfIsUnitDet

/- warning: matrix.nonsing_inv_unit -> Matrix.nonsingInvUnit is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Units.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))))
Case conversion may be inaccurate. Consider using '#align matrix.nonsing_inv_unit Matrix.nonsingInvUnitₓ'. -/
/-- A version of `matrix.units_of_det_invertible` with the inverse defeq to `A⁻¹` that is therefore
noncomputable. -/
noncomputable def nonsingInvUnit (h : IsUnit A.det) : (Matrix n n α)ˣ :=
  @unitOfInvertible _ _ _ (invertibleOfIsUnitDet A h)
#align matrix.nonsing_inv_unit Matrix.nonsingInvUnit

/- warning: matrix.unit_of_det_invertible_eq_nonsing_inv_unit -> Matrix.unitOfDetInvertible_eq_nonsingInvUnit is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Eq.{succ (max u1 u2)} (Units.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3)))) (Matrix.unitOfDetInvertible.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3 A _inst_4) (Matrix.nonsingInvUnit.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3 A (isUnit_of_invertible.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_4))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) [_inst_4 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)], Eq.{max (succ u1) (succ u2)} (Units.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))) (Matrix.unitOfDetInvertible.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3 A _inst_4) (Matrix.nonsingInvUnit.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3 A (isUnit_of_invertible.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) _inst_4))
Case conversion may be inaccurate. Consider using '#align matrix.unit_of_det_invertible_eq_nonsing_inv_unit Matrix.unitOfDetInvertible_eq_nonsingInvUnitₓ'. -/
theorem unitOfDetInvertible_eq_nonsingInvUnit [Invertible A.det] :
    unitOfDetInvertible A = nonsingInvUnit A (isUnit_of_invertible _) :=
  by
  ext
  rfl
#align matrix.unit_of_det_invertible_eq_nonsing_inv_unit Matrix.unitOfDetInvertible_eq_nonsingInvUnit

variable {A} {B}

/- warning: matrix.inv_eq_left_inv -> Matrix.inv_eq_left_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)
Case conversion may be inaccurate. Consider using '#align matrix.inv_eq_left_inv Matrix.inv_eq_left_invₓ'. -/
/-- If matrix A is left invertible, then its inverse equals its left inverse. -/
theorem inv_eq_left_inv (h : B ⬝ A = 1) : A⁻¹ = B :=
  letI := invertible_of_left_inverse _ _ h
  inv_of_eq_nonsing_inv A ▸ invOf_eq_left_inv h
#align matrix.inv_eq_left_inv Matrix.inv_eq_left_inv

/- warning: matrix.inv_eq_right_inv -> Matrix.inv_eq_right_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) B)
Case conversion may be inaccurate. Consider using '#align matrix.inv_eq_right_inv Matrix.inv_eq_right_invₓ'. -/
/-- If matrix A is right invertible, then its inverse equals its right inverse. -/
theorem inv_eq_right_inv (h : A ⬝ B = 1) : A⁻¹ = B :=
  inv_eq_left_inv (mul_eq_one_comm.2 h)
#align matrix.inv_eq_right_inv Matrix.inv_eq_right_inv

section InvEqInv

variable {C : Matrix n n α}

/- warning: matrix.left_inv_eq_left_inv -> Matrix.left_inv_eq_left_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) B C)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) B A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) B C)
Case conversion may be inaccurate. Consider using '#align matrix.left_inv_eq_left_inv Matrix.left_inv_eq_left_invₓ'. -/
/-- The left inverse of matrix A is unique when existing. -/
theorem left_inv_eq_left_inv (h : B ⬝ A = 1) (g : C ⬝ A = 1) : B = C := by
  rw [← inv_eq_left_inv h, ← inv_eq_left_inv g]
#align matrix.left_inv_eq_left_inv Matrix.left_inv_eq_left_inv

/- warning: matrix.right_inv_eq_right_inv -> Matrix.right_inv_eq_right_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A C) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) B C)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A C) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) B C)
Case conversion may be inaccurate. Consider using '#align matrix.right_inv_eq_right_inv Matrix.right_inv_eq_right_invₓ'. -/
/-- The right inverse of matrix A is unique when existing. -/
theorem right_inv_eq_right_inv (h : A ⬝ B = 1) (g : A ⬝ C = 1) : B = C := by
  rw [← inv_eq_right_inv h, ← inv_eq_right_inv g]
#align matrix.right_inv_eq_right_inv Matrix.right_inv_eq_right_inv

/- warning: matrix.right_inv_eq_left_inv -> Matrix.right_inv_eq_left_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.one.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))))))) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) B C)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α} {C : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) C A) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 1 (One.toOfNat1.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) B C)
Case conversion may be inaccurate. Consider using '#align matrix.right_inv_eq_left_inv Matrix.right_inv_eq_left_invₓ'. -/
/-- The right inverse of matrix A equals the left inverse of A when they exist. -/
theorem right_inv_eq_left_inv (h : A ⬝ B = 1) (g : C ⬝ A = 1) : B = C := by
  rw [← inv_eq_right_inv h, ← inv_eq_left_inv g]
#align matrix.right_inv_eq_left_inv Matrix.right_inv_eq_left_inv

/- warning: matrix.inv_inj -> Matrix.inv_inj is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) B)) -> (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) A B)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {A : Matrix.{u1, u1, u2} n n α} {B : Matrix.{u1, u1, u2} n n α}, (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) B)) -> (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) A B)
Case conversion may be inaccurate. Consider using '#align matrix.inv_inj Matrix.inv_injₓ'. -/
theorem inv_inj (h : A⁻¹ = B⁻¹) (h' : IsUnit A.det) : A = B :=
  by
  refine' left_inv_eq_left_inv (mul_nonsing_inv _ h') _
  rw [h]
  refine' mul_nonsing_inv _ _
  rwa [← is_unit_nonsing_inv_det_iff, ← h, is_unit_nonsing_inv_det_iff]
#align matrix.inv_inj Matrix.inv_inj

end InvEqInv

variable (A)

/- warning: matrix.inv_zero -> Matrix.inv_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (OfNat.mk.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.zero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasZero.{u2, u1, u1} n n α (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))))))))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α], Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))) (OfNat.ofNat.{max u1 u2} (Matrix.{u1, u1, u2} n n α) 0 (Zero.toOfNat0.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.zero.{u2, u1, u1} n n α (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))))
Case conversion may be inaccurate. Consider using '#align matrix.inv_zero Matrix.inv_zeroₓ'. -/
@[simp]
theorem inv_zero : (0 : Matrix n n α)⁻¹ = 0 :=
  by
  cases' subsingleton_or_nontrivial α with ht ht
  · simp
  cases' (Fintype.card n).zero_le.eq_or_lt with hc hc
  · rw [eq_comm, Fintype.card_eq_zero_iff] at hc
    haveI := hc
    ext i
    exact (IsEmpty.false i).elim
  · have hn : Nonempty n := fintype.card_pos_iff.mp hc
    refine' nonsing_inv_apply_not_is_unit _ _
    simp [hn]
#align matrix.inv_zero Matrix.inv_zero

noncomputable instance : InvOneClass (Matrix n n α) :=
  { Matrix.hasOne, Matrix.hasInv with inv_one := inv_eq_left_inv (by simp) }

/- warning: matrix.inv_smul -> Matrix.inv_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : α) [_inst_4 : Invertible.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) k], (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) k A)) (SMul.smul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Invertible.invOf.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3))))) k _inst_4) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : α) [_inst_4 : Invertible.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) k], (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) k A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Invertible.invOf.{u2} α (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) k _inst_4) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
Case conversion may be inaccurate. Consider using '#align matrix.inv_smul Matrix.inv_smulₓ'. -/
theorem inv_smul (k : α) [Invertible k] (h : IsUnit A.det) : (k • A)⁻¹ = ⅟ k • A⁻¹ :=
  inv_eq_left_inv (by simp [h, smul_smul])
#align matrix.inv_smul Matrix.inv_smul

/- warning: matrix.inv_smul' -> Matrix.inv_smul' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (SMul.smul.{u2, max u1 u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (Units.hasSmul.{u2, u2} α α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) k A)) (SMul.smul.{u2, max u1 u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (Units.hasSmul.{u2, u2} α α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Inv.inv.{u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Units.hasInv.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) k) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (k : Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Units.instSMulUnits.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) k A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Units.instSMulUnits.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Inv.inv.{u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Units.instInv.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) k) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)))
Case conversion may be inaccurate. Consider using '#align matrix.inv_smul' Matrix.inv_smul'ₓ'. -/
theorem inv_smul' (k : αˣ) (h : IsUnit A.det) : (k • A)⁻¹ = k⁻¹ • A⁻¹ :=
  inv_eq_left_inv (by simp [h, smul_smul])
#align matrix.inv_smul' Matrix.inv_smul'

/- warning: matrix.inv_adjugate -> Matrix.inv_adjugate is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (h : IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A)) (SMul.smul.{u2, max u1 u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Matrix.{u1, u1, u2} n n α) (Matrix.hasSmul.{u2, u1, u1, u2} n n (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) α (Units.hasSmul.{u2, u2} α α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Inv.inv.{u2} (Units.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (Units.hasInv.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) (IsUnit.unit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) h)) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (h : IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u2 u1} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.adjugate.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A)) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (instHSMul.{u2, max u1 u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.{u1, u1, u2} n n α) (Units.instSMulUnits.{u2, max u1 u2} α (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.smul.{u2, u1, u1, u2} n n α α (Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))))) (Inv.inv.{u2} (Units.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Units.instInv.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (IsUnit.unit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) h)) A)
Case conversion may be inaccurate. Consider using '#align matrix.inv_adjugate Matrix.inv_adjugateₓ'. -/
theorem inv_adjugate (A : Matrix n n α) (h : IsUnit A.det) : (adjugate A)⁻¹ = h.Unit⁻¹ • A :=
  by
  refine' inv_eq_left_inv _
  rw [smul_mul, mul_adjugate, Units.smul_def, smul_smul, h.coe_inv_mul, one_smul]
#align matrix.inv_adjugate Matrix.inv_adjugate

section Diagonal

/- warning: matrix.diagonal_invertible -> Matrix.diagonalInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] {α : Type.{u2}} [_inst_4 : NonAssocSemiring.{u2} α] (v : n -> α) [_inst_5 : Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_4)))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddMonoidWithOne.toOne.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α _inst_4)))) v], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MulOneClass.toHasMul.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.nonAssocSemiring.{u2, u1} n α _inst_4 _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))) (MulOneClass.toHasOne.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MulZeroOneClass.toMulOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (NonAssocSemiring.toMulZeroOneClass.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.nonAssocSemiring.{u2, u1} n α _inst_4 _inst_1 (fun (a : n) (b : n) => _inst_2 a b))))) (Matrix.diagonal.{u2, u1} n α (fun (i : n) (j : n) => (fun (a : n) (b : n) => (fun (a : n) (b : n) => _inst_2 a b) a b) i j) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_4))) v)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] {α : Type.{u2}} [_inst_4 : NonAssocSemiring.{u2} α] (v : n -> α) [_inst_5 : Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_4))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonAssocSemiring.toOne.{u2} α _inst_4)) v], Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocSemiring.toMul.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_4)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α _inst_4))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_4)) (NonAssocSemiring.toOne.{u2} α _inst_4)) (Matrix.diagonal.{u2, u1} n α (fun (i : n) (j : n) => _inst_2 i j) (MulZeroOneClass.toZero.{u2} α (NonAssocSemiring.toMulZeroOneClass.{u2} α _inst_4)) v)
Case conversion may be inaccurate. Consider using '#align matrix.diagonal_invertible Matrix.diagonalInvertibleₓ'. -/
/-- `diagonal v` is invertible if `v` is -/
def diagonalInvertible {α} [NonAssocSemiring α] (v : n → α) [Invertible v] :
    Invertible (diagonal v) :=
  Invertible.map (diagonalRingHom n α) v
#align matrix.diagonal_invertible Matrix.diagonalInvertible

/- warning: matrix.inv_of_diagonal_eq -> Matrix.invOf_diagonal_eq is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] {α : Type.{u2}} [_inst_4 : Semiring.{u2} α] (v : n -> α) [_inst_5 : Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddMonoidWithOne.toOne.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) v] [_inst_6 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (AddMonoidWithOne.toOne.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) v)], Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Invertible.invOf.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (AddMonoidWithOne.toOne.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) v) _inst_6) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4)))) (Invertible.invOf.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Distrib.toHasMul.{u2} α (NonUnitalNonAssocSemiring.toDistrib.{u2} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddMonoidWithOne.toOne.{u2} α (AddCommMonoidWithOne.toAddMonoidWithOne.{u2} α (NonAssocSemiring.toAddCommMonoidWithOne.{u2} α (Semiring.toNonAssocSemiring.{u2} α _inst_4))))) v _inst_5))
but is expected to have type
  forall {n : Type.{u2}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] {α : Type.{u1}} [_inst_4 : Semiring.{u1} α] (v : n -> α) [_inst_5 : Invertible.{max u2 u1} (n -> α) (Pi.instMul.{u2, u1} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4)))) (Pi.instOne.{u2, u1} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toOne.{u1} α _inst_4)) v] [_inst_6 : Invertible.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.instMulMatrix.{u1, u2} n α _inst_1 (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4)))) (Matrix.one.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) (Semiring.toOne.{u1} α _inst_4)) (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) v)], Eq.{max (succ u2) (succ u1)} (Matrix.{u2, u2, u1} n n α) (Invertible.invOf.{max u2 u1} (Matrix.{u2, u2, u1} n n α) (Matrix.instMulMatrix.{u1, u2} n α _inst_1 (NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4)))) (Matrix.one.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) (Semiring.toOne.{u1} α _inst_4)) (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) v) _inst_6) (Matrix.diagonal.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MonoidWithZero.toZero.{u1} α (Semiring.toMonoidWithZero.{u1} α _inst_4)) (Invertible.invOf.{max u2 u1} (n -> α) (Pi.instMul.{u2, u1} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toMul.{u1} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} α (Semiring.toNonAssocSemiring.{u1} α _inst_4)))) (Pi.instOne.{u2, u1} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toOne.{u1} α _inst_4)) v _inst_5))
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_diagonal_eq Matrix.invOf_diagonal_eqₓ'. -/
theorem invOf_diagonal_eq {α} [Semiring α] (v : n → α) [Invertible v] [Invertible (diagonal v)] :
    ⅟ (diagonal v) = diagonal (⅟ v) :=
  by
  letI := diagonal_invertible v
  haveI := Invertible.subsingleton (diagonal v)
  convert(rfl : ⅟ (diagonal v) = _)
#align matrix.inv_of_diagonal_eq Matrix.invOf_diagonal_eq

/- warning: matrix.invertible_of_diagonal_invertible -> Matrix.invertibleOfDiagonalInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v)], Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α) [_inst_4 : Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) v)], Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) v
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_diagonal_invertible Matrix.invertibleOfDiagonalInvertibleₓ'. -/
/-- `v` is invertible if `diagonal v` is -/
def invertibleOfDiagonalInvertible (v : n → α) [Invertible (diagonal v)] : Invertible v
    where
  invOf := diag (⅟ (diagonal v))
  invOf_mul_self :=
    funext fun i =>
      by
      letI : Invertible (diagonal v).det := det_invertible_of_invertible _
      rw [inv_of_eq, diag_smul, adjugate_diagonal, diag_diagonal]
      dsimp
      rw [mul_assoc, prod_erase_mul _ _ (Finset.mem_univ _), ← det_diagonal]
      exact mul_invOf_self _
  mul_invOf_self :=
    funext fun i =>
      by
      letI : Invertible (diagonal v).det := det_invertible_of_invertible _
      rw [inv_of_eq, diag_smul, adjugate_diagonal, diag_diagonal]
      dsimp
      rw [mul_left_comm, mul_prod_erase _ _ (Finset.mem_univ _), ← det_diagonal]
      exact mul_invOf_self _
#align matrix.invertible_of_diagonal_invertible Matrix.invertibleOfDiagonalInvertible

/- warning: matrix.diagonal_invertible_equiv_invertible -> Matrix.diagonalInvertibleEquivInvertible is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α), Equiv.{succ (max u1 u2), succ (max u1 u2)} (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v)) (Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α), Equiv.{succ (max u1 u2), succ (max u1 u2)} (Invertible.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) v)) (Invertible.{max u1 u2} (n -> α) (Pi.instMul.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Pi.instOne.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) v)
Case conversion may be inaccurate. Consider using '#align matrix.diagonal_invertible_equiv_invertible Matrix.diagonalInvertibleEquivInvertibleₓ'. -/
/-- Together `matrix.diagonal_invertible` and `matrix.invertible_of_diagonal_invertible` form an
equivalence, although both sides of the equiv are subsingleton anyway. -/
@[simps]
def diagonalInvertibleEquivInvertible (v : n → α) : Invertible (diagonal v) ≃ Invertible v
    where
  toFun := @invertibleOfDiagonalInvertible _ _ _ _ _ _
  invFun := @diagonalInvertible _ _ _ _ _ _
  left_inv _ := Subsingleton.elim _ _
  right_inv _ := Subsingleton.elim _ _
#align matrix.diagonal_invertible_equiv_invertible Matrix.diagonalInvertibleEquivInvertible

/- warning: matrix.is_unit_diagonal -> Matrix.isUnit_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {v : n -> α}, Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.ring.{u2, u1} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) (CommRing.toRing.{u2} α _inst_3))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v)) (IsUnit.{max u1 u2} (n -> α) (Pi.monoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3))) v)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] {v : n -> α}, Iff (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.semiring.{u2, u1} n α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_1 (fun (a : n) (b : n) => _inst_2 a b)))) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) v)) (IsUnit.{max u1 u2} (n -> α) (Pi.monoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) v)
Case conversion may be inaccurate. Consider using '#align matrix.is_unit_diagonal Matrix.isUnit_diagonalₓ'. -/
/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/
@[simp]
theorem isUnit_diagonal {v : n → α} : IsUnit (diagonal v) ↔ IsUnit v := by
  simp only [← nonempty_invertible_iff_isUnit,
    (diagonal_invertible_equiv_invertible v).nonempty_congr]
#align matrix.is_unit_diagonal Matrix.isUnit_diagonal

/- warning: matrix.inv_diagonal -> Matrix.inv_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) v)) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Ring.inverse.{max u1 u2} (n -> α) (Pi.monoidWithZero.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toMonoidWithZero.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) v))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (v : n -> α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) v)) (Matrix.diagonal.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Ring.inverse.{max u1 u2} (n -> α) (Pi.monoidWithZero.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) v))
Case conversion may be inaccurate. Consider using '#align matrix.inv_diagonal Matrix.inv_diagonalₓ'. -/
theorem inv_diagonal (v : n → α) : (diagonal v)⁻¹ = diagonal (Ring.inverse v) :=
  by
  rw [nonsing_inv_eq_ring_inverse]
  by_cases h : IsUnit v
  · have := is_unit_diagonal.mpr h
    cases this.nonempty_invertible
    cases h.nonempty_invertible
    rw [Ring.inverse_invertible, Ring.inverse_invertible, inv_of_diagonal_eq]
  · have := is_unit_diagonal.not.mpr h
    rw [Ring.inverse_non_unit _ h, Pi.zero_def, diagonal_zero, Ring.inverse_non_unit _ this]
#align matrix.inv_diagonal Matrix.inv_diagonal

end Diagonal

/- warning: matrix.inv_inv_inv -> Matrix.inv_inv_inv is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A)
Case conversion may be inaccurate. Consider using '#align matrix.inv_inv_inv Matrix.inv_inv_invₓ'. -/
@[simp]
theorem inv_inv_inv (A : Matrix n n α) : A⁻¹⁻¹⁻¹ = A⁻¹ :=
  by
  by_cases h : IsUnit A.det
  · rw [nonsing_inv_nonsing_inv _ h]
  · simp [nonsing_inv_apply_not_is_unit _ h]
#align matrix.inv_inv_inv Matrix.inv_inv_inv

/- warning: matrix.mul_inv_rev -> Matrix.mul_inv_rev is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) B) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (B : Matrix.{u1, u1, u2} n n α), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) A B)) (Matrix.mul.{u2, u1, u1, u1} n n n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) B) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))
Case conversion may be inaccurate. Consider using '#align matrix.mul_inv_rev Matrix.mul_inv_revₓ'. -/
theorem mul_inv_rev (A B : Matrix n n α) : (A ⬝ B)⁻¹ = B⁻¹ ⬝ A⁻¹ :=
  by
  simp only [inv_def]
  rw [Matrix.smul_mul, Matrix.mul_smul, smul_smul, det_mul, adjugate_mul_distrib,
    Ring.mul_inverse_rev]
#align matrix.mul_inv_rev Matrix.mul_inv_rev

/- warning: matrix.list_prod_inv_reverse -> Matrix.list_prod_inv_reverse is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (l : List.{max u1 u2} (Matrix.{u1, u1, u2} n n α)), Eq.{succ (max u1 u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) l)) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasMul.{u2, u1} n α _inst_1 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.hasOne.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u2} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (AddMonoidWithOne.toOne.{u2} α (AddGroupWithOne.toAddMonoidWithOne.{u2} α (AddCommGroupWithOne.toAddGroupWithOne.{u2} α (Ring.toAddCommGroupWithOne.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (List.map.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3)) (List.reverse.{max u1 u2} (Matrix.{u1, u1, u2} n n α) l)))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (l : List.{max u2 u1} (Matrix.{u1, u1, u2} n n α)), Eq.{max (succ u1) (succ u2)} (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) l)) (List.prod.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.instMulMatrix.{u2, u1} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Matrix.one.{u2, u1} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u2} α (CommSemiring.toCommMonoidWithZero.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))) (Semiring.toOne.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (List.map.{max u1 u2, max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.{u1, u1, u2} n n α) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3)) (List.reverse.{max u1 u2} (Matrix.{u1, u1, u2} n n α) l)))
Case conversion may be inaccurate. Consider using '#align matrix.list_prod_inv_reverse Matrix.list_prod_inv_reverseₓ'. -/
/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/
/-- A version of `list.prod_inv_reverse` for `matrix.has_inv`. -/
theorem list_prod_inv_reverse : ∀ l : List (Matrix n n α), l.Prod⁻¹ = (l.reverse.map Inv.inv).Prod
  | [] => by rw [List.reverse_nil, List.map_nil, List.prod_nil, inv_one]
  | A::Xs => by
    rw [List.reverse_cons', List.map_concat, List.prod_concat, List.prod_cons, Matrix.mul_eq_mul,
      Matrix.mul_eq_mul, mul_inv_rev, list_prod_inv_reverse]
#align matrix.list_prod_inv_reverse Matrix.list_prod_inv_reverse

/- warning: matrix.det_smul_inv_mul_vec_eq_cramer -> Matrix.det_smul_inv_mulVec_eq_cramer is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (n -> α) (SMul.smul.{u2, max u1 u2} α (n -> α) (Function.hasSMul.{u1, u2, u2} n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) _inst_1 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) b)) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A) b))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (n -> α) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (n -> α) (n -> α) (instHSMul.{u2, max u1 u2} α (n -> α) (Pi.instSMul.{u1, u2, u2} n α (fun (a._@.Mathlib.Data.Matrix.Basic._hyg.18074 : n) => α) (fun (i : n) => Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (Matrix.mulVec.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) _inst_1 (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A) b)) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 A) b))
Case conversion may be inaccurate. Consider using '#align matrix.det_smul_inv_mul_vec_eq_cramer Matrix.det_smul_inv_mulVec_eq_cramerₓ'. -/
/-- One form of **Cramer's rule**. See `matrix.mul_vec_cramer` for a stronger form. -/
@[simp]
theorem det_smul_inv_mulVec_eq_cramer (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :
    A.det • A⁻¹.mulVec b = cramer A b := by
  rw [cramer_eq_adjugate_mul_vec, A.nonsing_inv_apply h, ← smul_mul_vec_assoc, smul_smul,
    h.mul_coe_inv, one_smul]
#align matrix.det_smul_inv_mul_vec_eq_cramer Matrix.det_smul_inv_mulVec_eq_cramer

/- warning: matrix.det_smul_inv_vec_mul_eq_cramer_transpose -> Matrix.det_smul_inv_vecMul_eq_cramer_transpose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), (IsUnit.{u2} α (Ring.toMonoid.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{succ (max u1 u2)} (n -> α) (SMul.smul.{u2, max u1 u2} α (n -> α) (Function.hasSMul.{u1, u2, u2} n α α (Mul.toSMul.{u2} α (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (Matrix.vecMul.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) _inst_1 b (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.hasInv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (coeFn.{succ (max u1 u2), succ (max u1 u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (_x : LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) => (n -> α) -> n -> α) (LinearMap.hasCoeToFun.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (Pi.Function.module.{u1, u2, u2} n α α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Semiring.toModule.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (Ring.toSemiring.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 (Matrix.transpose.{u2, u1, u1} n n α A)) b))
but is expected to have type
  forall {n : Type.{u1}} {α : Type.{u2}} [_inst_1 : Fintype.{u1} n] [_inst_2 : DecidableEq.{succ u1} n] [_inst_3 : CommRing.{u2} α] (A : Matrix.{u1, u1, u2} n n α) (b : n -> α), (IsUnit.{u2} α (MonoidWithZero.toMonoid.{u2} α (Semiring.toMonoidWithZero.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A)) -> (Eq.{max (succ u1) (succ u2)} (n -> α) (HSMul.hSMul.{u2, max u1 u2, max u1 u2} α (n -> α) (n -> α) (instHSMul.{u2, max u1 u2} α (n -> α) (Pi.instSMul.{u1, u2, u2} n α (fun (a._@.Mathlib.Data.Matrix.Basic._hyg.18132 : n) => α) (fun (i : n) => Algebra.toSMul.{u2, u2} α α (CommRing.toCommSemiring.{u2} α _inst_3) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Algebra.id.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_2 a b) _inst_1 α _inst_3 A) (Matrix.vecMul.{u2, u1, u1} n n α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) _inst_1 b (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} n n α) (Matrix.inv.{u1, u2} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (LinearMap.{u2, u2, max u1 u2, max u1 u2} α α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (n -> α) (n -> α) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (n -> α) (fun (_x : n -> α) => (fun (x._@.Mathlib.Algebra.Module.LinearMap._hyg.6190 : n -> α) => n -> α) _x) (LinearMap.instFunLikeLinearMap.{u2, u2, max u1 u2, max u1 u2} α α (n -> α) (n -> α) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.addCommMonoid.{u1, u2} n (fun (ᾰ : n) => α) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (Pi.module.{u1, u2, u2} n (fun (a._@.Mathlib.LinearAlgebra.Matrix.Adjugate._hyg.274 : n) => α) α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) (fun (i : n) => NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (fun (i : n) => Semiring.toModule.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)))) (RingHom.id.{u2} α (Semiring.toNonAssocSemiring.{u2} α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3))))) (Matrix.cramer.{u1, u2} n α (fun (a : n) (b : n) => _inst_2 a b) _inst_1 _inst_3 (Matrix.transpose.{u2, u1, u1} n n α A)) b))
Case conversion may be inaccurate. Consider using '#align matrix.det_smul_inv_vec_mul_eq_cramer_transpose Matrix.det_smul_inv_vecMul_eq_cramer_transposeₓ'. -/
/-- One form of **Cramer's rule**. See `matrix.mul_vec_cramer` for a stronger form. -/
@[simp]
theorem det_smul_inv_vecMul_eq_cramer_transpose (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :
    A.det • A⁻¹.vecMul b = cramer Aᵀ b := by
  rw [← A⁻¹.transpose_transpose, vec_mul_transpose, transpose_nonsing_inv, ← det_transpose,
    Aᵀ.det_smul_inv_mulVec_eq_cramer _ (is_unit_det_transpose A h)]
#align matrix.det_smul_inv_vec_mul_eq_cramer_transpose Matrix.det_smul_inv_vecMul_eq_cramer_transpose

/-! ### Inverses of permutated matrices

Note that the simp-normal form of `matrix.reindex` is `matrix.submatrix`, so we prove most of these
results about only the latter.
-/


section Submatrix

variable [Fintype m]

variable [DecidableEq m]

/- warning: matrix.submatrix_equiv_invertible -> Matrix.submatrixEquivInvertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasMul.{u3, u1} m α _inst_4 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A], Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.instMulMatrix.{u3, u1} m α _inst_4 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A], Invertible.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂))
Case conversion may be inaccurate. Consider using '#align matrix.submatrix_equiv_invertible Matrix.submatrixEquivInvertibleₓ'. -/
/-- `A.submatrix e₁ e₂` is invertible if `A` is -/
def submatrixEquivInvertible (A : Matrix m m α) (e₁ e₂ : n ≃ m) [Invertible A] :
    Invertible (A.submatrix e₁ e₂) :=
  invertibleOfRightInverse _ ((⅟ A).submatrix e₂ e₁) <| by
    rw [Matrix.submatrix_mul_equiv, Matrix.mul_invOf_self, submatrix_one_equiv]
#align matrix.submatrix_equiv_invertible Matrix.submatrixEquivInvertible

/- warning: matrix.invertible_of_submatrix_equiv_invertible -> Matrix.invertibleOfSubmatrixEquivInvertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂))], Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasMul.{u3, u1} m α _inst_4 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂))], Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.instMulMatrix.{u3, u1} m α _inst_4 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A
Case conversion may be inaccurate. Consider using '#align matrix.invertible_of_submatrix_equiv_invertible Matrix.invertibleOfSubmatrixEquivInvertibleₓ'. -/
/-- `A` is invertible if `A.submatrix e₁ e₂` is -/
def invertibleOfSubmatrixEquivInvertible (A : Matrix m m α) (e₁ e₂ : n ≃ m)
    [Invertible (A.submatrix e₁ e₂)] : Invertible A :=
  invertibleOfRightInverse _ ((⅟ (A.submatrix e₁ e₂)).submatrix e₂.symm e₁.symm) <|
    by
    have : A = (A.submatrix e₁ e₂).submatrix e₁.symm e₂.symm := by simp
    conv in _ ⬝ _ =>
      congr
      rw [this]
    rw [Matrix.submatrix_mul_equiv, Matrix.mul_invOf_self, submatrix_one_equiv]
#align matrix.invertible_of_submatrix_equiv_invertible Matrix.invertibleOfSubmatrixEquivInvertible

/- warning: matrix.inv_of_submatrix_equiv_eq -> Matrix.invOf_submatrix_equiv_eq is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasMul.{u3, u1} m α _inst_4 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A] [_inst_7 : Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂))], Eq.{succ (max u2 u3)} (Matrix.{u2, u2, u3} n n α) (Invertible.invOf.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂)) _inst_7) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α (Invertible.invOf.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasMul.{u3, u1} m α _inst_4 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A _inst_6) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) [_inst_6 : Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.instMulMatrix.{u3, u1} m α _inst_4 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A] [_inst_7 : Invertible.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂))], Eq.{max (succ u2) (succ u3)} (Matrix.{u2, u2, u3} n n α) (Invertible.invOf.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂)) _inst_7) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α (Invertible.invOf.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.instMulMatrix.{u3, u1} m α _inst_4 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A _inst_6) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁))
Case conversion may be inaccurate. Consider using '#align matrix.inv_of_submatrix_equiv_eq Matrix.invOf_submatrix_equiv_eqₓ'. -/
theorem invOf_submatrix_equiv_eq (A : Matrix m m α) (e₁ e₂ : n ≃ m) [Invertible A]
    [Invertible (A.submatrix e₁ e₂)] : ⅟ (A.submatrix e₁ e₂) = (⅟ A).submatrix e₂ e₁ :=
  by
  letI := submatrix_equiv_invertible A e₁ e₂
  haveI := Invertible.subsingleton (A.submatrix e₁ e₂)
  convert(rfl : ⅟ (A.submatrix e₁ e₂) = _)
#align matrix.inv_of_submatrix_equiv_eq Matrix.invOf_submatrix_equiv_eq

/- warning: matrix.submatrix_equiv_invertible_equiv_invertible -> Matrix.submatrixEquivInvertibleEquivInvertible is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m), Equiv.{succ (max u2 u3), succ (max u1 u3)} (Invertible.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasMul.{u3, u2} n α _inst_1 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂))) (Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasMul.{u3, u1} m α _inst_4 (Distrib.toHasMul.{u3} α (Ring.toDistrib.{u3} α (CommRing.toRing.{u3} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toAddCommGroup.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.hasOne.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (MulZeroClass.toHasZero.{u3} α (NonUnitalNonAssocSemiring.toMulZeroClass.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (AddMonoidWithOne.toOne.{u3} α (AddGroupWithOne.toAddMonoidWithOne.{u3} α (AddCommGroupWithOne.toAddGroupWithOne.{u3} α (Ring.toAddCommGroupWithOne.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) A)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m), Equiv.{succ (max u3 u2), succ (max u1 u3)} (Invertible.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.instMulMatrix.{u3, u2} n α _inst_1 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u2} n α (fun (a : n) (b : n) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂))) (Invertible.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.instMulMatrix.{u3, u1} m α _inst_4 (NonUnitalNonAssocRing.toMul.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} α (NonAssocRing.toNonUnitalNonAssocRing.{u3} α (Ring.toNonAssocRing.{u3} α (CommRing.toRing.{u3} α _inst_3)))))) (Matrix.one.{u3, u1} m α (fun (a : m) (b : m) => _inst_5 a b) (CommMonoidWithZero.toZero.{u3} α (CommSemiring.toCommMonoidWithZero.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3))) (Semiring.toOne.{u3} α (CommSemiring.toSemiring.{u3} α (CommRing.toCommSemiring.{u3} α _inst_3)))) A)
Case conversion may be inaccurate. Consider using '#align matrix.submatrix_equiv_invertible_equiv_invertible Matrix.submatrixEquivInvertibleEquivInvertibleₓ'. -/
/-- Together `matrix.submatrix_equiv_invertible` and
`matrix.invertible_of_submatrix_equiv_invertible` form an equivalence, although both sides of the
equiv are subsingleton anyway. -/
@[simps]
def submatrixEquivInvertibleEquivInvertible (A : Matrix m m α) (e₁ e₂ : n ≃ m) :
    Invertible (A.submatrix e₁ e₂) ≃ Invertible A
    where
  toFun _ := invertible_of_submatrix_equiv_invertible A e₁ e₂
  invFun _ := submatrix_equiv_invertible A e₁ e₂
  left_inv _ := Subsingleton.elim _ _
  right_inv _ := Subsingleton.elim _ _
#align matrix.submatrix_equiv_invertible_equiv_invertible Matrix.submatrixEquivInvertibleEquivInvertible

#print Matrix.isUnit_submatrix_equiv /-
/-- When lowered to a prop, `matrix.invertible_of_submatrix_equiv_invertible` forms an `iff`. -/
@[simp]
theorem isUnit_submatrix_equiv {A : Matrix m m α} (e₁ e₂ : n ≃ m) :
    IsUnit (A.submatrix e₁ e₂) ↔ IsUnit A := by
  simp only [← nonempty_invertible_iff_isUnit,
    (submatrix_equiv_invertible_equiv_invertible A _ _).nonempty_congr]
#align matrix.is_unit_submatrix_equiv Matrix.isUnit_submatrix_equiv
-/

/- warning: matrix.inv_submatrix_equiv -> Matrix.inv_submatrix_equiv is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m), Eq.{succ (max u2 u3)} (Matrix.{u2, u2, u3} n n α) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α (Inv.inv.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasInv.{u1, u3} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) A) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₂) (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} n m) (fun (_x : Equiv.{succ u2, succ u1} n m) => n -> m) (Equiv.hasCoeToFun.{succ u2, succ u1} n m) e₁))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (A : Matrix.{u1, u1, u3} m m α) (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m), Eq.{max (succ u2) (succ u3)} (Matrix.{u2, u2, u3} n n α) (Inv.inv.{max u3 u2} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂))) (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n α (Inv.inv.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.inv.{u1, u3} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) A) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₂) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e₁))
Case conversion may be inaccurate. Consider using '#align matrix.inv_submatrix_equiv Matrix.inv_submatrix_equivₓ'. -/
@[simp]
theorem inv_submatrix_equiv (A : Matrix m m α) (e₁ e₂ : n ≃ m) :
    (A.submatrix e₁ e₂)⁻¹ = A⁻¹.submatrix e₂ e₁ :=
  by
  by_cases h : IsUnit A
  · cases h.nonempty_invertible
    letI := submatrix_equiv_invertible A e₁ e₂
    rw [← inv_of_eq_nonsing_inv, ← inv_of_eq_nonsing_inv, inv_of_submatrix_equiv_eq]
  · have := (is_unit_submatrix_equiv e₁ e₂).Not.mpr h
    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ this,
      submatrix_zero, Pi.zero_apply]
#align matrix.inv_submatrix_equiv Matrix.inv_submatrix_equiv

/- warning: matrix.inv_reindex -> Matrix.inv_reindex is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) (A : Matrix.{u2, u2, u3} n n α), Eq.{succ (max u1 u3)} (Matrix.{u1, u1, u3} m m α) (Inv.inv.{max u1 u3} (Matrix.{u1, u1, u3} m m α) (Matrix.hasInv.{u1, u3} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) (coeFn.{max 1 (max (succ (max u2 u3)) (succ (max u1 u3))) (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u2 u3)) (succ (max u1 u3))} (Equiv.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (fun (_x : Equiv.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) => (Matrix.{u2, u2, u3} n n α) -> (Matrix.{u1, u1, u3} m m α)) (Equiv.hasCoeToFun.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.reindex.{u3, u1, u2, u2, u1} m n n m α e₁ e₂) A)) (coeFn.{max 1 (max (succ (max u2 u3)) (succ (max u1 u3))) (succ (max u1 u3)) (succ (max u2 u3)), max (succ (max u2 u3)) (succ (max u1 u3))} (Equiv.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (fun (_x : Equiv.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) => (Matrix.{u2, u2, u3} n n α) -> (Matrix.{u1, u1, u3} m m α)) (Equiv.hasCoeToFun.{succ (max u2 u3), succ (max u1 u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.reindex.{u3, u1, u2, u2, u1} m n n m α e₂ e₁) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.hasInv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} {α : Type.{u3}} [_inst_1 : Fintype.{u2} n] [_inst_2 : DecidableEq.{succ u2} n] [_inst_3 : CommRing.{u3} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] (e₁ : Equiv.{succ u2, succ u1} n m) (e₂ : Equiv.{succ u2, succ u1} n m) (A : Matrix.{u2, u2, u3} n n α), Eq.{max (succ u1) (succ u3)} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u2, u2, u3} n n α) => Matrix.{u1, u1, u3} m m α) A) (Inv.inv.{max u1 u3} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u2, u2, u3} n n α) => Matrix.{u1, u1, u3} m m α) A) (Matrix.inv.{u1, u3} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u3) (succ u2), max (succ u3) (succ u1)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.{u2, u2, u3} n n α) (fun (_x : Matrix.{u2, u2, u3} n n α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u2, u2, u3} n n α) => Matrix.{u1, u1, u3} m m α) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u1) (succ u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.reindex.{u3, u1, u2, u2, u1} m n n m α e₁ e₂) A)) (FunLike.coe.{max (max (succ u1) (succ u2)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u3) (succ u2), max (succ u3) (succ u1)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.{u2, u2, u3} n n α) (fun (_x : Matrix.{u2, u2, u3} n n α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u2, u2, u3} n n α) => Matrix.{u1, u1, u3} m m α) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u1) (succ u3)} (Matrix.{u2, u2, u3} n n α) (Matrix.{u1, u1, u3} m m α)) (Matrix.reindex.{u3, u1, u2, u2, u1} m n n m α e₂ e₁) (Inv.inv.{max u2 u3} (Matrix.{u2, u2, u3} n n α) (Matrix.inv.{u2, u3} n α _inst_1 (fun (a : n) (b : n) => _inst_2 a b) _inst_3) A))
Case conversion may be inaccurate. Consider using '#align matrix.inv_reindex Matrix.inv_reindexₓ'. -/
theorem inv_reindex (e₁ e₂ : n ≃ m) (A : Matrix n n α) : (reindex e₁ e₂ A)⁻¹ = reindex e₂ e₁ A⁻¹ :=
  inv_submatrix_equiv A e₁.symm e₂.symm
#align matrix.inv_reindex Matrix.inv_reindex

end Submatrix

/-! ### More results about determinants -/


section Det

variable [Fintype m] [DecidableEq m]

/- warning: matrix.det_conj -> Matrix.det_conj is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] {M : Matrix.{u1, u1, u2} m m α}, (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.ring.{u2, u1} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) (CommRing.toRing.{u2} α _inst_3))) M) -> (forall (N : Matrix.{u1, u1, u2} m m α), Eq.{succ u2} α (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) M N) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.hasInv.{u1, u2} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) M))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 N))
but is expected to have type
  forall {m : Type.{u1}} {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] {M : Matrix.{u1, u1, u2} m m α}, (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.semiring.{u2, u1} m α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_4 (fun (a : m) (b : m) => _inst_5 a b)))) M) -> (forall (N : Matrix.{u1, u1, u2} m m α), Eq.{succ u2} α (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) M N) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.inv.{u1, u2} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) M))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 N))
Case conversion may be inaccurate. Consider using '#align matrix.det_conj Matrix.det_conjₓ'. -/
/-- A variant of `matrix.det_units_conj`. -/
theorem det_conj {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) : det (M ⬝ N ⬝ M⁻¹) = det N :=
  by rw [← h.unit_spec, ← coe_units_inv, det_units_conj]
#align matrix.det_conj Matrix.det_conj

/- warning: matrix.det_conj' -> Matrix.det_conj' is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u1}} {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] {M : Matrix.{u1, u1, u2} m m α}, (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Ring.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.ring.{u2, u1} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) (CommRing.toRing.{u2} α _inst_3))) M) -> (forall (N : Matrix.{u1, u1, u2} m m α), Eq.{succ u2} α (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (Distrib.toHasMul.{u2} α (Ring.toDistrib.{u2} α (CommRing.toRing.{u2} α _inst_3))) (AddCommGroup.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toAddCommGroup.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.hasInv.{u1, u2} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) M) N) M)) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 N))
but is expected to have type
  forall {m : Type.{u1}} {α : Type.{u2}} [_inst_3 : CommRing.{u2} α] [_inst_4 : Fintype.{u1} m] [_inst_5 : DecidableEq.{succ u1} m] {M : Matrix.{u1, u1, u2} m m α}, (IsUnit.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (MonoidWithZero.toMonoid.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Semiring.toMonoidWithZero.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.semiring.{u2, u1} m α (CommSemiring.toSemiring.{u2} α (CommRing.toCommSemiring.{u2} α _inst_3)) _inst_4 (fun (a : m) (b : m) => _inst_5 a b)))) M) -> (forall (N : Matrix.{u1, u1, u2} m m α), Eq.{succ u2} α (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Matrix.mul.{u2, u1, u1, u1} m m m α _inst_4 (NonUnitalNonAssocRing.toMul.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} α (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} α (NonAssocRing.toNonUnitalNonAssocRing.{u2} α (Ring.toNonAssocRing.{u2} α (CommRing.toRing.{u2} α _inst_3))))) (Inv.inv.{max u1 u2} (Matrix.{u1, u1, u2} m m α) (Matrix.inv.{u1, u2} m α _inst_4 (fun (a : m) (b : m) => _inst_5 a b) _inst_3) M) N) M)) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_5 a b) _inst_4 α _inst_3 N))
Case conversion may be inaccurate. Consider using '#align matrix.det_conj' Matrix.det_conj'ₓ'. -/
/-- A variant of `matrix.det_units_conj'`. -/
theorem det_conj' {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :
    det (M⁻¹ ⬝ N ⬝ M) = det N := by rw [← h.unit_spec, ← coe_units_inv, det_units_conj']
#align matrix.det_conj' Matrix.det_conj'

end Det

end Matrix

