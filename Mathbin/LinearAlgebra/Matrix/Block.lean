/-
Copyright (c) 2019 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen

! This file was ported from Lean 3 source module linear_algebra.matrix.block
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.LinearAlgebra.Matrix.Determinant
import Mathbin.LinearAlgebra.Matrix.NonsingularInverse
import Mathbin.Tactic.FinCases

/-!
# Block matrices and their determinant

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines a predicate `matrix.block_triangular` saying a matrix
is block triangular, and proves the value of the determinant for various
matrices built out of blocks.

## Main definitions

 * `matrix.block_triangular` expresses that a `o` by `o` matrix is block triangular,
   if the rows and columns are ordered according to some order `b : o → α`

## Main results
  * `matrix.det_of_block_triangular`: the determinant of a block triangular matrix
    is equal to the product of the determinants of all the blocks
  * `matrix.det_of_upper_triangular` and `matrix.det_of_lower_triangular`: the determinant of
    a triangular matrix is the product of the entries along the diagonal

## Tags

matrix, diagonal, det, block triangular

-/


open Finset Function OrderDual

open BigOperators Matrix

universe v

variable {α β m n o : Type _} {m' n' : α → Type _}

variable {R : Type v} [CommRing R] {M N : Matrix m m R} {b : m → α}

namespace Matrix

section LT

variable [LT α]

#print Matrix.BlockTriangular /-
/-- Let `b` map rows and columns of a square matrix `M` to blocks indexed by `α`s. Then
`block_triangular M n b` says the matrix is block triangular. -/
def BlockTriangular (M : Matrix m m R) (b : m → α) : Prop :=
  ∀ ⦃i j⦄, b j < b i → M i j = 0
#align matrix.block_triangular Matrix.BlockTriangular
-/

/- warning: matrix.block_triangular.submatrix -> Matrix.BlockTriangular.submatrix is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {n : Type.{u4}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : LT.{u2} α] {f : n -> m}, (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u1, u2, u4} α n R _inst_1 _inst_2 (Matrix.submatrix.{u1, u4, u3, u3, u4} n m m n R M f f) (Function.comp.{succ u4, succ u3, succ u2} n m α b f))
but is expected to have type
  forall {α : Type.{u3}} {m : Type.{u2}} {n : Type.{u1}} {R : Type.{u4}} [_inst_1 : CommRing.{u4} R] {M : Matrix.{u2, u2, u4} m m R} {b : m -> α} [_inst_2 : LT.{u3} α] {f : n -> m}, (Matrix.BlockTriangular.{u4, u3, u2} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u4, u3, u1} α n R _inst_1 _inst_2 (Matrix.submatrix.{u4, u1, u2, u2, u1} n m m n R M f f) (Function.comp.{succ u1, succ u2, succ u3} n m α b f))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.submatrix Matrix.BlockTriangular.submatrixₓ'. -/
@[simp]
protected theorem BlockTriangular.submatrix {f : n → m} (h : M.BlockTriangular b) :
    (M.submatrix f f).BlockTriangular (b ∘ f) := fun i j hij => h hij
#align matrix.block_triangular.submatrix Matrix.BlockTriangular.submatrix

/- warning: matrix.block_triangular_reindex_iff -> Matrix.blockTriangular_reindex_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {n : Type.{u4}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} [_inst_2 : LT.{u2} α] {b : n -> α} {e : Equiv.{succ u3, succ u4} m n}, Iff (Matrix.BlockTriangular.{u1, u2, u4} α n R _inst_1 _inst_2 (coeFn.{max 1 (max (succ (max u3 u1)) (succ (max u4 u1))) (succ (max u4 u1)) (succ (max u3 u1)), max (succ (max u3 u1)) (succ (max u4 u1))} (Equiv.{succ (max u3 u1), succ (max u4 u1)} (Matrix.{u3, u3, u1} m m R) (Matrix.{u4, u4, u1} n n R)) (fun (_x : Equiv.{succ (max u3 u1), succ (max u4 u1)} (Matrix.{u3, u3, u1} m m R) (Matrix.{u4, u4, u1} n n R)) => (Matrix.{u3, u3, u1} m m R) -> (Matrix.{u4, u4, u1} n n R)) (Equiv.hasCoeToFun.{succ (max u3 u1), succ (max u4 u1)} (Matrix.{u3, u3, u1} m m R) (Matrix.{u4, u4, u1} n n R)) (Matrix.reindex.{u1, u4, u3, u3, u4} n m m n R e e) M) b) (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M (Function.comp.{succ u3, succ u4, succ u2} m n α b (coeFn.{max 1 (max (succ u3) (succ u4)) (succ u4) (succ u3), max (succ u3) (succ u4)} (Equiv.{succ u3, succ u4} m n) (fun (_x : Equiv.{succ u3, succ u4} m n) => m -> n) (Equiv.hasCoeToFun.{succ u3, succ u4} m n) e)))
but is expected to have type
  forall {α : Type.{u1}} {m : Type.{u3}} {n : Type.{u2}} {R : Type.{u4}} [_inst_1 : CommRing.{u4} R] {M : Matrix.{u3, u3, u4} m m R} [_inst_2 : LT.{u1} α] {b : n -> α} {e : Equiv.{succ u3, succ u2} m n}, Iff (Matrix.BlockTriangular.{u4, u1, u2} α n R _inst_1 _inst_2 (FunLike.coe.{max (max (succ u3) (succ u2)) (succ u4), max (succ u3) (succ u4), max (succ u2) (succ u4)} (Equiv.{max (succ u4) (succ u3), max (succ u4) (succ u2)} (Matrix.{u3, u3, u4} m m R) (Matrix.{u2, u2, u4} n n R)) (Matrix.{u3, u3, u4} m m R) (fun (_x : Matrix.{u3, u3, u4} m m R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u3, u3, u4} m m R) => Matrix.{u2, u2, u4} n n R) _x) (Equiv.instFunLikeEquiv.{max (succ u3) (succ u4), max (succ u2) (succ u4)} (Matrix.{u3, u3, u4} m m R) (Matrix.{u2, u2, u4} n n R)) (Matrix.reindex.{u4, u2, u3, u3, u2} n m m n R e e) M) b) (Matrix.BlockTriangular.{u4, u1, u3} α m R _inst_1 _inst_2 M (Function.comp.{succ u3, succ u2, succ u1} m n α b (FunLike.coe.{max (succ u3) (succ u2), succ u3, succ u2} (Equiv.{succ u3, succ u2} m n) m (fun (_x : m) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : m) => n) _x) (Equiv.instFunLikeEquiv.{succ u3, succ u2} m n) e)))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_reindex_iff Matrix.blockTriangular_reindex_iffₓ'. -/
theorem blockTriangular_reindex_iff {b : n → α} {e : m ≃ n} :
    (reindex e e M).BlockTriangular b ↔ M.BlockTriangular (b ∘ e) :=
  by
  refine' ⟨fun h => _, fun h => _⟩
  · convert h.submatrix
    simp only [reindex_apply, submatrix_submatrix, submatrix_id_id, Equiv.symm_comp_self]
  · convert h.submatrix
    simp only [comp.assoc b e e.symm, Equiv.self_comp_symm, comp.right_id]
#align matrix.block_triangular_reindex_iff Matrix.blockTriangular_reindex_iff

/- warning: matrix.block_triangular.transpose -> Matrix.BlockTriangular.transpose is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u1, u2, u3} (OrderDual.{u2} α) m R _inst_1 (OrderDual.hasLt.{u2} α _inst_2) (Matrix.transpose.{u1, u3, u3} m m R M) (Function.comp.{succ u3, succ u2, succ u2} m α (OrderDual.{u2} α) (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) (fun (_x : Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) => α -> (OrderDual.{u2} α)) (Equiv.hasCoeToFun.{succ u2, succ u2} α (OrderDual.{u2} α)) (OrderDual.toDual.{u2} α)) b))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u3, u2, u1} (OrderDual.{u2} α) m R _inst_1 (OrderDual.instLTOrderDual.{u2} α _inst_2) (Matrix.transpose.{u3, u1, u1} m m R M) (Function.comp.{succ u1, succ u2, succ u2} m α (OrderDual.{u2} α) (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} α (OrderDual.{u2} α)) α (fun (_x : α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : α) => OrderDual.{u2} α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} α (OrderDual.{u2} α)) (OrderDual.toDual.{u2} α)) b))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.transpose Matrix.BlockTriangular.transposeₓ'. -/
protected theorem BlockTriangular.transpose :
    M.BlockTriangular b → Mᵀ.BlockTriangular (toDual ∘ b) :=
  swap
#align matrix.block_triangular.transpose Matrix.BlockTriangular.transpose

/- warning: matrix.block_triangular_transpose_iff -> Matrix.blockTriangular_transpose_iff is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} [_inst_2 : LT.{u2} α] {b : m -> (OrderDual.{u2} α)}, Iff (Matrix.BlockTriangular.{u1, u2, u3} (OrderDual.{u2} α) m R _inst_1 (OrderDual.hasLt.{u2} α _inst_2) (Matrix.transpose.{u1, u3, u3} m m R M) b) (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M (Function.comp.{succ u3, succ u2, succ u2} m (OrderDual.{u2} α) α (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} (OrderDual.{u2} α) α) (fun (_x : Equiv.{succ u2, succ u2} (OrderDual.{u2} α) α) => (OrderDual.{u2} α) -> α) (Equiv.hasCoeToFun.{succ u2, succ u2} (OrderDual.{u2} α) α) (OrderDual.ofDual.{u2} α)) b))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} [_inst_2 : LT.{u2} α] {b : m -> (OrderDual.{u2} α)}, Iff (Matrix.BlockTriangular.{u3, u2, u1} (OrderDual.{u2} α) m R _inst_1 (OrderDual.instLTOrderDual.{u2} α _inst_2) (Matrix.transpose.{u3, u1, u1} m m R M) b) (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 M (Function.comp.{succ u1, succ u2, succ u2} m (OrderDual.{u2} α) α (FunLike.coe.{succ u2, succ u2, succ u2} (Equiv.{succ u2, succ u2} (OrderDual.{u2} α) α) (OrderDual.{u2} α) (fun (_x : OrderDual.{u2} α) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : OrderDual.{u2} α) => α) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u2} (OrderDual.{u2} α) α) (OrderDual.ofDual.{u2} α)) b))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_transpose_iff Matrix.blockTriangular_transpose_iffₓ'. -/
@[simp]
protected theorem blockTriangular_transpose_iff {b : m → αᵒᵈ} :
    Mᵀ.BlockTriangular b ↔ M.BlockTriangular (ofDual ∘ b) :=
  forall_swap
#align matrix.block_triangular_transpose_iff Matrix.blockTriangular_transpose_iff

/- warning: matrix.block_triangular_zero -> Matrix.blockTriangular_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {b : m -> α} [_inst_2 : LT.{u2} α], Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 (OfNat.ofNat.{max u3 u1} (Matrix.{u3, u3, u1} m m R) 0 (OfNat.mk.{max u3 u1} (Matrix.{u3, u3, u1} m m R) 0 (Zero.zero.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasZero.{u1, u3, u3} m m R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) b
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {b : m -> α} [_inst_2 : LT.{u2} α], Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 (OfNat.ofNat.{max u3 u1} (Matrix.{u1, u1, u3} m m R) 0 (Zero.toOfNat0.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.zero.{u3, u1, u1} m m R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))))) b
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_zero Matrix.blockTriangular_zeroₓ'. -/
@[simp]
theorem blockTriangular_zero : BlockTriangular (0 : Matrix m m R) b := fun i j h => rfl
#align matrix.block_triangular_zero Matrix.blockTriangular_zero

/- warning: matrix.block_triangular.neg -> Matrix.BlockTriangular.neg is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 (Neg.neg.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasNeg.{u1, u3, u3} m m R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M) b)
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 (Neg.neg.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.neg.{u3, u1, u1} m m R (Ring.toNeg.{u3} R (CommRing.toRing.{u3} R _inst_1))) M) b)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.neg Matrix.BlockTriangular.negₓ'. -/
protected theorem BlockTriangular.neg (hM : BlockTriangular M b) : BlockTriangular (-M) b :=
  fun i j h => neg_eq_zero.2 <| hM h
#align matrix.block_triangular.neg Matrix.BlockTriangular.neg

/- warning: matrix.block_triangular.add -> Matrix.BlockTriangular.add is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {N : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 N b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (instHAdd.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasAdd.{u1, u3, u3} m m R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))))) M N) b)
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {N : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 N b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 (HAdd.hAdd.{max u3 u1, max u3 u1, max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.{u1, u1, u3} m m R) (Matrix.{u1, u1, u3} m m R) (instHAdd.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.add.{u3, u1, u1} m m R (Distrib.toAdd.{u3} R (NonUnitalNonAssocSemiring.toDistrib.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))))))) M N) b)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.add Matrix.BlockTriangular.addₓ'. -/
theorem BlockTriangular.add (hM : BlockTriangular M b) (hN : BlockTriangular N b) :
    BlockTriangular (M + N) b := fun i j h => by simp_rw [Pi.add_apply, hM h, hN h, zero_add]
#align matrix.block_triangular.add Matrix.BlockTriangular.add

/- warning: matrix.block_triangular.sub -> Matrix.BlockTriangular.sub is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {N : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 N b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 _inst_2 (HSub.hSub.{max u3 u1, max u3 u1, max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (instHSub.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasSub.{u1, u3, u3} m m R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))) M N) b)
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {N : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : LT.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 M b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 N b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 _inst_2 (HSub.hSub.{max u3 u1, max u3 u1, max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.{u1, u1, u3} m m R) (Matrix.{u1, u1, u3} m m R) (instHSub.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.sub.{u3, u1, u1} m m R (Ring.toSub.{u3} R (CommRing.toRing.{u3} R _inst_1)))) M N) b)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.sub Matrix.BlockTriangular.subₓ'. -/
theorem BlockTriangular.sub (hM : BlockTriangular M b) (hN : BlockTriangular N b) :
    BlockTriangular (M - N) b := fun i j h => by simp_rw [Pi.sub_apply, hM h, hN h, sub_zero]
#align matrix.block_triangular.sub Matrix.BlockTriangular.sub

end LT

section Preorder

variable [Preorder α]

/- warning: matrix.block_triangular_diagonal -> Matrix.blockTriangular_diagonal is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {b : m -> α} [_inst_2 : Preorder.{u2} α] [_inst_3 : DecidableEq.{succ u3} m] (d : m -> R), Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α _inst_2) (Matrix.diagonal.{u1, u3} m R (fun (a : m) (b : m) => _inst_3 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) d) b
but is expected to have type
  forall {α : Type.{u1}} {m : Type.{u2}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {b : m -> α} [_inst_2 : Preorder.{u1} α] [_inst_3 : DecidableEq.{succ u2} m] (d : m -> R), Matrix.BlockTriangular.{u3, u1, u2} α m R _inst_1 (Preorder.toLT.{u1} α _inst_2) (Matrix.diagonal.{u3, u2} m R (fun (a : m) (b : m) => _inst_3 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) d) b
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_diagonal Matrix.blockTriangular_diagonalₓ'. -/
theorem blockTriangular_diagonal [DecidableEq m] (d : m → R) : BlockTriangular (diagonal d) b :=
  fun i j h => diagonal_apply_ne' d fun h' => ne_of_lt h (congr_arg _ h')
#align matrix.block_triangular_diagonal Matrix.blockTriangular_diagonal

/- warning: matrix.block_triangular_block_diagonal' -> Matrix.blockTriangular_blockDiagonal' is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m' : α -> Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : Preorder.{u2} α] [_inst_3 : DecidableEq.{succ u2} α] (d : forall (i : α), Matrix.{u3, u3, u1} (m' i) (m' i) R), Matrix.BlockTriangular.{u1, u2, max u2 u3} α (Sigma.{u2, u3} α (fun (i : α) => m' i)) R _inst_1 (Preorder.toHasLt.{u2} α _inst_2) (Matrix.blockDiagonal'.{u2, u3, u3, u1} α (fun (i : α) => m' i) (fun (i : α) => m' i) R (fun (a : α) (b : α) => _inst_3 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) d) (Sigma.fst.{u2, u3} α (fun (i : α) => m' i))
but is expected to have type
  forall {α : Type.{u2}} {m' : α -> Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] [_inst_2 : Preorder.{u2} α] [_inst_3 : DecidableEq.{succ u2} α] (d : forall (i : α), Matrix.{u1, u1, u3} (m' i) (m' i) R), Matrix.BlockTriangular.{u3, u2, max u1 u2} α (Sigma.{u2, u1} α (fun (i : α) => m' i)) R _inst_1 (Preorder.toLT.{u2} α _inst_2) (Matrix.blockDiagonal'.{u2, u1, u1, u3} α (fun (i : α) => m' i) (fun (i : α) => m' i) R (fun (a : α) (b : α) => _inst_3 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) d) (Sigma.fst.{u2, u1} α (fun (i : α) => m' i))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_block_diagonal' Matrix.blockTriangular_blockDiagonal'ₓ'. -/
theorem blockTriangular_blockDiagonal' [DecidableEq α] (d : ∀ i : α, Matrix (m' i) (m' i) R) :
    BlockTriangular (blockDiagonal' d) Sigma.fst :=
  by
  rintro ⟨i, i'⟩ ⟨j, j'⟩ h
  apply block_diagonal'_apply_ne d i' j' fun h' => ne_of_lt h h'.symm
#align matrix.block_triangular_block_diagonal' Matrix.blockTriangular_blockDiagonal'

/- warning: matrix.block_triangular_block_diagonal -> Matrix.blockTriangular_blockDiagonal is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : Preorder.{u2} α] [_inst_3 : DecidableEq.{succ u2} α] (d : α -> (Matrix.{u3, u3, u1} m m R)), Matrix.BlockTriangular.{u1, u2, max u3 u2} α (Prod.{u3, u2} m α) R _inst_1 (Preorder.toHasLt.{u2} α _inst_2) (Matrix.blockDiagonal.{u3, u3, u2, u1} m m α R (fun (a : α) (b : α) => _inst_3 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) d) (Prod.snd.{u3, u2} m α)
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] [_inst_2 : Preorder.{u2} α] [_inst_3 : DecidableEq.{succ u2} α] (d : α -> (Matrix.{u1, u1, u3} m m R)), Matrix.BlockTriangular.{u3, u2, max u2 u1} α (Prod.{u1, u2} m α) R _inst_1 (Preorder.toLT.{u2} α _inst_2) (Matrix.blockDiagonal.{u1, u1, u2, u3} m m α R (fun (a : α) (b : α) => _inst_3 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) d) (Prod.snd.{u1, u2} m α)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_block_diagonal Matrix.blockTriangular_blockDiagonalₓ'. -/
theorem blockTriangular_blockDiagonal [DecidableEq α] (d : α → Matrix m m R) :
    BlockTriangular (blockDiagonal d) Prod.snd :=
  by
  rintro ⟨i, i'⟩ ⟨j, j'⟩ h
  rw [block_diagonal'_eq_block_diagonal, block_triangular_block_diagonal']
  exact h
#align matrix.block_triangular_block_diagonal Matrix.blockTriangular_blockDiagonal

end Preorder

section LinearOrder

variable [LinearOrder α]

/- warning: matrix.block_triangular.mul -> Matrix.BlockTriangular.mul is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {b : m -> α} [_inst_2 : LinearOrder.{u2} α] [_inst_3 : Fintype.{u3} m] {M : Matrix.{u3, u3, u1} m m R} {N : Matrix.{u3, u3, u1} m m R}, (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_2))))) M b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_2))))) N b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_2))))) (HMul.hMul.{max u3 u1, max u3 u1, max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (Matrix.{u3, u3, u1} m m R) (instHMul.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))))) M N) b)
but is expected to have type
  forall {α : Type.{u1}} {m : Type.{u2}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {b : m -> α} [_inst_2 : LinearOrder.{u1} α] [_inst_3 : Fintype.{u2} m] {M : Matrix.{u2, u2, u3} m m R} {N : Matrix.{u2, u2, u3} m m R}, (Matrix.BlockTriangular.{u3, u1, u2} α m R _inst_1 (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_2)))))) M b) -> (Matrix.BlockTriangular.{u3, u1, u2} α m R _inst_1 (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_2)))))) N b) -> (Matrix.BlockTriangular.{u3, u1, u2} α m R _inst_1 (Preorder.toLT.{u1} α (PartialOrder.toPreorder.{u1} α (SemilatticeInf.toPartialOrder.{u1} α (Lattice.toSemilatticeInf.{u1} α (DistribLattice.toLattice.{u1} α (instDistribLattice.{u1} α _inst_2)))))) (HMul.hMul.{max u3 u2, max u3 u2, max u3 u2} (Matrix.{u2, u2, u3} m m R) (Matrix.{u2, u2, u3} m m R) (Matrix.{u2, u2, u3} m m R) (instHMul.{max u3 u2} (Matrix.{u2, u2, u3} m m R) (Matrix.instMulMatrix.{u3, u2} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1))))))) M N) b)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.mul Matrix.BlockTriangular.mulₓ'. -/
theorem BlockTriangular.mul [Fintype m] {M N : Matrix m m R} (hM : BlockTriangular M b)
    (hN : BlockTriangular N b) : BlockTriangular (M * N) b :=
  by
  intro i j hij
  apply Finset.sum_eq_zero
  intro k hk
  by_cases hki : b k < b i
  · simp_rw [hM hki, MulZeroClass.zero_mul]
  · simp_rw [hN (lt_of_lt_of_le hij (le_of_not_lt hki)), MulZeroClass.mul_zero]
#align matrix.block_triangular.mul Matrix.BlockTriangular.mul

end LinearOrder

/- warning: matrix.upper_two_block_triangular -> Matrix.upper_two_blockTriangular is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {n : Type.{u4}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : Preorder.{u2} α] (A : Matrix.{u3, u3, u1} m m R) (B : Matrix.{u3, u4, u1} m n R) (D : Matrix.{u4, u4, u1} n n R) {a : α} {b : α}, (LT.lt.{u2} α (Preorder.toHasLt.{u2} α _inst_2) a b) -> (Matrix.BlockTriangular.{u1, u2, max u3 u4} α (Sum.{u3, u4} m n) R _inst_1 (Preorder.toHasLt.{u2} α _inst_2) (Matrix.fromBlocks.{u3, u4, u3, u4, u1} m n m n R A B (OfNat.ofNat.{max u4 u3 u1} (Matrix.{u4, u3, u1} n m R) 0 (OfNat.mk.{max u4 u3 u1} (Matrix.{u4, u3, u1} n m R) 0 (Zero.zero.{max u4 u3 u1} (Matrix.{u4, u3, u1} n m R) (Matrix.hasZero.{u1, u4, u3} n m R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))) D) (Sum.elim.{u3, u4, succ u2} m n α (fun (i : m) => a) (fun (j : n) => b)))
but is expected to have type
  forall {α : Type.{u3}} {m : Type.{u2}} {n : Type.{u1}} {R : Type.{u4}} [_inst_1 : CommRing.{u4} R] [_inst_2 : Preorder.{u3} α] (A : Matrix.{u2, u2, u4} m m R) (B : Matrix.{u2, u1, u4} m n R) (D : Matrix.{u1, u1, u4} n n R) {a : α} {b : α}, (LT.lt.{u3} α (Preorder.toLT.{u3} α _inst_2) a b) -> (Matrix.BlockTriangular.{u4, u3, max u1 u2} α (Sum.{u2, u1} m n) R _inst_1 (Preorder.toLT.{u3} α _inst_2) (Matrix.fromBlocks.{u2, u1, u2, u1, u4} m n m n R A B (OfNat.ofNat.{max (max u4 u2) u1} (Matrix.{u1, u2, u4} n m R) 0 (Zero.toOfNat0.{max (max u4 u2) u1} (Matrix.{u1, u2, u4} n m R) (Matrix.zero.{u4, u1, u2} n m R (CommMonoidWithZero.toZero.{u4} R (CommSemiring.toCommMonoidWithZero.{u4} R (CommRing.toCommSemiring.{u4} R _inst_1)))))) D) (Sum.elim.{u2, u1, succ u3} m n α (fun (i : m) => a) (fun (j : n) => b)))
Case conversion may be inaccurate. Consider using '#align matrix.upper_two_block_triangular Matrix.upper_two_blockTriangularₓ'. -/
theorem upper_two_blockTriangular [Preorder α] (A : Matrix m m R) (B : Matrix m n R)
    (D : Matrix n n R) {a b : α} (hab : a < b) :
    BlockTriangular (fromBlocks A B 0 D) (Sum.elim (fun i => a) fun j => b) := by
  rintro (c | c) (d | d) hcd <;> first |simpa [hab.not_lt] using hcd|simp
#align matrix.upper_two_block_triangular Matrix.upper_two_blockTriangular

/-! ### Determinant -/


variable [DecidableEq m] [Fintype m] [DecidableEq n] [Fintype n]

/- warning: matrix.equiv_block_det -> Matrix.equiv_block_det is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] (M : Matrix.{u2, u2, u1} m m R) {p : m -> Prop} {q : m -> Prop} [_inst_6 : DecidablePred.{succ u2} m p] [_inst_7 : DecidablePred.{succ u2} m q], (forall (x : m), Iff (q x) (p x)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => p a)) (b : Subtype.{succ u2} m (fun (a : m) => p a)) => Subtype.decidableEq.{u2} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M p)) (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => q a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => q a)) (b : Subtype.{succ u2} m (fun (a : m) => q a)) => Subtype.decidableEq.{u2} m (fun (x : m) => q x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => q a) (fun (a : m) => _inst_7 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M q)))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] (M : Matrix.{u1, u1, u2} m m R) {p : m -> Prop} {q : m -> Prop} [_inst_6 : DecidablePred.{succ u1} m p] [_inst_7 : DecidablePred.{succ u1} m q], (forall (x : m), Iff (q x) (p x)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u1} m (fun (a : m) => p a)) (b : Subtype.{succ u1} m (fun (a : m) => p a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M p)) (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => q a)) (fun (a : Subtype.{succ u1} m (fun (a : m) => q a)) (b : Subtype.{succ u1} m (fun (a : m) => q a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => q x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => q a) (fun (a : m) => _inst_7 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M q)))
Case conversion may be inaccurate. Consider using '#align matrix.equiv_block_det Matrix.equiv_block_detₓ'. -/
theorem equiv_block_det (M : Matrix m m R) {p q : m → Prop} [DecidablePred p] [DecidablePred q]
    (e : ∀ x, q x ↔ p x) : (toSquareBlockProp M p).det = (toSquareBlockProp M q).det := by
  convert Matrix.det_reindex_self (Equiv.subtypeEquivRight e) (to_square_block_prop M q)
#align matrix.equiv_block_det Matrix.equiv_block_det

/- warning: matrix.det_to_square_block_id -> Matrix.det_toSquareBlock_id is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] (M : Matrix.{u2, u2, u1} m m R) (i : m), Eq.{succ u1} R (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => Eq.{succ u2} m (id.{succ u2} m a) i)) (fun (a : Subtype.{succ u2} m (fun (a : m) => Eq.{succ u2} m (id.{succ u2} m a) i)) (b : Subtype.{succ u2} m (fun (a : m) => Eq.{succ u2} m (id.{succ u2} m a) i)) => Subtype.decidableEq.{u2} m (fun (x : m) => Eq.{succ u2} m (id.{succ u2} m x) i) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => Eq.{succ u2} m (id.{succ u2} m a) i) (fun (a : m) => _inst_2 (id.{succ u2} m a) i) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u2, u1, u2} m R m M (id.{succ u2} m) i)) (M i i)
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] (M : Matrix.{u1, u1, u2} m m R) (i : m), Eq.{succ u2} R (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => Eq.{succ u1} m (id.{succ u1} m a) i)) (fun (a : Subtype.{succ u1} m (fun (a : m) => Eq.{succ u1} m (id.{succ u1} m a) i)) (b : Subtype.{succ u1} m (fun (a : m) => Eq.{succ u1} m (id.{succ u1} m a) i)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Eq.{succ u1} m (id.{succ u1} m x) i) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => Eq.{succ u1} m (id.{succ u1} m a) i) (fun (a : m) => _inst_2 (id.{succ u1} m a) i) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u1, u2, u1} m R m M (id.{succ u1} m) i)) (M i i)
Case conversion may be inaccurate. Consider using '#align matrix.det_to_square_block_id Matrix.det_toSquareBlock_idₓ'. -/
@[simp]
theorem det_toSquareBlock_id (M : Matrix m m R) (i : m) : (M.toSquareBlock id i).det = M i i :=
  letI : Unique { a // id a = i } := ⟨⟨⟨i, rfl⟩⟩, fun j => Subtype.ext j.property⟩
  (det_unique _).trans rfl
#align matrix.det_to_square_block_id Matrix.det_toSquareBlock_id

/- warning: matrix.det_to_block -> Matrix.det_toBlock is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] (M : Matrix.{u2, u2, u1} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u2} m p], Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Matrix.det.{u1, u2} (Sum.{u2, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a)))) (fun (a : Sum.{u2, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a)))) (b : Sum.{u2, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a)))) => Sum.decidableEq.{u2, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => p a)) (b : Subtype.{succ u2} m (fun (a : m) => p a)) => Subtype.decidableEq.{u2} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.{succ u2} m (fun (a : m) => Not (p a))) (fun (a : Subtype.{succ u2} m (fun (a : m) => Not (p a))) (b : Subtype.{succ u2} m (fun (a : m) => Not (p a))) => Subtype.decidableEq.{u2} m (fun (x : m) => Not (p x)) (fun (a : m) (b : m) => _inst_2 a b) a b) a b) (Sum.fintype.{u2, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a))) (Subtype.fintype.{u2} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) (Subtype.fintype.{u2} m (fun (a : m) => Not (p a)) (fun (a : m) => Not.decidable (p a) (_inst_6 a)) _inst_3)) R _inst_1 (Matrix.fromBlocks.{u2, u2, u2, u2, u1} (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a))) (Subtype.{succ u2} m (fun (a : m) => p a)) (Subtype.{succ u2} m (fun (a : m) => Not (p a))) R (Matrix.toBlock.{u2, u2, u1} m m R M p p) (Matrix.toBlock.{u2, u2, u1} m m R M p (fun (j : m) => Not (p j))) (Matrix.toBlock.{u2, u2, u1} m m R M (fun (j : m) => Not (p j)) p) (Matrix.toBlock.{u2, u2, u1} m m R M (fun (j : m) => Not (p j)) (fun (j : m) => Not (p j)))))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] (M : Matrix.{u1, u1, u2} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u1} m p], Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Matrix.det.{u2, u1} (Sum.{u1, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a)))) (fun (a : Sum.{u1, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a)))) (b : Sum.{u1, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a)))) => Sum.instDecidableEqSum.{u1, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a))) (fun (a : Subtype.{succ u1} m (fun (a : m) => p a)) (b : Subtype.{succ u1} m (fun (a : m) => p a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (fun (a : Subtype.{succ u1} m (fun (a : m) => Not (p a))) (b : Subtype.{succ u1} m (fun (a : m) => Not (p a))) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Not (p x)) (fun (a : m) (b : m) => _inst_2 a b) a b) a b) (instFintypeSum.{u1, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a))) (Subtype.fintype.{u1} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) (Subtype.fintype.{u1} m (fun (a : m) => Not (p a)) (fun (a : m) => instDecidableNot (p a) (_inst_6 a)) _inst_3)) R _inst_1 (Matrix.fromBlocks.{u1, u1, u1, u1, u2} (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a))) (Subtype.{succ u1} m (fun (a : m) => p a)) (Subtype.{succ u1} m (fun (a : m) => Not (p a))) R (Matrix.toBlock.{u1, u1, u2} m m R M p p) (Matrix.toBlock.{u1, u1, u2} m m R M p (fun (j : m) => Not (p j))) (Matrix.toBlock.{u1, u1, u2} m m R M (fun (j : m) => Not (p j)) p) (Matrix.toBlock.{u1, u1, u2} m m R M (fun (j : m) => Not (p j)) (fun (j : m) => Not (p j)))))
Case conversion may be inaccurate. Consider using '#align matrix.det_to_block Matrix.det_toBlockₓ'. -/
theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det :=
  by
  rw [← Matrix.det_reindex_self (Equiv.sumCompl p).symm M]
  rw [det_apply', det_apply']
  congr ; ext σ; congr ; ext
  generalize hy : σ x = y
  cases x <;> cases y <;>
    simp only [Matrix.reindex_apply, to_block_apply, Equiv.symm_symm, Equiv.sumCompl_apply_inr,
      Equiv.sumCompl_apply_inl, from_blocks_apply₁₁, from_blocks_apply₁₂, from_blocks_apply₂₁,
      from_blocks_apply₂₂, Matrix.submatrix_apply]
#align matrix.det_to_block Matrix.det_toBlock

/- warning: matrix.two_block_triangular_det -> Matrix.twoBlockTriangular_det is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] (M : Matrix.{u2, u2, u1} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u2} m p], (forall (i : m), (Not (p i)) -> (forall (j : m), (p j) -> (Eq.{succ u1} R (M i j) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => p a)) (b : Subtype.{succ u2} m (fun (a : m) => p a)) => Subtype.decidableEq.{u2} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M p)) (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) (b : Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) => Subtype.decidableEq.{u2} m (fun (x : m) => (fun (i : m) => Not (p i)) x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a) (fun (a : m) => Not.decidable (p a) (_inst_6 a)) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M (fun (i : m) => Not (p i))))))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] (M : Matrix.{u1, u1, u2} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u1} m p], (forall (i : m), (Not (p i)) -> (forall (j : m), (p j) -> (Eq.{succ u2} R (M i j) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u1} m (fun (a : m) => p a)) (b : Subtype.{succ u1} m (fun (a : m) => p a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M p)) (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => Not (p a))) (fun (a : Subtype.{succ u1} m (fun (a : m) => Not (p a))) (b : Subtype.{succ u1} m (fun (a : m) => Not (p a))) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Not (p x)) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => Not (p a)) (fun (a : m) => instDecidableNot (p a) (_inst_6 a)) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M (fun (i : m) => Not (p i))))))
Case conversion may be inaccurate. Consider using '#align matrix.two_block_triangular_det Matrix.twoBlockTriangular_detₓ'. -/
theorem twoBlockTriangular_det (M : Matrix m m R) (p : m → Prop) [DecidablePred p]
    (h : ∀ i, ¬p i → ∀ j, p j → M i j = 0) :
    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det :=
  by
  rw [det_to_block M p]
  convert det_from_blocks_zero₂₁ (to_block M p p) (to_block M p fun j => ¬p j)
      (to_block M (fun j => ¬p j) fun j => ¬p j)
  ext
  exact h (↑i) i.2 (↑j) j.2
#align matrix.two_block_triangular_det Matrix.twoBlockTriangular_det

/- warning: matrix.two_block_triangular_det' -> Matrix.twoBlockTriangular_det' is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] (M : Matrix.{u2, u2, u1} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u2} m p], (forall (i : m), (p i) -> (forall (j : m), (Not (p j)) -> (Eq.{succ u1} R (M i j) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => p a)) (b : Subtype.{succ u2} m (fun (a : m) => p a)) => Subtype.decidableEq.{u2} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M p)) (Matrix.det.{u1, u2} (Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) (fun (a : Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) (b : Subtype.{succ u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a)) => Subtype.decidableEq.{u2} m (fun (x : m) => (fun (i : m) => Not (p i)) x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u2} m (fun (a : m) => (fun (i : m) => Not (p i)) a) (fun (a : m) => Not.decidable (p a) (_inst_6 a)) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u2, u1} m R M (fun (i : m) => Not (p i))))))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] (M : Matrix.{u1, u1, u2} m m R) (p : m -> Prop) [_inst_6 : DecidablePred.{succ u1} m p], (forall (i : m), (p i) -> (forall (j : m), (Not (p j)) -> (Eq.{succ u2} R (M i j) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_1)))))))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_1))))) (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => p a)) (fun (a : Subtype.{succ u1} m (fun (a : m) => p a)) (b : Subtype.{succ u1} m (fun (a : m) => p a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => p x) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => p a) (fun (a : m) => _inst_6 a) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M p)) (Matrix.det.{u2, u1} (Subtype.{succ u1} m (fun (a : m) => Not (p a))) (fun (a : Subtype.{succ u1} m (fun (a : m) => Not (p a))) (b : Subtype.{succ u1} m (fun (a : m) => Not (p a))) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Not (p x)) (fun (a : m) (b : m) => _inst_2 a b) a b) (Subtype.fintype.{u1} m (fun (a : m) => Not (p a)) (fun (a : m) => instDecidableNot (p a) (_inst_6 a)) _inst_3) R _inst_1 (Matrix.toSquareBlockProp.{u1, u2} m R M (fun (i : m) => Not (p i))))))
Case conversion may be inaccurate. Consider using '#align matrix.two_block_triangular_det' Matrix.twoBlockTriangular_det'ₓ'. -/
theorem twoBlockTriangular_det' (M : Matrix m m R) (p : m → Prop) [DecidablePred p]
    (h : ∀ i, p i → ∀ j, ¬p j → M i j = 0) :
    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det :=
  by
  rw [M.two_block_triangular_det fun i => ¬p i, mul_comm]
  simp_rw [Classical.not_not]
  congr 1
  exact equiv_block_det _ fun _ => not_not.symm
  simpa only [Classical.not_not] using h
#align matrix.two_block_triangular_det' Matrix.twoBlockTriangular_det'

/- warning: matrix.block_triangular.det -> Matrix.BlockTriangular.det is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : DecidableEq.{succ u2} α] [_inst_7 : LinearOrder.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_7))))) M b) -> (Eq.{succ u1} R (Matrix.det.{u1, u3} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u1, u2} R α (CommRing.toCommMonoid.{u1} R _inst_1) (Finset.image.{u3, u2} m α (fun (a : α) (b : α) => _inst_6 a b) b (Finset.univ.{u3} m _inst_3)) (fun (a : α) => Matrix.det.{u1, u3} (Subtype.{succ u3} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) (fun (a_1 : Subtype.{succ u3} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) (b_1 : Subtype.{succ u3} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) => Subtype.decidableEq.{u3} m (fun (x : m) => Eq.{succ u2} α (b x) a) (fun (a : m) (b : m) => _inst_2 a b) a_1 b_1) (Subtype.fintype.{u3} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a) (fun (a_1 : m) => _inst_6 (b a_1) a) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u3, u1, u2} m R α M b a))))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : DecidableEq.{succ u2} α] [_inst_7 : LinearOrder.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_7)))))) M b) -> (Eq.{succ u3} R (Matrix.det.{u3, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u3, u2} R α (CommRing.toCommMonoid.{u3} R _inst_1) (Finset.image.{u1, u2} m α (fun (a : α) (b : α) => _inst_6 a b) b (Finset.univ.{u1} m _inst_3)) (fun (a : α) => Matrix.det.{u3, u1} (Subtype.{succ u1} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) (fun (a_1 : Subtype.{succ u1} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) (b_1 : Subtype.{succ u1} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Eq.{succ u2} α (b x) a) (fun (a : m) (b : m) => _inst_2 a b) a_1 b_1) (Subtype.fintype.{u1} m (fun (a_1 : m) => Eq.{succ u2} α (b a_1) a) (fun (a_1 : m) => _inst_6 (b a_1) a) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u1, u3, u2} m R α M b a))))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.det Matrix.BlockTriangular.detₓ'. -/
protected theorem BlockTriangular.det [DecidableEq α] [LinearOrder α] (hM : BlockTriangular M b) :
    M.det = ∏ a in univ.image b, (M.toSquareBlock b a).det :=
  by
  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m
  subst hs
  cases isEmpty_or_nonempty m
  · simp
  let k := (univ.image b).max' (univ_nonempty.image _)
  rw [two_block_triangular_det' M fun i => b i = k]
  · have : univ.image b = insert k ((univ.image b).eraseₓ k) :=
      by
      rw [insert_erase]
      apply max'_mem
    rw [this, prod_insert (not_mem_erase _ _)]
    refine' congr_arg _ _
    let b' := fun i : { a // b a ≠ k } => b ↑i
    have h' : block_triangular (M.to_square_block_prop fun i => b i ≠ k) b' := hM.submatrix
    have hb' : image b' univ = (image b univ).eraseₓ k := by
      convert image_subtype_ne_univ_eq_image_erase k b
    rw [ih _ (erase_ssubset <| max'_mem _ _) h' hb']
    refine' Finset.prod_congr rfl fun l hl => _
    let he : { a // b' a = l } ≃ { a // b a = l } :=
      haveI hc : ∀ i, b i = l → b i ≠ k := fun i hi => ne_of_eq_of_ne hi (ne_of_mem_erase hl)
      Equiv.subtypeSubtypeEquivSubtype hc
    simp only [to_square_block_def]
    rw [← Matrix.det_reindex_self he.symm fun i j : { a // b a = l } => M ↑i ↑j]
    rfl
  · intro i hi j hj
    apply hM
    rw [hi]
    apply lt_of_le_of_ne _ hj
    exact Finset.le_max' (univ.image b) _ (mem_image_of_mem _ (mem_univ _))
#align matrix.block_triangular.det Matrix.BlockTriangular.det

/- warning: matrix.block_triangular.det_fintype -> Matrix.BlockTriangular.det_fintype is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : DecidableEq.{succ u2} α] [_inst_7 : Fintype.{u2} α] [_inst_8 : LinearOrder.{u2} α], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_8))))) M b) -> (Eq.{succ u1} R (Matrix.det.{u1, u3} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u1, u2} R α (CommRing.toCommMonoid.{u1} R _inst_1) (Finset.univ.{u2} α _inst_7) (fun (k : α) => Matrix.det.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => Eq.{succ u2} α (b a) k)) (fun (a : Subtype.{succ u3} m (fun (a : m) => Eq.{succ u2} α (b a) k)) (b_1 : Subtype.{succ u3} m (fun (a : m) => Eq.{succ u2} α (b a) k)) => Subtype.decidableEq.{u3} m (fun (x : m) => Eq.{succ u2} α (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (Subtype.fintype.{u3} m (fun (a : m) => Eq.{succ u2} α (b a) k) (fun (a : m) => _inst_6 (b a) k) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u3, u1, u2} m R α M b k))))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : DecidableEq.{succ u2} α] [_inst_7 : Fintype.{u2} α] [_inst_8 : LinearOrder.{u2} α], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_8)))))) M b) -> (Eq.{succ u3} R (Matrix.det.{u3, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u3, u2} R α (CommRing.toCommMonoid.{u3} R _inst_1) (Finset.univ.{u2} α _inst_7) (fun (k : α) => Matrix.det.{u3, u1} (Subtype.{succ u1} m (fun (a : m) => Eq.{succ u2} α (b a) k)) (fun (a : Subtype.{succ u1} m (fun (a : m) => Eq.{succ u2} α (b a) k)) (b_1 : Subtype.{succ u1} m (fun (a : m) => Eq.{succ u2} α (b a) k)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => Eq.{succ u2} α (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (Subtype.fintype.{u1} m (fun (a : m) => Eq.{succ u2} α (b a) k) (fun (a : m) => _inst_6 (b a) k) _inst_3) R _inst_1 (Matrix.toSquareBlock.{u1, u3, u2} m R α M b k))))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.det_fintype Matrix.BlockTriangular.det_fintypeₓ'. -/
theorem BlockTriangular.det_fintype [DecidableEq α] [Fintype α] [LinearOrder α]
    (h : BlockTriangular M b) : M.det = ∏ k : α, (M.toSquareBlock b k).det :=
  by
  refine' h.det.trans (prod_subset (subset_univ _) fun a _ ha => _)
  have : IsEmpty { i // b i = a } := ⟨fun i => ha <| mem_image.2 ⟨i, mem_univ _, i.2⟩⟩
  exact det_is_empty
#align matrix.block_triangular.det_fintype Matrix.BlockTriangular.det_fintype

/- warning: matrix.det_of_upper_triangular -> Matrix.det_of_upperTriangular is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u2, u2, u1} m m R} [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] [_inst_6 : LinearOrder.{u2} m], (Matrix.BlockTriangular.{u1, u2, u2} m m R _inst_1 (Preorder.toHasLt.{u2} m (PartialOrder.toPreorder.{u2} m (SemilatticeInf.toPartialOrder.{u2} m (Lattice.toSemilatticeInf.{u2} m (LinearOrder.toLattice.{u2} m _inst_6))))) M (id.{succ u2} m)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u1, u2} R m (CommRing.toCommMonoid.{u1} R _inst_1) (Finset.univ.{u2} m _inst_3) (fun (i : m) => M i i)))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] {M : Matrix.{u1, u1, u2} m m R} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u1} m], (Matrix.BlockTriangular.{u2, u1, u1} m m R _inst_1 (Preorder.toLT.{u1} m (PartialOrder.toPreorder.{u1} m (SemilatticeInf.toPartialOrder.{u1} m (Lattice.toSemilatticeInf.{u1} m (DistribLattice.toLattice.{u1} m (instDistribLattice.{u1} m _inst_6)))))) M (id.{succ u1} m)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u2, u1} R m (CommRing.toCommMonoid.{u2} R _inst_1) (Finset.univ.{u1} m _inst_3) (fun (i : m) => M i i)))
Case conversion may be inaccurate. Consider using '#align matrix.det_of_upper_triangular Matrix.det_of_upperTriangularₓ'. -/
theorem det_of_upperTriangular [LinearOrder m] (h : M.BlockTriangular id) :
    M.det = ∏ i : m, M i i :=
  by
  haveI : DecidableEq R := Classical.decEq _
  simp_rw [h.det, image_id, det_to_square_block_id]
#align matrix.det_of_upper_triangular Matrix.det_of_upperTriangular

/- warning: matrix.det_of_lower_triangular -> Matrix.det_of_lowerTriangular is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] [_inst_2 : DecidableEq.{succ u2} m] [_inst_3 : Fintype.{u2} m] [_inst_6 : LinearOrder.{u2} m] (M : Matrix.{u2, u2, u1} m m R), (Matrix.BlockTriangular.{u1, u2, u2} (OrderDual.{u2} m) m R _inst_1 (OrderDual.hasLt.{u2} m (Preorder.toHasLt.{u2} m (PartialOrder.toPreorder.{u2} m (SemilatticeInf.toPartialOrder.{u2} m (Lattice.toSemilatticeInf.{u2} m (LinearOrder.toLattice.{u2} m _inst_6)))))) M (coeFn.{succ u2, succ u2} (Equiv.{succ u2, succ u2} m (OrderDual.{u2} m)) (fun (_x : Equiv.{succ u2, succ u2} m (OrderDual.{u2} m)) => m -> (OrderDual.{u2} m)) (Equiv.hasCoeToFun.{succ u2, succ u2} m (OrderDual.{u2} m)) (OrderDual.toDual.{u2} m))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u1, u2} R m (CommRing.toCommMonoid.{u1} R _inst_1) (Finset.univ.{u2} m _inst_3) (fun (i : m) => M i i)))
but is expected to have type
  forall {m : Type.{u1}} {R : Type.{u2}} [_inst_1 : CommRing.{u2} R] [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u1} m] (M : Matrix.{u1, u1, u2} m m R), (Matrix.BlockTriangular.{u2, u1, u1} (OrderDual.{u1} m) m R _inst_1 (OrderDual.instLTOrderDual.{u1} m (Preorder.toLT.{u1} m (PartialOrder.toPreorder.{u1} m (SemilatticeInf.toPartialOrder.{u1} m (Lattice.toSemilatticeInf.{u1} m (DistribLattice.toLattice.{u1} m (instDistribLattice.{u1} m _inst_6))))))) M (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.{succ u1, succ u1} m (OrderDual.{u1} m)) m (fun (_x : m) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : m) => OrderDual.{u1} m) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} m (OrderDual.{u1} m)) (OrderDual.toDual.{u1} m))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_2 a b) _inst_3 R _inst_1 M) (Finset.prod.{u2, u1} R m (CommRing.toCommMonoid.{u2} R _inst_1) (Finset.univ.{u1} m _inst_3) (fun (i : m) => M i i)))
Case conversion may be inaccurate. Consider using '#align matrix.det_of_lower_triangular Matrix.det_of_lowerTriangularₓ'. -/
theorem det_of_lowerTriangular [LinearOrder m] (M : Matrix m m R) (h : M.BlockTriangular toDual) :
    M.det = ∏ i : m, M i i := by
  rw [← det_transpose]
  exact det_of_upper_triangular h.transpose
#align matrix.det_of_lower_triangular Matrix.det_of_lowerTriangular

/-! ### Invertible -/


/- warning: matrix.block_triangular.to_block_inverse_mul_to_block_eq_one -> Matrix.BlockTriangular.toBlock_inverse_mul_toBlock_eq_one is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) M b) -> (forall (k : α), Eq.{succ (max u3 u1)} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.mul.{u1, u3, u3, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (Subtype.fintype.{u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k) (fun (a : m) => LT.lt.decidable.{u2} α _inst_6 (b a) k) _inst_3) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1))))) (Matrix.toBlock.{u3, u3, u1} m m R (Inv.inv.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasInv.{u3, u1} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k)) (Matrix.toBlock.{u3, u3, u1} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k))) (OfNat.ofNat.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) 1 (OfNat.mk.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) 1 (One.one.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.hasOne.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (fun (a : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (b_1 : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) => Subtype.decidableEq.{u3} m (fun (x : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1))))))))))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.instMulMatrix.{u3, u1} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))))) (Matrix.one.{u3, u1} m R (fun (a : m) (b : m) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) (Semiring.toOne.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))) M], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) M b) -> (forall (k : α), Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.mul.{u3, u1, u1, u1} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (Subtype.fintype.{u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k) (fun (a : m) => instDecidableLtToLTToPreorderToPartialOrder.{u2} α _inst_6 (b a) k) _inst_3) (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1))))) (Matrix.toBlock.{u1, u1, u3} m m R (Inv.inv.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.inv.{u1, u3} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k)) (Matrix.toBlock.{u1, u1, u3} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k))) (OfNat.ofNat.{max u3 u1} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) 1 (One.toOfNat1.{max u3 u1} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.one.{u3, u1} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (fun (a : Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (b_1 : Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) (Semiring.toOne.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.to_block_inverse_mul_to_block_eq_one Matrix.BlockTriangular.toBlock_inverse_mul_toBlock_eq_oneₓ'. -/
theorem BlockTriangular.toBlock_inverse_mul_toBlock_eq_one [LinearOrder α] [Invertible M]
    (hM : BlockTriangular M b) (k : α) :
    ((M⁻¹.toBlock (fun i => b i < k) fun i => b i < k) ⬝
        M.toBlock (fun i => b i < k) fun i => b i < k) =
      1 :=
  by
  let p i := b i < k
  have h_sum :
    M⁻¹.toBlock p p ⬝ M.to_block p p +
        (M⁻¹.toBlock p fun i => ¬p i) ⬝ M.to_block (fun i => ¬p i) p =
      1 :=
    by rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_self]
  have h_zero : M.to_block (fun i => ¬p i) p = 0 :=
    by
    ext (i j)
    simpa using hM (lt_of_lt_of_le j.2 (le_of_not_lt i.2))
  simpa [h_zero] using h_sum
#align matrix.block_triangular.to_block_inverse_mul_to_block_eq_one Matrix.BlockTriangular.toBlock_inverse_mul_toBlock_eq_one

/- warning: matrix.block_triangular.inv_to_block -> Matrix.BlockTriangular.inv_toBlock is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) M b) -> (forall (k : α), Eq.{succ (max u3 u1)} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Inv.inv.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.hasInv.{u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (Subtype.fintype.{u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k) (fun (a : m) => LT.lt.decidable.{u2} α _inst_6 (b a) k) _inst_3) (fun (a : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (b_1 : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) => Subtype.decidableEq.{u3} m (fun (x : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) _inst_1) (Matrix.toBlock.{u3, u3, u1} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k))) (Matrix.toBlock.{u3, u3, u1} m m R (Inv.inv.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasInv.{u3, u1} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k)))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.instMulMatrix.{u3, u1} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))))) (Matrix.one.{u3, u1} m R (fun (a : m) (b : m) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) (Semiring.toOne.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))) M], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) M b) -> (forall (k : α), Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Inv.inv.{max u3 u1} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.inv.{u1, u3} (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (Subtype.fintype.{u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k) (fun (a : m) => instDecidableLtToLTToPreorderToPartialOrder.{u2} α _inst_6 (b a) k) _inst_3) (fun (a : Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (b_1 : Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) => Subtype.instDecidableEqSubtype.{u1} m (fun (x : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) _inst_1) (Matrix.toBlock.{u1, u1, u3} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k))) (Matrix.toBlock.{u1, u1, u3} m m R (Inv.inv.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.inv.{u1, u3} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k)))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.inv_to_block Matrix.BlockTriangular.inv_toBlockₓ'. -/
/-- The inverse of an upper-left subblock of a block-triangular matrix `M` is the upper-left
subblock of `M⁻¹`. -/
theorem BlockTriangular.inv_toBlock [LinearOrder α] [Invertible M] (hM : BlockTriangular M b)
    (k : α) :
    (M.toBlock (fun i => b i < k) fun i => b i < k)⁻¹ =
      M⁻¹.toBlock (fun i => b i < k) fun i => b i < k :=
  inv_eq_left_inv <| hM.toBlock_inverse_mul_toBlock_eq_one k
#align matrix.block_triangular.inv_to_block Matrix.BlockTriangular.inv_toBlock

/- warning: matrix.block_triangular.invertible_to_block -> Matrix.BlockTriangular.invertibleToBlock is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) M b) -> (forall (k : α), Invertible.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.hasMul.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (Subtype.fintype.{u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k) (fun (a : m) => LT.lt.decidable.{u2} α _inst_6 (b a) k) _inst_3) (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (fun (a : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) (b_1 : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) => Subtype.decidableEq.{u3} m (fun (x : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.toBlock.{u3, u3, u1} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k)))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u1 u3} (Matrix.{u3, u3, u1} m m R) (Matrix.instMulMatrix.{u1, u3} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.one.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) M b) -> (forall (k : α), Invertible.{max u1 u3} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.instMulMatrix.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (Subtype.fintype.{u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k) (fun (a : m) => instDecidableLtToLTToPreorderToPartialOrder.{u2} α _inst_6 (b a) k) _inst_3) (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.one.{u1, u3} (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (fun (a : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) (b_1 : Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) => Subtype.instDecidableEqSubtype.{u3} m (fun (x : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b x) k) (fun (a : m) (b : m) => _inst_2 a b) a b_1) (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1))) (Semiring.toOne.{u1} R (CommSemiring.toSemiring.{u1} R (CommRing.toCommSemiring.{u1} R _inst_1)))) (Matrix.toBlock.{u3, u3, u1} m m R M (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k)))
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular.invertible_to_block Matrix.BlockTriangular.invertibleToBlockₓ'. -/
/-- An upper-left subblock of an invertible block-triangular matrix is invertible. -/
def BlockTriangular.invertibleToBlock [LinearOrder α] [Invertible M] (hM : BlockTriangular M b)
    (k : α) : Invertible (M.toBlock (fun i => b i < k) fun i => b i < k) :=
  invertibleOfLeftInverse _ ((⅟ M).toBlock (fun i => b i < k) fun i => b i < k) <| by
    simpa only [inv_of_eq_nonsing_inv] using hM.to_block_inverse_mul_to_block_eq_one k
#align matrix.block_triangular.invertible_to_block Matrix.BlockTriangular.invertibleToBlock

/- warning: matrix.to_block_inverse_eq_zero -> Matrix.toBlock_inverse_eq_zero is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) M b) -> (forall (k : α), Eq.{succ (max u3 u1)} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b a))) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.toBlock.{u3, u3, u1} m m R (Inv.inv.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasInv.{u3, u1} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b i)) (fun (i : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b i) k)) (OfNat.ofNat.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b a))) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) 0 (OfNat.mk.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b a))) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) 0 (Zero.zero.{max u3 u1} (Matrix.{u3, u3, u1} (Subtype.{succ u3} m (fun (a : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b a))) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R) (Matrix.hasZero.{u1, u3, u3} (Subtype.{succ u3} m (fun (a : m) => LE.le.{u2} α (Preorder.toHasLe.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) k (b a))) (Subtype.{succ u3} m (fun (a : m) => LT.lt.{u2} α (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (b a) k)) R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))))))))
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.instMulMatrix.{u3, u1} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))))) (Matrix.one.{u3, u1} m R (fun (a : m) (b : m) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) (Semiring.toOne.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))) M], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) M b) -> (forall (k : α), Eq.{max (succ u3) (succ u1)} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) k (b a))) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.toBlock.{u1, u1, u3} m m R (Inv.inv.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.inv.{u1, u3} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) (fun (i : m) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) k (b i)) (fun (i : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b i) k)) (OfNat.ofNat.{max u3 u1} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) k (b a))) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) 0 (Zero.toOfNat0.{max u3 u1} (Matrix.{u1, u1, u3} (Subtype.{succ u1} m (fun (a : m) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) k (b a))) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R) (Matrix.zero.{u3, u1, u1} (Subtype.{succ u1} m (fun (a : m) => LE.le.{u2} α (Preorder.toLE.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) k (b a))) (Subtype.{succ u1} m (fun (a : m) => LT.lt.{u2} α (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (b a) k)) R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))))))
Case conversion may be inaccurate. Consider using '#align matrix.to_block_inverse_eq_zero Matrix.toBlock_inverse_eq_zeroₓ'. -/
/-- A lower-left subblock of the inverse of a block-triangular matrix is zero. This is a first step
towards `block_triangular.inv_to_block` below. -/
theorem toBlock_inverse_eq_zero [LinearOrder α] [Invertible M] (hM : BlockTriangular M b) (k : α) :
    (M⁻¹.toBlock (fun i => k ≤ b i) fun i => b i < k) = 0 :=
  by
  let p i := b i < k
  let q i := ¬b i < k
  have h_sum : M⁻¹.toBlock q p ⬝ M.to_block p p + M⁻¹.toBlock q q ⬝ M.to_block q p = 0 :=
    by
    rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_disjoint]
    rw [disjoint_iff_inf_le]
    exact fun i h => h.1 h.2
  have h_zero : M.to_block q p = 0 := by
    ext (i j)
    simpa using hM (lt_of_lt_of_le j.2 <| le_of_not_lt i.2)
  have h_mul_eq_zero : M⁻¹.toBlock q p ⬝ M.to_block p p = 0 := by simpa [h_zero] using h_sum
  haveI : Invertible (M.to_block p p) := hM.invertible_to_block k
  have : (fun i => k ≤ b i) = q := by
    ext
    exact not_lt.symm
  rw [this, ← Matrix.zero_mul (M.to_block p p)⁻¹, ← h_mul_eq_zero,
    mul_inv_cancel_right_of_invertible]
#align matrix.to_block_inverse_eq_zero Matrix.toBlock_inverse_eq_zero

/- warning: matrix.block_triangular_inv_of_block_triangular -> Matrix.blockTriangular_inv_of_blockTriangular is a dubious translation:
lean 3 declaration is
  forall {α : Type.{u2}} {m : Type.{u3}} {R : Type.{u1}} [_inst_1 : CommRing.{u1} R] {M : Matrix.{u3, u3, u1} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u3} m] [_inst_3 : Fintype.{u3} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasMul.{u1, u3} m R _inst_3 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_1))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (Matrix.hasOne.{u1, u3} m R (fun (a : m) (b : m) => _inst_2 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_1)))))) M], (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) M b) -> (Matrix.BlockTriangular.{u1, u2, u3} α m R _inst_1 (Preorder.toHasLt.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (LinearOrder.toLattice.{u2} α _inst_6))))) (Inv.inv.{max u3 u1} (Matrix.{u3, u3, u1} m m R) (Matrix.hasInv.{u3, u1} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) b)
but is expected to have type
  forall {α : Type.{u2}} {m : Type.{u1}} {R : Type.{u3}} [_inst_1 : CommRing.{u3} R] {M : Matrix.{u1, u1, u3} m m R} {b : m -> α} [_inst_2 : DecidableEq.{succ u1} m] [_inst_3 : Fintype.{u1} m] [_inst_6 : LinearOrder.{u2} α] [_inst_7 : Invertible.{max u3 u1} (Matrix.{u1, u1, u3} m m R) (Matrix.instMulMatrix.{u3, u1} m R _inst_3 (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_1)))))) (Matrix.one.{u3, u1} m R (fun (a : m) (b : m) => _inst_2 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1))) (Semiring.toOne.{u3} R (CommSemiring.toSemiring.{u3} R (CommRing.toCommSemiring.{u3} R _inst_1)))) M], (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) M b) -> (Matrix.BlockTriangular.{u3, u2, u1} α m R _inst_1 (Preorder.toLT.{u2} α (PartialOrder.toPreorder.{u2} α (SemilatticeInf.toPartialOrder.{u2} α (Lattice.toSemilatticeInf.{u2} α (DistribLattice.toLattice.{u2} α (instDistribLattice.{u2} α _inst_6)))))) (Inv.inv.{max u1 u3} (Matrix.{u1, u1, u3} m m R) (Matrix.inv.{u1, u3} m R _inst_3 (fun (a : m) (b : m) => _inst_2 a b) _inst_1) M) b)
Case conversion may be inaccurate. Consider using '#align matrix.block_triangular_inv_of_block_triangular Matrix.blockTriangular_inv_of_blockTriangularₓ'. -/
/-- The inverse of a block-triangular matrix is block-triangular. -/
theorem blockTriangular_inv_of_blockTriangular [LinearOrder α] [Invertible M]
    (hM : BlockTriangular M b) : BlockTriangular M⁻¹ b :=
  by
  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m
  subst hs
  intro i j hij
  haveI : Inhabited m := ⟨i⟩
  let k := (univ.image b).max' (univ_nonempty.image _)
  let b' := fun i : { a // b a < k } => b ↑i
  let A := M.to_block (fun i => b i < k) fun j => b j < k
  obtain hbi | hi : b i = k ∨ _ := (le_max' _ (b i) <| mem_image_of_mem _ <| mem_univ _).eq_or_lt
  · have : M⁻¹.toBlock (fun i => k ≤ b i) (fun i => b i < k) ⟨i, hbi.ge⟩ ⟨j, hbi ▸ hij⟩ = 0 := by
      simp only [to_block_inverse_eq_zero hM k, Pi.zero_apply]
    simp [this.symm]
  haveI : Invertible A := hM.invertible_to_block _
  have hA : A.block_triangular b' := hM.submatrix
  have hb' : image b' univ ⊂ image b univ :=
    by
    convert image_subtype_univ_ssubset_image_univ k b _ (fun a => a < k) (lt_irrefl _)
    convert max'_mem _ _
  have hij' : b' ⟨j, hij.trans hi⟩ < b' ⟨i, hi⟩ := by simp_rw [b', Subtype.coe_mk, hij]
  simp [hM.inv_to_block k, (ih (image b' univ) hb' hA rfl hij').symm]
#align matrix.block_triangular_inv_of_block_triangular Matrix.blockTriangular_inv_of_blockTriangular

end Matrix

