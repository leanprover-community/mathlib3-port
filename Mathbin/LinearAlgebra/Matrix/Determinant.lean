/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Chris Hughes, Tim Baanen

! This file was ported from Lean 3 source module linear_algebra.matrix.determinant
! leanprover-community/mathlib commit 86d1873c01a723aba6788f0b9051ae3d23b4c1c3
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Data.Matrix.Pequiv
import Mathbin.Data.Matrix.Block
import Mathbin.Data.Matrix.Notation
import Mathbin.Data.Fintype.BigOperators
import Mathbin.GroupTheory.Perm.Fin
import Mathbin.GroupTheory.Perm.Sign
import Mathbin.Algebra.Algebra.Basic
import Mathbin.Tactic.Ring
import Mathbin.LinearAlgebra.Alternating
import Mathbin.LinearAlgebra.Pi

/-!
# Determinant of a matrix

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines the determinant of a matrix, `matrix.det`, and its essential properties.

## Main definitions

 - `matrix.det`: the determinant of a square matrix, as a sum over permutations
 - `matrix.det_row_alternating`: the determinant, as an `alternating_map` in the rows of the matrix

## Main results

 - `det_mul`: the determinant of `A ⬝ B` is the product of determinants
 - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row
 - `det_block_diagonal`: the determinant of a block diagonal matrix is a product
   of the blocks' determinants

## Implementation notes

It is possible to configure `simp` to compute determinants. See the file
`test/matrix.lean` for some examples.

-/


universe u v w z

open Equiv Equiv.Perm Finset Function

namespace Matrix

open Matrix BigOperators

variable {m n : Type _} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]

variable {R : Type v} [CommRing R]

-- mathport name: «exprε »
local notation "ε " σ:arg => ((sign σ : ℤ) : R)

#print Matrix.detRowAlternating /-
/-- `det` is an `alternating_map` in the rows of the matrix. -/
def detRowAlternating : AlternatingMap R (n → R) R n :=
  ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj).alternatization
#align matrix.det_row_alternating Matrix.detRowAlternating
-/

#print Matrix.det /-
/-- The determinant of a matrix given by the Leibniz formula. -/
abbrev det (M : Matrix n n R) : R :=
  detRowAlternating M
#align matrix.det Matrix.det
-/

/- warning: matrix.det_apply -> Matrix.det_apply is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Finset.sum.{u1, u2} R (Equiv.Perm.{succ u2} n) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Finset.univ.{u2} (Equiv.Perm.{succ u2} n) (Equiv.fintype.{u2, u2} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u2} n) => SMul.smul.{0, u1} (Units.{0} Int Int.monoid) R (Units.hasSmul.{0, u1} Int R Int.monoid (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u2} n) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (i : n) => M (coeFn.{succ u2, succ u2} (Equiv.Perm.{succ u2} n) (fun (_x : Equiv.{succ u2, succ u2} n n) => n -> n) (Equiv.hasCoeToFun.{succ u2, succ u2} n n) σ i) i))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Finset.sum.{u2, u1} R (Equiv.Perm.{succ u1} n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Finset.univ.{u1} (Equiv.Perm.{succ u1} n) (equivFintype.{u1, u1} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u1} n) => HSMul.hSMul.{0, u2, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) σ) R R (instHSMul.{0, u2} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) σ) R (Units.instSMulUnits.{0, u2} Int R Int.instMonoidInt (SubNegMonoid.SMulInt.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (fun (_x : Equiv.Perm.{succ u1} n) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} n) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (i : n) => M (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.Perm.{succ u1} n) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} n n) σ i) i))))
Case conversion may be inaccurate. Consider using '#align matrix.det_apply Matrix.det_applyₓ'. -/
theorem det_apply (M : Matrix n n R) : M.det = ∑ σ : Perm n, σ.sign • ∏ i, M (σ i) i :=
  MultilinearMap.alternatization_apply _ M
#align matrix.det_apply Matrix.det_apply

/- warning: matrix.det_apply' -> Matrix.det_apply' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Finset.sum.{u1, u2} R (Equiv.Perm.{succ u2} n) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Finset.univ.{u2} (Equiv.Perm.{succ u2} n) (Equiv.fintype.{u2, u2} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u2} n) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} Int Int.monoid) Int (HasLiftT.mk.{1, 1} (Units.{0} Int Int.monoid) Int (CoeTCₓ.coe.{1, 1} (Units.{0} Int Int.monoid) Int (coeBase.{1, 1} (Units.{0} Int Int.monoid) Int (Units.hasCoe.{0} Int Int.monoid)))) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u2} n) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (i : n) => M (coeFn.{succ u2, succ u2} (Equiv.Perm.{succ u2} n) (fun (_x : Equiv.{succ u2, succ u2} n n) => n -> n) (Equiv.hasCoeToFun.{succ u2, succ u2} n n) σ i) i))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Finset.sum.{u2, u1} R (Equiv.Perm.{succ u1} n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Finset.univ.{u1} (Equiv.Perm.{succ u1} n) (equivFintype.{u1, u1} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u1} n) => HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Units.val.{0} Int Int.instMonoidInt (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (fun (_x : Equiv.Perm.{succ u1} n) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} n) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (i : n) => M (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.Perm.{succ u1} n) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} n n) σ i) i))))
Case conversion may be inaccurate. Consider using '#align matrix.det_apply' Matrix.det_apply'ₓ'. -/
-- This is what the old definition was. We use it to avoid having to change the old proofs below
theorem det_apply' (M : Matrix n n R) : M.det = ∑ σ : Perm n, ε σ * ∏ i, M (σ i) i := by
  simp [det_apply, Units.smul_def]
#align matrix.det_apply' Matrix.det_apply'

/- warning: matrix.det_diagonal -> Matrix.det_diagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {d : n -> R}, Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.diagonal.{u1, u2} n R (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) d)) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (i : n) => d i))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {d : n -> R}, Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.diagonal.{u2, u1} n R (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))) d)) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (i : n) => d i))
Case conversion may be inaccurate. Consider using '#align matrix.det_diagonal Matrix.det_diagonalₓ'. -/
@[simp]
theorem det_diagonal {d : n → R} : det (diagonal d) = ∏ i, d i :=
  by
  rw [det_apply']
  refine' (Finset.sum_eq_single 1 _ _).trans _
  · intro σ h1 h2
    cases' not_forall.1 (mt Equiv.ext h2) with x h3
    convert MulZeroClass.mul_zero _
    apply Finset.prod_eq_zero
    · change x ∈ _
      simp
    exact if_neg h3
  · simp
  · simp
#align matrix.det_diagonal Matrix.det_diagonal

/- warning: matrix.det_zero -> Matrix.det_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R], (Nonempty.{succ u2} n) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 0 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 0 (Zero.zero.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasZero.{u1, u2, u2} n n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R], (Nonempty.{succ u1} n) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 0 (Zero.toOfNat0.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.zero.{u2, u1, u1} n n R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_zero Matrix.det_zeroₓ'. -/
@[simp]
theorem det_zero (h : Nonempty n) : det (0 : Matrix n n R) = 0 :=
  (detRowAlternating : AlternatingMap R (n → R) R n).map_zero
#align matrix.det_zero Matrix.det_zero

/- warning: matrix.det_one -> Matrix.det_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R], Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (OfNat.ofNat.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (OfNat.mk.{max u2 u1} (Matrix.{u2, u2, u1} n n R) 1 (One.one.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasOne.{u1, u2} n R (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R], Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (OfNat.ofNat.{max u2 u1} (Matrix.{u1, u1, u2} n n R) 1 (One.toOfNat1.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.one.{u2, u1} n R (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))
Case conversion may be inaccurate. Consider using '#align matrix.det_one Matrix.det_oneₓ'. -/
@[simp]
theorem det_one : det (1 : Matrix n n R) = 1 := by rw [← diagonal_one] <;> simp [-diagonal_one]
#align matrix.det_one Matrix.det_one

/- warning: matrix.det_is_empty -> Matrix.det_isEmpty is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] [_inst_6 : IsEmpty.{succ u2} n] {A : Matrix.{u2, u2, u1} n n R}, Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] [_inst_6 : IsEmpty.{succ u1} n] {A : Matrix.{u1, u1, u2} n n R}, Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))
Case conversion may be inaccurate. Consider using '#align matrix.det_is_empty Matrix.det_isEmptyₓ'. -/
theorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]
#align matrix.det_is_empty Matrix.det_isEmpty

/- warning: matrix.coe_det_is_empty -> Matrix.coe_det_isEmpty is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] [_inst_6 : IsEmpty.{succ u2} n], Eq.{max (succ (max u2 u1)) (succ u1)} ((Matrix.{u2, u2, u1} n n R) -> R) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5) (Function.const.{succ u1, succ (max u2 u1)} R (Matrix.{u2, u2, u1} n n R) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] [_inst_6 : IsEmpty.{succ u1} n], Eq.{max (succ u2) (succ u1)} ((Matrix.{u1, u1, u2} n n R) -> R) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5) (Function.const.{succ u2, max (succ u2) (succ u1)} R (Matrix.{u1, u1, u2} n n R) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.coe_det_is_empty Matrix.coe_det_isEmptyₓ'. -/
@[simp]
theorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R → R) = Function.const _ 1 :=
  by
  ext
  exact det_is_empty
#align matrix.coe_det_is_empty Matrix.coe_det_isEmpty

/- warning: matrix.det_eq_one_of_card_eq_zero -> Matrix.det_eq_one_of_card_eq_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R}, (Eq.{1} Nat (Fintype.card.{u2} n _inst_2) (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R}, (Eq.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_one_of_card_eq_zero Matrix.det_eq_one_of_card_eq_zeroₓ'. -/
theorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=
  haveI : IsEmpty n := fintype.card_eq_zero_iff.mp h
  det_is_empty
#align matrix.det_eq_one_of_card_eq_zero Matrix.det_eq_one_of_card_eq_zero

/- warning: matrix.det_unique -> Matrix.det_unique is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Type.{u2}} [_inst_6 : Unique.{succ u2} n] [_inst_7 : DecidableEq.{succ u2} n] [_inst_8 : Fintype.{u2} n] (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_7 a b) _inst_8 R _inst_5 A) (A (Inhabited.default.{succ u2} n (Unique.inhabited.{succ u2} n _inst_6)) (Inhabited.default.{succ u2} n (Unique.inhabited.{succ u2} n _inst_6)))
but is expected to have type
  forall {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {n : Type.{u1}} [_inst_6 : Unique.{succ u1} n] [_inst_7 : DecidableEq.{succ u1} n] [_inst_8 : Fintype.{u1} n] (A : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_7 a b) _inst_8 R _inst_5 A) (A (Inhabited.default.{succ u1} n (Unique.instInhabited.{succ u1} n _inst_6)) (Inhabited.default.{succ u1} n (Unique.instInhabited.{succ u1} n _inst_6)))
Case conversion may be inaccurate. Consider using '#align matrix.det_unique Matrix.det_uniqueₓ'. -/
/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.
Although `unique` implies `decidable_eq` and `fintype`, the instances might
not be syntactically equal. Thus, we need to fill in the args explicitly. -/
@[simp]
theorem det_unique {n : Type _} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :
    det A = A default default := by simp [det_apply, univ_unique]
#align matrix.det_unique Matrix.det_unique

/- warning: matrix.det_eq_elem_of_subsingleton -> Matrix.det_eq_elem_of_subsingleton is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] [_inst_6 : Subsingleton.{succ u2} n] (A : Matrix.{u2, u2, u1} n n R) (k : n), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (A k k)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] [_inst_6 : Subsingleton.{succ u1} n] (A : Matrix.{u1, u1, u2} n n R) (k : n), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (A k k)
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_elem_of_subsingleton Matrix.det_eq_elem_of_subsingletonₓ'. -/
theorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) : det A = A k k :=
  by
  convert det_unique _
  exact uniqueOfSubsingleton k
#align matrix.det_eq_elem_of_subsingleton Matrix.det_eq_elem_of_subsingleton

/- warning: matrix.det_eq_elem_of_card_eq_one -> Matrix.det_eq_elem_of_card_eq_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R}, (Eq.{1} Nat (Fintype.card.{u2} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) -> (forall (k : n), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (A k k))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R}, (Eq.{1} Nat (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) -> (forall (k : n), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (A k k))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_elem_of_card_eq_one Matrix.det_eq_elem_of_card_eq_oneₓ'. -/
theorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :
    det A = A k k :=
  haveI : Subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
  det_eq_elem_of_subsingleton _ _
#align matrix.det_eq_elem_of_card_eq_one Matrix.det_eq_elem_of_card_eq_one

/- warning: matrix.det_mul_aux -> Matrix.det_mul_aux is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {M : Matrix.{u2, u2, u1} n n R} {N : Matrix.{u2, u2, u1} n n R} {p : n -> n}, (Not (Function.Bijective.{succ u2, succ u2} n n p)) -> (Eq.{succ u1} R (Finset.sum.{u1, u2} R (Equiv.Perm.{succ u2} n) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Finset.univ.{u2} (Equiv.Perm.{succ u2} n) (Equiv.fintype.{u2, u2} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u2} n) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) Int R (HasLiftT.mk.{1, succ u1} Int R (CoeTCₓ.coe.{1, succ u1} Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) ((fun (a : Type) (b : Type) [self : HasLiftT.{1, 1} a b] => self.0) (Units.{0} Int Int.monoid) Int (HasLiftT.mk.{1, 1} (Units.{0} Int Int.monoid) Int (CoeTCₓ.coe.{1, 1} (Units.{0} Int Int.monoid) Int (coeBase.{1, 1} (Units.{0} Int Int.monoid) Int (Units.hasCoe.{0} Int Int.monoid)))) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u2} n) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (x : n) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (M (coeFn.{succ u2, succ u2} (Equiv.Perm.{succ u2} n) (fun (_x : Equiv.{succ u2, succ u2} n n) => n -> n) (Equiv.hasCoeToFun.{succ u2, succ u2} n n) σ x) (p x)) (N (p x) x))))) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {M : Matrix.{u1, u1, u2} n n R} {N : Matrix.{u1, u1, u2} n n R} {p : n -> n}, (Not (Function.Bijective.{succ u1, succ u1} n n p)) -> (Eq.{succ u2} R (Finset.sum.{u2, u1} R (Equiv.Perm.{succ u1} n) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Finset.univ.{u1} (Equiv.Perm.{succ u1} n) (equivFintype.{u1, u1} n n (fun (a : n) (b : n) => _inst_1 a b) (fun (a : n) (b : n) => _inst_1 a b) _inst_2 _inst_2)) (fun (σ : Equiv.Perm.{succ u1} n) => HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Units.val.{0} Int Int.instMonoidInt (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (fun (_x : Equiv.Perm.{succ u1} n) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) _x) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} n) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (x : n) => HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (M (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.Perm.{succ u1} n) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} n n) σ x) (p x)) (N (p x) x))))) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_aux Matrix.det_mul_auxₓ'. -/
theorem det_mul_aux {M N : Matrix n n R} {p : n → n} (H : ¬Bijective p) :
    (∑ σ : Perm n, ε σ * ∏ x, M (σ x) (p x) * N (p x) x) = 0 :=
  by
  obtain ⟨i, j, hpij, hij⟩ : ∃ i j, p i = p j ∧ i ≠ j :=
    by
    rw [← Finite.injective_iff_bijective, injective] at H
    push_neg  at H
    exact H
  exact
    sum_involution (fun σ _ => σ * swap i j)
      (fun σ _ =>
        by
        have : (∏ x, M (σ x) (p x)) = ∏ x, M ((σ * swap i j) x) (p x) :=
          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])
        simp [this, sign_swap hij, prod_mul_distrib])
      (fun σ _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun σ _ =>
      mul_swap_involutive i j σ
#align matrix.det_mul_aux Matrix.det_mul_aux

/- warning: matrix.det_mul -> Matrix.det_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (N : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_2 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M N)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 N))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (N : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_2 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M N)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 N))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul Matrix.det_mulₓ'. -/
@[simp]
theorem det_mul (M N : Matrix n n R) : det (M ⬝ N) = det M * det N :=
  calc
    det (M ⬝ N) = ∑ p : n → n, ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (p i) * N (p i) i := by
      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ] <;>
        rw [Finset.sum_comm]
    _ =
        ∑ p in (@univ (n → n) _).filterₓ Bijective,
          ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (p i) * N (p i) i :=
      (Eq.symm <|
        sum_subset (filter_subset _ _) fun f _ hbij =>
          det_mul_aux <| by simpa only [true_and_iff, mem_filter, mem_univ] using hbij)
    _ = ∑ τ : Perm n, ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (τ i) * N (τ i) i :=
      (sum_bij (fun p h => Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ => mem_univ _)
        (fun _ _ => rfl) (fun _ _ _ _ h => by injection h) fun b _ =>
        ⟨b, mem_filter.2 ⟨mem_univ _, b.Bijective⟩, coe_fn_injective rfl⟩)
    _ = ∑ σ : Perm n, ∑ τ : Perm n, (∏ i, N (σ i) i) * ε τ * ∏ j, M (τ j) (σ j) := by
      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]
    _ = ∑ σ : Perm n, ∑ τ : Perm n, (∏ i, N (σ i) i) * (ε σ * ε τ) * ∏ i, M (τ i) i :=
      (sum_congr rfl fun σ _ =>
        Fintype.sum_equiv (Equiv.mulRight σ⁻¹) _ _ fun τ =>
          by
          have : (∏ j, M (τ j) (σ j)) = ∏ j, M ((τ * σ⁻¹) j) j :=
            by
            rw [← (σ⁻¹ : _ ≃ _).prod_comp]
            simp only [Equiv.Perm.coe_mul, apply_inv_self]
          have h : ε σ * ε (τ * σ⁻¹) = ε τ :=
            calc
              ε σ * ε (τ * σ⁻¹) = ε (τ * σ⁻¹ * σ) :=
                by
                rw [mul_comm, sign_mul (τ * σ⁻¹)]
                simp only [Int.cast_mul, Units.val_mul]
              _ = ε τ := by simp only [inv_mul_cancel_right]
              
          simp_rw [Equiv.coe_mulRight, h]
          simp only [this])
    _ = det M * det N := by simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm]
    
#align matrix.det_mul Matrix.det_mul

#print Matrix.detMonoidHom /-
/-- The determinant of a matrix, as a monoid homomorphism. -/
def detMonoidHom : Matrix n n R →* R where
  toFun := det
  map_one' := det_one
  map_mul' := det_mul
#align matrix.det_monoid_hom Matrix.detMonoidHom
-/

/- warning: matrix.coe_det_monoid_hom -> Matrix.coe_detMonoidHom is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R], Eq.{max (succ (max u2 u1)) (succ u1)} ((fun (_x : MonoidHom.{max u2 u1, u1} (Matrix.{u2, u2, u1} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.nonAssocSemiring.{u1, u2} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) => (Matrix.{u2, u2, u1} n n R) -> R) (Matrix.detMonoidHom.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5)) (coeFn.{max (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (MonoidHom.{max u2 u1, u1} (Matrix.{u2, u2, u1} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.nonAssocSemiring.{u1, u2} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (fun (_x : MonoidHom.{max u2 u1, u1} (Matrix.{u2, u2, u1} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.nonAssocSemiring.{u1, u2} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) => (Matrix.{u2, u2, u1} n n R) -> R) (MonoidHom.hasCoeToFun.{max u2 u1, u1} (Matrix.{u2, u2, u1} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.nonAssocSemiring.{u1, u2} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u1} R (NonAssocSemiring.toMulZeroOneClass.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (Matrix.detMonoidHom.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R], Eq.{max (succ u2) (succ u1)} (forall (a : Matrix.{u1, u1, u2} n n R), (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u1, u1, u2} n n R) => R) a) (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), succ u2} (MonoidHom.{max u2 u1, u2} (Matrix.{u1, u1, u2} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.{u1, u1, u2} n n R) (fun (_x : Matrix.{u1, u1, u2} n n R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u1, u1, u2} n n R) => R) _x) (MulHomClass.toFunLike.{max u1 u2, max u1 u2, u2} (MonoidHom.{max u2 u1, u2} (Matrix.{u1, u1, u2} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.{u1, u1, u2} n n R) R (MulOneClass.toMul.{max u1 u2} (Matrix.{u1, u1, u2} n n R) (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (MulOneClass.toMul.{u2} R (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (MonoidHomClass.toMulHomClass.{max u1 u2, max u1 u2, u2} (MonoidHom.{max u2 u1, u2} (Matrix.{u1, u1, u2} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.{u1, u1, u2} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (MonoidHom.monoidHomClass.{max u1 u2, u2} (Matrix.{u1, u1, u2} n n R) R (MulZeroOneClass.toMulOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toMulZeroOneClass.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (MulZeroOneClass.toMulOneClass.{u2} R (NonAssocSemiring.toMulZeroOneClass.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))))) (Matrix.detMonoidHom.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5)
Case conversion may be inaccurate. Consider using '#align matrix.coe_det_monoid_hom Matrix.coe_detMonoidHomₓ'. -/
@[simp]
theorem coe_detMonoidHom : (detMonoidHom : Matrix n n R → R) = det :=
  rfl
#align matrix.coe_det_monoid_hom Matrix.coe_detMonoidHom

/- warning: matrix.det_mul_comm -> Matrix.det_mul_comm is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} m m R) (N : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M N)) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) N M))
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} m m R) (N : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M N)) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) N M))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_comm Matrix.det_mul_commₓ'. -/
/-- On square matrices, `mul_comm` applies under `det`. -/
theorem det_mul_comm (M N : Matrix m m R) : det (M ⬝ N) = det (N ⬝ M) := by
  rw [det_mul, det_mul, mul_comm]
#align matrix.det_mul_comm Matrix.det_mul_comm

/- warning: matrix.det_mul_left_comm -> Matrix.det_mul_left_comm is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} m m R) (N : Matrix.{u2, u2, u1} m m R) (P : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) N P))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) N (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M P)))
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} m m R) (N : Matrix.{u1, u1, u2} m m R) (P : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) N P))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) N (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M P)))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_left_comm Matrix.det_mul_left_commₓ'. -/
/-- On square matrices, `mul_left_comm` applies under `det`. -/
theorem det_mul_left_comm (M N P : Matrix m m R) : det (M ⬝ (N ⬝ P)) = det (N ⬝ (M ⬝ P)) := by
  rw [← Matrix.mul_assoc, ← Matrix.mul_assoc, det_mul, det_mul_comm M N, ← det_mul]
#align matrix.det_mul_left_comm Matrix.det_mul_left_comm

/- warning: matrix.det_mul_right_comm -> Matrix.det_mul_right_comm is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} m m R) (N : Matrix.{u2, u2, u1} m m R) (P : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M N) P)) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) M P) N))
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} m m R) (N : Matrix.{u1, u1, u2} m m R) (P : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M N) P)) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) M P) N))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_right_comm Matrix.det_mul_right_commₓ'. -/
/-- On square matrices, `mul_right_comm` applies under `det`. -/
theorem det_mul_right_comm (M N P : Matrix m m R) : det (M ⬝ N ⬝ P) = det (M ⬝ P ⬝ N) := by
  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, ← det_mul]
#align matrix.det_mul_right_comm Matrix.det_mul_right_comm

/- warning: matrix.det_units_conj -> Matrix.det_units_conj is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (N : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) ((fun (a : Type.{max u2 u1}) (b : Type.{max u2 u1}) [self : HasLiftT.{succ (max u2 u1), succ (max u2 u1)} a b] => self.0) (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (HasLiftT.mk.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (CoeTCₓ.coe.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (coeBase.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (Units.hasCoe.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5))))))) M) N) ((fun (a : Type.{max u2 u1}) (b : Type.{max u2 u1}) [self : HasLiftT.{succ (max u2 u1), succ (max u2 u1)} a b] => self.0) (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (HasLiftT.mk.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (CoeTCₓ.coe.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (coeBase.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (Units.hasCoe.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5))))))) (Inv.inv.{max u2 u1} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Units.hasInv.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) M)))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 N)
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Units.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) (N : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Units.val.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b)))) M) N) (Units.val.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b)))) (Inv.inv.{max u2 u1} (Units.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) (Units.instInv.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) M)))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 N)
Case conversion may be inaccurate. Consider using '#align matrix.det_units_conj Matrix.det_units_conjₓ'. -/
theorem det_units_conj (M : (Matrix m m R)ˣ) (N : Matrix m m R) :
    det (↑M ⬝ N ⬝ ↑M⁻¹ : Matrix m m R) = det N := by
  rw [det_mul_right_comm, ← mul_eq_mul, ← mul_eq_mul, Units.mul_inv, one_mul]
#align matrix.det_units_conj Matrix.det_units_conj

/- warning: matrix.det_units_conj' -> Matrix.det_units_conj' is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (N : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Matrix.mul.{u1, u2, u2, u2} m m m R _inst_4 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) ((fun (a : Type.{max u2 u1}) (b : Type.{max u2 u1}) [self : HasLiftT.{succ (max u2 u1), succ (max u2 u1)} a b] => self.0) (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (HasLiftT.mk.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (CoeTCₓ.coe.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (coeBase.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (Units.hasCoe.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5))))))) (Inv.inv.{max u2 u1} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Units.hasInv.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) M)) N) ((fun (a : Type.{max u2 u1}) (b : Type.{max u2 u1}) [self : HasLiftT.{succ (max u2 u1), succ (max u2 u1)} a b] => self.0) (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (HasLiftT.mk.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (CoeTCₓ.coe.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (coeBase.{succ (max u2 u1), succ (max u2 u1)} (Units.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5)))) (Matrix.{u2, u2, u1} m m R) (Units.hasCoe.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5))))))) M))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 N)
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Units.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) (N : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Matrix.mul.{u2, u1, u1, u1} m m m R _inst_4 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Units.val.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b)))) (Inv.inv.{max u2 u1} (Units.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) (Units.instInv.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b))))) M)) N) (Units.val.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b)))) M))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 N)
Case conversion may be inaccurate. Consider using '#align matrix.det_units_conj' Matrix.det_units_conj'ₓ'. -/
theorem det_units_conj' (M : (Matrix m m R)ˣ) (N : Matrix m m R) :
    det (↑M⁻¹ ⬝ N ⬝ ↑M : Matrix m m R) = det N :=
  det_units_conj M⁻¹ N
#align matrix.det_units_conj' Matrix.det_units_conj'

/- warning: matrix.det_transpose -> Matrix.det_transpose is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.transpose.{u1, u2, u2} n n R M)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.transpose.{u2, u1, u1} n n R M)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)
Case conversion may be inaccurate. Consider using '#align matrix.det_transpose Matrix.det_transposeₓ'. -/
/-- Transposing a matrix preserves the determinant. -/
@[simp]
theorem det_transpose (M : Matrix n n R) : Mᵀ.det = M.det :=
  by
  rw [det_apply', det_apply']
  refine' Fintype.sum_bijective _ inv_involutive.bijective _ _ _
  intro σ
  rw [sign_inv]
  congr 1
  apply Fintype.prod_equiv σ
  intros
  simp
#align matrix.det_transpose Matrix.det_transpose

/- warning: matrix.det_permute -> Matrix.det_permute is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (σ : Equiv.Perm.{succ u2} n) (M : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (fun (i : n) => M (coeFn.{succ u2, succ u2} (Equiv.Perm.{succ u2} n) (fun (_x : Equiv.{succ u2, succ u2} n n) => n -> n) (Equiv.hasCoeToFun.{succ u2, succ u2} n n) σ i))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) (Units.{0} Int Int.monoid) R (HasLiftT.mk.{1, succ u1} (Units.{0} Int Int.monoid) R (CoeTCₓ.coe.{1, succ u1} (Units.{0} Int Int.monoid) R (coeTrans.{1, 1, succ u1} (Units.{0} Int Int.monoid) Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Units.hasCoe.{0} Int Int.monoid)))) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u2} n) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (σ : Equiv.Perm.{succ u1} n) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (fun (i : n) => M (FunLike.coe.{succ u1, succ u1, succ u1} (Equiv.Perm.{succ u1} n) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => n) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u1} n n) σ i))) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Units.val.{0} Int Int.instMonoidInt (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (fun (a : Equiv.Perm.{succ u1} n) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) a) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} n) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M))
Case conversion may be inaccurate. Consider using '#align matrix.det_permute Matrix.det_permuteₓ'. -/
/-- Permuting the columns changes the sign of the determinant. -/
theorem det_permute (σ : Perm n) (M : Matrix n n R) :
    (Matrix.det fun i => M (σ i)) = σ.sign * M.det :=
  ((detRowAlternating : AlternatingMap R (n → R) R n).map_perm M σ).trans (by simp [Units.smul_def])
#align matrix.det_permute Matrix.det_permute

/- warning: matrix.det_submatrix_equiv_self -> Matrix.det_submatrix_equiv_self is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (e : Equiv.{succ u3, succ u2} n m) (A : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.submatrix.{u1, u3, u2, u2, u3} n m m n R A (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} n m) (fun (_x : Equiv.{succ u3, succ u2} n m) => n -> m) (Equiv.hasCoeToFun.{succ u3, succ u2} n m) e) (coeFn.{max 1 (max (succ u3) (succ u2)) (succ u2) (succ u3), max (succ u3) (succ u2)} (Equiv.{succ u3, succ u2} n m) (fun (_x : Equiv.{succ u3, succ u2} n m) => n -> m) (Equiv.hasCoeToFun.{succ u3, succ u2} n m) e))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A)
but is expected to have type
  forall {m : Type.{u1}} {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] (e : Equiv.{succ u2, succ u1} n m) (A : Matrix.{u1, u1, u3} m m R), Eq.{succ u3} R (Matrix.det.{u3, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.submatrix.{u3, u2, u1, u1, u2} n m m n R A (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e) (FunLike.coe.{max (succ u1) (succ u2), succ u2, succ u1} (Equiv.{succ u2, succ u1} n m) n (fun (_x : n) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n) => m) _x) (Equiv.instFunLikeEquiv.{succ u2, succ u1} n m) e))) (Matrix.det.{u3, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A)
Case conversion may be inaccurate. Consider using '#align matrix.det_submatrix_equiv_self Matrix.det_submatrix_equiv_selfₓ'. -/
/-- Permuting rows and columns with the same equivalence has no effect. -/
@[simp]
theorem det_submatrix_equiv_self (e : n ≃ m) (A : Matrix m m R) : det (A.submatrix e e) = det A :=
  by
  rw [det_apply', det_apply']
  apply Fintype.sum_equiv (Equiv.permCongr e)
  intro σ
  rw [Equiv.Perm.sign_permCongr e σ]
  congr 1
  apply Fintype.prod_equiv e
  intro i
  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]
#align matrix.det_submatrix_equiv_self Matrix.det_submatrix_equiv_self

/- warning: matrix.det_reindex_self -> Matrix.det_reindex_self is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (e : Equiv.{succ u2, succ u3} m n) (A : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (coeFn.{max 1 (max (succ (max u2 u1)) (succ (max u3 u1))) (succ (max u3 u1)) (succ (max u2 u1)), max (succ (max u2 u1)) (succ (max u3 u1))} (Equiv.{succ (max u2 u1), succ (max u3 u1)} (Matrix.{u2, u2, u1} m m R) (Matrix.{u3, u3, u1} n n R)) (fun (_x : Equiv.{succ (max u2 u1), succ (max u3 u1)} (Matrix.{u2, u2, u1} m m R) (Matrix.{u3, u3, u1} n n R)) => (Matrix.{u2, u2, u1} m m R) -> (Matrix.{u3, u3, u1} n n R)) (Equiv.hasCoeToFun.{succ (max u2 u1), succ (max u3 u1)} (Matrix.{u2, u2, u1} m m R) (Matrix.{u3, u3, u1} n n R)) (Matrix.reindex.{u1, u3, u2, u2, u3} n m m n R e e) A)) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A)
but is expected to have type
  forall {m : Type.{u2}} {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] (e : Equiv.{succ u2, succ u1} m n) (A : Matrix.{u2, u2, u3} m m R), Eq.{succ u3} R (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (FunLike.coe.{max (max (succ u2) (succ u1)) (succ u3), max (succ u2) (succ u3), max (succ u1) (succ u3)} (Equiv.{max (succ u3) (succ u2), max (succ u3) (succ u1)} (Matrix.{u2, u2, u3} m m R) (Matrix.{u1, u1, u3} n n R)) (Matrix.{u2, u2, u3} m m R) (fun (_x : Matrix.{u2, u2, u3} m m R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : Matrix.{u2, u2, u3} m m R) => Matrix.{u1, u1, u3} n n R) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u3), max (succ u1) (succ u3)} (Matrix.{u2, u2, u3} m m R) (Matrix.{u1, u1, u3} n n R)) (Matrix.reindex.{u3, u1, u2, u2, u1} n m m n R e e) A)) (Matrix.det.{u3, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A)
Case conversion may be inaccurate. Consider using '#align matrix.det_reindex_self Matrix.det_reindex_selfₓ'. -/
/-- Reindexing both indices along the same equivalence preserves the determinant.

For the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because
`matrix.reindex_apply` unfolds `reindex` first.
-/
theorem det_reindex_self (e : m ≃ n) (A : Matrix m m R) : det (reindex e e A) = det A :=
  det_submatrix_equiv_self e.symm A
#align matrix.det_reindex_self Matrix.det_reindex_self

/- warning: matrix.det_permutation -> Matrix.det_permutation is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (σ : Equiv.Perm.{succ u2} n), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (PEquiv.toMatrix.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Equiv.toPEquiv.{u2, u2} n n σ))) ((fun (a : Type) (b : Type.{u1}) [self : HasLiftT.{1, succ u1} a b] => self.0) (Units.{0} Int Int.monoid) R (HasLiftT.mk.{1, succ u1} (Units.{0} Int Int.monoid) R (CoeTCₓ.coe.{1, succ u1} (Units.{0} Int Int.monoid) R (coeTrans.{1, 1, succ u1} (Units.{0} Int Int.monoid) Int R (Int.castCoe.{u1} R (AddGroupWithOne.toHasIntCast.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (Units.hasCoe.{0} Int Int.monoid)))) (coeFn.{succ u2, succ u2} (MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (fun (_x : MonoidHom.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) => (Equiv.Perm.{succ u2} n) -> (Units.{0} Int Int.monoid)) (MonoidHom.hasCoeToFun.{u2, 0} (Equiv.Perm.{succ u2} n) (Units.{0} Int Int.monoid) (Monoid.toMulOneClass.{u2} (Equiv.Perm.{succ u2} n) (DivInvMonoid.toMonoid.{u2} (Equiv.Perm.{succ u2} n) (Group.toDivInvMonoid.{u2} (Equiv.Perm.{succ u2} n) (Equiv.Perm.permGroup.{u2} n)))) (Units.mulOneClass.{0} Int Int.monoid)) (Equiv.Perm.sign.{u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (σ : Equiv.Perm.{succ u1} n), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (PEquiv.toMatrix.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))) (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (Equiv.toPEquiv.{u1, u1} n n σ))) (Int.cast.{u2} R (Ring.toIntCast.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Units.val.{0} Int Int.instMonoidInt (FunLike.coe.{succ u1, succ u1, 1} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (fun (a : Equiv.Perm.{succ u1} n) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Equiv.Perm.{succ u1} n) => Units.{0} Int Int.instMonoidInt) a) (MulHomClass.toFunLike.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (MulOneClass.toMul.{u1} (Equiv.Perm.{succ u1} n) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n))))) (MulOneClass.toMul.{0} (Units.{0} Int Int.instMonoidInt) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (MonoidHomClass.toMulHomClass.{u1, u1, 0} (MonoidHom.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)) (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt) (MonoidHom.monoidHomClass.{u1, 0} (Equiv.Perm.{succ u1} n) (Units.{0} Int Int.instMonoidInt) (Monoid.toMulOneClass.{u1} (Equiv.Perm.{succ u1} n) (DivInvMonoid.toMonoid.{u1} (Equiv.Perm.{succ u1} n) (Group.toDivInvMonoid.{u1} (Equiv.Perm.{succ u1} n) (Equiv.Perm.permGroup.{u1} n)))) (Units.instMulOneClassUnits.{0} Int Int.instMonoidInt)))) (Equiv.Perm.sign.{u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2) σ)))
Case conversion may be inaccurate. Consider using '#align matrix.det_permutation Matrix.det_permutationₓ'. -/
/-- The determinant of a permutation matrix equals its sign. -/
@[simp]
theorem det_permutation (σ : Perm n) : Matrix.det (σ.toPEquiv.toMatrix : Matrix n n R) = σ.sign :=
  by
  rw [← Matrix.mul_one (σ.to_pequiv.to_matrix : Matrix n n R), PEquiv.toPEquiv_mul_matrix,
    det_permute, det_one, mul_one]
#align matrix.det_permutation Matrix.det_permutation

/- warning: matrix.det_smul -> Matrix.det_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R) (c : R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (SMul.smul.{u1, max u2 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.hasSmul.{u1, u2, u2, u1} n n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) c A)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_5)))) c (Fintype.card.{u2} n _inst_2)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R) (c : R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u2} n n R) (instHSMul.{u2, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.smul.{u2, u1, u1, u2} n n R R (Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) c A)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) c (Fintype.card.{u1} n _inst_2)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_smul Matrix.det_smulₓ'. -/
theorem det_smul (A : Matrix n n R) (c : R) : det (c • A) = c ^ Fintype.card n * det A :=
  calc
    det (c • A) = det (Matrix.mul (diagonal fun _ => c) A) := by rw [smul_eq_diagonal_mul]
    _ = det (diagonal fun _ => c) * det A := (det_mul _ _)
    _ = c ^ Fintype.card n * det A := by simp [card_univ]
    
#align matrix.det_smul Matrix.det_smul

/- warning: matrix.det_smul_of_tower -> Matrix.det_smul_of_tower is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {α : Type.{u3}} [_inst_6 : Monoid.{u3} α] [_inst_7 : DistribMulAction.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))] [_inst_8 : IsScalarTower.{u3, u1, u1} α R R (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (DistribSMul.toSmulZeroClass.{u3, u1} α R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (DistribMulAction.toDistribSMul.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) _inst_7))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (DistribSMul.toSmulZeroClass.{u3, u1} α R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (DistribMulAction.toDistribSMul.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) _inst_7)))] [_inst_9 : SMulCommClass.{u3, u1, u1} α R R (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (DistribSMul.toSmulZeroClass.{u3, u1} α R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (DistribMulAction.toDistribSMul.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) _inst_7))) (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))] (c : α) (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (SMul.smul.{u3, max u2 u1} α (Matrix.{u2, u2, u1} n n R) (Matrix.hasSmul.{u1, u2, u2, u3} n n α R (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (DistribSMul.toSmulZeroClass.{u3, u1} α R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (DistribMulAction.toDistribSMul.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) _inst_7)))) c A)) (SMul.smul.{u3, u1} α R (SMulZeroClass.toHasSmul.{u3, u1} α R (AddZeroClass.toHasZero.{u1} R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (DistribSMul.toSmulZeroClass.{u3, u1} α R (AddMonoid.toAddZeroClass.{u1} R (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (DistribMulAction.toDistribSMul.{u3, u1} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))) _inst_7))) (HPow.hPow.{u3, 0, u3} α Nat α (instHPow.{u3, 0} α Nat (Monoid.Pow.{u3} α _inst_6)) c (Fintype.card.{u2} n _inst_2)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] {α : Type.{u2}} [_inst_6 : Monoid.{u2} α] [_inst_7 : DistribMulAction.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))] [_inst_8 : IsScalarTower.{u2, u3, u3} α R R (SMulZeroClass.toSMul.{u2, u3} α R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (DistribSMul.toSMulZeroClass.{u2, u3} α R (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (DistribMulAction.toDistribSMul.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5)))) _inst_7))) (Algebra.toSMul.{u3, u3} R R (CommRing.toCommSemiring.{u3} R _inst_5) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_5)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (SMulZeroClass.toSMul.{u2, u3} α R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (DistribSMul.toSMulZeroClass.{u2, u3} α R (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (DistribMulAction.toDistribSMul.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5)))) _inst_7)))] [_inst_9 : SMulCommClass.{u2, u3, u3} α R R (SMulZeroClass.toSMul.{u2, u3} α R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (DistribSMul.toSMulZeroClass.{u2, u3} α R (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (DistribMulAction.toDistribSMul.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5)))) _inst_7))) (Algebra.toSMul.{u3, u3} R R (CommRing.toCommSemiring.{u3} R _inst_5) (Ring.toSemiring.{u3} R (CommRing.toRing.{u3} R _inst_5)) (Algebra.id.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5)))] (c : α) (A : Matrix.{u1, u1, u3} n n R), Eq.{succ u3} R (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (HSMul.hSMul.{u2, max u3 u1, max u3 u1} α (Matrix.{u1, u1, u3} n n R) (Matrix.{u1, u1, u3} n n R) (instHSMul.{u2, max u3 u1} α (Matrix.{u1, u1, u3} n n R) (Matrix.smul.{u3, u1, u1, u2} n n α R (SMulZeroClass.toSMul.{u2, u3} α R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (DistribSMul.toSMulZeroClass.{u2, u3} α R (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (DistribMulAction.toDistribSMul.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5)))) _inst_7))))) c A)) (HSMul.hSMul.{u2, u3, u3} α R R (instHSMul.{u2, u3} α R (SMulZeroClass.toSMul.{u2, u3} α R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) (DistribSMul.toSMulZeroClass.{u2, u3} α R (AddMonoid.toAddZeroClass.{u3} R (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (DistribMulAction.toDistribSMul.{u2, u3} α R _inst_6 (AddMonoidWithOne.toAddMonoid.{u3} R (AddGroupWithOne.toAddMonoidWithOne.{u3} R (Ring.toAddGroupWithOne.{u3} R (CommRing.toRing.{u3} R _inst_5)))) _inst_7)))) (HPow.hPow.{u2, 0, u2} α Nat α (instHPow.{u2, 0} α Nat (Monoid.Pow.{u2} α _inst_6)) c (Fintype.card.{u1} n _inst_2)) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_smul_of_tower Matrix.det_smul_of_towerₓ'. -/
@[simp]
theorem det_smul_of_tower {α} [Monoid α] [DistribMulAction α R] [IsScalarTower α R R]
    [SMulCommClass α R R] (c : α) (A : Matrix n n R) : det (c • A) = c ^ Fintype.card n • det A :=
  by rw [← smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]
#align matrix.det_smul_of_tower Matrix.det_smul_of_tower

/- warning: matrix.det_neg -> Matrix.det_neg is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasNeg.{u1, u2, u2} n n R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) A)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Neg.neg.{u1} R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))) (Fintype.card.{u2} n _inst_2)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Neg.neg.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.neg.{u2, u1, u1} n n R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_5))) A)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Neg.neg.{u2} R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_5)) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Fintype.card.{u1} n _inst_2)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_neg Matrix.det_negₓ'. -/
theorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by
  rw [← det_smul, neg_one_smul]
#align matrix.det_neg Matrix.det_neg

/- warning: matrix.det_neg_eq_smul -> Matrix.det_neg_eq_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Neg.neg.{max u2 u1} (Matrix.{u2, u2, u1} n n R) (Matrix.hasNeg.{u1, u2, u2} n n R (SubNegMonoid.toHasNeg.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) A)) (SMul.smul.{0, u1} (Units.{0} Int Int.monoid) R (Units.hasSmul.{0, u1} Int R Int.monoid (SubNegMonoid.SMulInt.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (HPow.hPow.{0, 0, 0} (Units.{0} Int Int.monoid) Nat (Units.{0} Int Int.monoid) (instHPow.{0, 0} (Units.{0} Int Int.monoid) Nat (Monoid.Pow.{0} (Units.{0} Int Int.monoid) (DivInvMonoid.toMonoid.{0} (Units.{0} Int Int.monoid) (Group.toDivInvMonoid.{0} (Units.{0} Int Int.monoid) (Units.group.{0} Int Int.monoid))))) (Neg.neg.{0} (Units.{0} Int Int.monoid) (Units.hasNeg.{0} Int Int.monoid (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.ring)))) (OfNat.ofNat.{0} (Units.{0} Int Int.monoid) 1 (OfNat.mk.{0} (Units.{0} Int Int.monoid) 1 (One.one.{0} (Units.{0} Int Int.monoid) (MulOneClass.toHasOne.{0} (Units.{0} Int Int.monoid) (Units.mulOneClass.{0} Int Int.monoid)))))) (Fintype.card.{u2} n _inst_2)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Neg.neg.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.neg.{u2, u1, u1} n n R (Ring.toNeg.{u2} R (CommRing.toRing.{u2} R _inst_5))) A)) (HSMul.hSMul.{0, u2, u2} (Units.{0} Int Int.instMonoidInt) R R (instHSMul.{0, u2} (Units.{0} Int Int.instMonoidInt) R (Units.instSMulUnits.{0, u2} Int R Int.instMonoidInt (SubNegMonoid.SMulInt.{u2} R (AddGroup.toSubNegMonoid.{u2} R (AddGroupWithOne.toAddGroup.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (HPow.hPow.{0, 0, 0} (Units.{0} Int Int.instMonoidInt) Nat (Units.{0} Int Int.instMonoidInt) (instHPow.{0, 0} (Units.{0} Int Int.instMonoidInt) Nat (Monoid.Pow.{0} (Units.{0} Int Int.instMonoidInt) (DivInvMonoid.toMonoid.{0} (Units.{0} Int Int.instMonoidInt) (Group.toDivInvMonoid.{0} (Units.{0} Int Int.instMonoidInt) (Units.instGroupUnits.{0} Int Int.instMonoidInt))))) (Neg.neg.{0} (Units.{0} Int Int.instMonoidInt) (Units.instNegUnits.{0} Int Int.instMonoidInt (NonUnitalNonAssocRing.toHasDistribNeg.{0} Int (NonAssocRing.toNonUnitalNonAssocRing.{0} Int (Ring.toNonAssocRing.{0} Int Int.instRingInt)))) (OfNat.ofNat.{0} (Units.{0} Int Int.instMonoidInt) 1 (One.toOfNat1.{0} (Units.{0} Int Int.instMonoidInt) (InvOneClass.toOne.{0} (Units.{0} Int Int.instMonoidInt) (DivInvOneMonoid.toInvOneClass.{0} (Units.{0} Int Int.instMonoidInt) (DivisionMonoid.toDivInvOneMonoid.{0} (Units.{0} Int Int.instMonoidInt) (DivisionCommMonoid.toDivisionMonoid.{0} (Units.{0} Int Int.instMonoidInt) (CommGroup.toDivisionCommMonoid.{0} (Units.{0} Int Int.instMonoidInt) (Units.instCommGroupUnitsToMonoid.{0} Int Int.instCommMonoidInt))))))))) (Fintype.card.{u1} n _inst_2)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_neg_eq_smul Matrix.det_neg_eq_smulₓ'. -/
/-- A variant of `matrix.det_neg` with scalar multiplication by `units ℤ` instead of multiplication
by `R`. -/
theorem det_neg_eq_smul (A : Matrix n n R) : det (-A) = (-1 : Units ℤ) ^ Fintype.card n • det A :=
  by rw [← det_smul_of_tower, Units.neg_smul, one_smul]
#align matrix.det_neg_eq_smul Matrix.det_neg_eq_smul

/- warning: matrix.det_mul_row -> Matrix.det_mul_row is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (v : n -> R) (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ (max u2 u1))) (succ (max u2 u1)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ (max u2 u1))} (Equiv.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) (fun (_x : Equiv.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) => (n -> n -> R) -> (Matrix.{u2, u2, u1} n n R)) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) (Matrix.of.{u1, u2, u2} n n R) (fun (i : n) (j : n) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (v j) (A i j)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (i : n) => v i)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (v : n -> R) (A : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (n -> n -> R) (Matrix.{u1, u1, u2} n n R)) (n -> n -> R) (fun (_x : n -> n -> R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n -> n -> R) => Matrix.{u1, u1, u2} n n R) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (n -> n -> R) (Matrix.{u1, u1, u2} n n R)) (Matrix.of.{u2, u1, u1} n n R) (fun (i : n) (j : n) => HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (v j) (A i j)))) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (i : n) => v i)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_row Matrix.det_mul_rowₓ'. -/
/-- Multiplying each row by a fixed `v i` multiplies the determinant by
the product of the `v`s. -/
theorem det_mul_row (v : n → R) (A : Matrix n n R) :
    det (of fun i j => v j * A i j) = (∏ i, v i) * det A :=
  calc
    det (of fun i j => v j * A i j) = det (A ⬝ diagonal v) :=
      congr_arg det <| by
        ext
        simp [mul_comm]
    _ = (∏ i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]
    
#align matrix.det_mul_row Matrix.det_mul_row

/- warning: matrix.det_mul_column -> Matrix.det_mul_column is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (v : n -> R) (A : Matrix.{u2, u2, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (coeFn.{max 1 (max (max (succ u2) (succ u1)) (succ (max u2 u1))) (succ (max u2 u1)) (succ u2) (succ u1), max (max (succ u2) (succ u1)) (succ (max u2 u1))} (Equiv.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) (fun (_x : Equiv.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) => (n -> n -> R) -> (Matrix.{u2, u2, u1} n n R)) (Equiv.hasCoeToFun.{max (succ u2) (succ u1), succ (max u2 u1)} (n -> n -> R) (Matrix.{u2, u2, u1} n n R)) (Matrix.of.{u1, u2, u2} n n R) (fun (i : n) (j : n) => HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (v i) (A i j)))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Finset.prod.{u1, u2} R n (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u2} n _inst_2) (fun (i : n) => v i)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (v : n -> R) (A : Matrix.{u1, u1, u2} n n R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (FunLike.coe.{max (succ u1) (succ u2), max (succ u1) (succ u2), max (succ u1) (succ u2)} (Equiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (n -> n -> R) (Matrix.{u1, u1, u2} n n R)) (n -> n -> R) (fun (_x : n -> n -> R) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : n -> n -> R) => Matrix.{u1, u1, u2} n n R) _x) (Equiv.instFunLikeEquiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (n -> n -> R) (Matrix.{u1, u1, u2} n n R)) (Matrix.of.{u2, u1, u1} n n R) (fun (i : n) (j : n) => HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (v i) (A i j)))) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (Finset.prod.{u2, u1} R n (CommRing.toCommMonoid.{u2} R _inst_5) (Finset.univ.{u1} n _inst_2) (fun (i : n) => v i)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_mul_column Matrix.det_mul_columnₓ'. -/
/-- Multiplying each column by a fixed `v j` multiplies the determinant by
the product of the `v`s. -/
theorem det_mul_column (v : n → R) (A : Matrix n n R) :
    det (of fun i j => v i * A i j) = (∏ i, v i) * det A :=
  MultilinearMap.map_smul_univ _ v A
#align matrix.det_mul_column Matrix.det_mul_column

/- warning: matrix.det_pow -> Matrix.det_pow is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} m m R) (n : Nat), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (HPow.hPow.{max u2 u1, 0, max u2 u1} (Matrix.{u2, u2, u1} m m R) Nat (Matrix.{u2, u2, u1} m m R) (instHPow.{max u2 u1, 0} (Matrix.{u2, u2, u1} m m R) Nat (Monoid.Pow.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Ring.toMonoid.{max u2 u1} (Matrix.{u2, u2, u1} m m R) (Matrix.ring.{u1, u2} m R _inst_4 (fun (a : m) (b : m) => _inst_3 a b) (CommRing.toRing.{u1} R _inst_5))))) M n)) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 M) n)
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} m m R) (n : Nat), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (HPow.hPow.{max u2 u1, 0, max u2 u1} (Matrix.{u1, u1, u2} m m R) Nat (Matrix.{u1, u1, u2} m m R) (instHPow.{max u2 u1, 0} (Matrix.{u1, u1, u2} m m R) Nat (Monoid.Pow.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (MonoidWithZero.toMonoid.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Semiring.toMonoidWithZero.{max u2 u1} (Matrix.{u1, u1, u2} m m R) (Matrix.semiring.{u2, u1} m R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) _inst_4 (fun (a : m) (b : m) => _inst_3 a b)))))) M n)) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 M) n)
Case conversion may be inaccurate. Consider using '#align matrix.det_pow Matrix.det_powₓ'. -/
@[simp]
theorem det_pow (M : Matrix m m R) (n : ℕ) : det (M ^ n) = det M ^ n :=
  (detMonoidHom : Matrix m m R →* R).map_pow M n
#align matrix.det_pow Matrix.det_pow

section HomMap

variable {S : Type w} [CommRing S]

/- warning: ring_hom.map_det -> RingHom.map_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {S : Type.{u2}} [_inst_6 : CommRing.{u2} S] (f : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))) (M : Matrix.{u3, u3, u1} n n R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))) (fun (_x : RingHom.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))) => R -> S) (RingHom.hasCoeToFun.{u1, u2} R S (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))) f (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (Matrix.det.{u2, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 (coeFn.{max (succ (max u3 u1)) (succ (max u3 u2)), max (succ (max u3 u1)) (succ (max u3 u2))} (RingHom.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.nonAssocSemiring.{u1, u3} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u2, u3} n S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (fun (_x : RingHom.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.nonAssocSemiring.{u1, u3} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u2, u3} n S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) => (Matrix.{u3, u3, u1} n n R) -> (Matrix.{u3, u3, u2} n n S)) (RingHom.hasCoeToFun.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.nonAssocSemiring.{u1, u3} n R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u2, u3} n S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHom.mapMatrix.{u1, u2, u3} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6))) f) M))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] (f : RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u3} ((fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) R (fun (_x : R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : R) => S) _x) (MulHomClass.toFunLike.{max u2 u3, u2, u3} (RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) R S (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalRingHomClass.toMulHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) R S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (RingHomClass.toNonUnitalRingHomClass.{max u2 u3, u2, u3} (RingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) (RingHom.instRingHomClassRingHom.{u2, u3} R S (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) f (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (RingHom.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u1, u1, u2} n n R) (fun (_x : Matrix.{u1, u1, u2} n n R) => (fun (x._@.Mathlib.Algebra.Hom.Group._hyg.2391 : Matrix.{u1, u1, u2} n n R) => Matrix.{u1, u1, u3} n n S) _x) (MulHomClass.toFunLike.{max (max u2 u3) u1, max u2 u1, max u3 u1} (RingHom.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toMul.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalNonAssocSemiring.toMul.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonUnitalRingHomClass.toMulHomClass.{max (max u2 u3) u1, max u2 u1, max u3 u1} (RingHom.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u2 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (RingHomClass.toNonUnitalRingHomClass.{max (max u2 u3) u1, max u2 u1, max u3 u1} (RingHom.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (RingHom.instRingHomClassRingHom.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.nonAssocSemiring.{u2, u1} n R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.nonAssocSemiring.{u3, u1} n S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (RingHom.mapMatrix.{u2, u3, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) f) M))
Case conversion may be inaccurate. Consider using '#align ring_hom.map_det RingHom.map_detₓ'. -/
theorem RingHom.map_det (f : R →+* S) (M : Matrix n n R) : f M.det = Matrix.det (f.mapMatrix M) :=
  by simp [Matrix.det_apply', f.map_sum, f.map_prod]
#align ring_hom.map_det RingHom.map_det

/- warning: ring_equiv.map_det -> RingEquiv.map_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {S : Type.{u2}} [_inst_6 : CommRing.{u2} S] (f : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6))) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6)))) (M : Matrix.{u3, u3, u1} n n R), Eq.{succ u2} S (coeFn.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6))) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6)))) (fun (_x : RingEquiv.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6))) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6)))) => R -> S) (RingEquiv.hasCoeToFun.{u1, u2} R S (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (Distrib.toHasMul.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6))) (Distrib.toHasAdd.{u2} S (Ring.toDistrib.{u2} S (CommRing.toRing.{u2} S _inst_6)))) f (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (Matrix.det.{u2, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 (coeFn.{max (succ (max u3 u1)) (succ (max u3 u2)), max (succ (max u3 u1)) (succ (max u3 u2))} (RingEquiv.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.hasMul.{u1, u3} n R _inst_2 (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (Matrix.hasAdd.{u1, u3, u3} n n R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (Matrix.hasMul.{u2, u3} n S _inst_2 (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (Matrix.hasAdd.{u2, u3, u3} n n S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))))) (fun (_x : RingEquiv.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.hasMul.{u1, u3} n R _inst_2 (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (Matrix.hasAdd.{u1, u3, u3} n n R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (Matrix.hasMul.{u2, u3} n S _inst_2 (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (Matrix.hasAdd.{u2, u3, u3} n n S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))))) => (Matrix.{u3, u3, u1} n n R) -> (Matrix.{u3, u3, u2} n n S)) (RingEquiv.hasCoeToFun.{max u3 u1, max u3 u2} (Matrix.{u3, u3, u1} n n R) (Matrix.{u3, u3, u2} n n S) (Matrix.hasMul.{u1, u3} n R _inst_2 (Distrib.toHasMul.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) (Matrix.hasAdd.{u1, u3, u3} n n R (Distrib.toHasAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (Matrix.hasMul.{u2, u3} n S _inst_2 (Distrib.toHasMul.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))) (Matrix.hasAdd.{u2, u3, u3} n n S (Distrib.toHasAdd.{u2} S (NonUnitalNonAssocSemiring.toDistrib.{u2} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} S (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6)))))))) (RingEquiv.mapMatrix.{u1, u2, u3} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u2} S (Ring.toNonAssocRing.{u2} S (CommRing.toRing.{u2} S _inst_6))) f) M))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] (f : RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (M : Matrix.{u1, u1, u2} n n R), Eq.{succ u3} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (FunLike.coe.{max (succ u2) (succ u3), succ u2, succ u3} (RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) R (fun (_x : R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : R) => S) _x) (EmbeddingLike.toFunLike.{max (succ u2) (succ u3), succ u2, succ u3} (RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) R S (EquivLike.toEmbeddingLike.{max (succ u2) (succ u3), succ u2, succ u3} (RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) R S (MulEquivClass.toEquivLike.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (RingEquivClass.toMulEquivClass.{max u2 u3, u2, u3} (RingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (RingEquiv.instRingEquivClassRingEquiv.{u2, u3} R S (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocRing.toMul.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonUnitalNonAssocRing.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))))))) f (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M)) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 (FunLike.coe.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (RingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))) (Matrix.{u1, u1, u2} n n R) (fun (_x : Matrix.{u1, u1, u2} n n R) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Matrix.{u1, u1, u2} n n R) => Matrix.{u1, u1, u3} n n S) _x) (EmbeddingLike.toFunLike.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (RingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (EquivLike.toEmbeddingLike.{max (max (succ u2) (succ u3)) (succ u1), max (succ u2) (succ u1), max (succ u3) (succ u1)} (RingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (MulEquivClass.toEquivLike.{max (max u2 u3) u1, max u2 u1, max u3 u1} (RingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (RingEquivClass.toMulEquivClass.{max (max u2 u3) u1, max u2 u1, max u3 u1} (RingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))) (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (RingEquiv.instRingEquivClassRingEquiv.{max u2 u1, max u3 u1} (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u3} n n S) (Matrix.instMulMatrix.{u2, u1} n R _inst_2 (NonUnitalNonAssocSemiring.toMul.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) (Matrix.instMulMatrix.{u3, u1} n S _inst_2 (NonUnitalNonAssocSemiring.toMul.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Matrix.add.{u2, u1, u1} n n R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.add.{u3, u1, u1} n n S (Distrib.toAdd.{u3} S (NonUnitalNonAssocSemiring.toDistrib.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6)))))))))))) (RingEquiv.mapMatrix.{u2, u3, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (NonAssocRing.toNonAssocSemiring.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))) (NonAssocRing.toNonAssocSemiring.{u3} S (Ring.toNonAssocRing.{u3} S (CommRing.toRing.{u3} S _inst_6))) f) M))
Case conversion may be inaccurate. Consider using '#align ring_equiv.map_det RingEquiv.map_detₓ'. -/
theorem RingEquiv.map_det (f : R ≃+* S) (M : Matrix n n R) : f M.det = Matrix.det (f.mapMatrix M) :=
  f.toRingHom.map_det _
#align ring_equiv.map_det RingEquiv.map_det

/- warning: alg_hom.map_det -> AlgHom.map_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u4}} [_inst_1 : DecidableEq.{succ u4} n] [_inst_2 : Fintype.{u4} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {S : Type.{u2}} [_inst_6 : CommRing.{u2} S] [_inst_7 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6))] {T : Type.{u3}} [_inst_8 : CommRing.{u3} T] [_inst_9 : Algebra.{u1, u3} R T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8))] (f : AlgHom.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) (M : Matrix.{u4, u4, u2} n n S), Eq.{succ u3} T (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AlgHom.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) (fun (_x : AlgHom.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) => S -> T) ([anonymous].{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) f (Matrix.det.{u2, u4} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (Matrix.det.{u3, u4} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 T _inst_8 (coeFn.{max (succ (max u4 u2)) (succ (max u4 u3)), max (succ (max u4 u2)) (succ (max u4 u3))} (AlgHom.{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) (fun (_x : AlgHom.{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) => (Matrix.{u4, u4, u2} n n S) -> (Matrix.{u4, u4, u3} n n T)) ([anonymous].{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) (AlgHom.mapMatrix.{u2, u3, u4, u1} n R S T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9 f) M))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] [_inst_7 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))] {T : Type.{u4}} [_inst_8 : CommRing.{u4} T] [_inst_9 : Algebra.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))] (f : AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) (M : Matrix.{u1, u1, u3} n n S), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => T) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => T) _x) (SMulHomClass.toFunLike.{max u3 u4, u2, u3, u4} (AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (SMulZeroClass.toSMul.{u2, u3} R S (AddMonoid.toZero.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (DistribSMul.toSMulZeroClass.{u2, u3} R S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (DistribMulAction.toDistribSMul.{u2, u3} R S (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))))) (SMulZeroClass.toSMul.{u2, u4} R T (AddMonoid.toZero.{u4} T (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))))) (DistribSMul.toSMulZeroClass.{u2, u4} R T (AddMonoid.toAddZeroClass.{u4} T (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))))) (DistribMulAction.toDistribSMul.{u2, u4} R T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))))) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u4, u2, u3, u4} (AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u3 u4, u2, u3, u4} (AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u3, u4, max u3 u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9 (AlgHom.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) (AlgHom.algHomClass.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9))))) f (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (Matrix.det.{u4, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 T _inst_8 (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u1), max (succ u4) (succ u1)} (AlgHom.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (Matrix.{u1, u1, u3} n n S) (fun (_x : Matrix.{u1, u1, u3} n n S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u1, u1, u3} n n S) => Matrix.{u1, u1, u4} n n T) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgHom.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (SMulZeroClass.toSMul.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (AddMonoid.toZero.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (AddMonoid.toAddZeroClass.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)))))) (SMulZeroClass.toSMul.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (AddMonoid.toZero.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (AddMonoid.toAddZeroClass.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgHom.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgHom.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, max u3 u1, max u4 u1, max (max u3 u4) u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9) (AlgHom.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (AlgHom.algHomClass.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)))))) (AlgHom.mapMatrix.{u3, u4, u1, u2} n R S T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9 f) M))
Case conversion may be inaccurate. Consider using '#align alg_hom.map_det AlgHom.map_detₓ'. -/
theorem AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S →ₐ[R] T)
    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=
  f.toRingHom.map_det _
#align alg_hom.map_det AlgHom.map_det

/- warning: alg_equiv.map_det -> AlgEquiv.map_det is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u4}} [_inst_1 : DecidableEq.{succ u4} n] [_inst_2 : Fintype.{u4} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {S : Type.{u2}} [_inst_6 : CommRing.{u2} S] [_inst_7 : Algebra.{u1, u2} R S (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6))] {T : Type.{u3}} [_inst_8 : CommRing.{u3} T] [_inst_9 : Algebra.{u1, u3} R T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8))] (f : AlgEquiv.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) (M : Matrix.{u4, u4, u2} n n S), Eq.{succ u3} T (coeFn.{max (succ u2) (succ u3), max (succ u2) (succ u3)} (AlgEquiv.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) (fun (_x : AlgEquiv.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) => S -> T) (AlgEquiv.hasCoeToFun.{u1, u2, u3} R S T (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9) f (Matrix.det.{u2, u4} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (Matrix.det.{u3, u4} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 T _inst_8 (coeFn.{max (succ (max u4 u2)) (succ (max u4 u3)), max (succ (max u4 u2)) (succ (max u4 u3))} (AlgEquiv.{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) (fun (_x : AlgEquiv.{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) => (Matrix.{u4, u4, u2} n n S) -> (Matrix.{u4, u4, u3} n n T)) (AlgEquiv.hasCoeToFun.{u1, max u4 u2, max u4 u3} R (Matrix.{u4, u4, u2} n n S) (Matrix.{u4, u4, u3} n n T) (CommRing.toCommSemiring.{u1} R _inst_5) (Matrix.semiring.{u2, u4} n S (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u3, u4} n T (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.algebra.{u2, u4, u1} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) _inst_7) (Matrix.algebra.{u3, u4, u1} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_9)) (AlgEquiv.mapMatrix.{u2, u3, u4, u1} n R S T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u1} R _inst_5) (Ring.toSemiring.{u2} S (CommRing.toRing.{u2} S _inst_6)) (Ring.toSemiring.{u3} T (CommRing.toRing.{u3} T _inst_8)) _inst_7 _inst_9 f) M))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {S : Type.{u3}} [_inst_6 : CommRing.{u3} S] [_inst_7 : Algebra.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))] {T : Type.{u4}} [_inst_8 : CommRing.{u4} T] [_inst_9 : Algebra.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))] (f : AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) (M : Matrix.{u1, u1, u3} n n S), Eq.{succ u4} ((fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => T) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (FunLike.coe.{max (succ u3) (succ u4), succ u3, succ u4} (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) S (fun (_x : S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : S) => T) _x) (SMulHomClass.toFunLike.{max u3 u4, u2, u3, u4} (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (SMulZeroClass.toSMul.{u2, u3} R S (AddMonoid.toZero.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (DistribSMul.toSMulZeroClass.{u2, u3} R S (AddMonoid.toAddZeroClass.{u3} S (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))))) (DistribMulAction.toDistribSMul.{u2, u3} R S (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))))) (SMulZeroClass.toSMul.{u2, u4} R T (AddMonoid.toZero.{u4} T (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))))) (DistribSMul.toSMulZeroClass.{u2, u4} R T (AddMonoid.toAddZeroClass.{u4} T (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))))) (DistribMulAction.toDistribSMul.{u2, u4} R T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))))) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))))) (DistribMulActionHomClass.toSMulHomClass.{max u3 u4, u2, u3, u4} (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{u3} S (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))))) (AddCommMonoid.toAddMonoid.{u4} T (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max u3 u4, u2, u3, u4} (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)))) (Module.toDistribMulAction.{u2, u3} R S (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u3} S (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u3} S (Semiring.toNonAssocSemiring.{u3} S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6))))) (Algebra.toModule.{u2, u3} R S (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)) (Module.toDistribMulAction.{u2, u4} R T (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u4} T (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u4} T (Semiring.toNonAssocSemiring.{u4} T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8))))) (Algebra.toModule.{u2, u4} R T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, u3, u4, max u3 u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9 (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) (AlgEquivClass.toAlgHomClass.{max u3 u4, u2, u3, u4} (AlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9) R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9 (AlgEquiv.instAlgEquivClassAlgEquiv.{u2, u3, u4} R S T (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9)))))) f (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 S _inst_6 M)) (Matrix.det.{u4, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 T _inst_8 (FunLike.coe.{max (max (succ u3) (succ u4)) (succ u1), max (succ u3) (succ u1), max (succ u4) (succ u1)} (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (Matrix.{u1, u1, u3} n n S) (fun (_x : Matrix.{u1, u1, u3} n n S) => (fun (x._@.Mathlib.Algebra.Hom.GroupAction._hyg.2186 : Matrix.{u1, u1, u3} n n S) => Matrix.{u1, u1, u4} n n T) _x) (SMulHomClass.toFunLike.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (SMulZeroClass.toSMul.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (AddMonoid.toZero.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (AddMonoid.toAddZeroClass.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7)))))) (SMulZeroClass.toSMul.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (AddMonoid.toZero.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribSMul.toSMulZeroClass.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (AddMonoid.toAddZeroClass.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))))) (DistribMulAction.toDistribSMul.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)))))) (DistribMulActionHomClass.toSMulHomClass.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (AddCommMonoid.toAddMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (AddCommMonoid.toAddMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))) (NonUnitalAlgHomClass.toDistribMulActionHomClass.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)))) (Module.toDistribMulAction.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Semiring.toNonAssocSemiring.{max u3 u1} (Matrix.{u1, u1, u3} n n S) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u3 u1} R (Matrix.{u1, u1, u3} n n S) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7))) (Module.toDistribMulAction.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommSemiring.toSemiring.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)) (NonUnitalNonAssocSemiring.toAddCommMonoid.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (NonAssocSemiring.toNonUnitalNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Semiring.toNonAssocSemiring.{max u4 u1} (Matrix.{u1, u1, u4} n n T) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b))))) (Algebra.toModule.{u2, max u4 u1} R (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))) (AlgHom.instNonUnitalAlgHomClassToMonoidToMonoidWithZeroToSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToNonUnitalNonAssocSemiringToNonAssocSemiringToDistribMulActionToAddCommMonoidToModuleToDistribMulActionToAddCommMonoidToModule.{u2, max u3 u1, max u4 u1, max (max u3 u4) u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9) (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) (AlgEquivClass.toAlgHomClass.{max (max u3 u4) u1, u2, max u3 u1, max u4 u1} (AlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9)) R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9) (AlgEquiv.instAlgEquivClassAlgEquiv.{u2, max u3 u1, max u4 u1} R (Matrix.{u1, u1, u3} n n S) (Matrix.{u1, u1, u4} n n T) (CommRing.toCommSemiring.{u2} R _inst_5) (Matrix.semiring.{u3, u1} n S (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.semiring.{u4, u1} n T (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_2 (fun (a : n) (b : n) => _inst_1 a b)) (Matrix.instAlgebraMatrixSemiring.{u3, u1, u2} n R S _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) _inst_7) (Matrix.instAlgebraMatrixSemiring.{u4, u1, u2} n R T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_9))))))) (AlgEquiv.mapMatrix.{u3, u4, u1, u2} n R S T _inst_2 (fun (a : n) (b : n) => _inst_1 a b) (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u3} S (CommRing.toRing.{u3} S _inst_6)) (Ring.toSemiring.{u4} T (CommRing.toRing.{u4} T _inst_8)) _inst_7 _inst_9 f) M))
Case conversion may be inaccurate. Consider using '#align alg_equiv.map_det AlgEquiv.map_detₓ'. -/
theorem AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S ≃ₐ[R] T)
    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=
  f.toAlgHom.map_det _
#align alg_equiv.map_det AlgEquiv.map_det

end HomMap

/- warning: matrix.det_conj_transpose -> Matrix.det_conjTranspose is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] [_inst_6 : StarRing.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_5)))] (M : Matrix.{u2, u2, u1} m m R), Eq.{succ u1} R (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.conjTranspose.{u1, u2, u2} m m R (InvolutiveStar.toHasStar.{u1} R (StarAddMonoid.toHasInvolutiveStar.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_5)))))) (StarRing.toStarAddMonoid.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_5))) _inst_6))) M)) (Star.star.{u1} R (InvolutiveStar.toHasStar.{u1} R (StarAddMonoid.toHasInvolutiveStar.{u1} R (AddCommMonoid.toAddMonoid.{u1} R (NonUnitalNonAssocSemiring.toAddCommMonoid.{u1} R (NonUnitalSemiring.toNonUnitalNonAssocSemiring.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_5)))))) (StarRing.toStarAddMonoid.{u1} R (NonUnitalRing.toNonUnitalSemiring.{u1} R (NonUnitalCommRing.toNonUnitalRing.{u1} R (CommRing.toNonUnitalCommRing.{u1} R _inst_5))) _inst_6))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 M))
but is expected to have type
  forall {m : Type.{u1}} [_inst_3 : DecidableEq.{succ u1} m] [_inst_4 : Fintype.{u1} m] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] [_inst_6 : StarRing.{u2} R (NonUnitalRing.toNonUnitalSemiring.{u2} R (NonUnitalCommRing.toNonUnitalRing.{u2} R (CommRing.toNonUnitalCommRing.{u2} R _inst_5)))] (M : Matrix.{u1, u1, u2} m m R), Eq.{succ u2} R (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 (Matrix.conjTranspose.{u2, u1, u1} m m R (InvolutiveStar.toStar.{u2} R (StarAddMonoid.toInvolutiveStar.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (StarRing.toStarAddMonoid.{u2} R (NonUnitalRing.toNonUnitalSemiring.{u2} R (NonUnitalCommRing.toNonUnitalRing.{u2} R (CommRing.toNonUnitalCommRing.{u2} R _inst_5))) _inst_6))) M)) (Star.star.{u2} R (InvolutiveStar.toStar.{u2} R (StarAddMonoid.toInvolutiveStar.{u2} R (AddMonoidWithOne.toAddMonoid.{u2} R (AddGroupWithOne.toAddMonoidWithOne.{u2} R (Ring.toAddGroupWithOne.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (StarRing.toStarAddMonoid.{u2} R (NonUnitalRing.toNonUnitalSemiring.{u2} R (NonUnitalCommRing.toNonUnitalRing.{u2} R (CommRing.toNonUnitalCommRing.{u2} R _inst_5))) _inst_6))) (Matrix.det.{u2, u1} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 M))
Case conversion may be inaccurate. Consider using '#align matrix.det_conj_transpose Matrix.det_conjTransposeₓ'. -/
@[simp]
theorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det Mᴴ = star (det M) :=
  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose
#align matrix.det_conj_transpose Matrix.det_conjTranspose

section DetZero

/-!
### `det_zero` section

Prove that a matrix with a repeated column has determinant equal to zero.
-/


/- warning: matrix.det_eq_zero_of_row_eq_zero -> Matrix.det_eq_zero_of_row_eq_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} (i : n), (forall (j : n), Eq.{succ u1} R (A i j) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} (i : n), (forall (j : n), Eq.{succ u2} R (A i j) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_zero_of_row_eq_zero Matrix.det_eq_zero_of_row_eq_zeroₓ'. -/
theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : ∀ j, A i j = 0) : det A = 0 :=
  (detRowAlternating : AlternatingMap R (n → R) R n).map_coord_zero i (funext h)
#align matrix.det_eq_zero_of_row_eq_zero Matrix.det_eq_zero_of_row_eq_zero

/- warning: matrix.det_eq_zero_of_column_eq_zero -> Matrix.det_eq_zero_of_column_eq_zero is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} (j : n), (forall (i : n), Eq.{succ u1} R (A i j) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} (j : n), (forall (i : n), Eq.{succ u2} R (A i j) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_zero_of_column_eq_zero Matrix.det_eq_zero_of_column_eq_zeroₓ'. -/
theorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : ∀ i, A i j = 0) : det A = 0 :=
  by
  rw [← det_transpose]
  exact det_eq_zero_of_row_eq_zero j h
#align matrix.det_eq_zero_of_column_eq_zero Matrix.det_eq_zero_of_column_eq_zero

variable {M : Matrix n n R} {i j : n}

/- warning: matrix.det_zero_of_row_eq -> Matrix.det_zero_of_row_eq is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {M : Matrix.{u2, u2, u1} n n R} {i : n} {j : n}, (Ne.{succ u2} n i j) -> (Eq.{max (succ u2) (succ u1)} (n -> R) (M i) (M j)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {M : Matrix.{u1, u1, u2} n n R} {i : n} {j : n}, (Ne.{succ u1} n i j) -> (Eq.{max (succ u2) (succ u1)} (n -> R) (M i) (M j)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_zero_of_row_eq Matrix.det_zero_of_row_eqₓ'. -/
/-- If a matrix has a repeated row, the determinant will be zero. -/
theorem det_zero_of_row_eq (i_ne_j : i ≠ j) (hij : M i = M j) : M.det = 0 :=
  (detRowAlternating : AlternatingMap R (n → R) R n).map_eq_zero_of_eq M hij i_ne_j
#align matrix.det_zero_of_row_eq Matrix.det_zero_of_row_eq

/- warning: matrix.det_zero_of_column_eq -> Matrix.det_zero_of_column_eq is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {M : Matrix.{u2, u2, u1} n n R} {i : n} {j : n}, (Ne.{succ u2} n i j) -> (forall (k : n), Eq.{succ u1} R (M k i) (M k j)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {M : Matrix.{u1, u1, u2} n n R} {i : n} {j : n}, (Ne.{succ u1} n i j) -> (forall (k : n), Eq.{succ u2} R (M k i) (M k j)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 M) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_zero_of_column_eq Matrix.det_zero_of_column_eqₓ'. -/
/-- If a matrix has a repeated column, the determinant will be zero. -/
theorem det_zero_of_column_eq (i_ne_j : i ≠ j) (hij : ∀ k, M k i = M k j) : M.det = 0 :=
  by
  rw [← det_transpose, det_zero_of_row_eq i_ne_j]
  exact funext hij
#align matrix.det_zero_of_column_eq Matrix.det_zero_of_column_eq

end DetZero

/- warning: matrix.det_update_row_add -> Matrix.det_updateRow_add is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (u : n -> R) (v : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u2, u1} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) u v))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j v)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (u : n -> R) (v : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u1, u2} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))))) u v))) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j v)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_row_add Matrix.det_updateRow_addₓ'. -/
theorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n → R) :
    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v) :=
  (detRowAlternating : AlternatingMap R (n → R) R n).map_add M j u v
#align matrix.det_update_row_add Matrix.det_updateRow_add

/- warning: matrix.det_update_column_add -> Matrix.det_updateColumn_add is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (u : n -> R) (v : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u2, u1} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) u v))) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j v)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (u : n -> R) (v : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u1, u2} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))))) u v))) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j v)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_column_add Matrix.det_updateColumn_addₓ'. -/
theorem det_updateColumn_add (M : Matrix n n R) (j : n) (u v : n → R) :
    det (updateColumn M j <| u + v) = det (updateColumn M j u) + det (updateColumn M j v) :=
  by
  rw [← det_transpose, ← update_row_transpose, det_update_row_add]
  simp [update_row_transpose, det_transpose]
#align matrix.det_update_column_add Matrix.det_updateColumn_add

/- warning: matrix.det_update_row_smul -> Matrix.det_updateRow_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (SMul.smul.{u1, max u2 u1} R (n -> R) (Function.hasSMul.{u2, u1, u1} n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) s u))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) s (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (n -> R) (n -> R) (instHSMul.{u2, max u2 u1} R (n -> R) (Pi.instSMul.{u1, u2, u2} n R (fun (a._@.Mathlib.LinearAlgebra.Matrix.Determinant._hyg.5007 : n) => R) (fun (i : n) => Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) s u))) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) s (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_row_smul Matrix.det_updateRow_smulₓ'. -/
theorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n → R) :
    det (updateRow M j <| s • u) = s * det (updateRow M j u) :=
  (detRowAlternating : AlternatingMap R (n → R) R n).map_smul M j s u
#align matrix.det_update_row_smul Matrix.det_updateRow_smul

/- warning: matrix.det_update_column_smul -> Matrix.det_updateColumn_smul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (SMul.smul.{u1, max u2 u1} R (n -> R) (Function.hasSMul.{u2, u1, u1} n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) s u))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) s (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (n -> R) (n -> R) (instHSMul.{u2, max u2 u1} R (n -> R) (Pi.instSMul.{u1, u2, u2} n R (fun (a._@.Mathlib.LinearAlgebra.Matrix.Determinant._hyg.5079 : n) => R) (fun (i : n) => Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) s u))) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) s (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_column_smul Matrix.det_updateColumn_smulₓ'. -/
theorem det_updateColumn_smul (M : Matrix n n R) (j : n) (s : R) (u : n → R) :
    det (updateColumn M j <| s • u) = s * det (updateColumn M j u) :=
  by
  rw [← det_transpose, ← update_row_transpose, det_update_row_smul]
  simp [update_row_transpose, det_transpose]
#align matrix.det_update_column_smul Matrix.det_updateColumn_smul

/- warning: matrix.det_update_row_smul' -> Matrix.det_updateRow_smul' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) (SMul.smul.{u1, max u2 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.hasSmul.{u1, u2, u2, u1} n n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) s M) j u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_5)))) s (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u2} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u2} n n R) (instHSMul.{u2, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.smul.{u2, u1, u1, u2} n n R R (Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) s M) j u)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) s (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_row_smul' Matrix.det_updateRow_smul'ₓ'. -/
theorem det_updateRow_smul' (M : Matrix n n R) (j : n) (s : R) (u : n → R) :
    det (updateRow (s • M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u) :=
  MultilinearMap.map_update_smul _ M j s u
#align matrix.det_update_row_smul' Matrix.det_updateRow_smul'

/- warning: matrix.det_update_column_smul' -> Matrix.det_updateColumn_smul' is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (M : Matrix.{u2, u2, u1} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) (SMul.smul.{u1, max u2 u1} R (Matrix.{u2, u2, u1} n n R) (Matrix.hasSmul.{u1, u2, u2, u1} n n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) s M) j u)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (HPow.hPow.{u1, 0, u1} R Nat R (instHPow.{u1, 0} R Nat (Monoid.Pow.{u1} R (Ring.toMonoid.{u1} R (CommRing.toRing.{u1} R _inst_5)))) s (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) (Fintype.card.{u2} n _inst_2) (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (M : Matrix.{u1, u1, u2} n n R) (j : n) (s : R) (u : n -> R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.{u1, u1, u2} n n R) (instHSMul.{u2, max u2 u1} R (Matrix.{u1, u1, u2} n n R) (Matrix.smul.{u2, u1, u1, u2} n n R R (Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) s M) j u)) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (HPow.hPow.{u2, 0, u2} R Nat R (instHPow.{u2, 0} R Nat (Monoid.Pow.{u2} R (MonoidWithZero.toMonoid.{u2} R (Semiring.toMonoidWithZero.{u2} R (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) s (HSub.hSub.{0, 0, 0} Nat Nat Nat (instHSub.{0} Nat instSubNat) (Fintype.card.{u1} n _inst_2) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) M j u)))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_column_smul' Matrix.det_updateColumn_smul'ₓ'. -/
theorem det_updateColumn_smul' (M : Matrix n n R) (j : n) (s : R) (u : n → R) :
    det (updateColumn (s • M) j u) = s ^ (Fintype.card n - 1) * det (updateColumn M j u) :=
  by
  rw [← det_transpose, ← update_row_transpose, transpose_smul, det_update_row_smul']
  simp [update_row_transpose, det_transpose]
#align matrix.det_update_column_smul' Matrix.det_updateColumn_smul'

section DetEq

/-! ### `det_eq` section

Lemmas showing the determinant is invariant under a variety of operations.
-/


/- warning: matrix.det_eq_of_eq_mul_det_one -> Matrix.det_eq_of_eq_mul_det_one is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} {B : Matrix.{u2, u2, u1} n n R} (C : Matrix.{u2, u2, u1} n n R), (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 C) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))) -> (Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) A (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_2 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) B C)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} {B : Matrix.{u1, u1, u2} n n R} (C : Matrix.{u1, u1, u2} n n R), (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 C) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) -> (Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) A (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_2 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) B C)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_eq_mul_det_one Matrix.det_eq_of_eq_mul_det_oneₓ'. -/
theorem det_eq_of_eq_mul_det_one {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)
    (hA : A = B ⬝ C) : det A = det B :=
  calc
    det A = det (B ⬝ C) := congr_arg _ hA
    _ = det B * det C := (det_mul _ _)
    _ = det B := by rw [hC, mul_one]
    
#align matrix.det_eq_of_eq_mul_det_one Matrix.det_eq_of_eq_mul_det_one

/- warning: matrix.det_eq_of_eq_det_one_mul -> Matrix.det_eq_of_eq_det_one_mul is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} {B : Matrix.{u2, u2, u1} n n R} (C : Matrix.{u2, u2, u1} n n R), (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 C) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))) -> (Eq.{succ (max u2 u1)} (Matrix.{u2, u2, u1} n n R) A (Matrix.mul.{u1, u2, u2, u2} n n n R _inst_2 (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))) (AddCommGroup.toAddCommMonoid.{u1} R (NonUnitalNonAssocRing.toAddCommGroup.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) C B)) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} {B : Matrix.{u1, u1, u2} n n R} (C : Matrix.{u1, u1, u2} n n R), (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 C) (OfNat.ofNat.{u2} R 1 (One.toOfNat1.{u2} R (NonAssocRing.toOne.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))) -> (Eq.{max (succ u2) (succ u1)} (Matrix.{u1, u1, u2} n n R) A (Matrix.mul.{u2, u1, u1, u1} n n n R _inst_2 (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))) (NonUnitalNonAssocSemiring.toAddCommMonoid.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) C B)) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_eq_det_one_mul Matrix.det_eq_of_eq_det_one_mulₓ'. -/
theorem det_eq_of_eq_det_one_mul {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)
    (hA : A = C ⬝ B) : det A = det B :=
  calc
    det A = det (C ⬝ B) := congr_arg _ hA
    _ = det C * det B := (det_mul _ _)
    _ = det B := by rw [hC, one_mul]
    
#align matrix.det_eq_of_eq_det_one_mul Matrix.det_eq_of_eq_det_one_mul

/- warning: matrix.det_update_row_add_self -> Matrix.det_updateRow_add_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R) {i : n} {j : n}, (Ne.{succ u2} n i j) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u2, u1} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (A i) (A j)))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R) {i : n} {j : n}, (Ne.{succ u1} n i j) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u1, u2} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))))) (A i) (A j)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_row_add_self Matrix.det_updateRow_add_selfₓ'. -/
theorem det_updateRow_add_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) :
    det (updateRow A i (A i + A j)) = det A := by
  simp [det_update_row_add,
    det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]
#align matrix.det_update_row_add_self Matrix.det_updateRow_add_self

/- warning: matrix.det_update_column_add_self -> Matrix.det_updateColumn_add_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R) {i : n} {j : n}, (Ne.{succ u2} n i j) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (fun (k : n) => HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (A k i) (A k j)))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R) {i : n} {j : n}, (Ne.{succ u1} n i j) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (fun (k : n) => HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (A k i) (A k j)))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_column_add_self Matrix.det_updateColumn_add_selfₓ'. -/
theorem det_updateColumn_add_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) :
    det (updateColumn A i fun k => A k i + A k j) = det A :=
  by
  rw [← det_transpose, ← update_row_transpose, ← det_transpose A]
  exact det_update_row_add_self Aᵀ hij
#align matrix.det_update_column_add_self Matrix.det_updateColumn_add_self

/- warning: matrix.det_update_row_add_smul_self -> Matrix.det_updateRow_add_smul_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R) {i : n} {j : n}, (Ne.{succ u2} n i j) -> (forall (c : R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u2, u1} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (A i) (SMul.smul.{u1, max u2 u1} R (n -> R) (Function.hasSMul.{u2, u1, u1} n R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5))))) c (A j))))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R) {i : n} {j : n}, (Ne.{succ u1} n i j) -> (forall (c : R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateRow.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (HAdd.hAdd.{max u2 u1, max u2 u1, max u2 u1} (n -> R) (n -> R) (n -> R) (instHAdd.{max u2 u1} (n -> R) (Pi.instAdd.{u1, u2} n (fun (ᾰ : n) => R) (fun (i : n) => Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5)))))))) (A i) (HSMul.hSMul.{u2, max u2 u1, max u2 u1} R (n -> R) (n -> R) (instHSMul.{u2, max u2 u1} R (n -> R) (Pi.instSMul.{u1, u2, u2} n R (fun (a._@.Mathlib.Data.Matrix.Basic._hyg.12 : n) => R) (fun (i : n) => Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))) c (A j))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_row_add_smul_self Matrix.det_updateRow_add_smul_selfₓ'. -/
theorem det_updateRow_add_smul_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :
    det (updateRow A i (A i + c • A j)) = det A := by
  simp [det_update_row_add, det_update_row_smul,
    det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]
#align matrix.det_update_row_add_smul_self Matrix.det_updateRow_add_smul_self

/- warning: matrix.det_update_column_add_smul_self -> Matrix.det_updateColumn_add_smul_self is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} n n R) {i : n} {j : n}, (Ne.{succ u2} n i j) -> (forall (c : R), Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u1, u2, u2} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (fun (k : n) => HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (A k i) (SMul.smul.{u1, u1} R R (Mul.toSMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) c (A k j))))) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] (A : Matrix.{u1, u1, u2} n n R) {i : n} {j : n}, (Ne.{succ u1} n i j) -> (forall (c : R), Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (Matrix.updateColumn.{u2, u1, u1} n n R (fun (a : n) (b : n) => _inst_1 a b) A i (fun (k : n) => HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (A k i) (HSMul.hSMul.{u2, u2, u2} R R R (instHSMul.{u2, u2} R R (Algebra.toSMul.{u2, u2} R R (CommRing.toCommSemiring.{u2} R _inst_5) (Ring.toSemiring.{u2} R (CommRing.toRing.{u2} R _inst_5)) (Algebra.id.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))) c (A k j))))) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A))
Case conversion may be inaccurate. Consider using '#align matrix.det_update_column_add_smul_self Matrix.det_updateColumn_add_smul_selfₓ'. -/
theorem det_updateColumn_add_smul_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :
    det (updateColumn A i fun k => A k i + c • A k j) = det A :=
  by
  rw [← det_transpose, ← update_row_transpose, ← det_transpose A]
  exact det_update_row_add_smul_self Aᵀ hij c
#align matrix.det_update_column_add_smul_self Matrix.det_updateColumn_add_smul_self

/- warning: matrix.det_eq_of_forall_row_eq_smul_add_const_aux -> Matrix.det_eq_of_forall_row_eq_smul_add_const_aux is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} {B : Matrix.{u2, u2, u1} n n R} {s : Finset.{u2} n} (c : n -> R), (forall (i : n), (Not (Membership.Mem.{u2, u2} n (Finset.{u2} n) (Finset.hasMem.{u2} n) i s)) -> (Eq.{succ u1} R (c i) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))) -> (forall (k : n), (Not (Membership.Mem.{u2, u2} n (Finset.{u2} n) (Finset.hasMem.{u2} n) k s)) -> (forall (i : n) (j : n), Eq.{succ u1} R (A i j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (B i j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (c i) (B k j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} {B : Matrix.{u1, u1, u2} n n R} {s : Finset.{u1} n} (c : n -> R), (forall (i : n), (Not (Membership.mem.{u1, u1} n (Finset.{u1} n) (Finset.instMembershipFinset.{u1} n) i s)) -> (Eq.{succ u2} R (c i) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5))))))) -> (forall (k : n), (Not (Membership.mem.{u1, u1} n (Finset.{u1} n) (Finset.instMembershipFinset.{u1} n) k s)) -> (forall (i : n) (j : n), Eq.{succ u2} R (A i j) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (B i j) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (c i) (B k j)))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B)))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_forall_row_eq_smul_add_const_aux Matrix.det_eq_of_forall_row_eq_smul_add_const_auxₓ'. -/
theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :
    ∀ (c : n → R) (hs : ∀ i, i ∉ s → c i = 0) (k : n) (hk : k ∉ s)
      (A_eq : ∀ i j, A i j = B i j + c i * B k j), det A = det B :=
  by
  revert B
  refine' s.induction_on _ _
  · intro A c hs k hk A_eq
    have : ∀ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext (i j)
    rw [A_eq, this, MulZeroClass.zero_mul, add_zero]
  · intro i s hi ih B c hs k hk A_eq
    have hAi : A i = B i + c i • B k := funext (A_eq i)
    rw [@ih (update_row B i (A i)) (Function.update c i 0), hAi, det_update_row_add_smul_self]
    · exact mt (fun h => show k ∈ insert i s from h ▸ Finset.mem_insert_self _ _) hk
    · intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      · rfl
      · exact hs i' fun h => hi' ((finset.mem_insert.mp h).resolve_left hi'i)
    · exact fun h => hk (Finset.mem_insert_of_mem h)
    · intro i' j'
      rw [update_row_apply, Function.update_apply]
      split_ifs with hi'i
      · simp [hi'i]
      rw [A_eq, update_row_ne fun h : k = i => hk <| h ▸ Finset.mem_insert_self k s]
#align matrix.det_eq_of_forall_row_eq_smul_add_const_aux Matrix.det_eq_of_forall_row_eq_smul_add_const_aux

/- warning: matrix.det_eq_of_forall_row_eq_smul_add_const -> Matrix.det_eq_of_forall_row_eq_smul_add_const is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{u2, u2, u1} n n R} {B : Matrix.{u2, u2, u1} n n R} (c : n -> R) (k : n), (Eq.{succ u1} R (c k) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) -> (forall (i : n) (j : n), Eq.{succ u1} R (A i j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (B i j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (c i) (B k j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u2}} [_inst_5 : CommRing.{u2} R] {A : Matrix.{u1, u1, u2} n n R} {B : Matrix.{u1, u1, u2} n n R} (c : n -> R) (k : n), (Eq.{succ u2} R (c k) (OfNat.ofNat.{u2} R 0 (Zero.toOfNat0.{u2} R (CommMonoidWithZero.toZero.{u2} R (CommSemiring.toCommMonoidWithZero.{u2} R (CommRing.toCommSemiring.{u2} R _inst_5)))))) -> (forall (i : n) (j : n), Eq.{succ u2} R (A i j) (HAdd.hAdd.{u2, u2, u2} R R R (instHAdd.{u2} R (Distrib.toAdd.{u2} R (NonUnitalNonAssocSemiring.toDistrib.{u2} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))))) (B i j) (HMul.hMul.{u2, u2, u2} R R R (instHMul.{u2} R (NonUnitalNonAssocRing.toMul.{u2} R (NonAssocRing.toNonUnitalNonAssocRing.{u2} R (Ring.toNonAssocRing.{u2} R (CommRing.toRing.{u2} R _inst_5))))) (c i) (B k j)))) -> (Eq.{succ u2} R (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 A) (Matrix.det.{u2, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 B))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_forall_row_eq_smul_add_const Matrix.det_eq_of_forall_row_eq_smul_add_constₓ'. -/
/-- If you add multiples of row `B k` to other rows, the determinant doesn't change. -/
theorem det_eq_of_forall_row_eq_smul_add_const {A B : Matrix n n R} (c : n → R) (k : n)
    (hk : c k = 0) (A_eq : ∀ i j, A i j = B i j + c i * B k j) : det A = det B :=
  det_eq_of_forall_row_eq_smul_add_const_aux c
    (fun i =>
      not_imp_comm.mp fun hi =>
        Finset.mem_erase.mpr
          ⟨mt (fun h : i = k => show c i = 0 from h.symm ▸ hk) hi, Finset.mem_univ i⟩)
    k (Finset.not_mem_erase k Finset.univ) A_eq
#align matrix.det_eq_of_forall_row_eq_smul_add_const Matrix.det_eq_of_forall_row_eq_smul_add_const

/- warning: matrix.det_eq_of_forall_row_eq_smul_add_pred_aux -> Matrix.det_eq_of_forall_row_eq_smul_add_pred_aux is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} (k : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (c : (Fin n) -> R), (forall (i : Fin n), (LT.lt.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLt (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) k (Fin.succ n i)) -> (Eq.{succ u1} R (c i) (OfNat.ofNat.{u1} R 0 (OfNat.mk.{u1} R 0 (Zero.zero.{u1} R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))))) -> (forall {M : Matrix.{0, 0, u1} (Fin (Nat.succ n)) (Fin (Nat.succ n)) R} {N : Matrix.{0, 0, u1} (Fin (Nat.succ n)) (Fin (Nat.succ n)) R}, (forall (j : Fin (Nat.succ n)), Eq.{succ u1} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n))))) j) (N (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (OfNat.mk.{0} (Fin (Nat.succ n)) 0 (Zero.zero.{0} (Fin (Nat.succ n)) (Fin.hasZeroOfNeZero (Nat.succ n) (NeZero.succ n))))) j)) -> (forall (i : Fin n) (j : Fin (Nat.succ n)), Eq.{succ u1} R (M (Fin.succ n i) j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (N (Fin.succ n i) j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (c i) (M (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe n) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (fun (_x : RelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) => (Fin n) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Fin.castSucc n) i) j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) R _inst_5 M) (Matrix.det.{u1, 0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => Fin.decidableEq (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) R _inst_5 N)))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} (k : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (c : (Fin n) -> R), (forall (i : Fin n), (LT.lt.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLTFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) k (Fin.succ n i)) -> (Eq.{succ u1} R (c i) (OfNat.ofNat.{u1} R 0 (Zero.toOfNat0.{u1} R (CommMonoidWithZero.toZero.{u1} R (CommSemiring.toCommMonoidWithZero.{u1} R (CommRing.toCommSemiring.{u1} R _inst_5))))))) -> (forall {M : Matrix.{0, 0, u1} (Fin (Nat.succ n)) (Fin (Nat.succ n)) R} {N : Matrix.{0, 0, u1} (Fin (Nat.succ n)) (Fin (Nat.succ n)) R}, (forall (j : Fin (Nat.succ n)), Eq.{succ u1} R (M (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n))) j) (N (OfNat.ofNat.{0} (Fin (Nat.succ n)) 0 (Fin.instOfNatFin (Nat.succ n) 0 (NeZero.succ n))) j)) -> (forall (i : Fin n) (j : Fin (Nat.succ n)), Eq.{succ u1} R (M (Fin.succ n i) j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (N (Fin.succ n i) j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (c i) (M (FunLike.coe.{1, 1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (fun (_x : Fin n) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Fin n) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (InfHomClass.toFunLike.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toInf.{0} (Fin n) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n)))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n)) (LatticeHomClass.toInfHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (OrderHomClass.toLatticeHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin n) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (RelEmbedding.instRelHomClassRelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Fin n) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin n) => LE.le.{0} (Fin n) (instLEFin n) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))))) (Fin.castSucc n) i) j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) R _inst_5 M) (Matrix.det.{u1, 0} (Fin (Nat.succ n)) (fun (a : Fin (Nat.succ n)) (b : Fin (Nat.succ n)) => instDecidableEqFin (Nat.succ n) a b) (Fin.fintype (Nat.succ n)) R _inst_5 N)))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_forall_row_eq_smul_add_pred_aux Matrix.det_eq_of_forall_row_eq_smul_add_pred_auxₓ'. -/
theorem det_eq_of_forall_row_eq_smul_add_pred_aux {n : ℕ} (k : Fin (n + 1)) :
    ∀ (c : Fin n → R) (hc : ∀ i : Fin n, k < i.succ → c i = 0)
      {M N : Matrix (Fin n.succ) (Fin n.succ) R} (h0 : ∀ j, M 0 j = N 0 j)
      (hsucc : ∀ (i : Fin n) (j), M i.succ j = N i.succ j + c i * M i.cast_succ j), det M = det N :=
  by
  refine' Fin.induction _ (fun k ih => _) k <;> intro c hc M N h0 hsucc
  · congr
    ext (i j)
    refine' Fin.cases (h0 j) (fun i => _) i
    rw [hsucc, hc i (Fin.succ_pos _), MulZeroClass.zero_mul, add_zero]
  set M' := update_row M k.succ (N k.succ) with hM'
  have hM : M = update_row M' k.succ (M' k.succ + c k • M k.cast_succ) :=
    by
    ext (i j)
    by_cases hi : i = k.succ
    · simp [hi, hM', hsucc, update_row_self]
    rw [update_row_ne hi, hM', update_row_ne hi]
  have k_ne_succ : k.cast_succ ≠ k.succ := (Fin.castSucc_lt_succ k).Ne
  have M_k : M k.cast_succ = M' k.cast_succ := (update_row_ne k_ne_succ).symm
  rw [hM, M_k, det_update_row_add_smul_self M' k_ne_succ.symm, ih (Function.update c k 0)]
  · intro i hi
    rw [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff] at hi
    rw [Function.update_apply]
    split_ifs with hik
    · rfl
    exact hc _ (fin.succ_lt_succ_iff.mpr (lt_of_le_of_ne hi (Ne.symm hik)))
  · rwa [hM', update_row_ne (Fin.succ_ne_zero _).symm]
  intro i j
  rw [Function.update_apply]
  split_ifs with hik
  · rw [MulZeroClass.zero_mul, add_zero, hM', hik, update_row_self]
  rw [hM', update_row_ne ((Fin.succ_injective _).Ne hik), hsucc]
  by_cases hik2 : k < i
  · simp [hc i (fin.succ_lt_succ_iff.mpr hik2)]
  rw [update_row_ne]
  apply ne_of_lt
  rwa [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff, ← not_lt]
#align matrix.det_eq_of_forall_row_eq_smul_add_pred_aux Matrix.det_eq_of_forall_row_eq_smul_add_pred_aux

/- warning: matrix.det_eq_of_forall_row_eq_smul_add_pred -> Matrix.det_eq_of_forall_row_eq_smul_add_pred is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} {A : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R} {B : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R} (c : (Fin n) -> R), (forall (j : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u1} R (A (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))) j) (B (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))) j)) -> (forall (i : Fin n) (j : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u1} R (A (Fin.succ n i) j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (B (Fin.succ n i) j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (c i) (A (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe n) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (fun (_x : RelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) => (Fin n) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Fin.castSucc n) i) j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R _inst_5 A) (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R _inst_5 B))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} {A : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R} {B : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R} (c : (Fin n) -> R), (forall (j : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} R (A (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n))) j) (B (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n))) j)) -> (forall (i : Fin n) (j : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} R (A (Fin.succ n i) j) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (B (Fin.succ n i) j) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (c i) (A (FunLike.coe.{1, 1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (fun (_x : Fin n) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Fin n) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (InfHomClass.toFunLike.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toInf.{0} (Fin n) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n)))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n)) (LatticeHomClass.toInfHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (OrderHomClass.toLatticeHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin n) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (RelEmbedding.instRelHomClassRelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Fin n) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin n) => LE.le.{0} (Fin n) (instLEFin n) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))))) (Fin.castSucc n) i) j)))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R _inst_5 A) (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R _inst_5 B))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_forall_row_eq_smul_add_pred Matrix.det_eq_of_forall_row_eq_smul_add_predₓ'. -/
/-- If you add multiples of previous rows to the next row, the determinant doesn't change. -/
theorem det_eq_of_forall_row_eq_smul_add_pred {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}
    (c : Fin n → R) (A_zero : ∀ j, A 0 j = B 0 j)
    (A_succ : ∀ (i : Fin n) (j), A i.succ j = B i.succ j + c i * A i.cast_succ j) : det A = det B :=
  det_eq_of_forall_row_eq_smul_add_pred_aux (Fin.last _) c
    (fun i hi => absurd hi (not_lt_of_ge (Fin.le_last _))) A_zero A_succ
#align matrix.det_eq_of_forall_row_eq_smul_add_pred Matrix.det_eq_of_forall_row_eq_smul_add_pred

/- warning: matrix.det_eq_of_forall_col_eq_smul_add_pred -> Matrix.det_eq_of_forall_col_eq_smul_add_pred is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} {A : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R} {B : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R} (c : (Fin n) -> R), (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))), Eq.{succ u1} R (A i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n)))))) (B i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (One.one.{0} Nat Nat.hasOne)) (NeZero.succ n))))))) -> (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (j : Fin n), Eq.{succ u1} R (A i (Fin.succ n j)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toHasAdd.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (B i (Fin.succ n j)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (c j) (A i (coeFn.{1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe n) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (fun (_x : RelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) => (Fin n) -> (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))))) (RelEmbedding.hasCoeToFun.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (LE.le.{0} (Fin n) (Fin.hasLe n)) (LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (Fin.hasLe (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))))) (Fin.castSucc n) j))))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R _inst_5 A) (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) n (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))))) R _inst_5 B))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {n : Nat} {A : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R} {B : Matrix.{0, 0, u1} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R} (c : (Fin n) -> R), (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))), Eq.{succ u1} R (A i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n)))) (B i (OfNat.ofNat.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) 0 (Fin.instOfNatFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (NeZero.succ n))))) -> (forall (i : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (j : Fin n), Eq.{succ u1} R (A i (Fin.succ n j)) (HAdd.hAdd.{u1, u1, u1} R R R (instHAdd.{u1} R (Distrib.toAdd.{u1} R (NonUnitalNonAssocSemiring.toDistrib.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (B i (Fin.succ n j)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (c j) (A i (FunLike.coe.{1, 1, 1} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (fun (_x : Fin n) => (fun (x._@.Mathlib.Order.Hom.Lattice._hyg.494 : Fin n) => Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) _x) (InfHomClass.toFunLike.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Lattice.toInf.{0} (Fin n) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n)))) (Lattice.toInf.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n)) (LatticeHomClass.toInfHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (DistribLattice.toLattice.{0} (Fin n) (instDistribLattice.{0} (Fin n) (Fin.instLinearOrderFin n))) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (OrderHomClass.toLatticeHomClass.{0, 0, 0} (OrderEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin n) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Fin.instLinearOrderFin n) (Fin.instLatticeFinHAddNatInstHAddInstAddNatOfNat n) (RelEmbedding.instRelHomClassRelEmbedding.{0, 0} (Fin n) (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.680 : Fin n) (x._@.Mathlib.Order.Hom.Basic._hyg.682 : Fin n) => LE.le.{0} (Fin n) (instLEFin n) x._@.Mathlib.Order.Hom.Basic._hyg.680 x._@.Mathlib.Order.Hom.Basic._hyg.682) (fun (x._@.Mathlib.Order.Hom.Basic._hyg.695 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (x._@.Mathlib.Order.Hom.Basic._hyg.697 : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => LE.le.{0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (instLEFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) x._@.Mathlib.Order.Hom.Basic._hyg.695 x._@.Mathlib.Order.Hom.Basic._hyg.697))))) (Fin.castSucc n) j))))) -> (Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R _inst_5 A) (Matrix.det.{u1, 0} (Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (a : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (b : Fin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) => instDecidableEqFin (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) a b) (Fin.fintype (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) n (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) R _inst_5 B))
Case conversion may be inaccurate. Consider using '#align matrix.det_eq_of_forall_col_eq_smul_add_pred Matrix.det_eq_of_forall_col_eq_smul_add_predₓ'. -/
/-- If you add multiples of previous columns to the next columns, the determinant doesn't change. -/
theorem det_eq_of_forall_col_eq_smul_add_pred {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}
    (c : Fin n → R) (A_zero : ∀ i, A i 0 = B i 0)
    (A_succ : ∀ (i) (j : Fin n), A i j.succ = B i j.succ + c j * A i j.cast_succ) : det A = det B :=
  by
  rw [← det_transpose A, ← det_transpose B]
  exact det_eq_of_forall_row_eq_smul_add_pred c A_zero fun i j => A_succ j i
#align matrix.det_eq_of_forall_col_eq_smul_add_pred Matrix.det_eq_of_forall_col_eq_smul_add_pred

end DetEq

/- warning: matrix.det_block_diagonal -> Matrix.det_blockDiagonal is a dubious translation:
lean 3 declaration is
  forall {n : Type.{u2}} [_inst_1 : DecidableEq.{succ u2} n] [_inst_2 : Fintype.{u2} n] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {o : Type.{u3}} [_inst_6 : Fintype.{u3} o] [_inst_7 : DecidableEq.{succ u3} o] (M : o -> (Matrix.{u2, u2, u1} n n R)), Eq.{succ u1} R (Matrix.det.{u1, max u2 u3} (Prod.{u2, u3} n o) (fun (a : Prod.{u2, u3} n o) (b : Prod.{u2, u3} n o) => Prod.Lex.decidableEq.{u2, u3} n o (fun (a : n) (b : n) => _inst_1 a b) (fun (a : o) (b : o) => _inst_7 a b) a b) (Prod.fintype.{u2, u3} n o _inst_2 _inst_6) R _inst_5 (Matrix.blockDiagonal.{u2, u2, u3, u1} n n o R (fun (a : o) (b : o) => _inst_7 a b) (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))) M)) (Finset.prod.{u1, u3} R o (CommRing.toCommMonoid.{u1} R _inst_5) (Finset.univ.{u3} o _inst_6) (fun (k : o) => Matrix.det.{u1, u2} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (M k)))
but is expected to have type
  forall {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] {o : Type.{u2}} [_inst_6 : Fintype.{u2} o] [_inst_7 : DecidableEq.{succ u2} o] (M : o -> (Matrix.{u1, u1, u3} n n R)), Eq.{succ u3} R (Matrix.det.{u3, max u1 u2} (Prod.{u1, u2} n o) (fun (a : Prod.{u1, u2} n o) (b : Prod.{u1, u2} n o) => instDecidableEqProd.{u1, u2} n o (fun (a : n) (b : n) => _inst_1 a b) (fun (a : o) (b : o) => _inst_7 a b) a b) (instFintypeProd.{u1, u2} n o _inst_2 _inst_6) R _inst_5 (Matrix.blockDiagonal.{u1, u1, u2, u3} n n o R (fun (a : o) (b : o) => _inst_7 a b) (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5))) M)) (Finset.prod.{u3, u2} R o (CommRing.toCommMonoid.{u3} R _inst_5) (Finset.univ.{u2} o _inst_6) (fun (k : o) => Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 (M k)))
Case conversion may be inaccurate. Consider using '#align matrix.det_block_diagonal Matrix.det_blockDiagonalₓ'. -/
@[simp]
theorem det_blockDiagonal {o : Type _} [Fintype o] [DecidableEq o] (M : o → Matrix n n R) :
    (blockDiagonal M).det = ∏ k, (M k).det :=
  by
  -- Rewrite the determinants as a sum over permutations.
  simp_rw [det_apply']
  -- The right hand side is a product of sums, rewrite it as a sum of products.
  rw [Finset.prod_sum]
  simp_rw [Finset.mem_univ, Finset.prod_attach_univ, Finset.univ_pi_univ]
  -- We claim that the only permutations contributing to the sum are those that
  -- preserve their second component.
  let preserving_snd : Finset (Equiv.Perm (n × o)) :=
    finset.univ.filter fun σ => ∀ x, (σ x).snd = x.snd
  have mem_preserving_snd :
    ∀ {σ : Equiv.Perm (n × o)}, σ ∈ preserving_snd ↔ ∀ x, (σ x).snd = x.snd := fun σ =>
    finset.mem_filter.trans ⟨fun h => h.2, fun h => ⟨Finset.mem_univ _, h⟩⟩
  rw [← Finset.sum_subset (Finset.subset_univ preserving_snd) _]
  -- And that these are in bijection with `o → equiv.perm m`.
  rw [(Finset.sum_bij
        (fun (σ : ∀ k : o, k ∈ Finset.univ → Equiv.Perm n) _ =>
          prod_congr_left fun k => σ k (Finset.mem_univ k))
        _ _ _ _).symm]
  · intro σ _
    rw [mem_preserving_snd]
    rintro ⟨k, x⟩
    simp only [prod_congr_left_apply]
  · intro σ _
    rw [Finset.prod_mul_distrib, ← Finset.univ_product_univ, Finset.prod_product_right]
    simp only [sign_prod_congr_left, Units.coe_prod, Int.cast_prod, block_diagonal_apply_eq,
      prod_congr_left_apply]
  · intro σ σ' _ _ eq
    ext (x hx k)
    simp only at eq
    have :
      ∀ k x,
        prod_congr_left (fun k => σ k (Finset.mem_univ _)) (k, x) =
          prod_congr_left (fun k => σ' k (Finset.mem_univ _)) (k, x) :=
      fun k x => by rw [Eq]
    simp only [prod_congr_left_apply, Prod.mk.inj_iff] at this
    exact (this k x).1
  · intro σ hσ
    rw [mem_preserving_snd] at hσ
    have hσ' : ∀ x, (σ⁻¹ x).snd = x.snd := by
      intro x
      conv_rhs => rw [← perm.apply_inv_self σ x, hσ]
    have mk_apply_eq : ∀ k x, ((σ (x, k)).fst, k) = σ (x, k) :=
      by
      intro k x
      ext
      · simp only
      · simp only [hσ]
    have mk_inv_apply_eq : ∀ k x, ((σ⁻¹ (x, k)).fst, k) = σ⁻¹ (x, k) :=
      by
      intro k x
      conv_lhs => rw [← perm.apply_inv_self σ (x, k)]
      ext
      · simp only [apply_inv_self]
      · simp only [hσ']
    refine' ⟨fun k _ => ⟨fun x => (σ (x, k)).fst, fun x => (σ⁻¹ (x, k)).fst, _, _⟩, _, _⟩
    · intro x
      simp only [mk_apply_eq, inv_apply_self]
    · intro x
      simp only [mk_inv_apply_eq, apply_inv_self]
    · apply Finset.mem_univ
    · ext ⟨k, x⟩
      · simp only [coe_fn_mk, prod_congr_left_apply]
      · simp only [prod_congr_left_apply, hσ]
  · intro σ _ hσ
    rw [mem_preserving_snd] at hσ
    obtain ⟨⟨k, x⟩, hkx⟩ := not_forall.mp hσ
    rw [Finset.prod_eq_zero (Finset.mem_univ (k, x)), MulZeroClass.mul_zero]
    rw [← @Prod.mk.eta _ _ (σ (k, x)), block_diagonal_apply_ne]
    exact hkx
#align matrix.det_block_diagonal Matrix.det_blockDiagonal

/- warning: matrix.det_from_blocks_zero₂₁ -> Matrix.det_fromBlocks_zero₂₁ is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} m m R) (B : Matrix.{u2, u3, u1} m n R) (D : Matrix.{u3, u3, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, max u2 u3} (Sum.{u2, u3} m n) (fun (a : Sum.{u2, u3} m n) (b : Sum.{u2, u3} m n) => Sum.decidableEq.{u2, u3} m (fun (a : m) (b : m) => _inst_3 a b) n (fun (a : n) (b : n) => _inst_1 a b) a b) (Sum.fintype.{u2, u3} m n _inst_4 _inst_2) R _inst_5 (Matrix.fromBlocks.{u2, u3, u2, u3, u1} m n m n R A B (OfNat.ofNat.{max u3 u2 u1} (Matrix.{u3, u2, u1} n m R) 0 (OfNat.mk.{max u3 u2 u1} (Matrix.{u3, u2, u1} n m R) 0 (Zero.zero.{max u3 u2 u1} (Matrix.{u3, u2, u1} n m R) (Matrix.hasZero.{u1, u3, u2} n m R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) D)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A) (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 D))
but is expected to have type
  forall {m : Type.{u2}} {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] (A : Matrix.{u2, u2, u3} m m R) (B : Matrix.{u2, u1, u3} m n R) (D : Matrix.{u1, u1, u3} n n R), Eq.{succ u3} R (Matrix.det.{u3, max u2 u1} (Sum.{u2, u1} m n) (fun (a : Sum.{u2, u1} m n) (b : Sum.{u2, u1} m n) => Sum.instDecidableEqSum.{u2, u1} m n (fun (a : m) (b : m) => _inst_3 a b) (fun (a : n) (b : n) => _inst_1 a b) a b) (instFintypeSum.{u2, u1} m n _inst_4 _inst_2) R _inst_5 (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n R A B (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} n m R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u1, u2, u3} n m R) (Matrix.zero.{u3, u1, u2} n m R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5)))))) D)) (HMul.hMul.{u3, u3, u3} R R R (instHMul.{u3} R (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (Matrix.det.{u3, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 D))
Case conversion may be inaccurate. Consider using '#align matrix.det_from_blocks_zero₂₁ Matrix.det_fromBlocks_zero₂₁ₓ'. -/
/-- The determinant of a 2×2 block matrix with the lower-left block equal to zero is the product of
the determinants of the diagonal blocks. For the generalization to any number of blocks, see
`matrix.det_of_upper_triangular`. -/
@[simp]
theorem det_fromBlocks_zero₂₁ (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) :
    (Matrix.fromBlocks A B 0 D).det = A.det * D.det := by
  classical
    simp_rw [det_apply']
    convert(sum_subset (subset_univ ((sum_congr_hom m n).range : Set (perm (Sum m n))).toFinset)
          _).symm
    rw [sum_mul_sum]
    simp_rw [univ_product_univ]
    rw [(sum_bij (fun (σ : perm m × perm n) _ => Equiv.sumCongr σ.fst σ.snd) _ _ _ _).symm]
    · intro σ₁₂ h
      simp only
      erw [Set.mem_toFinset, MonoidHom.mem_range]
      use σ₁₂
      simp only [sum_congr_hom_apply]
    · simp only [forall_prop_of_true, Prod.forall, mem_univ]
      intro σ₁ σ₂
      rw [Fintype.prod_sum_type]
      simp_rw [Equiv.sumCongr_apply, Sum.map_inr, Sum.map_inl, from_blocks_apply₁₁,
        from_blocks_apply₂₂]
      rw [mul_mul_mul_comm]
      congr
      rw [sign_sum_congr, Units.val_mul, Int.cast_mul]
    · intro σ₁ σ₂ h₁ h₂
      dsimp only
      intro h
      have h2 : ∀ x, perm.sum_congr σ₁.fst σ₁.snd x = perm.sum_congr σ₂.fst σ₂.snd x :=
        by
        intro x
        exact congr_fun (congr_arg to_fun h) x
      simp only [Sum.map_inr, Sum.map_inl, perm.sum_congr_apply, Sum.forall] at h2
      ext
      · exact h2.left x
      · exact h2.right x
    · intro σ hσ
      erw [Set.mem_toFinset, MonoidHom.mem_range] at hσ
      obtain ⟨σ₁₂, hσ₁₂⟩ := hσ
      use σ₁₂
      rw [← hσ₁₂]
      simp
    · intro σ hσ hσn
      have h1 : ¬∀ x, ∃ y, Sum.inl y = σ (Sum.inl x) :=
        by
        by_contra
        rw [Set.mem_toFinset] at hσn
        apply absurd (mem_sum_congr_hom_range_of_perm_maps_to_inl _) hσn
        rintro x ⟨a, ha⟩
        rw [← ha]
        exact h a
      obtain ⟨a, ha⟩ := not_forall.mp h1
      cases' hx : σ (Sum.inl a) with a2 b
      · have hn := (not_exists.mp ha) a2
        exact absurd hx.symm hn
      · rw [Finset.prod_eq_zero (Finset.mem_univ (Sum.inl a)), MulZeroClass.mul_zero]
        rw [hx, from_blocks_apply₂₁]
        rfl
#align matrix.det_from_blocks_zero₂₁ Matrix.det_fromBlocks_zero₂₁

/- warning: matrix.det_from_blocks_zero₁₂ -> Matrix.det_fromBlocks_zero₁₂ is a dubious translation:
lean 3 declaration is
  forall {m : Type.{u2}} {n : Type.{u3}} [_inst_1 : DecidableEq.{succ u3} n] [_inst_2 : Fintype.{u3} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{u2, u2, u1} m m R) (C : Matrix.{u3, u2, u1} n m R) (D : Matrix.{u3, u3, u1} n n R), Eq.{succ u1} R (Matrix.det.{u1, max u2 u3} (Sum.{u2, u3} m n) (fun (a : Sum.{u2, u3} m n) (b : Sum.{u2, u3} m n) => Sum.decidableEq.{u2, u3} m (fun (a : m) (b : m) => _inst_3 a b) n (fun (a : n) (b : n) => _inst_1 a b) a b) (Sum.fintype.{u2, u3} m n _inst_4 _inst_2) R _inst_5 (Matrix.fromBlocks.{u2, u3, u2, u3, u1} m n m n R A (OfNat.ofNat.{max u2 u3 u1} (Matrix.{u2, u3, u1} m n R) 0 (OfNat.mk.{max u2 u3 u1} (Matrix.{u2, u3, u1} m n R) 0 (Zero.zero.{max u2 u3 u1} (Matrix.{u2, u3, u1} m n R) (Matrix.hasZero.{u1, u2, u3} m n R (MulZeroClass.toHasZero.{u1} R (NonUnitalNonAssocSemiring.toMulZeroClass.{u1} R (NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))))))) C D)) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (Matrix.det.{u1, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A) (Matrix.det.{u1, u3} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 D))
but is expected to have type
  forall {m : Type.{u2}} {n : Type.{u1}} [_inst_1 : DecidableEq.{succ u1} n] [_inst_2 : Fintype.{u1} n] [_inst_3 : DecidableEq.{succ u2} m] [_inst_4 : Fintype.{u2} m] {R : Type.{u3}} [_inst_5 : CommRing.{u3} R] (A : Matrix.{u2, u2, u3} m m R) (C : Matrix.{u1, u2, u3} n m R) (D : Matrix.{u1, u1, u3} n n R), Eq.{succ u3} R (Matrix.det.{u3, max u2 u1} (Sum.{u2, u1} m n) (fun (a : Sum.{u2, u1} m n) (b : Sum.{u2, u1} m n) => Sum.instDecidableEqSum.{u2, u1} m n (fun (a : m) (b : m) => _inst_3 a b) (fun (a : n) (b : n) => _inst_1 a b) a b) (instFintypeSum.{u2, u1} m n _inst_4 _inst_2) R _inst_5 (Matrix.fromBlocks.{u2, u1, u2, u1, u3} m n m n R A (OfNat.ofNat.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n R) 0 (Zero.toOfNat0.{max (max u3 u2) u1} (Matrix.{u2, u1, u3} m n R) (Matrix.zero.{u3, u2, u1} m n R (CommMonoidWithZero.toZero.{u3} R (CommSemiring.toCommMonoidWithZero.{u3} R (CommRing.toCommSemiring.{u3} R _inst_5)))))) C D)) (HMul.hMul.{u3, u3, u3} R R R (instHMul.{u3} R (NonUnitalNonAssocRing.toMul.{u3} R (NonAssocRing.toNonUnitalNonAssocRing.{u3} R (Ring.toNonAssocRing.{u3} R (CommRing.toRing.{u3} R _inst_5))))) (Matrix.det.{u3, u2} m (fun (a : m) (b : m) => _inst_3 a b) _inst_4 R _inst_5 A) (Matrix.det.{u3, u1} n (fun (a : n) (b : n) => _inst_1 a b) _inst_2 R _inst_5 D))
Case conversion may be inaccurate. Consider using '#align matrix.det_from_blocks_zero₁₂ Matrix.det_fromBlocks_zero₁₂ₓ'. -/
/-- The determinant of a 2×2 block matrix with the upper-right block equal to zero is the product of
the determinants of the diagonal blocks. For the generalization to any number of blocks, see
`matrix.det_of_lower_triangular`. -/
@[simp]
theorem det_fromBlocks_zero₁₂ (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) :
    (Matrix.fromBlocks A 0 C D).det = A.det * D.det := by
  rw [← det_transpose, from_blocks_transpose, transpose_zero, det_from_blocks_zero₂₁, det_transpose,
    det_transpose]
#align matrix.det_from_blocks_zero₁₂ Matrix.det_fromBlocks_zero₁₂

#print Matrix.det_succ_column_zero /-
/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. -/
theorem det_succ_column_zero {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :
    det A = ∑ i : Fin n.succ, (-1) ^ (i : ℕ) * A i 0 * det (A.submatrix i.succAbove Fin.succ) :=
  by
  rw [Matrix.det_apply, Finset.univ_perm_fin_succ, ← Finset.univ_product_univ]
  simp only [Finset.sum_map, Equiv.toEmbedding_apply, Finset.sum_product, Matrix.submatrix]
  refine' Finset.sum_congr rfl fun i _ => Fin.cases _ (fun i => _) i
  ·
    simp only [Fin.prod_univ_succ, Matrix.det_apply, Finset.mul_sum,
      Equiv.Perm.decomposeFin_symm_apply_zero, Fin.val_zero, one_mul,
      Equiv.Perm.decomposeFin.symm_sign, Equiv.swap_self, if_true, id.def, eq_self_iff_true,
      Equiv.Perm.decomposeFin_symm_apply_succ, Fin.succAbove_zero, Equiv.coe_refl, pow_zero,
      mul_smul_comm, of_apply]
  -- `univ_perm_fin_succ` gives a different embedding of `perm (fin n)` into
  -- `perm (fin n.succ)` than the determinant of the submatrix we want,
  -- permute `A` so that we get the correct one.
  have : (-1 : R) ^ (i : ℕ) = i.cycle_range.sign := by simp [Fin.sign_cycleRange]
  rw [Fin.val_succ, pow_succ, this, mul_assoc, mul_assoc, mul_left_comm ↑(Equiv.Perm.sign _), ←
    det_permute, Matrix.det_apply, Finset.mul_sum, Finset.mul_sum]
  -- now we just need to move the corresponding parts to the same place
  refine' Finset.sum_congr rfl fun σ _ => _
  rw [Equiv.Perm.decomposeFin.symm_sign, if_neg (Fin.succ_ne_zero i)]
  calc
    ((-1 * σ.sign : ℤ) • ∏ i', A (equiv.perm.decompose_fin.symm (Fin.succ i, σ) i') i') =
        (-1 * σ.sign : ℤ) •
          (A (Fin.succ i) 0 * ∏ i', A ((Fin.succ i).succAbove (Fin.cycleRange i (σ i'))) i'.succ) :=
      by
      simp only [Fin.prod_univ_succ, Fin.succAbove_cycleRange,
        Equiv.Perm.decomposeFin_symm_apply_zero, Equiv.Perm.decomposeFin_symm_apply_succ]
    _ =
        -1 *
          (A (Fin.succ i) 0 *
            (σ.sign : ℤ) • ∏ i', A ((Fin.succ i).succAbove (Fin.cycleRange i (σ i'))) i'.succ) :=
      by
      simp only [mul_assoc, mul_comm, _root_.neg_mul, one_mul, zsmul_eq_mul, neg_inj, neg_smul,
        Fin.succAbove_cycleRange]
    
#align matrix.det_succ_column_zero Matrix.det_succ_column_zero
-/

#print Matrix.det_succ_row_zero /-
/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row 0. -/
theorem det_succ_row_zero {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :
    det A = ∑ j : Fin n.succ, (-1) ^ (j : ℕ) * A 0 j * det (A.submatrix Fin.succ j.succAbove) :=
  by
  rw [← det_transpose A, det_succ_column_zero]
  refine' Finset.sum_congr rfl fun i _ => _
  rw [← det_transpose]
  simp only [transpose_apply, transpose_submatrix, transpose_transpose]
#align matrix.det_succ_row_zero Matrix.det_succ_row_zero
-/

#print Matrix.det_succ_row /-
/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row `i`. -/
theorem det_succ_row {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (i : Fin n.succ) :
    det A =
      ∑ j : Fin n.succ, (-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succAbove j.succAbove) :=
  by
  simp_rw [pow_add, mul_assoc, ← mul_sum]
  have : det A = (-1 : R) ^ (i : ℕ) * i.cycle_range⁻¹.sign * det A := by
    calc
      det A = ↑((-1 : ℤˣ) ^ (i : ℕ) * (-1 : ℤˣ) ^ (i : ℕ) : ℤˣ) * det A := by simp
      _ = (-1 : R) ^ (i : ℕ) * i.cycle_range⁻¹.sign * det A := by simp [-Int.units_mul_self]
      
  rw [this, mul_assoc]
  congr
  rw [← det_permute, det_succ_row_zero]
  refine' Finset.sum_congr rfl fun j _ => _
  rw [mul_assoc, Matrix.submatrix, Matrix.submatrix]
  congr
  · rw [Equiv.Perm.inv_def, Fin.cycleRange_symm_zero]
  · ext (i' j')
    rw [Equiv.Perm.inv_def, Fin.cycleRange_symm_succ]
#align matrix.det_succ_row Matrix.det_succ_row
-/

#print Matrix.det_succ_column /-
/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column `j`. -/
theorem det_succ_column {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (j : Fin n.succ) :
    det A =
      ∑ i : Fin n.succ, (-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succAbove j.succAbove) :=
  by
  rw [← det_transpose, det_succ_row _ j]
  refine' Finset.sum_congr rfl fun i _ => _
  rw [add_comm, ← det_transpose, transpose_apply, transpose_submatrix, transpose_transpose]
#align matrix.det_succ_column Matrix.det_succ_column
-/

/- warning: matrix.det_fin_zero -> Matrix.det_fin_zero is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) R}, Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (fun (a : Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) (b : Fin (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 0 (OfNat.mk.{0} Nat 0 (Zero.zero.{0} Nat Nat.hasZero)))) R _inst_5 A) (OfNat.ofNat.{u1} R 1 (OfNat.mk.{u1} R 1 (One.one.{u1} R (AddMonoidWithOne.toOne.{u1} R (AddGroupWithOne.toAddMonoidWithOne.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] {A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R}, Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (fun (a : Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (b : Fin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) R _inst_5 A) (OfNat.ofNat.{u1} R 1 (One.toOfNat1.{u1} R (NonAssocRing.toOne.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5)))))
Case conversion may be inaccurate. Consider using '#align matrix.det_fin_zero Matrix.det_fin_zeroₓ'. -/
/-- Determinant of 0x0 matrix -/
@[simp]
theorem det_fin_zero {A : Matrix (Fin 0) (Fin 0) R} : det A = 1 :=
  det_isEmpty
#align matrix.det_fin_zero Matrix.det_fin_zero

/- warning: matrix.det_fin_one -> Matrix.det_fin_one is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) R), Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (fun (a : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) (b : Fin (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 1 (OfNat.mk.{0} Nat 1 (One.one.{0} Nat Nat.hasOne)))) R _inst_5 A) (A (OfNat.ofNat.{0} (Fin (One.one.{0} Nat Nat.hasOne)) 0 (OfNat.mk.{0} (Fin (One.one.{0} Nat Nat.hasOne)) 0 (Zero.zero.{0} (Fin (One.one.{0} Nat Nat.hasOne)) (Fin.hasZeroOfNeZero (One.one.{0} Nat Nat.hasOne) (NeZero.one.{0} Nat (NonAssocSemiring.toMulZeroOneClass.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) Nat.nontrivial))))) (OfNat.ofNat.{0} (Fin (One.one.{0} Nat Nat.hasOne)) 0 (OfNat.mk.{0} (Fin (One.one.{0} Nat Nat.hasOne)) 0 (Zero.zero.{0} (Fin (One.one.{0} Nat Nat.hasOne)) (Fin.hasZeroOfNeZero (One.one.{0} Nat Nat.hasOne) (NeZero.one.{0} Nat (NonAssocSemiring.toMulZeroOneClass.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring)) Nat.nontrivial))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) R), Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (fun (a : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) (b : Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) R _inst_5 A) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_fin_one Matrix.det_fin_oneₓ'. -/
/-- Determinant of 1x1 matrix -/
theorem det_fin_one (A : Matrix (Fin 1) (Fin 1) R) : det A = A 0 0 :=
  det_unique A
#align matrix.det_fin_one Matrix.det_fin_one

#print Matrix.det_fin_one_of /-
theorem det_fin_one_of (a : R) : det !![a] = a :=
  det_fin_one _
#align matrix.det_fin_one_of Matrix.det_fin_one_of
-/

/- warning: matrix.det_fin_two -> Matrix.det_fin_two is a dubious translation:
lean 3 declaration is
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) R), Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) (b : Fin (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) => Fin.decidableEq (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)))) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (OfNat.mk.{0} Nat 2 (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))))) R _inst_5 A) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (SubNegMonoid.toHasSub.{u1} R (AddGroup.toSubNegMonoid.{u1} R (AddGroupWithOne.toAddGroup.{u1} R (AddCommGroupWithOne.toAddGroupWithOne.{u1} R (Ring.toAddCommGroupWithOne.{u1} R (CommRing.toRing.{u1} R _inst_5))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (Distrib.toHasMul.{u1} R (Ring.toDistrib.{u1} R (CommRing.toRing.{u1} R _inst_5)))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring))))))) (A (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 1 (One.one.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasOneOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))) (OfNat.ofNat.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (OfNat.mk.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) 0 (Zero.zero.{0} (Fin (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne))) (Fin.hasZeroOfNeZero (bit0.{0} Nat Nat.hasAdd (One.one.{0} Nat Nat.hasOne)) (CharZero.NeZero.two.{0} Nat (AddCommMonoidWithOne.toAddMonoidWithOne.{0} Nat (NonAssocSemiring.toAddCommMonoidWithOne.{0} Nat (Semiring.toNonAssocSemiring.{0} Nat Nat.semiring))) (StrictOrderedSemiring.to_charZero.{0} Nat Nat.strictOrderedSemiring)))))))))
but is expected to have type
  forall {R : Type.{u1}} [_inst_5 : CommRing.{u1} R] (A : Matrix.{0, 0, u1} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) R), Eq.{succ u1} R (Matrix.det.{u1, 0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (fun (a : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (b : Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) => instDecidableEqFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) a b) (Fin.fintype (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) R _inst_5 A) (HSub.hSub.{u1, u1, u1} R R R (instHSub.{u1} R (Ring.toSub.{u1} R (CommRing.toRing.{u1} R _inst_5))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))) (HMul.hMul.{u1, u1, u1} R R R (instHMul.{u1} R (NonUnitalNonAssocRing.toMul.{u1} R (NonAssocRing.toNonUnitalNonAssocRing.{u1} R (Ring.toNonAssocRing.{u1} R (CommRing.toRing.{u1} R _inst_5))))) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))))) (A (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 1 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 1 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (OfNat.ofNat.{0} (Fin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) 0 (Fin.instOfNatFin (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) 0 (NeZero.succ (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))))))
Case conversion may be inaccurate. Consider using '#align matrix.det_fin_two Matrix.det_fin_twoₓ'. -/
/-- Determinant of 2x2 matrix -/
theorem det_fin_two (A : Matrix (Fin 2) (Fin 2) R) : det A = A 0 0 * A 1 1 - A 0 1 * A 1 0 :=
  by
  simp [Matrix.det_succ_row_zero, Fin.sum_univ_succ]
  ring
#align matrix.det_fin_two Matrix.det_fin_two

#print Matrix.det_fin_two_of /-
@[simp]
theorem det_fin_two_of (a b c d : R) : Matrix.det !![a, b; c, d] = a * d - b * c :=
  det_fin_two _
#align matrix.det_fin_two_of Matrix.det_fin_two_of
-/

#print Matrix.det_fin_three /-
/-- Determinant of 3x3 matrix -/
theorem det_fin_three (A : Matrix (Fin 3) (Fin 3) R) :
    det A =
      A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 +
            A 0 1 * A 1 2 * A 2 0 +
          A 0 2 * A 1 0 * A 2 1 -
        A 0 2 * A 1 1 * A 2 0 :=
  by
  simp [Matrix.det_succ_row_zero, Fin.sum_univ_succ]
  ring
#align matrix.det_fin_three Matrix.det_fin_three
-/

end Matrix

